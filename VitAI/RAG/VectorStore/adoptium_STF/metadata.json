{
  "metastore": {
    "0": {
      "metadata": {
        "chunk_id": "fed56ee3821e9b5839d899960bda222c3e6d3f09099b8f44e6b5e5a3d255e7e4",
        "file_path": ".gitattributes",
        "content": "# Default - treat files as text as convert line ending to LF\n* text eol=lf\n\n# Overrides for files to be left untouched - treat as binary\n*.bin binary\n*.bmp binary\n*.ciphertext binary\n*.class binary\n*.dat binary\n*.dict binary\n*.dll binary\n*.doc binary\n*.ear binary\n*.exe binary\n*.gif binary\n*.ico binary\n*.idx binary\n*.iv binary\n*.jar binary\n*.jks binary\n*.jpeg binary\n*.jpg binary\n*.key binary\n*.o binary\n*.obj binary\n*.odg binary\n*.pack binary\n*.pdf binary\n*.png binary\n*.rtf binary\n*.ser binary\n*.so binary\n*.war binary\n*.zip binary\n\n\n",
        "start_line": 0,
        "end_line": 36,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 157,
        "node_type": null,
        "file_sha": "ad794a9c709f4a26208559569282a444f7237655",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.615502"
      },
      "text": "# Default - treat files as text as convert line ending to LF\n* text eol=lf\n\n# Overrides for files to be left untouched - treat as binary\n*.bin binary\n*.bmp binary\n*.ciphertext binary\n*.class binary\n*.dat binary\n*.dict binary\n*.dll binary\n*.doc binary\n*.ear binary\n*.exe binary\n*.gif binary\n*.ico binary\n*.idx binary\n*.iv binary\n*.jar binary\n*.jks binary\n*.jpeg binary\n*.jpg binary\n*.key binary\n*.o binary\n*.obj binary\n*.odg binary\n*.pack binary\n*.pdf binary\n*.png binary\n*.rtf binary\n*.ser binary\n*.so binary\n*.war binary\n*.zip binary\n\n\n"
    },
    "1": {
      "metadata": {
        "chunk_id": "3d3af0e681d57eb8d87431639df3a10e5cb03f1b791e67c1bcc6aa20c6d824c0",
        "file_path": ".gitattributes.zos",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n\n# The default for text files\n* git-encoding=iso8859-1 working-tree-encoding=ibm-1047\n\n# Specific types of files remain as ASCII\n*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1\n*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1\n*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1\n*.classpath git-encoding=iso8859-1 working-tree-encoding=iso8859-1\n\n# Default - treat files as text as convert line ending to LF\n* text eol=lf\n\n# Overrides for files to be left untouched - treat as binary\n*.bin binary\n*.bmp binary\n*.ciphertext binary\n*.class binary\n*.dat binary\n*.dict binary\n*.dll binary\n*.doc binary\n*.ear binary\n*.exe binary\n*.gif binary\n*.ico binary\n*.idx binary\n*.iv binary\n*.jar binary\n*.jks binary\n*.jpeg binary\n*.jpg binary\n*.key binary\n*.o binary\n*.obj binary\n*.odg binary\n*.pack binary\n*.pdf binary\n*.png binary\n*.rtf binary\n*.ser binary\n*.so binary\n*.war binary\n*.zip binary\n\n\n",
        "start_line": 0,
        "end_line": 56,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 393,
        "node_type": null,
        "file_sha": "43569e2c72d849fcb1a271e1a5e091d9ca3a9158",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.618784"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n\n# The default for text files\n* git-encoding=iso8859-1 working-tree-encoding=ibm-1047\n\n# Specific types of files remain as ASCII\n*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1\n*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1\n*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1\n*.classpath git-encoding=iso8859-1 working-tree-encoding=iso8859-1\n\n# Default - treat files as text as convert line ending to LF\n* text eol=lf\n\n# Overrides for files to be left untouched - treat as binary\n*.bin binary\n*.bmp binary\n*.ciphertext binary\n*.class binary\n*.dat binary\n*.dict binary\n*.dll binary\n*.doc binary\n*.ear binary\n*.exe binary\n*.gif binary\n*.ico binary\n*.idx binary\n*.iv binary\n*.jar binary\n*.jks binary\n*.jpeg binary\n*.jpg binary\n*.key binary\n*.o binary\n*.obj binary\n*.odg binary\n*.pack binary\n*.pdf binary\n*.png binary\n*.rtf binary\n*.ser binary\n*.so binary\n*.war binary\n*.zip binary\n\n\n"
    },
    "2": {
      "metadata": {
        "chunk_id": "cbf36750ab135a6d748115e33a7ea1cce23097812a73da0c07a8b30e83ca1b45",
        "file_path": ".gitignore",
        "content": "bin/\n\n\n",
        "start_line": 0,
        "end_line": 3,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 2,
        "node_type": null,
        "file_sha": "e660fd93d3196215552065b1e63bf6a2f393ed86",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.620759"
      },
      "text": "bin/\n\n\n"
    },
    "3": {
      "metadata": {
        "chunk_id": "0cb3de12b904fa809b80f89ddd69bb3f68f00135c0cbc20e55f9e7cf97c5b1cd",
        "file_path": "CODE_OF_CONDUCT.md",
        "content": "# Community Code of Conduct\n\n**Version 1.1 \nOctober 21, 2019**\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies within all project spaces, and it also applies when\nan individual is representing the project or its community in public spaces.\nExamples of representing a project or community include using an official\nproject e-mail address, posting via an official social media account, or acting\nas an appointed representative at an online or offline event. Representation of\na project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at codeofconduct@eclipse.org. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n\n\n",
        "start_line": 0,
        "end_line": 81,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 641,
        "node_type": null,
        "file_sha": "7b998c19c084d8cdfa55c3247148fffa8ca3faed",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.623277"
      },
      "text": "# Community Code of Conduct\n\n**Version 1.1 \nOctober 21, 2019**\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies within all project spaces, and it also applies when\nan individual is representing the project or its community in public spaces.\nExamples of representing a project or community include using an official\nproject e-mail address, posting via an official social media account, or acting\nas an appointed representative at an online or offline event. Representation of\na project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at codeofconduct@eclipse.org. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n\n\n"
    },
    "4": {
      "metadata": {
        "chunk_id": "4a0931fbda2f42c047b19bfd7e277aac727377e41e960cc3e3ec6e2a0e1f85e2",
        "file_path": "CONTRIBUTING.md",
        "content": "# Contributing to STF\n\nThanks for your interest in this project.\n\n## Project description\n\nSTF is a project that contains system test framework code. \n\n* https://github.com/adoptium/STF\n\n## Developer resources\n\nThe project maintains the following source code repositories\n\n* https://github.com/adoptium/STF\n\n## Eclipse Contributor Agreement\n\nBefore your contribution can be accepted by the project team contributors must\nelectronically sign the Eclipse Contributor Agreement (ECA).\n\n* http://www.eclipse.org/legal/ECA.php\n\nCommits that are provided by non-committers must have a Signed-off-by field in\nthe footer indicating that the author is aware of the terms by which the\ncontribution has been provided to the project. The non-committer must\nadditionally have an Eclipse Foundation account and must have a signed Eclipse\nContributor Agreement (ECA) on file.\n\nFor more information, please see the Eclipse Committer Handbook:\nhttps://www.eclipse.org/projects/handbook/#resources-commit\n\n## Contact\n\nContact the Eclipse Foundation Webdev team via webdev@eclipse-foundation.org.\n\n\n",
        "start_line": 0,
        "end_line": 37,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 216,
        "node_type": null,
        "file_sha": "d43ed35469056e0f8988fda16bf86b1d4c45b8a2",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.626308"
      },
      "text": "# Contributing to STF\n\nThanks for your interest in this project.\n\n## Project description\n\nSTF is a project that contains system test framework code. \n\n* https://github.com/adoptium/STF\n\n## Developer resources\n\nThe project maintains the following source code repositories\n\n* https://github.com/adoptium/STF\n\n## Eclipse Contributor Agreement\n\nBefore your contribution can be accepted by the project team contributors must\nelectronically sign the Eclipse Contributor Agreement (ECA).\n\n* http://www.eclipse.org/legal/ECA.php\n\nCommits that are provided by non-committers must have a Signed-off-by field in\nthe footer indicating that the author is aware of the terms by which the\ncontribution has been provided to the project. The non-committer must\nadditionally have an Eclipse Foundation account and must have a signed Eclipse\nContributor Agreement (ECA) on file.\n\nFor more information, please see the Eclipse Committer Handbook:\nhttps://www.eclipse.org/projects/handbook/#resources-commit\n\n## Contact\n\nContact the Eclipse Foundation Webdev team via webdev@eclipse-foundation.org.\n\n\n"
    },
    "5": {
      "metadata": {
        "chunk_id": "382691a9883f8fe10b1aa1200f8b8850e4cf53d94fde2e9fe8cf1268e9c197d6",
        "file_path": "LICENSE",
        "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n",
        "start_line": 0,
        "end_line": 88,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 995,
        "node_type": null,
        "file_sha": "8f71f43fee3f78649d238238cbde51e6d7055c82",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.628870"
      },
      "text": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n"
    },
    "6": {
      "metadata": {
        "chunk_id": "32f0f768c27ff53ba480714a13fed00da4a0efda46f3ce578f150134349f671c",
        "file_path": "LICENSE",
        "content": "   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n",
        "start_line": 89,
        "end_line": 165,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 878,
        "node_type": null,
        "file_sha": "8f71f43fee3f78649d238238cbde51e6d7055c82",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.628901"
      },
      "text": "   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n"
    },
    "7": {
      "metadata": {
        "chunk_id": "66566f875e8790e6675e2772a07c323acd1e6bc35a8770920b1722bb6a4920bb",
        "file_path": "LICENSE",
        "content": "   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n\n\n",
        "start_line": 166,
        "end_line": 206,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 388,
        "node_type": null,
        "file_sha": "8f71f43fee3f78649d238238cbde51e6d7055c82",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.628905"
      },
      "text": "   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n\n\n"
    },
    "8": {
      "metadata": {
        "chunk_id": "3e62a15dfc16285805d6d39d786893c7d13801a5d38bf4533c5cb3ce6bf05586",
        "file_path": "NOTICE",
        "content": "Portions of this software are\n(C) Copyright IBM Corporation 2017\n\n\n",
        "start_line": 0,
        "end_line": 4,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 16,
        "node_type": null,
        "file_sha": "8cab3205f9b71559a4ee986e965cdf894f2f443f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.631008"
      },
      "text": "Portions of this software are\n(C) Copyright IBM Corporation 2017\n\n\n"
    },
    "9": {
      "metadata": {
        "chunk_id": "a27b3192f51e24c6fee74b46276d7da5d372126691765d66714fe00a06693d92",
        "file_path": "README.md",
        "content": "# stf\n\nThis repository contains the System Test Framework (STF) used by test cases in the javasvt repository to execute multi process, multi step Java tests.\n\n[Quick start (Unix)](#unix)\n[Quick start (Windows)](#windows)\n[More documentation](stf.build/docs/build.md)\n\n<a name=\"unix\"></a>\n## Quick start (Unix)\n\nThis quick start is for people who want to clone and build the project.  To set up a development environment for enhancing STF or creating new test cases, refer to [this document](stf.build/docs/build.md).\n\nBefore running the build for the first time make sure GNU make, ant and wget are on your PATH.\n\nwget is only required for the make configure step, which only needs to be done once.\n\nEither copy, paste and execute [this script](stf.build/scripts/stf_clone_make.sh) which runs the command below, or run the commands yourself.\n\n```shell\n# 1. Create a directory for the git clone\nmkdir -p $HOME/git\n\n# 2. Clone the git repository\ncd $HOME/git\ngit clone https://github.com/adoptium/STF.git stf\n\n# 3. Set JAVA_HOME to a Java 8 or later Java\n\nexport JAVA_HOME=<java-home>\n\n# 4.Install the prereqs\n# This requires wget to be on the PATH\ncd $HOME/git/stf/stf.build\nmake configure\n\n# 5. Build\ncd $HOME/git/stf/stf.build\nmake\n\n# 6. Run the STF samples\ncd $HOME/git/stf/stf.build\nmake test\necho See /tmp/stf to view the test results\n```\n\n<a name=\"windows\"></a>\n## Quick Start (Windows)\n\nThis quick start is for people who want to clone and build the project.  To set up a development environment for enhancing STF or creating new test cases, refer to [this document](stf.build/docs/build.md).\n\nBefore running the build for the first time make sure GNU make, ant and wget are on your PATH.\n\nwget is only required for the make configure step, which only needs to be done once.\n\nEither copy, paste and execute [this script](stf.build/scripts/stf_clone_make.bat) which runs the command below, or run the commands yourself.\n\n```dos\nREM 1. Create a directory for the git clones\nmkdir c:\\%USERPROFILE%\\git\n\nREM 2. Clone the test cases\ncd c:\\%USERPROFILE%\\git\ngit clone https://github.com/adoptium/STF.git stf\n\nREM 3. Set JAVA_HOME to a Java 8 or later Java\nSET JAVA_HOME=<java-home>\n\nREM 4. Get the test case prereqs\ncd C:\\%USERPROFILE%\\git\\stf\\stf.build\nmake configure\n\nREM 5. Build\ncd C:\\%USERPROFILE%\\git\\stf\\stf.build\nmake\n\nREM 6. Run the samples\ncd C:\\%USERPROFILE%\\git\\stf\\stf.build\nmake test\necho See c:\\stf_temp to view the test results\n```\n\n\n",
        "start_line": 0,
        "end_line": 83,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 650,
        "node_type": null,
        "file_sha": "c715a992449142c14144914dd4285c8b99ea2b22",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.632820"
      },
      "text": "# stf\n\nThis repository contains the System Test Framework (STF) used by test cases in the javasvt repository to execute multi process, multi step Java tests.\n\n[Quick start (Unix)](#unix)\n[Quick start (Windows)](#windows)\n[More documentation](stf.build/docs/build.md)\n\n<a name=\"unix\"></a>\n## Quick start (Unix)\n\nThis quick start is for people who want to clone and build the project.  To set up a development environment for enhancing STF or creating new test cases, refer to [this document](stf.build/docs/build.md).\n\nBefore running the build for the first time make sure GNU make, ant and wget are on your PATH.\n\nwget is only required for the make configure step, which only needs to be done once.\n\nEither copy, paste and execute [this script](stf.build/scripts/stf_clone_make.sh) which runs the command below, or run the commands yourself.\n\n```shell\n# 1. Create a directory for the git clone\nmkdir -p $HOME/git\n\n# 2. Clone the git repository\ncd $HOME/git\ngit clone https://github.com/adoptium/STF.git stf\n\n# 3. Set JAVA_HOME to a Java 8 or later Java\n\nexport JAVA_HOME=<java-home>\n\n# 4.Install the prereqs\n# This requires wget to be on the PATH\ncd $HOME/git/stf/stf.build\nmake configure\n\n# 5. Build\ncd $HOME/git/stf/stf.build\nmake\n\n# 6. Run the STF samples\ncd $HOME/git/stf/stf.build\nmake test\necho See /tmp/stf to view the test results\n```\n\n<a name=\"windows\"></a>\n## Quick Start (Windows)\n\nThis quick start is for people who want to clone and build the project.  To set up a development environment for enhancing STF or creating new test cases, refer to [this document](stf.build/docs/build.md).\n\nBefore running the build for the first time make sure GNU make, ant and wget are on your PATH.\n\nwget is only required for the make configure step, which only needs to be done once.\n\nEither copy, paste and execute [this script](stf.build/scripts/stf_clone_make.bat) which runs the command below, or run the commands yourself.\n\n```dos\nREM 1. Create a directory for the git clones\nmkdir c:\\%USERPROFILE%\\git\n\nREM 2. Clone the test cases\ncd c:\\%USERPROFILE%\\git\ngit clone https://github.com/adoptium/STF.git stf\n\nREM 3. Set JAVA_HOME to a Java 8 or later Java\nSET JAVA_HOME=<java-home>\n\nREM 4. Get the test case prereqs\ncd C:\\%USERPROFILE%\\git\\stf\\stf.build\nmake configure\n\nREM 5. Build\ncd C:\\%USERPROFILE%\\git\\stf\\stf.build\nmake\n\nREM 6. Run the samples\ncd C:\\%USERPROFILE%\\git\\stf\\stf.build\nmake test\necho See c:\\stf_temp to view the test results\n```\n\n\n"
    },
    "10": {
      "metadata": {
        "chunk_id": "dcc451ca3e8bb0ab8b25610da1fd23d4b54777cbbd6dc97f6a0908a74d2c50fc",
        "file_path": "stf.build/.project",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>stf.build</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t</buildSpec>\n\t<natures>\n\t</natures>\n</projectDescription>\n\n\n",
        "start_line": 0,
        "end_line": 13,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 65,
        "node_type": null,
        "file_sha": "3f35f4683021565d6102e8479ceeca76c2028ab4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.635122"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>stf.build</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t</buildSpec>\n\t<natures>\n\t</natures>\n</projectDescription>\n\n\n"
    },
    "11": {
      "metadata": {
        "chunk_id": "a182f6ef389e9b060e002465386aca21d67832b275fc146e234517d34171c678",
        "file_path": "stf.build/build.xml",
        "content": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<project name=\"stf.build\" default=\"build\">\n\n\t<echo message=\"Executing stf.build/build.xml\"/>\n\n\t<!-- Set default for source_root.  -->\n\t<property name=\"source_root\" location=\"..\"/>\n\n\t<property name=\"stf_root\" location=\"${source_root}/../stf\"/>\n\n\t<!-- Import settings used by multiple projects.  -->\n\t<import file=\"${stf_root}/stf.build/include/top.xml\"/>\n\n\t<!-- Build dependencies of this project.  -->\n\t<!-- dir must be set on the ant task otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-dependencies\" depends=\"check-prereqs\">\n\t\t<ant antfile=\"${stf_root}/stf.core/build.xml\" dir=\"${stf_root}/stf.core\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.load/build.xml\" dir=\"${stf_root}/stf.load\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.samples/build.xml\" dir=\"${stf_root}/stf.samples\" inheritAll=\"true\"/>\n\t</target>\n\n\t<!-- Target to build all projects in the STF repository.  -->\n\t<target name=\"build\" depends=\"build-dependencies\">\n\t</target>\n\n\t<target name=\"clean\">\n\t\t<ant antfile=\"${stf_root}/stf.core/build.xml\" target=\"clean\" dir=\"${stf_root}/stf.core\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.load/build.xml\" target=\"clean\" dir=\"${stf_root}/stf.load\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.samples/build.xml\" target=\"clean\" dir=\"${stf_root}/stf.samples\" inheritAll=\"true\"/>\n\t</target>\n\n</project>",
        "start_line": 0,
        "end_line": 46,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 519,
        "node_type": null,
        "file_sha": "3d8fcb709b56740789395b0fe5f56216d5d69f06",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.636834"
      },
      "text": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<project name=\"stf.build\" default=\"build\">\n\n\t<echo message=\"Executing stf.build/build.xml\"/>\n\n\t<!-- Set default for source_root.  -->\n\t<property name=\"source_root\" location=\"..\"/>\n\n\t<property name=\"stf_root\" location=\"${source_root}/../stf\"/>\n\n\t<!-- Import settings used by multiple projects.  -->\n\t<import file=\"${stf_root}/stf.build/include/top.xml\"/>\n\n\t<!-- Build dependencies of this project.  -->\n\t<!-- dir must be set on the ant task otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-dependencies\" depends=\"check-prereqs\">\n\t\t<ant antfile=\"${stf_root}/stf.core/build.xml\" dir=\"${stf_root}/stf.core\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.load/build.xml\" dir=\"${stf_root}/stf.load\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.samples/build.xml\" dir=\"${stf_root}/stf.samples\" inheritAll=\"true\"/>\n\t</target>\n\n\t<!-- Target to build all projects in the STF repository.  -->\n\t<target name=\"build\" depends=\"build-dependencies\">\n\t</target>\n\n\t<target name=\"clean\">\n\t\t<ant antfile=\"${stf_root}/stf.core/build.xml\" target=\"clean\" dir=\"${stf_root}/stf.core\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.load/build.xml\" target=\"clean\" dir=\"${stf_root}/stf.load\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.samples/build.xml\" target=\"clean\" dir=\"${stf_root}/stf.samples\" inheritAll=\"true\"/>\n\t</target>\n\n</project>"
    },
    "12": {
      "metadata": {
        "chunk_id": "03f57e8ed630bf2db455d5f0e87f74f12308ad6fc611e2a5f4ea804c060f403e",
        "file_path": "stf.build/docs/build.md",
        "content": "# System Test Framework (STF) Build\n\nBasic process is:\n1. Install prerequisite software\n2. clone the repository\n3. `make configure` (installs some other prereqs)\n4. `make` (or make build - builds the repository)\n5. `make test` (runs the STF sample tests)\n\n## Prerequisite software which cannot be installed by the STF build scripts\nThese prereqs must be installed before attempting to build STF\n1. [Apache Ant](http://ant.apache.org) version 1.8.4 or later\n2. Java 8 or later (any implementation)\n3. [GNU make](https://www.gnu.org/software/make/) version 3.79 or later\n4. [GNU Wget](https://www.gnu.org/software/wget/) (optional - only required if you want to install the other prereqs automatically)\n\n## Prerequisite software which can be installed by the STF build scripts\n### Installing the prereqs using the build scripts\n1. An internet connection is required\n2. Review the list of prereqs listed under 'Installing prereqs manually' and confirm that you accept their license terms.\n3. `git clone https://github.com/adoptium/STF.git stf`\n4. Change into the stf.build directory `cd <git-root>;stf.build`\n5. `make configure`\n\n### Installing prereqs manually\n1. Create a systemtest_prereqs directory alongside the git repository directory - e.g. /home/user/systemtest_prereqs (alongside /home/user/git)\n2. Download and install the prereqs as described in the table below.\n\n",
        "start_line": 0,
        "end_line": 28,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 341,
        "node_type": null,
        "file_sha": "457c95e5fa8d86afb7ef79339888c8896b21e06a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.639059"
      },
      "text": "# System Test Framework (STF) Build\n\nBasic process is:\n1. Install prerequisite software\n2. clone the repository\n3. `make configure` (installs some other prereqs)\n4. `make` (or make build - builds the repository)\n5. `make test` (runs the STF sample tests)\n\n## Prerequisite software which cannot be installed by the STF build scripts\nThese prereqs must be installed before attempting to build STF\n1. [Apache Ant](http://ant.apache.org) version 1.8.4 or later\n2. Java 8 or later (any implementation)\n3. [GNU make](https://www.gnu.org/software/make/) version 3.79 or later\n4. [GNU Wget](https://www.gnu.org/software/wget/) (optional - only required if you want to install the other prereqs automatically)\n\n## Prerequisite software which can be installed by the STF build scripts\n### Installing the prereqs using the build scripts\n1. An internet connection is required\n2. Review the list of prereqs listed under 'Installing prereqs manually' and confirm that you accept their license terms.\n3. `git clone https://github.com/adoptium/STF.git stf`\n4. Change into the stf.build directory `cd <git-root>;stf.build`\n5. `make configure`\n\n### Installing prereqs manually\n1. Create a systemtest_prereqs directory alongside the git repository directory - e.g. /home/user/systemtest_prereqs (alongside /home/user/git)\n2. Download and install the prereqs as described in the table below.\n\n"
    },
    "13": {
      "metadata": {
        "chunk_id": "b6104048cd42358e052aa77af4746cd7b0e51625769d53a208d34435b22d5941",
        "file_path": "stf.build/docs/build.md",
        "content": "| Dependency            | License                                                       | Used by    | Steps to obtain                                                                                                                                                                                                                                            |Install instructions                                                                                                                                                                                                                                                   |Installed via make / ant configure? |\n|-----------------------|---------------------------------------------------------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------|\n| apache-ant-1.10.1     | https://ant.apache.org/license.html                           | stf.build  | Download from https://archive.apache.org/dist/ant/binaries/apache-ant-1.10.1-bin.zip                                                                                                                                                                            | Unzip to PREREQS_ROOT/apache-ant-1.10.1                                                                                                                                                                                                                                 | Yes                                |\n| log4j-2.16.0             | https://logging.apache.org/log4j/2.0/license.html             | stf.*      | Download from https://archive.apache.org/dist/logging/log4j/2.16.0/apache-log4j-2.16.0-bin.zip                                                                                                                                                                        | Copy to PREREQS_ROOT/log4j-2.16.0/log4j-api-2.16.0.jar and PREREQS_ROOT/log4j-2.16.0/log4j-core-2.16.0.jar                                                                                                                                                                                                                      | Yes                                |\n| GNU make 3.79 or later| https://www.gnu.org/licenses/gpl.html                         | stf.build  | Windows - Download from http://gnuwin32.sourceforge.net/packages/make.htm<br>Unix: may already be installed on the test machine, a prebuilt version may already be available, otherwise build from source - see https://www.gnu.org/software/software.html\t         | Add GNU make to PATH (ahead of any native platform make) before executing make or make test, or copy make to PREREQS_ROOT/gmake/<platform> where platform is linux_x86-32, linux_x86-64, linux_ppc-32, linux_390-31, linux_arm-32, win_x86-32, aix_ppc-64, zos_390-64                                                                    | No                                 |\n| perl 5.6.1 or later   | http://perldoc.perl.org/index-licence.html                    | stf.core   | Windows - tests can be executed using Strawberry perl.  Other perl implementations may be OK too.                                       | Add to PATH                                                                                                                                                                                                                                                           | No                                 |\n| Windows Sysinternals  | https://technet.microsoft.com/en-us/sysinternals/bb469936.aspx| stf.core   | Download from https://download.sysinternals.com/files/SysinternalsSuite.zip                                                                                                                                                                                         | Unzip to PREREQS_ROOT/windows_sysinternals                                                                                                                                                                                                                              | Yes                                |\n| wget                  | https://www.gnu.org/copyleft/gpl.html                         | stf.build  | Windows - download from https://sourceforge.net/projects/gnuwin32/files/wget/1.11.4-1/wget-1.11.4-1-bin.zip                                                                                                                                                                   | Add to PATH                                                                                                                                                                                                                                                           | No                                 |\n| asm 9.7.1                  | https://asm.ow2.io/                         | stf.load  | Download from https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm/9.7.1/asm-9.7.1.jar                                                                                                                                                                   | Copy to PREREQS_ROOT/asm/asm.jar                                                                                                                                                                                                                                                           | Yes                                 |\n| asm-commons 9.7.1                  | https://asm.ow2.io/                         | stf.load  | Download from https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm-commons/9.7.1/asm-commons-9.7.1.jar                                                                                                                                                                   | Copy to PREREQS_ROOT/asm/asm-commons.jar                                                                                                                                                                                                                                                           | Yes                                 |\n\n## Building from a command line\n1. `git clone https://github.com/adoptium/STF.git stf`\n2. Change into the stf.build directory `cd <git-root>;stf.build`\n3. `make`\n\n",
        "start_line": 29,
        "end_line": 45,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 845,
        "node_type": null,
        "file_sha": "457c95e5fa8d86afb7ef79339888c8896b21e06a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.639068"
      },
      "text": "| Dependency            | License                                                       | Used by    | Steps to obtain                                                                                                                                                                                                                                            |Install instructions                                                                                                                                                                                                                                                   |Installed via make / ant configure? |\n|-----------------------|---------------------------------------------------------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------|\n| apache-ant-1.10.1     | https://ant.apache.org/license.html                           | stf.build  | Download from https://archive.apache.org/dist/ant/binaries/apache-ant-1.10.1-bin.zip                                                                                                                                                                            | Unzip to PREREQS_ROOT/apache-ant-1.10.1                                                                                                                                                                                                                                 | Yes                                |\n| log4j-2.16.0             | https://logging.apache.org/log4j/2.0/license.html             | stf.*      | Download from https://archive.apache.org/dist/logging/log4j/2.16.0/apache-log4j-2.16.0-bin.zip                                                                                                                                                                        | Copy to PREREQS_ROOT/log4j-2.16.0/log4j-api-2.16.0.jar and PREREQS_ROOT/log4j-2.16.0/log4j-core-2.16.0.jar                                                                                                                                                                                                                      | Yes                                |\n| GNU make 3.79 or later| https://www.gnu.org/licenses/gpl.html                         | stf.build  | Windows - Download from http://gnuwin32.sourceforge.net/packages/make.htm<br>Unix: may already be installed on the test machine, a prebuilt version may already be available, otherwise build from source - see https://www.gnu.org/software/software.html\t         | Add GNU make to PATH (ahead of any native platform make) before executing make or make test, or copy make to PREREQS_ROOT/gmake/<platform> where platform is linux_x86-32, linux_x86-64, linux_ppc-32, linux_390-31, linux_arm-32, win_x86-32, aix_ppc-64, zos_390-64                                                                    | No                                 |\n| perl 5.6.1 or later   | http://perldoc.perl.org/index-licence.html                    | stf.core   | Windows - tests can be executed using Strawberry perl.  Other perl implementations may be OK too.                                       | Add to PATH                                                                                                                                                                                                                                                           | No                                 |\n| Windows Sysinternals  | https://technet.microsoft.com/en-us/sysinternals/bb469936.aspx| stf.core   | Download from https://download.sysinternals.com/files/SysinternalsSuite.zip                                                                                                                                                                                         | Unzip to PREREQS_ROOT/windows_sysinternals                                                                                                                                                                                                                              | Yes                                |\n| wget                  | https://www.gnu.org/copyleft/gpl.html                         | stf.build  | Windows - download from https://sourceforge.net/projects/gnuwin32/files/wget/1.11.4-1/wget-1.11.4-1-bin.zip                                                                                                                                                                   | Add to PATH                                                                                                                                                                                                                                                           | No                                 |\n| asm 9.7.1                  | https://asm.ow2.io/                         | stf.load  | Download from https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm/9.7.1/asm-9.7.1.jar                                                                                                                                                                   | Copy to PREREQS_ROOT/asm/asm.jar                                                                                                                                                                                                                                                           | Yes                                 |\n| asm-commons 9.7.1                  | https://asm.ow2.io/                         | stf.load  | Download from https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm-commons/9.7.1/asm-commons-9.7.1.jar                                                                                                                                                                   | Copy to PREREQS_ROOT/asm/asm-commons.jar                                                                                                                                                                                                                                                           | Yes                                 |\n\n## Building from a command line\n1. `git clone https://github.com/adoptium/STF.git stf`\n2. Change into the stf.build directory `cd <git-root>;stf.build`\n3. `make`\n\n"
    },
    "14": {
      "metadata": {
        "chunk_id": "3eb3c63b7a355f43b766e5763fa49a1b4dcb0a12294b11e025914057b27f5904",
        "file_path": "stf.build/docs/build.md",
        "content": "## Working in Eclipse - developing STF and STF test cases\nSTF and STF test case development must be done in an Eclipse environment. STF uses the Eclipse metadata\nin the project .classpath files to work out the test dependencies, these are then translated into -classpath command\nline arguments when the tests execute outside of Eclipse.\n1. Create a new Eclipse workspace (once configured the workspace will reference multiple git repositories and a local directory containing the test prereqs).\n2. Install the prerequisites\n- Follow the instructions above to install the prereqs which can't be installed by STF.\n- Follow the instructions above to install the remaining prereqs manually or via the build scripts.\n- Create a General Project in Eclipse called systemtest_prereqs\n- File --> Import --> File System\n- Select the directory containing the prereqs. Select import into the new systemtest_prereqs folder.  Do not tick\nthe 'Create top level folder' check box (otherwise you get an extra 'systemtest_prereqs' folder which you do not\nwant).\n3. `git clone https://github.com/adoptium/STF.git stf`\n4. Import the STF projects into Eclipse (Find and import Eclipse projects)\n5. Eclipse should now build the projects without errors (check the 'Problems' view).\n\n\n",
        "start_line": 46,
        "end_line": 64,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 271,
        "node_type": null,
        "file_sha": "457c95e5fa8d86afb7ef79339888c8896b21e06a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.639070"
      },
      "text": "## Working in Eclipse - developing STF and STF test cases\nSTF and STF test case development must be done in an Eclipse environment. STF uses the Eclipse metadata\nin the project .classpath files to work out the test dependencies, these are then translated into -classpath command\nline arguments when the tests execute outside of Eclipse.\n1. Create a new Eclipse workspace (once configured the workspace will reference multiple git repositories and a local directory containing the test prereqs).\n2. Install the prerequisites\n- Follow the instructions above to install the prereqs which can't be installed by STF.\n- Follow the instructions above to install the remaining prereqs manually or via the build scripts.\n- Create a General Project in Eclipse called systemtest_prereqs\n- File --> Import --> File System\n- Select the directory containing the prereqs. Select import into the new systemtest_prereqs folder.  Do not tick\nthe 'Create top level folder' check box (otherwise you get an extra 'systemtest_prereqs' folder which you do not\nwant).\n3. `git clone https://github.com/adoptium/STF.git stf`\n4. Import the STF projects into Eclipse (Find and import Eclipse projects)\n5. Eclipse should now build the projects without errors (check the 'Problems' view).\n\n\n"
    },
    "15": {
      "metadata": {
        "chunk_id": "0ce1f9b222ab3b989360dc67d133b46585e1543b36996b09018bde639490db28",
        "file_path": "stf.build/include/top.xml",
        "content": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->",
        "start_line": 0,
        "end_line": 14,
        "chunk_index": 0,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 119,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642225"
      },
      "text": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->"
    },
    "16": {
      "metadata": {
        "chunk_id": "be87101b16f10ac4be5d32765f6635746e7b670e6955875151331c325109379e",
        "file_path": "stf.build/include/top.xml",
        "content": "<project name=\"stf.top\">\n\n\t<!-- Set a property for accessing environment variables.  -->\n\t<property environment=\"env\"/>\n\t<condition property=\"system_lib_dir\" value=\"${env.SYSTEM_LIB_DIR}\" else=\"${source_root}/../../systemtest_prereqs\">\n\t\t<isset property=\"env.SYSTEM_LIB_DIR\"/>\n\t</condition>\n\n\t<echo message=\"system_lib_dir: ${system_lib_dir}\"/>\n\t<!-- Set default prereqs_root.  -->\n\t<!-- If source has been checked out to /home/user/git/stf, default location for prereqs is /home/user/systemtest_prereqs.  -->\n\t<property name=\"prereqs_root\" location=\"${system_lib_dir}\"/>\n\n\t<!-- Test specific prereqs may have been added to prereqs-root (in path1;path2;path3 notation).\n\t     Here the property first_prereqs_root is set containing just the first path in prereqs_root\n\t     which is assumed to be where the make configure prereqs are installed. -->\n\t<loadresource property=\"first_prereqs_root\" encoding=\"UTF-8\">\n\t\t<concat>${prereqs_root}</concat>\n\t\t<filterchain>\n\t\t\t<replaceregex pattern=\"([^\\;]*).*\" replace=\"\\1\" />\n\t\t</filterchain>\n\t</loadresource>\n\n\t<!-- Platform dependent settings.  -->\n\t<condition property=\"exe_suffix\" value=\".exe\" else=\"\" >\n\t   <os family=\"windows\" />\n    </condition>\n\t<condition property=\"is_windows\" value=\"true\" else=\"false\" >\n\t\t<os family=\"windows\" />\n\t</condition>\n\t<condition property=\"isOpenJ9\" value=\"true\" else=\"false\" >\n\t\t<contains string=\"${java_java_vm_vendor}\" substring=\"J9\"/>\n\t</condition>\n\n\t<!--Following are the systemtest prereq jar versions currently in use-->\n\t<property name=\"asm-version\" value=\"9.7.1\"/>\n\t<property name=\"ant-version\" value=\"1.10.2\"/>\n\t<property name=\"log4j-version\" value=\"2.16.0\"/>\n\t<property name=\"junit-version\" value=\"4.12\"/>\n\t<property name=\"hamcrest-version\" value=\"1.3\"/>\n\n\t<!--\n\t\tDetermine the java version being used for the build and set properties for use by build.xml files.\n\t\tIf the user did not set the property java_home, use the ant java.home property.\n\t\tOn IBM zOS java and Java 9, the ant property java.home points at JAVA_HOME.\n\t\tOn pre Java 9 non IBM zOS java, the ant property java.home points at JAVA_HOME/jre.\n\t-->\n\t<target name=\"setup-java-properties\" unless=\"setup_java_properties_run\">\n\t\t<property name=\"setup_java_properties_run\" value=\"true\"/>\n\t\t<echo message=\"java_home is ${java_home}\"/>\n\t\t<echo message=\"java.home is ${java.home}\"/>\n\t\t<condition property=\"java_home\" value=\"${java.home}\">\n\t\t\t<not>\n\t\t\t\t<available file=\"${java_home}\"/>\n\t\t\t</not>\n\t\t</condition>\n\t\t<set-platform-properties platform.property=\"java_platform\"\n\t\t\t\t\t\t\t\t platformclass.property=\"java_platformclass\"\n\t\t\t\t\t\t\t\t java.bindir.property=\"java_bindir\"\n\t\t\t\t\t\t\t\t java.compiler.property=\"java_compiler\"\n\t\t\t\t\t\t\t\t osname.property=\"java_osname\"\n\t\t\t\t\t\t\t\t arch.property=\"java_arch\"\n\t\t\t\t\t\t\t\t bits.property=\"java_bits\"\n\t\t\t\t\t\t\t\t java.specification.version.property=\"java_java_specification_version\"\n\t\t\t\t\t\t\t\t java.vm.vendor.property=\"java_java_vm_vendor\"\n\t\t\t\t\t\t\t\t java.home=\"${java_home}\"\n\t\t\t\t\t\t\t\t java.id=\"buildjdk\"/>\n\t\t<!-- Uncomment for debugging.  -->\n\t\t<!-- <echo message=\"java_platformclass set to ${java_platformclass}\"/> -->\n\t\t<!-- <echo message=\"java_osname set to ${java_osname}\"/> -->\n\t\t<!-- <echo message=\"java_arch set to ${java_arch}\"/> -->\n\t\t<!-- <echo message=\"java_bits set to ${java_bits}\"/> -->\n\t\t<echo message=\"java_platform set to ${java_platform}\"/>\n\t\t<echo message=\"java_java_specification_version set to ${java_java_specification_version}\"/>\n\t\t<echo message=\"java_java_vm_vendor set to ${java_java_vm_vendor}\"/>\n\t\t<echo message=\"java_bindir set to ${java_bindir}\"/>\n\t\t<property name=\"java_compiler\" location=\"${java_bindir}/javac${exe_suffix}\"/>\n\t\t<echo message=\"java_compiler set to ${java_compiler}\"/>\n\t</target>",
        "start_line": 15,
        "end_line": 93,
        "chunk_index": 1,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 955,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642233"
      },
      "text": "<project name=\"stf.top\">\n\n\t<!-- Set a property for accessing environment variables.  -->\n\t<property environment=\"env\"/>\n\t<condition property=\"system_lib_dir\" value=\"${env.SYSTEM_LIB_DIR}\" else=\"${source_root}/../../systemtest_prereqs\">\n\t\t<isset property=\"env.SYSTEM_LIB_DIR\"/>\n\t</condition>\n\n\t<echo message=\"system_lib_dir: ${system_lib_dir}\"/>\n\t<!-- Set default prereqs_root.  -->\n\t<!-- If source has been checked out to /home/user/git/stf, default location for prereqs is /home/user/systemtest_prereqs.  -->\n\t<property name=\"prereqs_root\" location=\"${system_lib_dir}\"/>\n\n\t<!-- Test specific prereqs may have been added to prereqs-root (in path1;path2;path3 notation).\n\t     Here the property first_prereqs_root is set containing just the first path in prereqs_root\n\t     which is assumed to be where the make configure prereqs are installed. -->\n\t<loadresource property=\"first_prereqs_root\" encoding=\"UTF-8\">\n\t\t<concat>${prereqs_root}</concat>\n\t\t<filterchain>\n\t\t\t<replaceregex pattern=\"([^\\;]*).*\" replace=\"\\1\" />\n\t\t</filterchain>\n\t</loadresource>\n\n\t<!-- Platform dependent settings.  -->\n\t<condition property=\"exe_suffix\" value=\".exe\" else=\"\" >\n\t   <os family=\"windows\" />\n    </condition>\n\t<condition property=\"is_windows\" value=\"true\" else=\"false\" >\n\t\t<os family=\"windows\" />\n\t</condition>\n\t<condition property=\"isOpenJ9\" value=\"true\" else=\"false\" >\n\t\t<contains string=\"${java_java_vm_vendor}\" substring=\"J9\"/>\n\t</condition>\n\n\t<!--Following are the systemtest prereq jar versions currently in use-->\n\t<property name=\"asm-version\" value=\"9.7.1\"/>\n\t<property name=\"ant-version\" value=\"1.10.2\"/>\n\t<property name=\"log4j-version\" value=\"2.16.0\"/>\n\t<property name=\"junit-version\" value=\"4.12\"/>\n\t<property name=\"hamcrest-version\" value=\"1.3\"/>\n\n\t<!--\n\t\tDetermine the java version being used for the build and set properties for use by build.xml files.\n\t\tIf the user did not set the property java_home, use the ant java.home property.\n\t\tOn IBM zOS java and Java 9, the ant property java.home points at JAVA_HOME.\n\t\tOn pre Java 9 non IBM zOS java, the ant property java.home points at JAVA_HOME/jre.\n\t-->\n\t<target name=\"setup-java-properties\" unless=\"setup_java_properties_run\">\n\t\t<property name=\"setup_java_properties_run\" value=\"true\"/>\n\t\t<echo message=\"java_home is ${java_home}\"/>\n\t\t<echo message=\"java.home is ${java.home}\"/>\n\t\t<condition property=\"java_home\" value=\"${java.home}\">\n\t\t\t<not>\n\t\t\t\t<available file=\"${java_home}\"/>\n\t\t\t</not>\n\t\t</condition>\n\t\t<set-platform-properties platform.property=\"java_platform\"\n\t\t\t\t\t\t\t\t platformclass.property=\"java_platformclass\"\n\t\t\t\t\t\t\t\t java.bindir.property=\"java_bindir\"\n\t\t\t\t\t\t\t\t java.compiler.property=\"java_compiler\"\n\t\t\t\t\t\t\t\t osname.property=\"java_osname\"\n\t\t\t\t\t\t\t\t arch.property=\"java_arch\"\n\t\t\t\t\t\t\t\t bits.property=\"java_bits\"\n\t\t\t\t\t\t\t\t java.specification.version.property=\"java_java_specification_version\"\n\t\t\t\t\t\t\t\t java.vm.vendor.property=\"java_java_vm_vendor\"\n\t\t\t\t\t\t\t\t java.home=\"${java_home}\"\n\t\t\t\t\t\t\t\t java.id=\"buildjdk\"/>\n\t\t<!-- Uncomment for debugging.  -->\n\t\t<!-- <echo message=\"java_platformclass set to ${java_platformclass}\"/> -->\n\t\t<!-- <echo message=\"java_osname set to ${java_osname}\"/> -->\n\t\t<!-- <echo message=\"java_arch set to ${java_arch}\"/> -->\n\t\t<!-- <echo message=\"java_bits set to ${java_bits}\"/> -->\n\t\t<echo message=\"java_platform set to ${java_platform}\"/>\n\t\t<echo message=\"java_java_specification_version set to ${java_java_specification_version}\"/>\n\t\t<echo message=\"java_java_vm_vendor set to ${java_java_vm_vendor}\"/>\n\t\t<echo message=\"java_bindir set to ${java_bindir}\"/>\n\t\t<property name=\"java_compiler\" location=\"${java_bindir}/javac${exe_suffix}\"/>\n\t\t<echo message=\"java_compiler set to ${java_compiler}\"/>\n\t</target>"
    },
    "17": {
      "metadata": {
        "chunk_id": "d76f52bb63f53704a37e11ea974dcc1f9f0c6bbb6df7eb49cca964c391f2efc6",
        "file_path": "stf.build/include/top.xml",
        "content": "<!-- Setup properties to allow projects to use a copy of Visual Studio for compiling native test cases.  -->\n\t<!-- Look for either version 10.0 or 14.0 in the default installation location.  -->\n\t<!-- To use a different location property rtb.vcvarsall_filename needs to be set on the command line for the build.  -->\n\t<!-- The vcvarsall.bat file argument amd64 is added if the javac being used to compile the java classes is a 64 bit java. -->\n\n\t<!-- Set up classpaths for prereqs. -->\n\t<path id=\"junit.class.path\">\n\t\t<pathelement location=\"${first_prereqs_root}/junit/junit.jar\"/>\n\t\t<pathelement location=\"${first_prereqs_root}/junit/hamcrest-core.jar\"/>\n\t</path>\n\t<path id=\"log4j.class.path\">\n\t\t<pathelement location=\"${first_prereqs_root}/log4j/log4j-api.jar\"/>\n\t\t<pathelement location=\"${first_prereqs_root}/log4j/log4j-core.jar\"/>\n\t</path>\n\t<path id=\"tools.class.path\">\n\t\t<pathelement location=\"${first_prereqs_root}/tools/tools.jar\"/>\n\t</path>\n\t<path id=\"asm.class.path\">\n\t\t<pathelement location=\"${first_prereqs_root}/asm/asm.jar\"/>\n\t\t<pathelement location=\"${first_prereqs_root}/asm/asm-commons.jar\"/>\n\t</path>\n\t<path id=\"stf.class.path\">\n\t\t<pathelement location=\"${stf_root}/stf.core/bin/stf.core.jar\"/>\n\t\t<pathelement location=\"${stf_root}/stf.load/bin/stf.load.jar\"/>\n\t</path>\n\t<path id=\"project.class.path\">\n\t\t<path refid=\"junit.class.path\" />\n\t\t<path refid=\"log4j.class.path\" />\n\t</path>\n\n\t<!--\n\t\tTarget to check for prereqs.\n\t\tSame as configure target except prereqs are not installed if missing.\n\t-->\n\t<target name=\"check-prereqs\" depends=\"setup-java-properties\" unless=\"check_prereqs_run\">\n\t\t<ant target=\"run-check-prereqs\" inheritAll=\"true\"/>\n\t\t<property name=\"check_prereqs_run\" value=\"true\"/>\n\t</target>\n\t<target name=\"run-check-prereqs\" depends=\"check-for-ant, print-ant-location, print-ant-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-junit, print-junit-location, print-junit-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-hamcrest-core, print-hamcrest-core-location, print-hamcrest-core-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-log4j, print-log4j-location, print-log4j-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-asm, print-asm-location, print-asm-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-tools-jar, print-tools-jar-location, print-tools-jar-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-windows-sysinternals, print-windows-sysinternals-location, print-windows-sysinternals-error,\n\t\t\t\t\t\t\t\t\t\t  fail-if-error, print-all-prereq-versions\">\n\t</target>\n\n\t<!--\n\t\tTargets to check for and download prereqs.\n\t\tAll prereqs are installed under the same ${first_prereqs_root} directory.\n\t-->\n\t<target name=\"configure\" depends=\"check-for-ant, configure-ant, print-ant-location, print-ant-error,\n\t\t\t\t\t\t\t\t\t  check-for-junit, configure-junit, print-junit-location, print-junit-error,\n\t\t\t\t\t\t\t\t\t  check-for-hamcrest-core, configure-hamcrest-core, print-hamcrest-core-location, print-hamcrest-core-error,\n\t\t\t\t\t\t\t\t\t  check-for-log4j, configure-log4j, print-log4j-location, print-log4j-error,\n\t\t\t\t\t\t\t\t\t  check-for-asm, configure-asm, print-asm-location, print-asm-error,\n\t\t\t\t\t\t\t\t\t  check-for-tools-jar, configure-tools-jar, print-tools-jar-location, print-tools-jar-error,\n\t\t\t\t\t\t\t\t\t  check-for-windows-sysinternals, set-download-windows-sysinternals-required, configure-windows-sysinternals, print-windows-sysinternals-location, print-windows-sysinternals-error,\n\t\t\t\t\t\t\t\t\t  fail-if-error, print-all-prereq-versions\">\n\t</target>\n\n\t<!-- Target to check if ant is available. -->\n\t<!-- At the time of writing, the default apt-get ant version on Ubuntu is 1.9.6. -->\n\t<!-- Building Java 9 applications requires 1.10.2. -->\n\t<target name=\"check-for-ant\">\n\t\t<property name=\"ant_dir\" location=\"${first_prereqs_root}/apache-ant\"/>\n\t\t<property name=\"ant_file\" value=\"lib/ant-launcher.jar\"/>\n\t\t<property name=\"ant\" location=\"${ant_dir}/${ant_file}\"/>\n\t    <available file=\"${ant}\" property=\"ant_available\"/>\n\t</target>",
        "start_line": 94,
        "end_line": 164,
        "chunk_index": 2,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 1026,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642235"
      },
      "text": "<!-- Setup properties to allow projects to use a copy of Visual Studio for compiling native test cases.  -->\n\t<!-- Look for either version 10.0 or 14.0 in the default installation location.  -->\n\t<!-- To use a different location property rtb.vcvarsall_filename needs to be set on the command line for the build.  -->\n\t<!-- The vcvarsall.bat file argument amd64 is added if the javac being used to compile the java classes is a 64 bit java. -->\n\n\t<!-- Set up classpaths for prereqs. -->\n\t<path id=\"junit.class.path\">\n\t\t<pathelement location=\"${first_prereqs_root}/junit/junit.jar\"/>\n\t\t<pathelement location=\"${first_prereqs_root}/junit/hamcrest-core.jar\"/>\n\t</path>\n\t<path id=\"log4j.class.path\">\n\t\t<pathelement location=\"${first_prereqs_root}/log4j/log4j-api.jar\"/>\n\t\t<pathelement location=\"${first_prereqs_root}/log4j/log4j-core.jar\"/>\n\t</path>\n\t<path id=\"tools.class.path\">\n\t\t<pathelement location=\"${first_prereqs_root}/tools/tools.jar\"/>\n\t</path>\n\t<path id=\"asm.class.path\">\n\t\t<pathelement location=\"${first_prereqs_root}/asm/asm.jar\"/>\n\t\t<pathelement location=\"${first_prereqs_root}/asm/asm-commons.jar\"/>\n\t</path>\n\t<path id=\"stf.class.path\">\n\t\t<pathelement location=\"${stf_root}/stf.core/bin/stf.core.jar\"/>\n\t\t<pathelement location=\"${stf_root}/stf.load/bin/stf.load.jar\"/>\n\t</path>\n\t<path id=\"project.class.path\">\n\t\t<path refid=\"junit.class.path\" />\n\t\t<path refid=\"log4j.class.path\" />\n\t</path>\n\n\t<!--\n\t\tTarget to check for prereqs.\n\t\tSame as configure target except prereqs are not installed if missing.\n\t-->\n\t<target name=\"check-prereqs\" depends=\"setup-java-properties\" unless=\"check_prereqs_run\">\n\t\t<ant target=\"run-check-prereqs\" inheritAll=\"true\"/>\n\t\t<property name=\"check_prereqs_run\" value=\"true\"/>\n\t</target>\n\t<target name=\"run-check-prereqs\" depends=\"check-for-ant, print-ant-location, print-ant-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-junit, print-junit-location, print-junit-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-hamcrest-core, print-hamcrest-core-location, print-hamcrest-core-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-log4j, print-log4j-location, print-log4j-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-asm, print-asm-location, print-asm-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-tools-jar, print-tools-jar-location, print-tools-jar-error,\n\t\t\t\t\t\t\t\t\t\t  check-for-windows-sysinternals, print-windows-sysinternals-location, print-windows-sysinternals-error,\n\t\t\t\t\t\t\t\t\t\t  fail-if-error, print-all-prereq-versions\">\n\t</target>\n\n\t<!--\n\t\tTargets to check for and download prereqs.\n\t\tAll prereqs are installed under the same ${first_prereqs_root} directory.\n\t-->\n\t<target name=\"configure\" depends=\"check-for-ant, configure-ant, print-ant-location, print-ant-error,\n\t\t\t\t\t\t\t\t\t  check-for-junit, configure-junit, print-junit-location, print-junit-error,\n\t\t\t\t\t\t\t\t\t  check-for-hamcrest-core, configure-hamcrest-core, print-hamcrest-core-location, print-hamcrest-core-error,\n\t\t\t\t\t\t\t\t\t  check-for-log4j, configure-log4j, print-log4j-location, print-log4j-error,\n\t\t\t\t\t\t\t\t\t  check-for-asm, configure-asm, print-asm-location, print-asm-error,\n\t\t\t\t\t\t\t\t\t  check-for-tools-jar, configure-tools-jar, print-tools-jar-location, print-tools-jar-error,\n\t\t\t\t\t\t\t\t\t  check-for-windows-sysinternals, set-download-windows-sysinternals-required, configure-windows-sysinternals, print-windows-sysinternals-location, print-windows-sysinternals-error,\n\t\t\t\t\t\t\t\t\t  fail-if-error, print-all-prereq-versions\">\n\t</target>\n\n\t<!-- Target to check if ant is available. -->\n\t<!-- At the time of writing, the default apt-get ant version on Ubuntu is 1.9.6. -->\n\t<!-- Building Java 9 applications requires 1.10.2. -->\n\t<target name=\"check-for-ant\">\n\t\t<property name=\"ant_dir\" location=\"${first_prereqs_root}/apache-ant\"/>\n\t\t<property name=\"ant_file\" value=\"lib/ant-launcher.jar\"/>\n\t\t<property name=\"ant\" location=\"${ant_dir}/${ant_file}\"/>\n\t    <available file=\"${ant}\" property=\"ant_available\"/>\n\t</target>"
    },
    "18": {
      "metadata": {
        "chunk_id": "80e699dc739047d9bb4f4a5553e509f9a80e8713d767d71ec956c9772f20132d",
        "file_path": "stf.build/include/top.xml",
        "content": "<!-- Target to check if ant is available. -->\n\t<!-- At the time of writing, the default apt-get ant version on Ubuntu is 1.9.6. -->\n\t<!-- Building Java 9 applications requires 1.10.2. -->\n\t<target name=\"check-for-ant\">\n\t\t<property name=\"ant_dir\" location=\"${first_prereqs_root}/apache-ant\"/>\n\t\t<property name=\"ant_file\" value=\"lib/ant-launcher.jar\"/>\n\t\t<property name=\"ant\" location=\"${ant_dir}/${ant_file}\"/>\n\t    <available file=\"${ant}\" property=\"ant_available\"/>\n\t</target>\n\n\t<!--\n\t\tTarget to get ant from http://archive.apache.org/dist/ant/binaries/apache-ant-bin.zip\n\t\tUnzip to PREREQS_ROOT/ant\n\t-->\n\t<target name=\"configure-ant\" unless=\"ant_available\">\n\t\t<download-file destdir=\"${java.io.tmpdir}/apache-ant\" destfile=\"apache-ant-bin.zip\" srcurl=\"http://archive.apache.org/dist/ant/binaries/apache-ant-${ant-version}-bin.zip\"/>\n\t\t<!-- The ant zip file includes a top level apache-ant directory. -->\n\t\t<unzip src=\"${java.io.tmpdir}/apache-ant/apache-ant-bin.zip\" dest=\"${java.io.tmpdir}/apache-ant\"/>\n\t\t<copydir src=\"${java.io.tmpdir}/apache-ant/apache-ant-${ant-version}\" dest=\"${first_prereqs_root}/apache-ant\"/>\n\t\t<delete dir=\"${java.io.tmpdir}/apache-ant\"/>\n\t    <available file=\"${ant}\" property=\"ant_available\"/>\n\t</target>\n\n\t<!-- Target to check if junit is available. -->\n\t<target name=\"check-for-junit\" unless=\"check_prereqs_run\">\n\t\t<property name=\"junit_dir\" location=\"${first_prereqs_root}/junit\"/>\n\t\t<property name=\"junit_file\" value=\"junit.jar\"/>\n\t\t<property name=\"junit\" location=\"${junit_dir}/${junit_file}\"/>\n\t\t<available file=\"${junit}\" property=\"junit_available\"/>\n\t</target>\n\n\t<!--\n\t\tTarget to get junit from https://search.maven.org/remotecontent?filepath=junit/junit/4.12/junit.jar\n\t\tCopy to ${first_prereqs_root}/junit/junit.jar\n\t-->\n\t<target name=\"configure-junit\" unless=\"junit_available\">\n\t\t<download-file destdir=\"${first_prereqs_root}/junit\" destfile=\"junit.jar\" srcurl=\"https://search.maven.org/remotecontent?filepath=junit/junit/${junit-version}/junit-${junit-version}.jar\"/>\n\t\t<available file=\"${junit}\" property=\"junit_available\"/>\n\t</target>\n\n\t<!-- Target to check if hamcrest core (required by junit) is available. -->\n\t<target name=\"check-for-hamcrest-core\" unless=\"check_prereqs_run\">\n\t\t<property name=\"hamcrest_core_dir\" location=\"${first_prereqs_root}/junit\"/>\n\t\t<property name=\"hamcrest_core_file\" value=\"hamcrest-core.jar\"/>\n\t\t<property name=\"hamcrest_core\" location=\"${hamcrest_core_dir}/${hamcrest_core_file}\"/>\n\t\t<available file=\"${hamcrest_core}\" property=\"hamcrest_core_available\"/>\n\t</target>\n\n\t<!--\n\t\tTarget to get hamcrest core from https://search.maven.org/remotecontent?filepath=org/hamcrest/hamcrest-core/${hamcrest-version}/hamcrest-core.jar\n\t\tCopy to PREREQS_ROOT/junit/hamcrest-core.jar\n\t-->\n\t<target name=\"configure-hamcrest-core\" unless=\"hamcrest_core_available\">\n\t\t<download-file destdir=\"${first_prereqs_root}/junit\" destfile=\"hamcrest-core.jar\" srcurl=\"https://search.maven.org/remotecontent?filepath=org/hamcrest/hamcrest-core/${hamcrest-version}/hamcrest-core-${hamcrest-version}.jar\"/>\n\t\t<available file=\"${hamcrest_core}\" property=\"hamcrest_core_available\"/>\n\t</target>\n\n\t<!-- Target to check if log4j is available. -->\n\t<target name=\"check-for-log4j\" unless=\"check_prereqs_run\">\n\t\t<property name=\"log4j_dir\" location=\"${first_prereqs_root}/log4j\"/>\n\t\t<property name=\"log4j_api_file\" value=\"log4j-api.jar\"/>\n\t\t<property name=\"log4j_core_file\" value=\"log4j-core.jar\"/>\n\t\t<property name=\"log4j_api\" location=\"${log4j_dir}/${log4j_api_file}\"/>\n\t\t<property name=\"log4j_core\" location=\"${log4j_dir}/${log4j_core_file}\"/>\n\t\t<condition property=\"log4j_available\">\n\t\t\t<and>\n\t\t\t\t<available file=\"${log4j_api}\"/>\n\t\t\t\t<available file=\"${log4j_core}\"/>\n\t\t\t</and>\n\t\t</condition>\n\t</target>",
        "start_line": 165,
        "end_line": 235,
        "chunk_index": 3,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 1076,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642238"
      },
      "text": "<!-- Target to check if ant is available. -->\n\t<!-- At the time of writing, the default apt-get ant version on Ubuntu is 1.9.6. -->\n\t<!-- Building Java 9 applications requires 1.10.2. -->\n\t<target name=\"check-for-ant\">\n\t\t<property name=\"ant_dir\" location=\"${first_prereqs_root}/apache-ant\"/>\n\t\t<property name=\"ant_file\" value=\"lib/ant-launcher.jar\"/>\n\t\t<property name=\"ant\" location=\"${ant_dir}/${ant_file}\"/>\n\t    <available file=\"${ant}\" property=\"ant_available\"/>\n\t</target>\n\n\t<!--\n\t\tTarget to get ant from http://archive.apache.org/dist/ant/binaries/apache-ant-bin.zip\n\t\tUnzip to PREREQS_ROOT/ant\n\t-->\n\t<target name=\"configure-ant\" unless=\"ant_available\">\n\t\t<download-file destdir=\"${java.io.tmpdir}/apache-ant\" destfile=\"apache-ant-bin.zip\" srcurl=\"http://archive.apache.org/dist/ant/binaries/apache-ant-${ant-version}-bin.zip\"/>\n\t\t<!-- The ant zip file includes a top level apache-ant directory. -->\n\t\t<unzip src=\"${java.io.tmpdir}/apache-ant/apache-ant-bin.zip\" dest=\"${java.io.tmpdir}/apache-ant\"/>\n\t\t<copydir src=\"${java.io.tmpdir}/apache-ant/apache-ant-${ant-version}\" dest=\"${first_prereqs_root}/apache-ant\"/>\n\t\t<delete dir=\"${java.io.tmpdir}/apache-ant\"/>\n\t    <available file=\"${ant}\" property=\"ant_available\"/>\n\t</target>\n\n\t<!-- Target to check if junit is available. -->\n\t<target name=\"check-for-junit\" unless=\"check_prereqs_run\">\n\t\t<property name=\"junit_dir\" location=\"${first_prereqs_root}/junit\"/>\n\t\t<property name=\"junit_file\" value=\"junit.jar\"/>\n\t\t<property name=\"junit\" location=\"${junit_dir}/${junit_file}\"/>\n\t\t<available file=\"${junit}\" property=\"junit_available\"/>\n\t</target>\n\n\t<!--\n\t\tTarget to get junit from https://search.maven.org/remotecontent?filepath=junit/junit/4.12/junit.jar\n\t\tCopy to ${first_prereqs_root}/junit/junit.jar\n\t-->\n\t<target name=\"configure-junit\" unless=\"junit_available\">\n\t\t<download-file destdir=\"${first_prereqs_root}/junit\" destfile=\"junit.jar\" srcurl=\"https://search.maven.org/remotecontent?filepath=junit/junit/${junit-version}/junit-${junit-version}.jar\"/>\n\t\t<available file=\"${junit}\" property=\"junit_available\"/>\n\t</target>\n\n\t<!-- Target to check if hamcrest core (required by junit) is available. -->\n\t<target name=\"check-for-hamcrest-core\" unless=\"check_prereqs_run\">\n\t\t<property name=\"hamcrest_core_dir\" location=\"${first_prereqs_root}/junit\"/>\n\t\t<property name=\"hamcrest_core_file\" value=\"hamcrest-core.jar\"/>\n\t\t<property name=\"hamcrest_core\" location=\"${hamcrest_core_dir}/${hamcrest_core_file}\"/>\n\t\t<available file=\"${hamcrest_core}\" property=\"hamcrest_core_available\"/>\n\t</target>\n\n\t<!--\n\t\tTarget to get hamcrest core from https://search.maven.org/remotecontent?filepath=org/hamcrest/hamcrest-core/${hamcrest-version}/hamcrest-core.jar\n\t\tCopy to PREREQS_ROOT/junit/hamcrest-core.jar\n\t-->\n\t<target name=\"configure-hamcrest-core\" unless=\"hamcrest_core_available\">\n\t\t<download-file destdir=\"${first_prereqs_root}/junit\" destfile=\"hamcrest-core.jar\" srcurl=\"https://search.maven.org/remotecontent?filepath=org/hamcrest/hamcrest-core/${hamcrest-version}/hamcrest-core-${hamcrest-version}.jar\"/>\n\t\t<available file=\"${hamcrest_core}\" property=\"hamcrest_core_available\"/>\n\t</target>\n\n\t<!-- Target to check if log4j is available. -->\n\t<target name=\"check-for-log4j\" unless=\"check_prereqs_run\">\n\t\t<property name=\"log4j_dir\" location=\"${first_prereqs_root}/log4j\"/>\n\t\t<property name=\"log4j_api_file\" value=\"log4j-api.jar\"/>\n\t\t<property name=\"log4j_core_file\" value=\"log4j-core.jar\"/>\n\t\t<property name=\"log4j_api\" location=\"${log4j_dir}/${log4j_api_file}\"/>\n\t\t<property name=\"log4j_core\" location=\"${log4j_dir}/${log4j_core_file}\"/>\n\t\t<condition property=\"log4j_available\">\n\t\t\t<and>\n\t\t\t\t<available file=\"${log4j_api}\"/>\n\t\t\t\t<available file=\"${log4j_core}\"/>\n\t\t\t</and>\n\t\t</condition>\n\t</target>"
    },
    "19": {
      "metadata": {
        "chunk_id": "235b38854f086e5980fdcdbeff19d9cfc28e66a197e23e1a294ef622e8bbc976",
        "file_path": "stf.build/include/top.xml",
        "content": "<!-- Target to check if log4j is available. -->\n\t<target name=\"check-for-log4j\" unless=\"check_prereqs_run\">\n\t\t<property name=\"log4j_dir\" location=\"${first_prereqs_root}/log4j\"/>\n\t\t<property name=\"log4j_api_file\" value=\"log4j-api.jar\"/>\n\t\t<property name=\"log4j_core_file\" value=\"log4j-core.jar\"/>\n\t\t<property name=\"log4j_api\" location=\"${log4j_dir}/${log4j_api_file}\"/>\n\t\t<property name=\"log4j_core\" location=\"${log4j_dir}/${log4j_core_file}\"/>\n\t\t<condition property=\"log4j_available\">\n\t\t\t<and>\n\t\t\t\t<available file=\"${log4j_api}\"/>\n\t\t\t\t<available file=\"${log4j_core}\"/>\n\t\t\t</and>\n\t\t</condition>\n\t</target>\n\n\t<!--\n\t\tTarget to get log4j from https://archive.apache.org/dist/logging/log4j/${log4j-version}/log4j-bin.zip\n\t\tCopy to PREREQS_ROOT/log4j/log4j-api.jar and PREREQS_ROOT/log4j/log4j-core.jar\n\t-->\n\t<target name=\"configure-log4j\" unless=\"log4j_available\">\n\t\t<download-file destdir=\"${java.io.tmpdir}/log4j\" destfile=\"apache-log4j-bin.zip\" srcurl=\"https://archive.apache.org/dist/logging/log4j/${log4j-version}/apache-log4j-${log4j-version}-bin.zip\"/>\n\t\t<unzip src=\"${java.io.tmpdir}/log4j/apache-log4j-bin.zip\" dest=\"${java.io.tmpdir}/log4j\"/>\n\t\t<copy file=\"${java.io.tmpdir}/log4j/apache-log4j-${log4j-version}-bin/log4j-api-${log4j-version}.jar\" tofile=\"${log4j_api}\"/>\n\t\t<copy file=\"${java.io.tmpdir}/log4j/apache-log4j-${log4j-version}-bin/log4j-core-${log4j-version}.jar\" tofile=\"${log4j_core}\"/>\n\t\t<delete dir=\"${java.io.tmpdir}/log4j\"/>\n\t\t<condition property=\"log4j_available\">\n\t\t\t<and>\n\t\t\t\t<available file=\"${log4j_api}\"/>\n\t\t\t\t<available file=\"${log4j_core}\"/>\n\t\t\t</and>\n\t\t</condition>\n\t</target>\n\t<!--\n\t\tIf we're running on Windows, check if the windows sysinternals tools are available.\n\t \tThe Windows Sysinternals tools are used to collect dumps and kill hung processes.\n\t-->\n\t<target name=\"check-for-windows-sysinternals\" unless=\"check_prereqs_run\">\n\t\t<property name=\"windows_sysinternals_dir\" location=\"${first_prereqs_root}/windows_sysinternals\"/>\n\t\t<!-- We're just using the existence of pskill.exe to determine whether the tools are installed. -->\n\t    <available file=\"${windows_sysinternals_dir}/pskill.exe\" property=\"windows_sysinternals_available\"/>\n\t</target>",
        "start_line": 236,
        "end_line": 276,
        "chunk_index": 4,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 669,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642241"
      },
      "text": "<!-- Target to check if log4j is available. -->\n\t<target name=\"check-for-log4j\" unless=\"check_prereqs_run\">\n\t\t<property name=\"log4j_dir\" location=\"${first_prereqs_root}/log4j\"/>\n\t\t<property name=\"log4j_api_file\" value=\"log4j-api.jar\"/>\n\t\t<property name=\"log4j_core_file\" value=\"log4j-core.jar\"/>\n\t\t<property name=\"log4j_api\" location=\"${log4j_dir}/${log4j_api_file}\"/>\n\t\t<property name=\"log4j_core\" location=\"${log4j_dir}/${log4j_core_file}\"/>\n\t\t<condition property=\"log4j_available\">\n\t\t\t<and>\n\t\t\t\t<available file=\"${log4j_api}\"/>\n\t\t\t\t<available file=\"${log4j_core}\"/>\n\t\t\t</and>\n\t\t</condition>\n\t</target>\n\n\t<!--\n\t\tTarget to get log4j from https://archive.apache.org/dist/logging/log4j/${log4j-version}/log4j-bin.zip\n\t\tCopy to PREREQS_ROOT/log4j/log4j-api.jar and PREREQS_ROOT/log4j/log4j-core.jar\n\t-->\n\t<target name=\"configure-log4j\" unless=\"log4j_available\">\n\t\t<download-file destdir=\"${java.io.tmpdir}/log4j\" destfile=\"apache-log4j-bin.zip\" srcurl=\"https://archive.apache.org/dist/logging/log4j/${log4j-version}/apache-log4j-${log4j-version}-bin.zip\"/>\n\t\t<unzip src=\"${java.io.tmpdir}/log4j/apache-log4j-bin.zip\" dest=\"${java.io.tmpdir}/log4j\"/>\n\t\t<copy file=\"${java.io.tmpdir}/log4j/apache-log4j-${log4j-version}-bin/log4j-api-${log4j-version}.jar\" tofile=\"${log4j_api}\"/>\n\t\t<copy file=\"${java.io.tmpdir}/log4j/apache-log4j-${log4j-version}-bin/log4j-core-${log4j-version}.jar\" tofile=\"${log4j_core}\"/>\n\t\t<delete dir=\"${java.io.tmpdir}/log4j\"/>\n\t\t<condition property=\"log4j_available\">\n\t\t\t<and>\n\t\t\t\t<available file=\"${log4j_api}\"/>\n\t\t\t\t<available file=\"${log4j_core}\"/>\n\t\t\t</and>\n\t\t</condition>\n\t</target>\n\t<!--\n\t\tIf we're running on Windows, check if the windows sysinternals tools are available.\n\t \tThe Windows Sysinternals tools are used to collect dumps and kill hung processes.\n\t-->\n\t<target name=\"check-for-windows-sysinternals\" unless=\"check_prereqs_run\">\n\t\t<property name=\"windows_sysinternals_dir\" location=\"${first_prereqs_root}/windows_sysinternals\"/>\n\t\t<!-- We're just using the existence of pskill.exe to determine whether the tools are installed. -->\n\t    <available file=\"${windows_sysinternals_dir}/pskill.exe\" property=\"windows_sysinternals_available\"/>\n\t</target>"
    },
    "20": {
      "metadata": {
        "chunk_id": "4fad22499a71e90af2e81952ca4118e76b2182226e4b3a39370b5b486e4c5042",
        "file_path": "stf.build/include/top.xml",
        "content": "<target name=\"set-download-windows-sysinternals-required\">\n\t\t<condition property=\"download_windows_sysinternals_required\">\n\t\t\t<and>\n\t\t\t\t<os family=\"windows\" />\n\t\t\t\t<not>\n\t\t\t\t\t<isset property=\"windows_sysinternals_available\"/>\n\t\t\t\t</not>\n\t\t\t</and>\n\t    </condition>\n\t</target>\n\t<!--\n\t\tGet the windows sysinternals tools from https://download.sysinternals.com/files/SysinternalsSuite.zip\n\t\tUnzip to PREREQS_ROOT/windows_sysinternals\n\t-->\n\t<target name=\"configure-windows-sysinternals\" if=\"download_windows_sysinternals_required\">\n\t\t<download-file destdir=\"${java.io.tmpdir}/windows_sysinternals\" destfile=\"SysinternalsSuite.zip\" srcurl=\"https://download.sysinternals.com/files/SysinternalsSuite.zip\"/>\n\t\t<unzip src=\"${java.io.tmpdir}/windows_sysinternals/SysinternalsSuite.zip\" dest=\"${windows_sysinternals_dir}\"/>\n\t\t<delete dir=\"${java.io.tmpdir}/windows_sysinternals\"/>\n\t\t<!-- We're just using the existence of pskill.exe to determine whether the tools are installed. -->\n\t    <available file=\"${windows_sysinternals_dir}/pskill.exe\" property=\"windows_sysinternals_available\"/>\n\t</target>\n\t<!--\n\t\tTarget to check if there is a tools.jar already copied to PREREQS_ROOT/tools.\n\t\tIf we already have a tools.jar, or we are using Java >8, then tools.jar is correct.\n\t\tIf we do not have a tools.jar, and we are using Java 8, then tools.jar is not correct.\n\t\tNote: In Java 9 the classes we need from tools.jar were folded into the Class Library,\n\t\tso we don't need the jar, and this is correct.\n\t-->\n\t<target name=\"check-for-tools-jar\" depends=\"setup-java-properties\">\n\t\t<property name=\"tools_jar_dir\" location=\"${first_prereqs_root}/tools\"/>\n\t\t<property name=\"tools_jar_file\" value=\"tools.jar\"/>\n\t\t<echo message=\"java_java_specification_version is ${java_java_specification_version}\"/>\n\t\t<condition property=\"tools_jar_correct\">\n\t\t\t<or>\n\t\t\t\t<not>\n\t\t\t\t\t<equals arg1=\"${java_java_specification_version}\" arg2=\"1.8\"/>\n\t\t\t\t</not>\n\t\t\t\t<and>\n\t\t\t\t\t<equals arg1=\"${java_java_specification_version}\" arg2=\"1.8\"/>\n\t\t\t\t\t<available file=\"${tools_jar_dir}/${tools_jar_file}\"/>\n\t\t\t\t</and>\n\t\t\t</or>\n\t\t</condition>\n\t    <available file=\"${tools_jar_dir}/${tools_jar_file}\" property=\"tools_jar\" value=\"${tools_jar_dir}/${tools_jar_file}\"/>\n\t</target>\n\n\t<!--\n\t\tSome tests may require test.debugging requires tools.jar for building (e.g. test.debugging in aqa-systemtest).\n\t\ttools.jar is shipped with java8, but is built into the jdk in later releases (so does not exist).\n\t\tThe code below looks for tools.jar in Java 8, but only if we are using java 8.\n\t\tIf tools.jar is found, it is copied to PREREQS_ROOT/tools.\n\t\tThe file is not automatically refreshed once it exists in PREREQS_ROOT/tools.\n\t-->\n\n\t<target name=\"configure-tools-jar\" depends=\"setup-java-properties\" unless=\"${tools_jar_correct}\">\n\t\t<property name=\"tools_jar_origin\" value=\"${java_bindir}/../lib/tools.jar\"/>\n\t\t<echo message=\"configure-tools-jar: Copying ${tools_jar_origin} to ${tools_jar_dir}\"/>\n\t\t<copy file=\"${tools_jar_origin}\" todir=\"${tools_jar_dir}\"/>\n\t\t<property name=\"tools_jar\" value=\"${tools_jar_dir}/${tools_jar_file}\"/>\n\t\t<available file=\"${tools_jar_dir}/${tools_jar_file}\" property=\"tools_jar_correct\"/>\n\t</target>\n\n\t<!-- Target to check if there is an asm-${asm-version}.jar already copied to PREREQS_ROOT/asm-${asm-version} -->\n\t<target name=\"check-for-asm\">\n\t\t<property name=\"asm_dir\" location=\"${first_prereqs_root}/asm\"/>\n\t\t<property name=\"asm_file\" value=\"asm.jar\"/>\n\t\t<property name=\"asm_commons_file\" value=\"asm-commons.jar\"/>\n\t\t<property name=\"asm\" value=\"${asm_dir}/${asm_file}\"/>\n\t\t<property name=\"asm_commons\" value=\"${asm_dir}/${asm_commons_file}\"/>\n\t\t<condition property=\"asm_available\">\n\t\t\t<and>\n\t\t\t\t<available file=\"${asm}\"/>\n\t\t\t\t<available file=\"${asm_commons}\"/>\n\t\t\t</and>\n\t\t</condition>\n\t</target>",
        "start_line": 277,
        "end_line": 352,
        "chunk_index": 5,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 1037,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642243"
      },
      "text": "<target name=\"set-download-windows-sysinternals-required\">\n\t\t<condition property=\"download_windows_sysinternals_required\">\n\t\t\t<and>\n\t\t\t\t<os family=\"windows\" />\n\t\t\t\t<not>\n\t\t\t\t\t<isset property=\"windows_sysinternals_available\"/>\n\t\t\t\t</not>\n\t\t\t</and>\n\t    </condition>\n\t</target>\n\t<!--\n\t\tGet the windows sysinternals tools from https://download.sysinternals.com/files/SysinternalsSuite.zip\n\t\tUnzip to PREREQS_ROOT/windows_sysinternals\n\t-->\n\t<target name=\"configure-windows-sysinternals\" if=\"download_windows_sysinternals_required\">\n\t\t<download-file destdir=\"${java.io.tmpdir}/windows_sysinternals\" destfile=\"SysinternalsSuite.zip\" srcurl=\"https://download.sysinternals.com/files/SysinternalsSuite.zip\"/>\n\t\t<unzip src=\"${java.io.tmpdir}/windows_sysinternals/SysinternalsSuite.zip\" dest=\"${windows_sysinternals_dir}\"/>\n\t\t<delete dir=\"${java.io.tmpdir}/windows_sysinternals\"/>\n\t\t<!-- We're just using the existence of pskill.exe to determine whether the tools are installed. -->\n\t    <available file=\"${windows_sysinternals_dir}/pskill.exe\" property=\"windows_sysinternals_available\"/>\n\t</target>\n\t<!--\n\t\tTarget to check if there is a tools.jar already copied to PREREQS_ROOT/tools.\n\t\tIf we already have a tools.jar, or we are using Java >8, then tools.jar is correct.\n\t\tIf we do not have a tools.jar, and we are using Java 8, then tools.jar is not correct.\n\t\tNote: In Java 9 the classes we need from tools.jar were folded into the Class Library,\n\t\tso we don't need the jar, and this is correct.\n\t-->\n\t<target name=\"check-for-tools-jar\" depends=\"setup-java-properties\">\n\t\t<property name=\"tools_jar_dir\" location=\"${first_prereqs_root}/tools\"/>\n\t\t<property name=\"tools_jar_file\" value=\"tools.jar\"/>\n\t\t<echo message=\"java_java_specification_version is ${java_java_specification_version}\"/>\n\t\t<condition property=\"tools_jar_correct\">\n\t\t\t<or>\n\t\t\t\t<not>\n\t\t\t\t\t<equals arg1=\"${java_java_specification_version}\" arg2=\"1.8\"/>\n\t\t\t\t</not>\n\t\t\t\t<and>\n\t\t\t\t\t<equals arg1=\"${java_java_specification_version}\" arg2=\"1.8\"/>\n\t\t\t\t\t<available file=\"${tools_jar_dir}/${tools_jar_file}\"/>\n\t\t\t\t</and>\n\t\t\t</or>\n\t\t</condition>\n\t    <available file=\"${tools_jar_dir}/${tools_jar_file}\" property=\"tools_jar\" value=\"${tools_jar_dir}/${tools_jar_file}\"/>\n\t</target>\n\n\t<!--\n\t\tSome tests may require test.debugging requires tools.jar for building (e.g. test.debugging in aqa-systemtest).\n\t\ttools.jar is shipped with java8, but is built into the jdk in later releases (so does not exist).\n\t\tThe code below looks for tools.jar in Java 8, but only if we are using java 8.\n\t\tIf tools.jar is found, it is copied to PREREQS_ROOT/tools.\n\t\tThe file is not automatically refreshed once it exists in PREREQS_ROOT/tools.\n\t-->\n\n\t<target name=\"configure-tools-jar\" depends=\"setup-java-properties\" unless=\"${tools_jar_correct}\">\n\t\t<property name=\"tools_jar_origin\" value=\"${java_bindir}/../lib/tools.jar\"/>\n\t\t<echo message=\"configure-tools-jar: Copying ${tools_jar_origin} to ${tools_jar_dir}\"/>\n\t\t<copy file=\"${tools_jar_origin}\" todir=\"${tools_jar_dir}\"/>\n\t\t<property name=\"tools_jar\" value=\"${tools_jar_dir}/${tools_jar_file}\"/>\n\t\t<available file=\"${tools_jar_dir}/${tools_jar_file}\" property=\"tools_jar_correct\"/>\n\t</target>\n\n\t<!-- Target to check if there is an asm-${asm-version}.jar already copied to PREREQS_ROOT/asm-${asm-version} -->\n\t<target name=\"check-for-asm\">\n\t\t<property name=\"asm_dir\" location=\"${first_prereqs_root}/asm\"/>\n\t\t<property name=\"asm_file\" value=\"asm.jar\"/>\n\t\t<property name=\"asm_commons_file\" value=\"asm-commons.jar\"/>\n\t\t<property name=\"asm\" value=\"${asm_dir}/${asm_file}\"/>\n\t\t<property name=\"asm_commons\" value=\"${asm_dir}/${asm_commons_file}\"/>\n\t\t<condition property=\"asm_available\">\n\t\t\t<and>\n\t\t\t\t<available file=\"${asm}\"/>\n\t\t\t\t<available file=\"${asm_commons}\"/>\n\t\t\t</and>\n\t\t</condition>\n\t</target>"
    },
    "21": {
      "metadata": {
        "chunk_id": "a1a2a1f921706655c1ed5dae37fab0643e04487fa5c74f3a55f92914cd188970",
        "file_path": "stf.build/include/top.xml",
        "content": "<target name=\"print-windows-sysinternals-location\" if=\"windows_sysinternals_available\">\n\t\t<echo message=\"Using windows sysinternals from from ${windows_sysinternals_dir}\"/>\n\t</target>\n\n\t<target name=\"print-tools-jar-location\" if=\"tools_jar\">\n\t\t<echo message=\"Using tools.jar from ${tools_jar}\"/>\n\t</target>\n\n\t<target name=\"print-asm-location\" if=\"asm_available\">\n\t\t<echo message=\"Using ${asm_file} from ${asm}\"/>\n\t\t<echo message=\"Using ${asm_commons_file} from ${asm_commons}\"/>\n\t</target>\n\n\t<target name=\"print-ant-error\" unless=\"ant_available\">\n\t\t<echo message=\"ERROR: Cannot find ant at ${ant}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-junit-error\" unless=\"junit_available\">\n\t\t<echo message=\"ERROR: Cannot find junit at ${junit}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-hamcrest-core-error\" unless=\"hamcrest_core_available\">\n\t\t<echo message=\"ERROR: Cannot find hamcrest-core at ${hamcrest_core}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-log4j-error\" unless=\"log4j_available\">\n\t\t<echo message=\"ERROR: Cannot find log4j-api at ${log4j_api} and / or log4j-core at ${log4j_core}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-asm-error\" unless=\"asm_available\">\n\t\t<echo message=\"ERROR: Cannot find ${asm_file} at ${asm} and / or ${asm_commons_file} at ${asm_commons}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-tools-jar-error\" unless=\"tools_jar_correct\">\n\t\t<echo message=\"ERROR: Cannot find tools.jar at ${tools_jar}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-windows-sysinternals-error\" depends=\"set-print-windows-sysinternals-error-required,really-print-windows-sysinternals-error\">\n\t</target>\n\n\t<target name=\"set-print-windows-sysinternals-error-required\">\n\t\t<condition property=\"print_windows_sysinternals_error_required\">\n\t\t\t<and>\n\t\t\t\t<os family=\"windows\" />\n\t\t\t\t<not>\n\t\t\t\t\t<isset property=\"windows_sysinternals_available\"/>\n\t\t\t\t</not>\n\t\t\t</and>\n\t    </condition>\n\t</target>\n\n\t<target name=\"really-print-windows-sysinternals-error\" if=\"${print_windows_sysinternals_error_required}\">\n\t\t<echo message=\"ERROR: Cannot find windows sysinternals at ${windows_sysinternals_dir}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<!-- <target name=\"fail-if-error\" if=\"${fail_run}\"> -->\n\t<target name=\"fail-if-error\" if=\"fail_run\">\n\t\t<fail message=\"Cannot find one or more prereqs.  See the above error messages.  Running 'make configure' or the ant configure target may get all the missing prereqs.  See the appropriate stf.build/docs/build.md or openjdk.build/docs/build.md for more details.\"/>\n\t</target>\n\n\t<target name=\"print-all-prereq-versions\">\n\t\t<echo message=\"Ant version in use     : ${ant-version}\"/>\n\t\t<echo message=\"log4j version in use   : ${log4j-version}\"/>\n\t\t<echo message=\"ASM version in use     : ${asm-version}\"/>\n\t\t<echo message=\"junit version in use   : ${junit-version}\"/>\n\t\t<echo message=\"hamcrest version in use: ${hamcrest-version}\"/>\n\t</target>",
        "start_line": 353,
        "end_line": 426,
        "chunk_index": 6,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 868,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642245"
      },
      "text": "<target name=\"print-windows-sysinternals-location\" if=\"windows_sysinternals_available\">\n\t\t<echo message=\"Using windows sysinternals from from ${windows_sysinternals_dir}\"/>\n\t</target>\n\n\t<target name=\"print-tools-jar-location\" if=\"tools_jar\">\n\t\t<echo message=\"Using tools.jar from ${tools_jar}\"/>\n\t</target>\n\n\t<target name=\"print-asm-location\" if=\"asm_available\">\n\t\t<echo message=\"Using ${asm_file} from ${asm}\"/>\n\t\t<echo message=\"Using ${asm_commons_file} from ${asm_commons}\"/>\n\t</target>\n\n\t<target name=\"print-ant-error\" unless=\"ant_available\">\n\t\t<echo message=\"ERROR: Cannot find ant at ${ant}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-junit-error\" unless=\"junit_available\">\n\t\t<echo message=\"ERROR: Cannot find junit at ${junit}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-hamcrest-core-error\" unless=\"hamcrest_core_available\">\n\t\t<echo message=\"ERROR: Cannot find hamcrest-core at ${hamcrest_core}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-log4j-error\" unless=\"log4j_available\">\n\t\t<echo message=\"ERROR: Cannot find log4j-api at ${log4j_api} and / or log4j-core at ${log4j_core}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-asm-error\" unless=\"asm_available\">\n\t\t<echo message=\"ERROR: Cannot find ${asm_file} at ${asm} and / or ${asm_commons_file} at ${asm_commons}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-tools-jar-error\" unless=\"tools_jar_correct\">\n\t\t<echo message=\"ERROR: Cannot find tools.jar at ${tools_jar}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<target name=\"print-windows-sysinternals-error\" depends=\"set-print-windows-sysinternals-error-required,really-print-windows-sysinternals-error\">\n\t</target>\n\n\t<target name=\"set-print-windows-sysinternals-error-required\">\n\t\t<condition property=\"print_windows_sysinternals_error_required\">\n\t\t\t<and>\n\t\t\t\t<os family=\"windows\" />\n\t\t\t\t<not>\n\t\t\t\t\t<isset property=\"windows_sysinternals_available\"/>\n\t\t\t\t</not>\n\t\t\t</and>\n\t    </condition>\n\t</target>\n\n\t<target name=\"really-print-windows-sysinternals-error\" if=\"${print_windows_sysinternals_error_required}\">\n\t\t<echo message=\"ERROR: Cannot find windows sysinternals at ${windows_sysinternals_dir}\"/>\n\t\t<property name=\"fail_run\" value=\"true\"/>\n\t</target>\n\n\t<!-- <target name=\"fail-if-error\" if=\"${fail_run}\"> -->\n\t<target name=\"fail-if-error\" if=\"fail_run\">\n\t\t<fail message=\"Cannot find one or more prereqs.  See the above error messages.  Running 'make configure' or the ant configure target may get all the missing prereqs.  See the appropriate stf.build/docs/build.md or openjdk.build/docs/build.md for more details.\"/>\n\t</target>\n\n\t<target name=\"print-all-prereq-versions\">\n\t\t<echo message=\"Ant version in use     : ${ant-version}\"/>\n\t\t<echo message=\"log4j version in use   : ${log4j-version}\"/>\n\t\t<echo message=\"ASM version in use     : ${asm-version}\"/>\n\t\t<echo message=\"junit version in use   : ${junit-version}\"/>\n\t\t<echo message=\"hamcrest version in use: ${hamcrest-version}\"/>\n\t</target>"
    },
    "22": {
      "metadata": {
        "chunk_id": "1fda931deb875f9d863c1b3f9296292cf2978c2732fb17f5e840d2417bf7aa2a",
        "file_path": "stf.build/include/top.xml",
        "content": "<target name=\"print-all-prereq-versions\">\n\t\t<echo message=\"Ant version in use     : ${ant-version}\"/>\n\t\t<echo message=\"log4j version in use   : ${log4j-version}\"/>\n\t\t<echo message=\"ASM version in use     : ${asm-version}\"/>\n\t\t<echo message=\"junit version in use   : ${junit-version}\"/>\n\t\t<echo message=\"hamcrest version in use: ${hamcrest-version}\"/>\n\t</target>\n\n\t<macrodef name=\"set-platform-properties\" description=\"Sets various properties for the java at the provided java_home location\">\n\t\t<attribute name=\"platform.property\" description=\"The property to put the platform name in - e.g. win_x86-64\"/>\n\t\t<attribute name=\"platformclass.property\" description=\"The property to put the platform class in - e.g. win_x86, linux_ppcle\"/>\n\t\t<attribute name=\"java.bindir.property\" description=\"The property to put the java bin directory in\"/>\n\t\t<attribute name=\"java.compiler.property\" description=\"The property to put the java compiler executable in\"/>\n\t\t<attribute name=\"osname.property\" description=\"The property to put the osname in e.g. win, linux\"/>\n\t\t<attribute name=\"arch.property\" description=\"The property to put the architecture in - e.g. x86, ppcle, 390\"/>\n\t\t<attribute name=\"bits.property\" description=\"The property to put the bits in - e.g. 31, 32, 64\"/>\n\t\t<attribute name=\"java.specification.version.property\" description=\"The property to put the java version in - e.g. 1.8, 9\"/>\n\t\t<attribute name=\"java.vm.vendor.property\" description=\"The JVM version - e.g. Eclipse OpenJ9\"/>\n\t\t<attribute name=\"java.home\" description=\"The JAVA_HOME directory of the java to query\"/>\n\t\t<attribute name=\"java.id\" description=\"A unique identifier to prefix the properties for the java instance with\"/>\n\t\t<sequential>\n\t\t\t<available file=\"@{java.home}/bin/javac${exe_suffix}\" property=\"@{java.bindir.property}\" value=\"@{java.home}/bin\"/>\n\t\t\t<available file=\"@{java.home}/../bin/javac${exe_suffix}\"  property=\"@{java.bindir.property}\" value=\"@{java.home}/../bin\"/>\n\t\t\t<property name=\"@{java.compiler.property}\" location=\"${@{java.bindir.property}}/javac${exe_suffix}\"/>\n\t\t\t<tempfile property=\"properties_file\" destDir=\"${java.io.tmpdir}\" prefix=\"openjdk.java.build.properties.\"/>\n\t\t\t<!-- Run java -XshowSettings:properties -version to determine java platform\" -->\n\t\t\t<exec executable=\"${@{java.bindir.property}}/java\" output=\"${properties_file}\">\n\t\t\t\t<arg value=\"-XshowSettings:properties\"/>\n\t\t\t\t<arg value=\"-version\"/>\n\t\t\t</exec>\n\t\t\t<loadproperties srcFile=\"${properties_file}\" prefix=\"@{java.id}.\" prefixValues=\"false\">\n\t\t\t\t<filterchain>\n\t\t\t\t\t<replacestring from=\"\\\" to=\"\\\\\" />\n\t\t\t\t</filterchain>\n\t\t\t</loadproperties>\n\t\t\t<!-- comment to stop echo the -XshowSettings:properties output to the log. -->\n\t\t\t<echoproperties>\n\t\t\t\t<propertyset>\n\t\t\t\t\t<propertyref prefix=\"@{java.id}.\"/>\n\t\t\t\t</propertyset>\n\t\t\t</echoproperties>\n\t\t\t<delete file=\"${properties_file}\" verbose=\"false\"/>\n\t\t\t<property name=\"resolved.os.name\" value=\"${@{java.id}.os.name}\"/>\n\t\t\t<echo message=\"DEBUG: Resolved os.name for @{java.id} is ${resolved.os.name}\"/>\n\t\t\t<get-platform-prefix property=\"@{osname.property}\" osname=\"${resolved.os.name}\"/>\n\t\t\t<get-platform-arch property=\"@{arch.property}\" arch=\"${@{java.id}.os.arch}\"/>\n\t\t\t<get-platform-bits property=\"@{bits.property}\" bits=\"${@{java.id}.sun.arch.data.model}\"/>\n\t\t\t<property name=\"@{platform.property}\" value=\"${@{osname.property}}_${@{arch.property}}-${@{bits.property}}\"/>\n\t\t\t<property name=\"@{platformclass.property}\" value=\"${@{osname.property}}_${@{arch.property}}\"/>\n\t\t\t<property name=\"@{java.specification.version.property}\" value=\"${@{java.id}.java.specification.version}\"/>\n\t\t\t<property name=\"@{java.vm.vendor.property}\" value=\"${@{java.id}.java.vm.vendor}\"/>\n\t\t</sequential>\n\t</macrodef>",
        "start_line": 427,
        "end_line": 479,
        "chunk_index": 7,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 985,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642247"
      },
      "text": "<target name=\"print-all-prereq-versions\">\n\t\t<echo message=\"Ant version in use     : ${ant-version}\"/>\n\t\t<echo message=\"log4j version in use   : ${log4j-version}\"/>\n\t\t<echo message=\"ASM version in use     : ${asm-version}\"/>\n\t\t<echo message=\"junit version in use   : ${junit-version}\"/>\n\t\t<echo message=\"hamcrest version in use: ${hamcrest-version}\"/>\n\t</target>\n\n\t<macrodef name=\"set-platform-properties\" description=\"Sets various properties for the java at the provided java_home location\">\n\t\t<attribute name=\"platform.property\" description=\"The property to put the platform name in - e.g. win_x86-64\"/>\n\t\t<attribute name=\"platformclass.property\" description=\"The property to put the platform class in - e.g. win_x86, linux_ppcle\"/>\n\t\t<attribute name=\"java.bindir.property\" description=\"The property to put the java bin directory in\"/>\n\t\t<attribute name=\"java.compiler.property\" description=\"The property to put the java compiler executable in\"/>\n\t\t<attribute name=\"osname.property\" description=\"The property to put the osname in e.g. win, linux\"/>\n\t\t<attribute name=\"arch.property\" description=\"The property to put the architecture in - e.g. x86, ppcle, 390\"/>\n\t\t<attribute name=\"bits.property\" description=\"The property to put the bits in - e.g. 31, 32, 64\"/>\n\t\t<attribute name=\"java.specification.version.property\" description=\"The property to put the java version in - e.g. 1.8, 9\"/>\n\t\t<attribute name=\"java.vm.vendor.property\" description=\"The JVM version - e.g. Eclipse OpenJ9\"/>\n\t\t<attribute name=\"java.home\" description=\"The JAVA_HOME directory of the java to query\"/>\n\t\t<attribute name=\"java.id\" description=\"A unique identifier to prefix the properties for the java instance with\"/>\n\t\t<sequential>\n\t\t\t<available file=\"@{java.home}/bin/javac${exe_suffix}\" property=\"@{java.bindir.property}\" value=\"@{java.home}/bin\"/>\n\t\t\t<available file=\"@{java.home}/../bin/javac${exe_suffix}\"  property=\"@{java.bindir.property}\" value=\"@{java.home}/../bin\"/>\n\t\t\t<property name=\"@{java.compiler.property}\" location=\"${@{java.bindir.property}}/javac${exe_suffix}\"/>\n\t\t\t<tempfile property=\"properties_file\" destDir=\"${java.io.tmpdir}\" prefix=\"openjdk.java.build.properties.\"/>\n\t\t\t<!-- Run java -XshowSettings:properties -version to determine java platform\" -->\n\t\t\t<exec executable=\"${@{java.bindir.property}}/java\" output=\"${properties_file}\">\n\t\t\t\t<arg value=\"-XshowSettings:properties\"/>\n\t\t\t\t<arg value=\"-version\"/>\n\t\t\t</exec>\n\t\t\t<loadproperties srcFile=\"${properties_file}\" prefix=\"@{java.id}.\" prefixValues=\"false\">\n\t\t\t\t<filterchain>\n\t\t\t\t\t<replacestring from=\"\\\" to=\"\\\\\" />\n\t\t\t\t</filterchain>\n\t\t\t</loadproperties>\n\t\t\t<!-- comment to stop echo the -XshowSettings:properties output to the log. -->\n\t\t\t<echoproperties>\n\t\t\t\t<propertyset>\n\t\t\t\t\t<propertyref prefix=\"@{java.id}.\"/>\n\t\t\t\t</propertyset>\n\t\t\t</echoproperties>\n\t\t\t<delete file=\"${properties_file}\" verbose=\"false\"/>\n\t\t\t<property name=\"resolved.os.name\" value=\"${@{java.id}.os.name}\"/>\n\t\t\t<echo message=\"DEBUG: Resolved os.name for @{java.id} is ${resolved.os.name}\"/>\n\t\t\t<get-platform-prefix property=\"@{osname.property}\" osname=\"${resolved.os.name}\"/>\n\t\t\t<get-platform-arch property=\"@{arch.property}\" arch=\"${@{java.id}.os.arch}\"/>\n\t\t\t<get-platform-bits property=\"@{bits.property}\" bits=\"${@{java.id}.sun.arch.data.model}\"/>\n\t\t\t<property name=\"@{platform.property}\" value=\"${@{osname.property}}_${@{arch.property}}-${@{bits.property}}\"/>\n\t\t\t<property name=\"@{platformclass.property}\" value=\"${@{osname.property}}_${@{arch.property}}\"/>\n\t\t\t<property name=\"@{java.specification.version.property}\" value=\"${@{java.id}.java.specification.version}\"/>\n\t\t\t<property name=\"@{java.vm.vendor.property}\" value=\"${@{java.id}.java.vm.vendor}\"/>\n\t\t</sequential>\n\t</macrodef>"
    },
    "23": {
      "metadata": {
        "chunk_id": "14df5d5e00d788792f6b21cbbe150ff0064f40b884712890e2d6fe621f7605cc",
        "file_path": "stf.build/include/top.xml",
        "content": "</project>",
        "start_line": 480,
        "end_line": 480,
        "chunk_index": 8,
        "total_chunks": 9,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 3,
        "node_type": null,
        "file_sha": "329b8b872a1f0ab8f75d5bcafa2b6f421adc6efb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.642250"
      },
      "text": "</project>"
    },
    "24": {
      "metadata": {
        "chunk_id": "6e2c3bd06b181be56cbf01a9780a5a069c20927c5be721ef193bd51f065538c9",
        "file_path": "stf.build/makefile",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nEMPTY=\n\n# Environment variable OSTYPE is set to cygwin if running under cygwin.\n# Set our own macro to indicate we're running under cygwin.\n# Also Windows commands will need to be prefixed with cmd /c to run them in a Windows shell.\nifndef CYGWIN\n  OSTYPE?=$(shell echo $$OSTYPE)\n  ifeq ($(OSTYPE),cygwin)\n    CYGWIN:=1\n    CMD_PREFIX=cmd /c\n  else\n    CYGWIN:=0\n  endif\nendif\n#$(warning CYGWIN is $(CYGWIN))\n\n# Use a macro to say whether we are running under Windows.\n# OS may not be set to Windows_NT under cygwin\nifeq ($(OS),Windows_NT)\n  ifneq ($(CYGWIN),1)\n    WINDOWS:=1\n  endif\nendif\n\n# Work out the resolved root directory name of the repository from the current makefile.\n\n# Assumes directory structure is\n#\n# git repository is checked out to <testing_root>$(D)git$(D)stf\n# So\n# <testing_root>$(D)git$(D)stf.core$(D)test_project1\n# <testing_root>$(D)git$(D)stf.core$(D)test_project2\n#\n# prereqs are installed to <testing_root>$(D)systemtest_prereqs\n# So\n# <testing_root>$(D)systemtest_prereqs$(D)prereq1\n# <testing_root>$(D)systemtest_prereqs$(D)prereq2\n#\n# To change override SOURCE_ROOT and $(D) or PREREQS_ROOT on the make command line\n# make SOURCE_ROOT=<my_SOURCE_ROOT> PREREQS_ROOT=<my_prereqs_root>\n\n# The current makefile is the last makefile in MAKEFILE_LIST\n\n#$(warning MAKEFILE_LIST is $(MAKEFILE_LIST))\nifeq ($(MAKEFILE_LIST),)\n  $(warning The MAKEFILE_LIST variable is not supported, this inbuilt variable is available on gnu make 3.80+)\n  $(warning Expecting the SOURCE_ROOT variable set instead) \n  ifeq ($(SOURCE_ROOT),)\n    $(error The SOURCE_ROOT variable is not set)\n  endif\nelse\n  CURRENT_MAKEFILE:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\n  $(warning CURRENT_MAKEFILE is $(CURRENT_MAKEFILE))\n  #MAKEFILE_ROOT_DIR:=$(dir $(CURRENT_MAKEFILE))$(D)..$(D)..\n  MAKEFILE_ROOT_DIR:=$(dir $(CURRENT_MAKEFILE))$(D)..\n  $(warning MAKEFILE_ROOT_DIR is $(MAKEFILE_ROOT_DIR))\n\n  ifneq ($(WINDOWS),1)\n    SOURCE_ROOT?=$(shell cd \"$(MAKEFILE_ROOT_DIR)\"; pwd)\n  else\n    SOURCE_ROOT:=$(subst \\,\\,$(strip $(subst Directory of,,$(shell $(CMD_PREFIX) dir \"$(subst \\,$(D),$(MAKEFILE_ROOT_DIR))\" | findstr $(D)C:\"Directory of\"))))\n  endif\n  # If we are running under cygwin, turn the $(D)cygdrive style path into the real Windows path.\n  # The tests all expect to be running under real Windows.\n  ifeq ($(CYGWIN),1)\n    WINDOWS:=1\n    #$(warning Running under cygwin)\n    #$(warning Before cygpath SOURCE_ROOT set to $(SOURCE_ROOT))\n    SOURCE_ROOT:=$(shell $(CMD_PREFIX) cygpath -m '$(SOURCE_ROOT)')\n  endif\nendif\n\n$(warning SOURCE_ROOT set to $(SOURCE_ROOT))",
        "start_line": 0,
        "end_line": 84,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "make",
        "chunk_type": "recursive",
        "token_count": 877,
        "node_type": null,
        "file_sha": "2d45600458126dddcae92991032e093d622aec92",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.645682"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nEMPTY=\n\n# Environment variable OSTYPE is set to cygwin if running under cygwin.\n# Set our own macro to indicate we're running under cygwin.\n# Also Windows commands will need to be prefixed with cmd /c to run them in a Windows shell.\nifndef CYGWIN\n  OSTYPE?=$(shell echo $$OSTYPE)\n  ifeq ($(OSTYPE),cygwin)\n    CYGWIN:=1\n    CMD_PREFIX=cmd /c\n  else\n    CYGWIN:=0\n  endif\nendif\n#$(warning CYGWIN is $(CYGWIN))\n\n# Use a macro to say whether we are running under Windows.\n# OS may not be set to Windows_NT under cygwin\nifeq ($(OS),Windows_NT)\n  ifneq ($(CYGWIN),1)\n    WINDOWS:=1\n  endif\nendif\n\n# Work out the resolved root directory name of the repository from the current makefile.\n\n# Assumes directory structure is\n#\n# git repository is checked out to <testing_root>$(D)git$(D)stf\n# So\n# <testing_root>$(D)git$(D)stf.core$(D)test_project1\n# <testing_root>$(D)git$(D)stf.core$(D)test_project2\n#\n# prereqs are installed to <testing_root>$(D)systemtest_prereqs\n# So\n# <testing_root>$(D)systemtest_prereqs$(D)prereq1\n# <testing_root>$(D)systemtest_prereqs$(D)prereq2\n#\n# To change override SOURCE_ROOT and $(D) or PREREQS_ROOT on the make command line\n# make SOURCE_ROOT=<my_SOURCE_ROOT> PREREQS_ROOT=<my_prereqs_root>\n\n# The current makefile is the last makefile in MAKEFILE_LIST\n\n#$(warning MAKEFILE_LIST is $(MAKEFILE_LIST))\nifeq ($(MAKEFILE_LIST),)\n  $(warning The MAKEFILE_LIST variable is not supported, this inbuilt variable is available on gnu make 3.80+)\n  $(warning Expecting the SOURCE_ROOT variable set instead) \n  ifeq ($(SOURCE_ROOT),)\n    $(error The SOURCE_ROOT variable is not set)\n  endif\nelse\n  CURRENT_MAKEFILE:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\n  $(warning CURRENT_MAKEFILE is $(CURRENT_MAKEFILE))\n  #MAKEFILE_ROOT_DIR:=$(dir $(CURRENT_MAKEFILE))$(D)..$(D)..\n  MAKEFILE_ROOT_DIR:=$(dir $(CURRENT_MAKEFILE))$(D)..\n  $(warning MAKEFILE_ROOT_DIR is $(MAKEFILE_ROOT_DIR))\n\n  ifneq ($(WINDOWS),1)\n    SOURCE_ROOT?=$(shell cd \"$(MAKEFILE_ROOT_DIR)\"; pwd)\n  else\n    SOURCE_ROOT:=$(subst \\,\\,$(strip $(subst Directory of,,$(shell $(CMD_PREFIX) dir \"$(subst \\,$(D),$(MAKEFILE_ROOT_DIR))\" | findstr $(D)C:\"Directory of\"))))\n  endif\n  # If we are running under cygwin, turn the $(D)cygdrive style path into the real Windows path.\n  # The tests all expect to be running under real Windows.\n  ifeq ($(CYGWIN),1)\n    WINDOWS:=1\n    #$(warning Running under cygwin)\n    #$(warning Before cygpath SOURCE_ROOT set to $(SOURCE_ROOT))\n    SOURCE_ROOT:=$(shell $(CMD_PREFIX) cygpath -m '$(SOURCE_ROOT)')\n  endif\nendif\n\n$(warning SOURCE_ROOT set to $(SOURCE_ROOT))"
    },
    "25": {
      "metadata": {
        "chunk_id": "ff3a4ad52b8632b00ceb130ab062c4c6ce58880141a9d4fd83f46018fefd3a23",
        "file_path": "stf.build/makefile",
        "content": "# Create unix style path name - fixes are required to escape backslashes in all places they may be found.\nPREREQS_ROOT_UNIX = $(subst \\,$(D),$(PREREQS_ROOT))\n\n# To build to a different location specify TARGET_ROOT=<a directory> on the make command line\nTARGET_ROOT:=$(SOURCE_ROOT)\n\nANT_LIB:=lib\nANT_LIB_PATH=$(ANT_HOME)$(D)$(ANT_LIB)\nANT_JAVA_HOME:=$(JAVA_HOME)\nANT_LAUNCHER=$(ANT_LIB_PATH)$(D)ant-launcher.jar\n\nifeq (,$(ANT_JAVA_HOME))\n  $(warning ANT_JAVA_HOME not set, will use $(JAVA_HOME) to run ant)\nendif\n\nifndef ANT_HOME\n  # Is there an ant in $(PREREQS_ROOT)$(D)apache-ant?\n  # If not, try to find ant on the path and use that one\n  ANT_HOME:=$(PREREQS_ROOT)$(D)apache-ant\n  $(warning ANT_HOME not set, looking in $(ANT_HOME))\n  ifeq (file_exists,$(call file_exists,$(ANT_LAUNCHER)))\n    $(warning Found $(ANT_LAUNCHER))\n  else\n    $(warning Cannot find $(ANT_LAUNCHER), looking for ant on the PATH)\n    # On Windows run where ant.bat\n    # On Unix run which ant, and use realpath to resolve symlinks (ant is likely to be symlinked e.g. to usr$(D)bin$(D)ant).\n    ifeq ($(WINDOWS),1)\n      ANT_BINDIR:=$(dir $(firstword $(shell $(CMD_PREFIX) $(WHICH) ant$(BAT) 2>$(NULL))))\n      $(warning $(CMD_PREFIX) $(WHICH) ant$(BAT) 2>$(NULL) returned)\n      $(warning $(ANT_BINDIR))\n      ifneq (,$(ANT_BINDIR))\n        ANT_HOME:=$(ANT_BINDIR)$(D)..\n        $(warning ANT_HOME set to $(ANT_HOME))\n        $(warning Found $(ANT_BINDIR), will start build with $(ANT_LAUNCHER).  Run make configure to install the required ant version 1.10.1 or follow the prereq install instructions in build$(D)build.md)\n      else\n        $(error Unable to locate ant to start the build. Either add ant to PATH, set ANT_HOME or follow the prereq install instructions in build$(D)build.md)\n      endif\n    else  # Unix\n      ANT_BINDIR:=$(dir $(firstword $(shell $(WHICH) ant$(BAT) 2>$(NULL))))\n      $(warning $(WHICH) ant$(BAT) 2>$(NULL) returned)\n      $(warning $(ANT_BINDIR))\n      ifneq (,$(ANT_BINDIR))\n        ANT_BINDIR:=$(realpath $(ANT_BINDIR)$(D)ant$(BAT))\n        ANT_HOME:=$(abspath $(ANT_BINDIR)$(D)..$(D)..)\n        $(warning ANT_BINDIR set to $(ANT_BINDIR))\n        $(warning ANT_HOME set to $(ANT_HOME))\n        $(warning Found $(ANT_BINDIR), will start build with $(ANT_LAUNCHER).  Run make configure to install the required ant version 1.10.1 or follow the prereq install instructions in build$(D)build.md)\n        ifeq (,$(wildcard $(ANT_LIB_PATH)))\n        # On OSX if ant has been installed using homebrew cater for the ant-launcher.jar being in libexec/lib rather than lib.\n        $(warning WARNING: Cannot find $(ANT_LIB_PATH) directory. Looking in libexec/lib.)\n          ANT_LIB:=libexec$(D)lib\n          ifeq (,$(wildcard $(ANT_LIB_PATH)))\n            $(error ERROR: ANT_LIB_PATH directory $(ANT_LIB_PATH) does not exist.)\n          endif\n        endif\n      else\n        $(error Unable to locate ant to start the build. Either add ant to PATH, set ANT_HOME or follow the prereq install instructions in build$(D)build.md)\n      endif\n    endif\n  endif\nendif\n\nifeq (1,$(ERROR))\n  $(error Fix above errors and retry)\nendif\n\n$(warning JAVA_HOME is $(JAVA_HOME))\nJAVA:=$(JAVA_HOME)$(D)bin$(D)java$(EXE)\nJAVAC:=$(JAVA_HOME)$(D)bin$(D)javac$(EXE)\nJAVA_OUTPUT:=$(shell $(CMD_PREFIX) $(JAVA) -fullversion 2>&1)\n$(warning $(CMD_PREFIX) $(JAVA) -fullversion returned)\n$(warning $(JAVA_OUTPUT))\n\nBUILD_COMMAND:=$(CMD_PREFIX) $(ANT_JAVA_HOME)$(D)bin$(D)java$(EXE) -classpath $(ANT_LAUNCHER) org.apache.tools.ant.launch.Launcher -buildfile $(TARGET_ROOT)$(D)stf.build$(D)build.xml -Dprereqs_root=\"$(PREREQS_ROOT)\"\nBUILD_COMMAND:=$(BUILD_COMMAND) -Djava_home=$(JAVA_HOME)",
        "start_line": 85,
        "end_line": 159,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "make",
        "chunk_type": "recursive",
        "token_count": 1044,
        "node_type": null,
        "file_sha": "2d45600458126dddcae92991032e093d622aec92",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.645688"
      },
      "text": "# Create unix style path name - fixes are required to escape backslashes in all places they may be found.\nPREREQS_ROOT_UNIX = $(subst \\,$(D),$(PREREQS_ROOT))\n\n# To build to a different location specify TARGET_ROOT=<a directory> on the make command line\nTARGET_ROOT:=$(SOURCE_ROOT)\n\nANT_LIB:=lib\nANT_LIB_PATH=$(ANT_HOME)$(D)$(ANT_LIB)\nANT_JAVA_HOME:=$(JAVA_HOME)\nANT_LAUNCHER=$(ANT_LIB_PATH)$(D)ant-launcher.jar\n\nifeq (,$(ANT_JAVA_HOME))\n  $(warning ANT_JAVA_HOME not set, will use $(JAVA_HOME) to run ant)\nendif\n\nifndef ANT_HOME\n  # Is there an ant in $(PREREQS_ROOT)$(D)apache-ant?\n  # If not, try to find ant on the path and use that one\n  ANT_HOME:=$(PREREQS_ROOT)$(D)apache-ant\n  $(warning ANT_HOME not set, looking in $(ANT_HOME))\n  ifeq (file_exists,$(call file_exists,$(ANT_LAUNCHER)))\n    $(warning Found $(ANT_LAUNCHER))\n  else\n    $(warning Cannot find $(ANT_LAUNCHER), looking for ant on the PATH)\n    # On Windows run where ant.bat\n    # On Unix run which ant, and use realpath to resolve symlinks (ant is likely to be symlinked e.g. to usr$(D)bin$(D)ant).\n    ifeq ($(WINDOWS),1)\n      ANT_BINDIR:=$(dir $(firstword $(shell $(CMD_PREFIX) $(WHICH) ant$(BAT) 2>$(NULL))))\n      $(warning $(CMD_PREFIX) $(WHICH) ant$(BAT) 2>$(NULL) returned)\n      $(warning $(ANT_BINDIR))\n      ifneq (,$(ANT_BINDIR))\n        ANT_HOME:=$(ANT_BINDIR)$(D)..\n        $(warning ANT_HOME set to $(ANT_HOME))\n        $(warning Found $(ANT_BINDIR), will start build with $(ANT_LAUNCHER).  Run make configure to install the required ant version 1.10.1 or follow the prereq install instructions in build$(D)build.md)\n      else\n        $(error Unable to locate ant to start the build. Either add ant to PATH, set ANT_HOME or follow the prereq install instructions in build$(D)build.md)\n      endif\n    else  # Unix\n      ANT_BINDIR:=$(dir $(firstword $(shell $(WHICH) ant$(BAT) 2>$(NULL))))\n      $(warning $(WHICH) ant$(BAT) 2>$(NULL) returned)\n      $(warning $(ANT_BINDIR))\n      ifneq (,$(ANT_BINDIR))\n        ANT_BINDIR:=$(realpath $(ANT_BINDIR)$(D)ant$(BAT))\n        ANT_HOME:=$(abspath $(ANT_BINDIR)$(D)..$(D)..)\n        $(warning ANT_BINDIR set to $(ANT_BINDIR))\n        $(warning ANT_HOME set to $(ANT_HOME))\n        $(warning Found $(ANT_BINDIR), will start build with $(ANT_LAUNCHER).  Run make configure to install the required ant version 1.10.1 or follow the prereq install instructions in build$(D)build.md)\n        ifeq (,$(wildcard $(ANT_LIB_PATH)))\n        # On OSX if ant has been installed using homebrew cater for the ant-launcher.jar being in libexec/lib rather than lib.\n        $(warning WARNING: Cannot find $(ANT_LIB_PATH) directory. Looking in libexec/lib.)\n          ANT_LIB:=libexec$(D)lib\n          ifeq (,$(wildcard $(ANT_LIB_PATH)))\n            $(error ERROR: ANT_LIB_PATH directory $(ANT_LIB_PATH) does not exist.)\n          endif\n        endif\n      else\n        $(error Unable to locate ant to start the build. Either add ant to PATH, set ANT_HOME or follow the prereq install instructions in build$(D)build.md)\n      endif\n    endif\n  endif\nendif\n\nifeq (1,$(ERROR))\n  $(error Fix above errors and retry)\nendif\n\n$(warning JAVA_HOME is $(JAVA_HOME))\nJAVA:=$(JAVA_HOME)$(D)bin$(D)java$(EXE)\nJAVAC:=$(JAVA_HOME)$(D)bin$(D)javac$(EXE)\nJAVA_OUTPUT:=$(shell $(CMD_PREFIX) $(JAVA) -fullversion 2>&1)\n$(warning $(CMD_PREFIX) $(JAVA) -fullversion returned)\n$(warning $(JAVA_OUTPUT))\n\nBUILD_COMMAND:=$(CMD_PREFIX) $(ANT_JAVA_HOME)$(D)bin$(D)java$(EXE) -classpath $(ANT_LAUNCHER) org.apache.tools.ant.launch.Launcher -buildfile $(TARGET_ROOT)$(D)stf.build$(D)build.xml -Dprereqs_root=\"$(PREREQS_ROOT)\"\nBUILD_COMMAND:=$(BUILD_COMMAND) -Djava_home=$(JAVA_HOME)"
    },
    "26": {
      "metadata": {
        "chunk_id": "f0dbf3e00eaadac5bddd2f567d55065d693bfe70faaf3a06f92afb2d9a47fe37",
        "file_path": "stf.build/makefile",
        "content": "help:\n\t@echo make or make build: Builds stf projects\n\t@echo make test: Runs all samples\n\t@echo make $(SAMPLE_TARGETS): Runs all samples\n\t@echo make test.xxxx: Runs individual sample xxxx",
        "start_line": 160,
        "end_line": 164,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "make",
        "chunk_type": "recursive",
        "token_count": 50,
        "node_type": null,
        "file_sha": "2d45600458126dddcae92991032e093d622aec92",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.645691"
      },
      "text": "help:\n\t@echo make or make build: Builds stf projects\n\t@echo make test: Runs all samples\n\t@echo make $(SAMPLE_TARGETS): Runs all samples\n\t@echo make test.xxxx: Runs individual sample xxxx"
    },
    "27": {
      "metadata": {
        "chunk_id": "18f1f0eaf9c7e20f314fff1574bee978cc7b86b161c710f5b804c0ad18ce244a",
        "file_path": "stf.build/scripts/stf_clone_make.bat",
        "content": "REM Licensed under the Apache License, Version 2.0 (the \"License\");\nREM you may not use this file except in compliance with the License.\nREM You may obtain a copy of the License at\nREM\nREM      http://www.apache.org/licenses/LICENSE-2.0\nREM\nREM Unless required by applicable law or agreed to in writing, software\nREM distributed under the License is distributed on an \"AS IS\" BASIS,\nREM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nREM See the License for the specific language governing permissions and\nREM limitations under the License.\n\nREM Save current directory\nset currdir=%cd%\nREM Clone\n(IF NOT EXIST %USERPROFILE%\\git mkdir %USERPROFILE%\\git) && cd %USERPROFILE%\\git && (IF EXIST stf rmdir /s /q stf) && git clone https://github.com/adoptium/STF.git stf\nREM Configure (get prereqs)\ncd %USERPROFILE%\\git\\stf\\stf.build\nmake configure\nIF ERRORLEVEL 1 cd %currdir% && exit /B 1\nREM Build\ncd %USERPROFILE%\\git\\stf\\stf.build\nmake\nIF ERRORLEVEL 1 cd %currdir% && exit /B 1\n@echo stf repository build successful - to run the STF samples\n@echo cd %USERPROFILE%\\git\\stf\\stf.build && make test\nREM Restore current directory\ncd %currdir%\nexit /B 0\n\n\n",
        "start_line": 0,
        "end_line": 31,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 318,
        "node_type": null,
        "file_sha": "69502577b700a22b9618ab3054cdd83dc7bc9e93",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.648924"
      },
      "text": "REM Licensed under the Apache License, Version 2.0 (the \"License\");\nREM you may not use this file except in compliance with the License.\nREM You may obtain a copy of the License at\nREM\nREM      http://www.apache.org/licenses/LICENSE-2.0\nREM\nREM Unless required by applicable law or agreed to in writing, software\nREM distributed under the License is distributed on an \"AS IS\" BASIS,\nREM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nREM See the License for the specific language governing permissions and\nREM limitations under the License.\n\nREM Save current directory\nset currdir=%cd%\nREM Clone\n(IF NOT EXIST %USERPROFILE%\\git mkdir %USERPROFILE%\\git) && cd %USERPROFILE%\\git && (IF EXIST stf rmdir /s /q stf) && git clone https://github.com/adoptium/STF.git stf\nREM Configure (get prereqs)\ncd %USERPROFILE%\\git\\stf\\stf.build\nmake configure\nIF ERRORLEVEL 1 cd %currdir% && exit /B 1\nREM Build\ncd %USERPROFILE%\\git\\stf\\stf.build\nmake\nIF ERRORLEVEL 1 cd %currdir% && exit /B 1\n@echo stf repository build successful - to run the STF samples\n@echo cd %USERPROFILE%\\git\\stf\\stf.build && make test\nREM Restore current directory\ncd %currdir%\nexit /B 0\n\n\n"
    },
    "28": {
      "metadata": {
        "chunk_id": "50aba95dcd535cb1723f66665c13932d155396a8643f5ea316a8b459a2729596",
        "file_path": "stf.build/scripts/stf_clone_make.sh",
        "content": "#!/bin/sh\n#-------------------------------------------------------------------------\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#-------------------------------------------------------------------------\n\n# Clone\nmkdir -p $HOME/git && cd $HOME/git && rm -rf stf && mkdir stf && git clone https://github.com/adoptium/STF.git stf\nif [ \"$?\" != \"0\" ]; then\n        echo \"Error cloning stf\" 1>&2\n        exit 1\nfi\n# Configure (get prereqs)\ncd $HOME/git/stf/stf.build/ && make configure\nif [ \"$?\" != \"0\" ]; then\n        echo \"Error building stf - see build output\" 1>&2\n        exit 1\nfi\n# Build\ncd $HOME/git/stf/stf.build/ && make\nif [ \"$?\" != \"0\" ]; then\n        echo \"Error building stf - see build output\" 1>&2\n        exit 1\nfi\necho \"stf repository build successful - to run the STF samples\"\necho \"make -f $HOME/git/stf/stf.build/makefile test\"\nexit 0",
        "start_line": 0,
        "end_line": 35,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "bash",
        "chunk_type": "recursive",
        "token_count": 342,
        "node_type": null,
        "file_sha": "f4ac5f955d13b75bf7e2ca932485d3cc1ac212c6",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.651808"
      },
      "text": "#!/bin/sh\n#-------------------------------------------------------------------------\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#-------------------------------------------------------------------------\n\n# Clone\nmkdir -p $HOME/git && cd $HOME/git && rm -rf stf && mkdir stf && git clone https://github.com/adoptium/STF.git stf\nif [ \"$?\" != \"0\" ]; then\n        echo \"Error cloning stf\" 1>&2\n        exit 1\nfi\n# Configure (get prereqs)\ncd $HOME/git/stf/stf.build/ && make configure\nif [ \"$?\" != \"0\" ]; then\n        echo \"Error building stf - see build output\" 1>&2\n        exit 1\nfi\n# Build\ncd $HOME/git/stf/stf.build/ && make\nif [ \"$?\" != \"0\" ]; then\n        echo \"Error building stf - see build output\" 1>&2\n        exit 1\nfi\necho \"stf repository build successful - to run the STF samples\"\necho \"make -f $HOME/git/stf/stf.build/makefile test\"\nexit 0"
    },
    "29": {
      "metadata": {
        "chunk_id": "24f4b297c2924db94906d102f4ae6f374301c72f5b677759b261ba204ca94692",
        "file_path": "stf.core/.classpath",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<classpath>\n\t<classpathentry kind=\"src\" path=\"src/stf.core\"/>\n\t<classpathentry kind=\"src\" path=\"test/stf.core\"/>\n\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-api.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-core.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/junit/junit.jar\"/>\n\t<classpathentry kind=\"output\" path=\"bin\"/>\n</classpath>\n\n\n",
        "start_line": 0,
        "end_line": 12,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 151,
        "node_type": null,
        "file_sha": "bd8a8823d1a72e001eb0f240051b0e235e5c3a00",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.655544"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<classpath>\n\t<classpathentry kind=\"src\" path=\"src/stf.core\"/>\n\t<classpathentry kind=\"src\" path=\"test/stf.core\"/>\n\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-api.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-core.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/junit/junit.jar\"/>\n\t<classpathentry kind=\"output\" path=\"bin\"/>\n</classpath>\n\n\n"
    },
    "30": {
      "metadata": {
        "chunk_id": "2c57fd4ab33a72a400daaae06aaa6f56f75cb03570bc504d83aeb6e4b0363821",
        "file_path": "stf.core/.project",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>stf.core</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.jdt.core.javabuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.jdt.core.javanature</nature>\n\t</natures>\n</projectDescription>\n\n\n",
        "start_line": 0,
        "end_line": 19,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 119,
        "node_type": null,
        "file_sha": "a758215e1aabf21a33c8d4a0d5080aa33ab07d24",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.659245"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>stf.core</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.jdt.core.javabuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.jdt.core.javanature</nature>\n\t</natures>\n</projectDescription>\n\n\n"
    },
    "31": {
      "metadata": {
        "chunk_id": "d4a27cbe06c6ee2ffdb384ec7f9fdf4ac6c46166ac8e0aa6abe3687b4ee48768",
        "file_path": "stf.core/.settings/org.eclipse.jdt.core.prefs",
        "content": "eclipse.preferences.version=1\norg.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled\norg.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate\norg.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6\norg.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve\norg.eclipse.jdt.core.compiler.compliance=1.6\norg.eclipse.jdt.core.compiler.debug.lineNumber=generate\norg.eclipse.jdt.core.compiler.debug.localVariable=generate\norg.eclipse.jdt.core.compiler.debug.sourceFile=generate\norg.eclipse.jdt.core.compiler.problem.assertIdentifier=error\norg.eclipse.jdt.core.compiler.problem.enumIdentifier=error\norg.eclipse.jdt.core.compiler.source=1.6\n\n\n",
        "start_line": 0,
        "end_line": 14,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 152,
        "node_type": null,
        "file_sha": "ef8a789ca023fbae6a38ec202a1c1450598a792b",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.662327"
      },
      "text": "eclipse.preferences.version=1\norg.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled\norg.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate\norg.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6\norg.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve\norg.eclipse.jdt.core.compiler.compliance=1.6\norg.eclipse.jdt.core.compiler.debug.lineNumber=generate\norg.eclipse.jdt.core.compiler.debug.localVariable=generate\norg.eclipse.jdt.core.compiler.debug.sourceFile=generate\norg.eclipse.jdt.core.compiler.problem.assertIdentifier=error\norg.eclipse.jdt.core.compiler.problem.enumIdentifier=error\norg.eclipse.jdt.core.compiler.source=1.6\n\n\n"
    },
    "32": {
      "metadata": {
        "chunk_id": "bb364982d9301f5cc7a15e22e46e8dd23efe0ac4ffda1b5e30cc4ea1aeb0ebaf",
        "file_path": "stf.core/build.xml",
        "content": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n     http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->",
        "start_line": 0,
        "end_line": 12,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 119,
        "node_type": null,
        "file_sha": "96503d71eff6d05ec32ff2132be62c515035680e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.665332"
      },
      "text": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n     http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->"
    },
    "33": {
      "metadata": {
        "chunk_id": "05272f5d80a8a6eb5d9b96b0e5736e5717c0d4cf6cca511bda7c2e9cb9cc3cc9",
        "file_path": "stf.core/build.xml",
        "content": "<project name=\"stf.core\" default=\"build\">\n\n\t<echo message=\"Executing stf.core/build.xml\"/>\n\n\t<!-- Set default for source_root.  -->\n\t<property name=\"source_root\" location=\"..\"/>\n\n\t<property name=\"stf_root\" location=\"${source_root}/../stf\"/>\n\n\t<!-- Import settings used by multiple projects.  -->\n\t<import file=\"${stf_root}/stf.build/include/top.xml\"/>\n\n\t<!-- For modularity you need a directory above the package structure to hold the module.java file -->\n        \n\t<property name=\"stf_core_module\" value=\"stf.core\" />\n\t<property name=\"stf_core_src_dir\" value=\"src/${stf_core_module}\" />\n\t<property name=\"stf_core_test_dir\" value=\"test/${stf_core_module}\" />\n\t<property name=\"stf_core_bin_dir\" value=\"bin\" />\n\n\t<property name=\"stf_core_jar_file\" value=\"${stf_core_bin_dir}/${stf_core_module}.jar\" />\n\n\t<!-- Projects which need to be built before this one. -->\n\t<!-- dir must be set on the ant task otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-dependencies\">\n\t</target>\n\n\t<target name=\"build\" depends=\"check-prereqs, build-no-natives, build-natives\">\n\t</target>\n\n\t<!-- dir must be set otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-no-natives\" depends=\"check-prereqs, build-dependencies, build-archives, copy-log4j2-config\">\n\t</target>\n\n\t<!-- dir must be set otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-natives\" depends=\"check-prereqs, build-dependencies, copy-log4j2-config\">\n\t</target>\n\n\t<!-- <target name=\"build-archives\" depends=\"switch-to-target-dir,build-jar, build-jmod, build-jimage\"> -->\n\t<target name=\"build-archives\" depends=\"build-jar\">\n\t</target>\n\n\t<!-- Log4j config needs to be in the bin directory so that is on stf's classpath --> \n\t<target name=\"copy-log4j2-config\">\n\t\t<copy file=\"${stf_core_src_dir}/log4j2.xml\" tofile=\"${stf_core_bin_dir}/log4j2.xml\" />\n\t</target>\n\n\t<target name=\"build-jar\" depends=\"build-java, create-bin-dir\">\n\t\t<jar destfile=\"${stf_core_jar_file}\">\n\t\t\t<fileset dir=\"${stf_core_bin_dir}\" includes=\"**/*.class\" />\n\t\t</jar>\n\t</target>\n\n\t<target name=\"build-java\" depends=\"check-prereqs, create-bin-dir\">\n\t\t <!-- The Ant javac task only checks time dependencies between .java files and their .class files,\n\t\t      so fails to recompile in situations such as the signatures of a dependent method changing.\n\t\t      The depend target checks the dependencies and deletes any .class files older than the files\n\t\t      which depend on them, thereby ensuring recompilation.  -->\n\t\t<!--\n\t\tCommented out because depend appears to be evaluating class files as always out of date with jdk11 (at 28/03/2019)\n\t\t<depend srcdir=\"${stf_core_src_dir}:${stf_core_test_dir}\" destdir=\"${stf_core_bin_dir}\" classpathref=\"project.class.path\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</depend>\n\t\t-->\n\t    <!-- STF can be built using Java 7 or later.  -->\n\t    <!-- Build STF itself.  -->\n\t\t<javac srcdir=\"${stf_core_src_dir}\"\n\t\t\t   destdir=\"${stf_core_bin_dir}\"\n\t\t\t   debug=\"true\"\n\t\t\t   fork=\"true\"\n\t\t\t   executable=\"${java_compiler}\"\n\t\t\t   classpathref=\"project.class.path\"\n\t\t\t    encoding=\"${src-encoding}\"\n\t\t\t   includeantruntime=\"false\"\n\t\t\t   failonerror=\"true\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</javac>\n\t    <!-- Build test cases which verify STF.  -->\n\t\t<javac srcdir=\"${stf_core_test_dir}\"\n\t\t\t   destdir=\"${stf_core_bin_dir}\"\n\t\t\t   debug=\"true\"\n\t\t\t   fork=\"true\"\n\t\t\t   executable=\"${java_compiler}\"\n\t\t\t   classpathref=\"project.class.path\"\n\t\t\t   encoding=\"${src-encoding}\"\n\t\t\t   includeantruntime=\"false\"\n\t\t\t   failonerror=\"true\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</javac>\n\t</target>\n\n\t<target name=\"create-bin-dir\">\n\t\t<mkdir dir=\"${stf_core_bin_dir}\"/>\n\t</target>\n\n\t<target name=\"clean\">\n\t\t<delete dir=\"${stf_core_bin_dir}\"/>\n\t</target>\n\n</project>",
        "start_line": 13,
        "end_line": 111,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 1048,
        "node_type": null,
        "file_sha": "96503d71eff6d05ec32ff2132be62c515035680e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.665344"
      },
      "text": "<project name=\"stf.core\" default=\"build\">\n\n\t<echo message=\"Executing stf.core/build.xml\"/>\n\n\t<!-- Set default for source_root.  -->\n\t<property name=\"source_root\" location=\"..\"/>\n\n\t<property name=\"stf_root\" location=\"${source_root}/../stf\"/>\n\n\t<!-- Import settings used by multiple projects.  -->\n\t<import file=\"${stf_root}/stf.build/include/top.xml\"/>\n\n\t<!-- For modularity you need a directory above the package structure to hold the module.java file -->\n        \n\t<property name=\"stf_core_module\" value=\"stf.core\" />\n\t<property name=\"stf_core_src_dir\" value=\"src/${stf_core_module}\" />\n\t<property name=\"stf_core_test_dir\" value=\"test/${stf_core_module}\" />\n\t<property name=\"stf_core_bin_dir\" value=\"bin\" />\n\n\t<property name=\"stf_core_jar_file\" value=\"${stf_core_bin_dir}/${stf_core_module}.jar\" />\n\n\t<!-- Projects which need to be built before this one. -->\n\t<!-- dir must be set on the ant task otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-dependencies\">\n\t</target>\n\n\t<target name=\"build\" depends=\"check-prereqs, build-no-natives, build-natives\">\n\t</target>\n\n\t<!-- dir must be set otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-no-natives\" depends=\"check-prereqs, build-dependencies, build-archives, copy-log4j2-config\">\n\t</target>\n\n\t<!-- dir must be set otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-natives\" depends=\"check-prereqs, build-dependencies, copy-log4j2-config\">\n\t</target>\n\n\t<!-- <target name=\"build-archives\" depends=\"switch-to-target-dir,build-jar, build-jmod, build-jimage\"> -->\n\t<target name=\"build-archives\" depends=\"build-jar\">\n\t</target>\n\n\t<!-- Log4j config needs to be in the bin directory so that is on stf's classpath --> \n\t<target name=\"copy-log4j2-config\">\n\t\t<copy file=\"${stf_core_src_dir}/log4j2.xml\" tofile=\"${stf_core_bin_dir}/log4j2.xml\" />\n\t</target>\n\n\t<target name=\"build-jar\" depends=\"build-java, create-bin-dir\">\n\t\t<jar destfile=\"${stf_core_jar_file}\">\n\t\t\t<fileset dir=\"${stf_core_bin_dir}\" includes=\"**/*.class\" />\n\t\t</jar>\n\t</target>\n\n\t<target name=\"build-java\" depends=\"check-prereqs, create-bin-dir\">\n\t\t <!-- The Ant javac task only checks time dependencies between .java files and their .class files,\n\t\t      so fails to recompile in situations such as the signatures of a dependent method changing.\n\t\t      The depend target checks the dependencies and deletes any .class files older than the files\n\t\t      which depend on them, thereby ensuring recompilation.  -->\n\t\t<!--\n\t\tCommented out because depend appears to be evaluating class files as always out of date with jdk11 (at 28/03/2019)\n\t\t<depend srcdir=\"${stf_core_src_dir}:${stf_core_test_dir}\" destdir=\"${stf_core_bin_dir}\" classpathref=\"project.class.path\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</depend>\n\t\t-->\n\t    <!-- STF can be built using Java 7 or later.  -->\n\t    <!-- Build STF itself.  -->\n\t\t<javac srcdir=\"${stf_core_src_dir}\"\n\t\t\t   destdir=\"${stf_core_bin_dir}\"\n\t\t\t   debug=\"true\"\n\t\t\t   fork=\"true\"\n\t\t\t   executable=\"${java_compiler}\"\n\t\t\t   classpathref=\"project.class.path\"\n\t\t\t    encoding=\"${src-encoding}\"\n\t\t\t   includeantruntime=\"false\"\n\t\t\t   failonerror=\"true\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</javac>\n\t    <!-- Build test cases which verify STF.  -->\n\t\t<javac srcdir=\"${stf_core_test_dir}\"\n\t\t\t   destdir=\"${stf_core_bin_dir}\"\n\t\t\t   debug=\"true\"\n\t\t\t   fork=\"true\"\n\t\t\t   executable=\"${java_compiler}\"\n\t\t\t   classpathref=\"project.class.path\"\n\t\t\t   encoding=\"${src-encoding}\"\n\t\t\t   includeantruntime=\"false\"\n\t\t\t   failonerror=\"true\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</javac>\n\t</target>\n\n\t<target name=\"create-bin-dir\">\n\t\t<mkdir dir=\"${stf_core_bin_dir}\"/>\n\t</target>\n\n\t<target name=\"clean\">\n\t\t<delete dir=\"${stf_core_bin_dir}\"/>\n\t</target>\n\n</project>"
    },
    "34": {
      "metadata": {
        "chunk_id": "f66fba47cb08259c6a83a7d9b5d28b7ecd247ae4b729bdde89ba6431f30bdf5f",
        "file_path": "stf.core/config/stf.core.properties",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Specify jar locations. \n# Note that /systemtest-prereqs will be replaced, at java runtime, with the \n# supplied systemtest-prereq location that contains that jar.\njunit-jar         = /systemtest-prereqs/junit/junit.jar\nhamcrest-core-jar = /systemtest-prereqs/junit/hamcrest-core.jar\nlog4j-api-jar     = /systemtest-prereqs/log4j/log4j-api.jar\nlog4j-core-jar    = /systemtest-prereqs/log4j/log4j-core.jar\nasm-jar           = /systemtest-prereqs/asm/asm.jar\nasm-commons-jar   = /systemtest-prereqs/asm/asm-commons.jar\n#\n# Set the default location for apps-root.\n# Should no longer be required since systemtest-prereqs can now take multiple paths.\napps-root = /tmp\n#\n# Default mode is to run Java without any extra options.\n# If set then the options to use are read from the 'modes.xml' file. \nmode = NoOptions",
        "start_line": 0,
        "end_line": 28,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "properties",
        "chunk_type": "recursive",
        "token_count": 350,
        "node_type": null,
        "file_sha": "ad648e8b22bc409dd2b8033ea4746455bc9d647d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.668596"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Specify jar locations. \n# Note that /systemtest-prereqs will be replaced, at java runtime, with the \n# supplied systemtest-prereq location that contains that jar.\njunit-jar         = /systemtest-prereqs/junit/junit.jar\nhamcrest-core-jar = /systemtest-prereqs/junit/hamcrest-core.jar\nlog4j-api-jar     = /systemtest-prereqs/log4j/log4j-api.jar\nlog4j-core-jar    = /systemtest-prereqs/log4j/log4j-core.jar\nasm-jar           = /systemtest-prereqs/asm/asm.jar\nasm-commons-jar   = /systemtest-prereqs/asm/asm-commons.jar\n#\n# Set the default location for apps-root.\n# Should no longer be required since systemtest-prereqs can now take multiple paths.\napps-root = /tmp\n#\n# Default mode is to run Java without any extra options.\n# If set then the options to use are read from the 'modes.xml' file. \nmode = NoOptions"
    },
    "35": {
      "metadata": {
        "chunk_id": "079f2fa071c4f144978bd3e7a7b162414e65a53b54c23c417c192ca00bec93e8",
        "file_path": "stf.core/config/stf.properties",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# This file contains the lowest level of STF configuration.\n#\n# Any of the values specified here can be overridden by higher level configuration.\n# The search order for a parameters is:\n#   - command line arguments\n#   - user specific extension properties, eg. ~/.stf.runtimes.properties\n#   - user specific stf properties, eg ~/.stf.properties\n#   - extensions default properties, eg. stf.runtimes/config/stf.runtimes.properties\n#   - default stf properties file, eg. stf/config/stf.properties\n#\n# If an parameter is specified more than once then the value used is from the \n# first level it is encountered on.\n# If the same parameter is specified more than once on a particular level then the\n# final value overrides the earlier values.\n#\n# If the value of a property contains a '${.*}' then every such occurrence is replaced \n# with the value of the corresponding environment variable or the value of another property.\n# Resolution of the referenced property starts at the highest level.\n# Property values and environment variables may themselves reference other environment \n# variables or properties.\n#\n# For example:\n#   property value: java-execution-args = -Xss:512k ${fixed-args} ${extension-args}\n#   env.variable 1: fixed-args = ${java-memory-args} -Xverbose:gc\n#   env.variable 2: java-memory-args = -Xms:64m -Xmx:128m\n#   env.variable 3: extension-args = -server\n# Would be resolved to:\n#   java-execution-args = -Xss:512k -Xms:64m -Xmx:128m -Xverbose:gc -server\n# \n# Parameters which have a value of 'null' are ignored. They are allowed so that a \n# config file, such as this file, can list and document all possible parameters.\n# \n\n\n# ------------------------  Properties used by stf.pl  ------------------------\n\n# If dry-run is set to true then the setup,execute and teardown scripts are not executed following generation.\n# The default is for it not to be a dry-run, which leads to the test being run following script generation.\ndry-run = false\n\n# To allow debug of the code generation step\ndebug-generation = false\njava-debug-args = -Xdebug -Xrunjdwp:transport=dt_socket,address=8999,server=y,suspend=y\n\n# Controls the creation of symbolic links to each timestamed result directory. \n# eg /stf/UtilLoadTest -> /stf/20161107-134621-UtilLoadTest\n# This can help when repeatedly running the same test, as the results will always \n# be at a consistent location.\n# If you want to use this then set it to true in ~/.stf.properties\ncreate-results-sym-links = false\n\n\n# ----------------------  Properties used by STF itself  ----------------------\n\n# Logical name of the test to be used.\ntest = null\n\n# Test specific data can be specified as name value pairs.\n# If set then the name/value pairs are available to the test specific plugin.\ntest-args = null\n\n# Points to the root directory of testing prerequisites. \n# This contains jar files, required perl libraries, test material, etc\n# Null by default. If the user does not supply it, stf.pl will search for it.\nsystemtest-prereqs        = null\n\n# JVM used for each stage\njavahome-generation        = ${JAVA_HOME}\njavahome-setup             = ${JAVA_HOME}\njavahome-execute           = ${JAVA_HOME}\njavahome-execute-secondary = ${JAVA_HOME_SECONDARY}\njavahome-teardown          = ${JAVA_HOME}",
        "start_line": 0,
        "end_line": 84,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "properties",
        "chunk_type": "recursive",
        "token_count": 906,
        "node_type": null,
        "file_sha": "fded26f19195bb89c3078da29feb76d2fc80cf94",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.671995"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# This file contains the lowest level of STF configuration.\n#\n# Any of the values specified here can be overridden by higher level configuration.\n# The search order for a parameters is:\n#   - command line arguments\n#   - user specific extension properties, eg. ~/.stf.runtimes.properties\n#   - user specific stf properties, eg ~/.stf.properties\n#   - extensions default properties, eg. stf.runtimes/config/stf.runtimes.properties\n#   - default stf properties file, eg. stf/config/stf.properties\n#\n# If an parameter is specified more than once then the value used is from the \n# first level it is encountered on.\n# If the same parameter is specified more than once on a particular level then the\n# final value overrides the earlier values.\n#\n# If the value of a property contains a '${.*}' then every such occurrence is replaced \n# with the value of the corresponding environment variable or the value of another property.\n# Resolution of the referenced property starts at the highest level.\n# Property values and environment variables may themselves reference other environment \n# variables or properties.\n#\n# For example:\n#   property value: java-execution-args = -Xss:512k ${fixed-args} ${extension-args}\n#   env.variable 1: fixed-args = ${java-memory-args} -Xverbose:gc\n#   env.variable 2: java-memory-args = -Xms:64m -Xmx:128m\n#   env.variable 3: extension-args = -server\n# Would be resolved to:\n#   java-execution-args = -Xss:512k -Xms:64m -Xmx:128m -Xverbose:gc -server\n# \n# Parameters which have a value of 'null' are ignored. They are allowed so that a \n# config file, such as this file, can list and document all possible parameters.\n# \n\n\n# ------------------------  Properties used by stf.pl  ------------------------\n\n# If dry-run is set to true then the setup,execute and teardown scripts are not executed following generation.\n# The default is for it not to be a dry-run, which leads to the test being run following script generation.\ndry-run = false\n\n# To allow debug of the code generation step\ndebug-generation = false\njava-debug-args = -Xdebug -Xrunjdwp:transport=dt_socket,address=8999,server=y,suspend=y\n\n# Controls the creation of symbolic links to each timestamed result directory. \n# eg /stf/UtilLoadTest -> /stf/20161107-134621-UtilLoadTest\n# This can help when repeatedly running the same test, as the results will always \n# be at a consistent location.\n# If you want to use this then set it to true in ~/.stf.properties\ncreate-results-sym-links = false\n\n\n# ----------------------  Properties used by STF itself  ----------------------\n\n# Logical name of the test to be used.\ntest = null\n\n# Test specific data can be specified as name value pairs.\n# If set then the name/value pairs are available to the test specific plugin.\ntest-args = null\n\n# Points to the root directory of testing prerequisites. \n# This contains jar files, required perl libraries, test material, etc\n# Null by default. If the user does not supply it, stf.pl will search for it.\nsystemtest-prereqs        = null\n\n# JVM used for each stage\njavahome-generation        = ${JAVA_HOME}\njavahome-setup             = ${JAVA_HOME}\njavahome-execute           = ${JAVA_HOME}\njavahome-execute-secondary = ${JAVA_HOME_SECONDARY}\njavahome-teardown          = ${JAVA_HOME}"
    },
    "36": {
      "metadata": {
        "chunk_id": "48e1875b5a9dc9873438e104669a8cf53e3d6de4bc1c837fdc0f8c7116037fa8",
        "file_path": "stf.core/config/stf.properties",
        "content": "# ----------------------  Properties used by STF itself  ----------------------\n\n# Logical name of the test to be used.\ntest = null\n\n# Test specific data can be specified as name value pairs.\n# If set then the name/value pairs are available to the test specific plugin.\ntest-args = null\n\n# Points to the root directory of testing prerequisites. \n# This contains jar files, required perl libraries, test material, etc\n# Null by default. If the user does not supply it, stf.pl will search for it.\nsystemtest-prereqs        = null\n\n# JVM used for each stage\njavahome-generation        = ${JAVA_HOME}\njavahome-setup             = ${JAVA_HOME}\njavahome-execute           = ${JAVA_HOME}\njavahome-execute-secondary = ${JAVA_HOME_SECONDARY}\njavahome-teardown          = ${JAVA_HOME}\n\n# These properties hold arguments which are given to any java process that is \n# started in the corresponding stage.\n# 'java-args' is used as a shorthand for 'java-args-execute' (due to the redirection) \njava-args = null\njava-args-setup             = null\njava-args-execute           = ${java-args}\njava-args-execute-secondary = null\njava-args-teardown          = null\n\n# Supplies java arguments when they really must be the very first java arguments.\n# These will be used before any java arguments from the test plugin.\njava-args-execute-initial = null\njava-args-execute-secondary-initial = null\n\n# Undocumented argument for supplying a string to describe the java-args-execute-initial value.\n# Added so that the seed used for '-mode=random' can be output to the execute.pl script.\njava-args-execute-comment = null\njava-args-execute-secondary-comment = null\n\n# Specifies the directory containing STF files or test cases.\n# This should point to a directory which has top level project directories that \n# actually contain the test cases.\n# ie. it is typically either an eclipse workspace directory or the build output directory\n# from building a repository which contains STF test cases.\n# The default value is set to the directory two steps up from stf.pl.\n# To get STF to look for tests in an additional location, specify -test-root=xxxx. \n# To look in multiple locations, separate the entries with semicolons.\n# E.g. -test-root=xxxx;yyyy;zzzz\ntest-root = null\n\n# All result and debugging files are written below the following directory.\nresults-root = ${STF_TEMP}\n\n# Set default number of directories to retain under results-root. stf.pl\n# will use an LRU algorithm but retain failed tests\nretain = 10\n\n# Set default number of directories under results-root that will be taken to\n# indicate \"We have suffered a very bad failure\". This should be > retain above\nretain-limit = 20\n\n# If true, remove the results directory if the test passed.\nrm-pass = false\n\n# The number of times that a plugins execute method is called.\nrepeat=1\n\n# This optional property specifies the platform used for perl code generation.\n# For example 'win_x86-64' or 'aix_ppc-64'.\n# The default is to use the current platform, but setting this value helps with \n# cross platform development/debugging.\nplatform = null\n\n# Set to 'true' to get information about STF and plugin arguments.\nhelp = false\n\n# Set to true to get STF to list all test plugins within the workspace.\nlist = false\n\n# For debugging, to get verbose and super-verbose output.\nv = false\nvv = false",
        "start_line": 85,
        "end_line": 167,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "properties",
        "chunk_type": "recursive",
        "token_count": 764,
        "node_type": null,
        "file_sha": "fded26f19195bb89c3078da29feb76d2fc80cf94",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.672030"
      },
      "text": "# ----------------------  Properties used by STF itself  ----------------------\n\n# Logical name of the test to be used.\ntest = null\n\n# Test specific data can be specified as name value pairs.\n# If set then the name/value pairs are available to the test specific plugin.\ntest-args = null\n\n# Points to the root directory of testing prerequisites. \n# This contains jar files, required perl libraries, test material, etc\n# Null by default. If the user does not supply it, stf.pl will search for it.\nsystemtest-prereqs        = null\n\n# JVM used for each stage\njavahome-generation        = ${JAVA_HOME}\njavahome-setup             = ${JAVA_HOME}\njavahome-execute           = ${JAVA_HOME}\njavahome-execute-secondary = ${JAVA_HOME_SECONDARY}\njavahome-teardown          = ${JAVA_HOME}\n\n# These properties hold arguments which are given to any java process that is \n# started in the corresponding stage.\n# 'java-args' is used as a shorthand for 'java-args-execute' (due to the redirection) \njava-args = null\njava-args-setup             = null\njava-args-execute           = ${java-args}\njava-args-execute-secondary = null\njava-args-teardown          = null\n\n# Supplies java arguments when they really must be the very first java arguments.\n# These will be used before any java arguments from the test plugin.\njava-args-execute-initial = null\njava-args-execute-secondary-initial = null\n\n# Undocumented argument for supplying a string to describe the java-args-execute-initial value.\n# Added so that the seed used for '-mode=random' can be output to the execute.pl script.\njava-args-execute-comment = null\njava-args-execute-secondary-comment = null\n\n# Specifies the directory containing STF files or test cases.\n# This should point to a directory which has top level project directories that \n# actually contain the test cases.\n# ie. it is typically either an eclipse workspace directory or the build output directory\n# from building a repository which contains STF test cases.\n# The default value is set to the directory two steps up from stf.pl.\n# To get STF to look for tests in an additional location, specify -test-root=xxxx. \n# To look in multiple locations, separate the entries with semicolons.\n# E.g. -test-root=xxxx;yyyy;zzzz\ntest-root = null\n\n# All result and debugging files are written below the following directory.\nresults-root = ${STF_TEMP}\n\n# Set default number of directories to retain under results-root. stf.pl\n# will use an LRU algorithm but retain failed tests\nretain = 10\n\n# Set default number of directories under results-root that will be taken to\n# indicate \"We have suffered a very bad failure\". This should be > retain above\nretain-limit = 20\n\n# If true, remove the results directory if the test passed.\nrm-pass = false\n\n# The number of times that a plugins execute method is called.\nrepeat=1\n\n# This optional property specifies the platform used for perl code generation.\n# For example 'win_x86-64' or 'aix_ppc-64'.\n# The default is to use the current platform, but setting this value helps with \n# cross platform development/debugging.\nplatform = null\n\n# Set to 'true' to get information about STF and plugin arguments.\nhelp = false\n\n# Set to true to get STF to list all test plugins within the workspace.\nlist = false\n\n# For debugging, to get verbose and super-verbose output.\nv = false\nvv = false"
    },
    "37": {
      "metadata": {
        "chunk_id": "b25aa3f4570c61d9c43c88ded9ac0a5f921e6eeac9d08ce48d9eddffbd480616",
        "file_path": "stf.core/docs/STF-GettingStarted.md",
        "content": "# STF - Getting started\n\n<a href=\"#1\">Introduction</a>  \n<a href=\"#2\">Setting up development environment</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.1\">Prerequisites</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.2\">Configure Eclipse</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.3\">Clone and build the stf git repository</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.4\">Clone and build the openjdk git repository</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.5\">Verifying the environment</a>  \n<a href=\"#3\">STF mini guide</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.1\">How do I see all available tests?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.2\">How do I find the source code for a test?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.3\">Where can I find the log files for a run?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.4\">How do I find a test's command line options?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.5\">How do I see the generated perl code which is executed when the test runs?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.6\">How can I re-execute the test?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.7\">How can I tweak a Java command?</a>  \n\n<a name=\"1\"></a>\n## Introduction\n\nThis page documents the steps needed to get STF based tests running\nfrom source on a development machine.\n\nOn completion of these instructions you'll have an\nEclipse installation with a workspace\nthat contains the source code for STF itself and the adoptium tests which use it. These tests will be runnable from the command prompt and should pass.\n\nEclipse is used a development tool to make the development/debugging of test\nautomation quicker and easier, with local compile time checking, and tests which can execute\ndirectly from the Eclipse workspace.\n\nNative (C code) tests need to be built using the ant based build, which can be invoked from within the Eclipse 'Ant' View or from a command line.\n\nAs the title suggests, the purpose of this document is to get you to the point where you can run tests. Refer to STF-Manual.md for information such as:\n- Overview of how STF works\n- How to add automation for a new test\n- Debugging and fixing test automation\n- Coordination of multiple concurrent processes\n- Rules and guidelines for test automation\n\n<a name=\"2\"></a>\n## Setting up the development environment\n\n<a name=\"2.1\"></a>\n### Prerequisites\n\nThe easiest way to setup the STF and test prereqs is to run the configure build targets.  STF and each test repository containing STF dependent tests has such a target.  When  the configure target is run wget is used to download the various software packages, which are then installed as required.\n\nHowever, there are a few prereqs which cannot be installed in this way, since the are required for the configure step itself or are too complex to install via . These prereqs are:\n1. Java\n1. Eclipse (use a version which comes with a git client and supports Java 9)\n1. wget\n1. ant\n1. GNU make\n1. perl\n1. Microsoft Visual Studio (Windows only)\n\nSome of the prereqs (e.g. perl, make) may already be installed on the test machine.\n\nYou should review the licenses of the prereqs before running the configure step to make sure you agree with their terms and conditions. Refer to stf.build/docs/build.md (or equivalent files in other projects which contain tests which use STF).\n\n<a name=\"2.2\"></a>\n## Configure Eclipse\nDownload and extract Eclipse to a suitable directory. Then start Eclipse and create a new workspace.\n\nNote: Do not create a workspace whose path includes a space character. STF will abort the run if the workspace path contains a space.\n\nVerify that the Eclipse version works with at least Java 8 by opening\n'Window -> Preferences -> Java -> Compiler' and checking that 'Compiler compliance level' is at least 1.8.\n\n",
        "start_line": 0,
        "end_line": 71,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 932,
        "node_type": null,
        "file_sha": "aff2901aa0b71bbd167e9353fd3c7a1831b67613",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.679580"
      },
      "text": "# STF - Getting started\n\n<a href=\"#1\">Introduction</a>  \n<a href=\"#2\">Setting up development environment</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.1\">Prerequisites</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.2\">Configure Eclipse</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.3\">Clone and build the stf git repository</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.4\">Clone and build the openjdk git repository</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.5\">Verifying the environment</a>  \n<a href=\"#3\">STF mini guide</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.1\">How do I see all available tests?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.2\">How do I find the source code for a test?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.3\">Where can I find the log files for a run?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.4\">How do I find a test's command line options?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.5\">How do I see the generated perl code which is executed when the test runs?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.6\">How can I re-execute the test?</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#3.7\">How can I tweak a Java command?</a>  \n\n<a name=\"1\"></a>\n## Introduction\n\nThis page documents the steps needed to get STF based tests running\nfrom source on a development machine.\n\nOn completion of these instructions you'll have an\nEclipse installation with a workspace\nthat contains the source code for STF itself and the adoptium tests which use it. These tests will be runnable from the command prompt and should pass.\n\nEclipse is used a development tool to make the development/debugging of test\nautomation quicker and easier, with local compile time checking, and tests which can execute\ndirectly from the Eclipse workspace.\n\nNative (C code) tests need to be built using the ant based build, which can be invoked from within the Eclipse 'Ant' View or from a command line.\n\nAs the title suggests, the purpose of this document is to get you to the point where you can run tests. Refer to STF-Manual.md for information such as:\n- Overview of how STF works\n- How to add automation for a new test\n- Debugging and fixing test automation\n- Coordination of multiple concurrent processes\n- Rules and guidelines for test automation\n\n<a name=\"2\"></a>\n## Setting up the development environment\n\n<a name=\"2.1\"></a>\n### Prerequisites\n\nThe easiest way to setup the STF and test prereqs is to run the configure build targets.  STF and each test repository containing STF dependent tests has such a target.  When  the configure target is run wget is used to download the various software packages, which are then installed as required.\n\nHowever, there are a few prereqs which cannot be installed in this way, since the are required for the configure step itself or are too complex to install via . These prereqs are:\n1. Java\n1. Eclipse (use a version which comes with a git client and supports Java 9)\n1. wget\n1. ant\n1. GNU make\n1. perl\n1. Microsoft Visual Studio (Windows only)\n\nSome of the prereqs (e.g. perl, make) may already be installed on the test machine.\n\nYou should review the licenses of the prereqs before running the configure step to make sure you agree with their terms and conditions. Refer to stf.build/docs/build.md (or equivalent files in other projects which contain tests which use STF).\n\n<a name=\"2.2\"></a>\n## Configure Eclipse\nDownload and extract Eclipse to a suitable directory. Then start Eclipse and create a new workspace.\n\nNote: Do not create a workspace whose path includes a space character. STF will abort the run if the workspace path contains a space.\n\nVerify that the Eclipse version works with at least Java 8 by opening\n'Window -> Preferences -> Java -> Compiler' and checking that 'Compiler compliance level' is at least 1.8.\n\n"
    },
    "38": {
      "metadata": {
        "chunk_id": "4c7406b69221d35f3ef24f597163b6a51a8d70f9cd1ddddf55e5fbcb6f649192",
        "file_path": "stf.core/docs/STF-GettingStarted.md",
        "content": "<a name=\"2.3\"></a>\n### Clone and build the stf git repository\n1. Follow the instructions in stf.build/docs/readme.md to clone the stf git repository and set up the prereqs.\n1. Import the projects into Eclipse (Find and import Eclipse projects)\n1. Eclipse will attempt to build java classes itself, but this will not succeed until the prereqs have been imported into the Eclipse workspace.\n1. Import the prerreqs as a 'General' Eclipse project under the project name 'systemtest_prereqs'.\n1. The stf projects should now build without build errors.\n\n<a name=\"2.4\"></a>\n### Clone and build the aqa-systemtest git repository\n1. Follow the instructions in openjdk.build/docs/readme.md to clone the aqa-systemtest git repository and set up the prereqs.\n1. Import these projects into Eclipse alongside the stf projects (Find and import Eclipse projects)\n1. Add any additional prereqs from the aqa-systemtest make configure step to the systemtest_prereqs folder (use File --> Import).\n1. The openjdk.xxx projects should also now build without build errors.\n1. The native (C code) test cases cannot be built automatically by Eclipse.\n To build these run the ant build.  This can be done from within Eclipse by opening the Ant View,\n dragging the openjdk.build/build.xml file into the View and then running the 'build' target.\n  Note that a suitable C compiler needs to be installed prior to invoking the native build.\n   See the Prerequisites section above for more details.\n\n<a name=\"2.5\">\n### Verifying the environment\n\n#### Windows\n\n```\nperl -v\nThis is perl 5, version 22, subversion 1 (v5.22.1) built for...\n(or similar)\n```\n\n```\njava -version\njava version \"1.8.0_nn\"\n...\n(or similar)\n```\n\n```\n%JAVA_HOME%/bin/java -version\njava version \"1.8.0_nn\"\n...\n(or similar)\n```\n\n```\n%USERPROFILE%\\git\\stf\\stf.core\\scripts\\stf.pl -test=UtilLoadTest</b>\n...\nSTF 16:04:08.625 - Overall result: PASSED\n```\n#### Unix\n\n```\nperl -v\nThis is perl 5, version 18, subversion 2 (v5.18.2) built for ...\n(or similar)\n```\n\n```\njava -version\njava version \"1.8.0_nn\"\n...\n(or similar)\n```\n\n```\n$JAVA_HOME/bin/java -version\njava version \"1.8.0\"\n...\n(or similar)\n```\n\n```\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test=UtilLoadTest\n...\nSTF 15:56:06.778 - Overall result: PASSED\n```\n\n<a name=\"3\"></a>\n## STF mini guide\n\n<a name=\"3.1\"></a>\n### How do I see all available tests?\nSTF can scan your workspace and list all classes which are runnable as STF based tests.\nThis is obviously useful for getting a full list of all tests, but is also useful when\nyou want the full test name but only know part of the name.\n\n```\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test-root=\"$HOME/git/aqa-systemtest\" -list\n\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test-root=\"$HOME/git/aqa-systemtest\" -list | grep -i memory\n\nGEN 10:51:58.145 -   | test.jlm               | TestJlmRemoteMemoryAuth        |\nGEN 10:51:58.145 -   | test.jlm               | TestJlmRemoteMemoryNoAuth      |\n\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test=SampleClientServer\n...\nGEN 10:48:01.185 - Test command summary:\nGEN 10:48:01.185 -   Step  Stage       Command       Description\nGEN 10:48:01.185 -  -----+--------+-----------------+------------\nGEN 10:48:01.185 -     1  execute  Run java          Run server\nGEN 10:48:01.185 -     2  execute  Run java*4        Run client\nGEN 10:48:01.185 -     3  execute  Monitor           Wait for clients to complete\nGEN 10:48:01.185 -     4  execute  kill              Stop server process\n...\nSTF 10:48:05.354 - Overall result: PASSED\n```\n\n<a name=\"3.2\"></a>\n### How do I find the source code for a test?\n\n",
        "start_line": 72,
        "end_line": 183,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 993,
        "node_type": null,
        "file_sha": "aff2901aa0b71bbd167e9353fd3c7a1831b67613",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.679590"
      },
      "text": "<a name=\"2.3\"></a>\n### Clone and build the stf git repository\n1. Follow the instructions in stf.build/docs/readme.md to clone the stf git repository and set up the prereqs.\n1. Import the projects into Eclipse (Find and import Eclipse projects)\n1. Eclipse will attempt to build java classes itself, but this will not succeed until the prereqs have been imported into the Eclipse workspace.\n1. Import the prerreqs as a 'General' Eclipse project under the project name 'systemtest_prereqs'.\n1. The stf projects should now build without build errors.\n\n<a name=\"2.4\"></a>\n### Clone and build the aqa-systemtest git repository\n1. Follow the instructions in openjdk.build/docs/readme.md to clone the aqa-systemtest git repository and set up the prereqs.\n1. Import these projects into Eclipse alongside the stf projects (Find and import Eclipse projects)\n1. Add any additional prereqs from the aqa-systemtest make configure step to the systemtest_prereqs folder (use File --> Import).\n1. The openjdk.xxx projects should also now build without build errors.\n1. The native (C code) test cases cannot be built automatically by Eclipse.\n To build these run the ant build.  This can be done from within Eclipse by opening the Ant View,\n dragging the openjdk.build/build.xml file into the View and then running the 'build' target.\n  Note that a suitable C compiler needs to be installed prior to invoking the native build.\n   See the Prerequisites section above for more details.\n\n<a name=\"2.5\">\n### Verifying the environment\n\n#### Windows\n\n```\nperl -v\nThis is perl 5, version 22, subversion 1 (v5.22.1) built for...\n(or similar)\n```\n\n```\njava -version\njava version \"1.8.0_nn\"\n...\n(or similar)\n```\n\n```\n%JAVA_HOME%/bin/java -version\njava version \"1.8.0_nn\"\n...\n(or similar)\n```\n\n```\n%USERPROFILE%\\git\\stf\\stf.core\\scripts\\stf.pl -test=UtilLoadTest</b>\n...\nSTF 16:04:08.625 - Overall result: PASSED\n```\n#### Unix\n\n```\nperl -v\nThis is perl 5, version 18, subversion 2 (v5.18.2) built for ...\n(or similar)\n```\n\n```\njava -version\njava version \"1.8.0_nn\"\n...\n(or similar)\n```\n\n```\n$JAVA_HOME/bin/java -version\njava version \"1.8.0\"\n...\n(or similar)\n```\n\n```\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test=UtilLoadTest\n...\nSTF 15:56:06.778 - Overall result: PASSED\n```\n\n<a name=\"3\"></a>\n## STF mini guide\n\n<a name=\"3.1\"></a>\n### How do I see all available tests?\nSTF can scan your workspace and list all classes which are runnable as STF based tests.\nThis is obviously useful for getting a full list of all tests, but is also useful when\nyou want the full test name but only know part of the name.\n\n```\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test-root=\"$HOME/git/aqa-systemtest\" -list\n\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test-root=\"$HOME/git/aqa-systemtest\" -list | grep -i memory\n\nGEN 10:51:58.145 -   | test.jlm               | TestJlmRemoteMemoryAuth        |\nGEN 10:51:58.145 -   | test.jlm               | TestJlmRemoteMemoryNoAuth      |\n\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test=SampleClientServer\n...\nGEN 10:48:01.185 - Test command summary:\nGEN 10:48:01.185 -   Step  Stage       Command       Description\nGEN 10:48:01.185 -  -----+--------+-----------------+------------\nGEN 10:48:01.185 -     1  execute  Run java          Run server\nGEN 10:48:01.185 -     2  execute  Run java*4        Run client\nGEN 10:48:01.185 -     3  execute  Monitor           Wait for clients to complete\nGEN 10:48:01.185 -     4  execute  kill              Stop server process\n...\nSTF 10:48:05.354 - Overall result: PASSED\n```\n\n<a name=\"3.2\"></a>\n### How do I find the source code for a test?\n\n"
    },
    "39": {
      "metadata": {
        "chunk_id": "d3daa67e8d5393df293885102868a8f479973904dbc11edeb0d76e2d3f885985",
        "file_path": "stf.core/docs/STF-GettingStarted.md",
        "content": "Once you have the name of a test you can find its source code in Eclipse by\ntyping Ctrl-shift-t and type in the name of the test automation STF plugin, eg, SampleClientServer\n\n<a name=\"3.3\"></a>\n### Where can I find the log files for a run?\n\nAll log files are written to a results subdirectory under /tmp/stf on unix or C:\\stf_temp on Windows (default locations, can be overridden via the -results-root stf.pl argument).\n\n<a name=\"3.4\"></a>\n### How do I find a test's command line options?\n\nThe full set of STF depends on exactly which test you want to run. So\nto get a UNIX style list of the available options you need to use '-help'\nargument in conjunction with a '-test=x' argument.\n\n```\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test-root=\"$HOME/git/aqa-systemtest\" -test=UtilLoadTest -help\n```\n\n<a name=\"3.5\"></a>\n### How do I see the generated perl code which is executed when the test runs?\n\n<p>The actions described in the testcase are executed by perl code because\nit is suitable for operating system level operations and is available on\nall platforms. To see that commands which were executed for a test look\nin '&lt;stf-results-dir&gt;/&lt;test-name&gt;/execute.pl'.\n\n<a name=\"3.6\"></a>\n### How can I re-execute the test?\n\nIf a test has a significant setup time and you want to repeatedly rerun then\nit is usually easiest to just rerun the execute script. Providing that the test\ndoesn't do any teardown work this can be run after the stf run, or alternatively\nyou can manually run the setup, execute and teardown scripts.\n\nFor fully manual execution:\n```\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test-root=\"$HOME/git/aqa-systemtest\" -test=UtilLoadTest -dry-run</b>\n...\nC:\\stf_temp\\20170801-133510-UtilLoadTest\n(STF creates the results directory yyyymmdd-hhmmss-testname)\nperl /tmp/stf/20170801-133510-UtilLoadTest/setUp.pl</b>\nperl /tmp/stf/20170801-133510-UtilLoadTest/execute.pl</b>\nperl /tmp/stf/20170801-133510-UtilLoadTest/teardown.pl</b>\n...\n```\n\n<a name=\"3.7\"></a>\n### How can I tweak a Java command?\n1. Because STF generates unique setup.pl, execute.pl and teardown.pl scripts each time it runs\nyou are free to edit any of the commands in those scripts and then reexecute as shown in the previous section.\n\n1. Alternatively, and depending on the test, a more complex but flexible option is to\nextract the the command for a step and manually run it on the command line. Generally each step\nhas a cut and pastable version of every command, with all paths etc. fully expanded.\n\n</body>\n</html>\n\n\n",
        "start_line": 184,
        "end_line": 244,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 651,
        "node_type": null,
        "file_sha": "aff2901aa0b71bbd167e9353fd3c7a1831b67613",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.679593"
      },
      "text": "Once you have the name of a test you can find its source code in Eclipse by\ntyping Ctrl-shift-t and type in the name of the test automation STF plugin, eg, SampleClientServer\n\n<a name=\"3.3\"></a>\n### Where can I find the log files for a run?\n\nAll log files are written to a results subdirectory under /tmp/stf on unix or C:\\stf_temp on Windows (default locations, can be overridden via the -results-root stf.pl argument).\n\n<a name=\"3.4\"></a>\n### How do I find a test's command line options?\n\nThe full set of STF depends on exactly which test you want to run. So\nto get a UNIX style list of the available options you need to use '-help'\nargument in conjunction with a '-test=x' argument.\n\n```\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test-root=\"$HOME/git/aqa-systemtest\" -test=UtilLoadTest -help\n```\n\n<a name=\"3.5\"></a>\n### How do I see the generated perl code which is executed when the test runs?\n\n<p>The actions described in the testcase are executed by perl code because\nit is suitable for operating system level operations and is available on\nall platforms. To see that commands which were executed for a test look\nin '&lt;stf-results-dir&gt;/&lt;test-name&gt;/execute.pl'.\n\n<a name=\"3.6\"></a>\n### How can I re-execute the test?\n\nIf a test has a significant setup time and you want to repeatedly rerun then\nit is usually easiest to just rerun the execute script. Providing that the test\ndoesn't do any teardown work this can be run after the stf run, or alternatively\nyou can manually run the setup, execute and teardown scripts.\n\nFor fully manual execution:\n```\nperl $HOME/git/stf/stf.core/scripts/stf.pl -test-root=\"$HOME/git/aqa-systemtest\" -test=UtilLoadTest -dry-run</b>\n...\nC:\\stf_temp\\20170801-133510-UtilLoadTest\n(STF creates the results directory yyyymmdd-hhmmss-testname)\nperl /tmp/stf/20170801-133510-UtilLoadTest/setUp.pl</b>\nperl /tmp/stf/20170801-133510-UtilLoadTest/execute.pl</b>\nperl /tmp/stf/20170801-133510-UtilLoadTest/teardown.pl</b>\n...\n```\n\n<a name=\"3.7\"></a>\n### How can I tweak a Java command?\n1. Because STF generates unique setup.pl, execute.pl and teardown.pl scripts each time it runs\nyou are free to edit any of the commands in those scripts and then reexecute as shown in the previous section.\n\n1. Alternatively, and depending on the test, a more complex but flexible option is to\nextract the the command for a step and manually run it on the command line. Generally each step\nhas a cut and pastable version of every command, with all paths etc. fully expanded.\n\n</body>\n</html>\n\n\n"
    },
    "40": {
      "metadata": {
        "chunk_id": "8f223e6fb52f1690e1111f26baf72b6dfd4c7b88c2a54bb5ddaec3380e2018f8",
        "file_path": "stf.core/docs/STF-Internals.md",
        "content": "# STF Internals\n\n<a href=\"#1\">Terminology</a>  \n<a href=\"#2\">Code Structure</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.1\">2.1 stf.core Project</a>\n\n<a name=\"1\"></a>\n## Terminology\n\nSome key terms are:\n- Plugin - This is a user written test case which 'plugs' into STF at runtime.\n-- Each plugin contains 4 methods: pluginInit, setup, execute and teardown.\n- Extension - A class which provides operations to plugin code, such as create a directory, unpack a file, etc.\n-- Plugins make use of extensions to generate perl code.\n\n<a name=\"2\"></a>\n## Code Structure\n\nThe code for STF exits within 3 projects:\n- stf.core - Holds key STF code. This is sufficient to run tests on their own.\n- stf.java - Contains the Java extension, which adds capabilities related specifially to testing Java implementations.</li>\n- stf.load - Standalone tool used by STF to run multi-threaded load tests.</li>\n\n<a name=\"2.1\"></a>\n### stf.core Project\n\nThe code within stf.core is divided into the following packages:\n- *src.stf.net.adoptopenjdk.stf* - This top level package holds simple classes for StfException, constants, etc.\n- *src.stf.net.adoptopenjdk.stf.runner* - Key classes for running Java code as a STF plugin test.\nStfRunner.java contains the critical main method which is invoked by stf.pl.\nThe 'modes' subpackage contains code for handling the stf '-help' and '-list' options.\n- *src.stf.net.adoptopenjdk.stf.environment* - Contains classes to represent the machine and the environment that the test is running on.\nKey classes are FileRef.java and DirRef.java to represent files and directories.\nThe 'properties' sub package contains classes to manage the hierarchical properties supported by STF tests and extension classes.\n- *src.stf.net.adoptopenjdk.stf.plugin.interfaces* - Defines key interfaces needed by test classes.\n- *src.stf.net.adoptopenjdk.stf.extensions* - Holds logic and common funnctions needed by extension classes.\n- *src.stf.net.adoptopenjdk.stf.extensions.core* - Implementation of the virtually essential 'StfCoreExtension', which\nprovides basic actions needed by most tests.\n- *src.stf.net.adoptopenjdk.stf.processes* - Support for tests which run child processes.\n- *src.stf.net.adoptopenjdk.stf.processes.definitions* - Utility classes used to build command lines for running\ndifferent types of processes. eg, running Java, jlink or load test processes.\nThe subpackage 'generic' contains code which makes writing process definition classes easier.\n- *src.stf.net.adoptopenjdk.stf.codeGeneration* - Code for creating perl scripts, so that tests can run child processes on the current platform.\n- *src.stf.net.adoptopenjdk.stf.results* - Utility classes for examining test results. Supports the filtering of results from known failing tests.\n- *src.stf.net.adoptopenjdk.stf.util* - Simple generic classes for parsing duration strings, running child processes, etc.\n\n\n",
        "start_line": 0,
        "end_line": 47,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 691,
        "node_type": null,
        "file_sha": "fa3b5ac5b156753a8e4f0471ef10a1ef32734a4c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.683384"
      },
      "text": "# STF Internals\n\n<a href=\"#1\">Terminology</a>  \n<a href=\"#2\">Code Structure</a>  \n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"#2.1\">2.1 stf.core Project</a>\n\n<a name=\"1\"></a>\n## Terminology\n\nSome key terms are:\n- Plugin - This is a user written test case which 'plugs' into STF at runtime.\n-- Each plugin contains 4 methods: pluginInit, setup, execute and teardown.\n- Extension - A class which provides operations to plugin code, such as create a directory, unpack a file, etc.\n-- Plugins make use of extensions to generate perl code.\n\n<a name=\"2\"></a>\n## Code Structure\n\nThe code for STF exits within 3 projects:\n- stf.core - Holds key STF code. This is sufficient to run tests on their own.\n- stf.java - Contains the Java extension, which adds capabilities related specifially to testing Java implementations.</li>\n- stf.load - Standalone tool used by STF to run multi-threaded load tests.</li>\n\n<a name=\"2.1\"></a>\n### stf.core Project\n\nThe code within stf.core is divided into the following packages:\n- *src.stf.net.adoptopenjdk.stf* - This top level package holds simple classes for StfException, constants, etc.\n- *src.stf.net.adoptopenjdk.stf.runner* - Key classes for running Java code as a STF plugin test.\nStfRunner.java contains the critical main method which is invoked by stf.pl.\nThe 'modes' subpackage contains code for handling the stf '-help' and '-list' options.\n- *src.stf.net.adoptopenjdk.stf.environment* - Contains classes to represent the machine and the environment that the test is running on.\nKey classes are FileRef.java and DirRef.java to represent files and directories.\nThe 'properties' sub package contains classes to manage the hierarchical properties supported by STF tests and extension classes.\n- *src.stf.net.adoptopenjdk.stf.plugin.interfaces* - Defines key interfaces needed by test classes.\n- *src.stf.net.adoptopenjdk.stf.extensions* - Holds logic and common funnctions needed by extension classes.\n- *src.stf.net.adoptopenjdk.stf.extensions.core* - Implementation of the virtually essential 'StfCoreExtension', which\nprovides basic actions needed by most tests.\n- *src.stf.net.adoptopenjdk.stf.processes* - Support for tests which run child processes.\n- *src.stf.net.adoptopenjdk.stf.processes.definitions* - Utility classes used to build command lines for running\ndifferent types of processes. eg, running Java, jlink or load test processes.\nThe subpackage 'generic' contains code which makes writing process definition classes easier.\n- *src.stf.net.adoptopenjdk.stf.codeGeneration* - Code for creating perl scripts, so that tests can run child processes on the current platform.\n- *src.stf.net.adoptopenjdk.stf.results* - Utility classes for examining test results. Supports the filtering of results from known failing tests.\n- *src.stf.net.adoptopenjdk.stf.util* - Simple generic classes for parsing duration strings, running child processes, etc.\n\n\n"
    },
    "41": {
      "metadata": {
        "chunk_id": "d83641d32ecf17daed72701022be83b7196c491b4f055422b3c241fd0a024007",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "# STF - System Test Framework\n\n",
        "start_line": 0,
        "end_line": 2,
        "chunk_index": 0,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 7,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687338"
      },
      "text": "# STF - System Test Framework\n\n"
    },
    "42": {
      "metadata": {
        "chunk_id": "bee80d8b092babb29a1fdb935e8f71cc538b67ca1d5eb2a8ea62fb3658e39189",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "<a name=\"1\"></a>\n## Introduction\nSTF (System Test Framework) is a testing tool which provides a framework for automating tests which cannot, or cannot easily, be automated using unit test frameworks such as junit or testNG.\n\nWhereas a JUnit or TestNG test runs in a single process the tests run by STF frequently involve running multiple processes, or require setup which must be done before the test process can run.\n\nAn STF test is implemented as a high level description of the required actions, such as:\n- Creating directories\n- Unzipping files\n- Running processes, sequentially or concurrently\n- Waiting for process completion\n- Filtering test results such as text output for success or for known failures\n\nThe examples used in this document assume that you have a working STF installation, as described in 'STF-GettingStarted.md'.\n\n<a name=\"2\"></a>\n## STF Principles\n\nSTF was designed to enable the automation of multiple step, multi-process test cases in a way which\n1. Provides a clear demarcation between setting up the test environment and executing the tests which use the environment.\n1. Enforces automation code reuse.\n1. Allows a developer investigating test failures to modify the test execution in order to isolate commands within the multistep process in order to amend those commands to employ debugging aids or to run private builds of the system under test.\n\nThe test developer describes his / her test in terms of the high level steps to be carried out.  This test description is implemented as a Java class which uses the STF class library to carry out the steps.  Examples of library methods are 'doUnzip' or 'doRunForegroundProcess'.\n\nTest execution is in two stages.\nFirstly, the test java classes are executed. The result of that execution is:\n1. A unique directory into which the artifacts and results of the test execution are placed.\n2. A setup.pl, execute.pl and teardown.pl perl script.\n3. The creation of test data or other test resource artifacts required for the test execution.\n\nSecondly, (and optionally), the setup.pl, execute.pl and teardown.pl scripts are executed in that order.\n\nGenerating the test script code in this way has the following advantages:\n1. Only capabilities which have been provided by the framework can be used, since the framework is responsible for emitting the perl code which executes the test.  This prevents the test script code containing errors which would lead to erroneous test results.\n2. The script code is tailored specifically to the environment in which the test is to be executed.  Since at code generration time the execution environment is known, the generated code does not need to contain placeholders for variables such as the location of the system under test, nor  conditionals to execute different code on one platform versus another.  This leads to more compact, easily understood and modifiable code.\n3. The generated code can be consistently and clearly documented, so that a developer can easily identify points of failure in the test execution and modify the code to assist in debugging.\n\n<a name=\"3\"></a>\n## Development\n\n<a name=\"3.1\"></a>\n### An example STF test\n\nTo be completed.\n\n<a name=\"3.2\"></a>\n### Interfaces and test methods\n\nFor a class to be treated as runnable test automation by STF it must conform to certain conditions:\n- It must implement the StfPluginRootInterface\n- It must implement the five key plugin methods - help, pluginInit, setUp, execute and tearDown\n\nThe easiest way to conform to these conditions is for a test automation class to implement StfPluginInterface:\n``` java\npublic interface StfPluginInterface extends StfPluginRootInterface {\n\n    public void help(HelpTextGenerator help) throws StfException;\n\n    public void pluginInit(StfCoreExtension test) throws StfException;\n\n    public void setUp(StfCoreExtension test) throws StfException;\n\n    public void execute(StfCoreExtension test) throws StfException;\n\n    public void tearDown(StfCoreExtension test) throws StfException;\n}\n```\n\n<a name=\"3.2.1\"></a>\n#### help method\nThis method is run if the user runs the test automation with a '-help' argument.\nOnce the standard STF help text has been generated the automations help() method is called.\n\nThe help method has two responsibilites. Firstly, it should provide a short summary about\nthe purpose of the test. It's purpose is to remind the reader about the test and maybe\nrefer them to full documentation which is held elsewhere.\nThe second purpose of the help is to supply a summary about any test specific arguments.\n\n",
        "start_line": 56,
        "end_line": 135,
        "chunk_index": 2,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 947,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687349"
      },
      "text": "<a name=\"1\"></a>\n## Introduction\nSTF (System Test Framework) is a testing tool which provides a framework for automating tests which cannot, or cannot easily, be automated using unit test frameworks such as junit or testNG.\n\nWhereas a JUnit or TestNG test runs in a single process the tests run by STF frequently involve running multiple processes, or require setup which must be done before the test process can run.\n\nAn STF test is implemented as a high level description of the required actions, such as:\n- Creating directories\n- Unzipping files\n- Running processes, sequentially or concurrently\n- Waiting for process completion\n- Filtering test results such as text output for success or for known failures\n\nThe examples used in this document assume that you have a working STF installation, as described in 'STF-GettingStarted.md'.\n\n<a name=\"2\"></a>\n## STF Principles\n\nSTF was designed to enable the automation of multiple step, multi-process test cases in a way which\n1. Provides a clear demarcation between setting up the test environment and executing the tests which use the environment.\n1. Enforces automation code reuse.\n1. Allows a developer investigating test failures to modify the test execution in order to isolate commands within the multistep process in order to amend those commands to employ debugging aids or to run private builds of the system under test.\n\nThe test developer describes his / her test in terms of the high level steps to be carried out.  This test description is implemented as a Java class which uses the STF class library to carry out the steps.  Examples of library methods are 'doUnzip' or 'doRunForegroundProcess'.\n\nTest execution is in two stages.\nFirstly, the test java classes are executed. The result of that execution is:\n1. A unique directory into which the artifacts and results of the test execution are placed.\n2. A setup.pl, execute.pl and teardown.pl perl script.\n3. The creation of test data or other test resource artifacts required for the test execution.\n\nSecondly, (and optionally), the setup.pl, execute.pl and teardown.pl scripts are executed in that order.\n\nGenerating the test script code in this way has the following advantages:\n1. Only capabilities which have been provided by the framework can be used, since the framework is responsible for emitting the perl code which executes the test.  This prevents the test script code containing errors which would lead to erroneous test results.\n2. The script code is tailored specifically to the environment in which the test is to be executed.  Since at code generration time the execution environment is known, the generated code does not need to contain placeholders for variables such as the location of the system under test, nor  conditionals to execute different code on one platform versus another.  This leads to more compact, easily understood and modifiable code.\n3. The generated code can be consistently and clearly documented, so that a developer can easily identify points of failure in the test execution and modify the code to assist in debugging.\n\n<a name=\"3\"></a>\n## Development\n\n<a name=\"3.1\"></a>\n### An example STF test\n\nTo be completed.\n\n<a name=\"3.2\"></a>\n### Interfaces and test methods\n\nFor a class to be treated as runnable test automation by STF it must conform to certain conditions:\n- It must implement the StfPluginRootInterface\n- It must implement the five key plugin methods - help, pluginInit, setUp, execute and tearDown\n\nThe easiest way to conform to these conditions is for a test automation class to implement StfPluginInterface:\n``` java\npublic interface StfPluginInterface extends StfPluginRootInterface {\n\n    public void help(HelpTextGenerator help) throws StfException;\n\n    public void pluginInit(StfCoreExtension test) throws StfException;\n\n    public void setUp(StfCoreExtension test) throws StfException;\n\n    public void execute(StfCoreExtension test) throws StfException;\n\n    public void tearDown(StfCoreExtension test) throws StfException;\n}\n```\n\n<a name=\"3.2.1\"></a>\n#### help method\nThis method is run if the user runs the test automation with a '-help' argument.\nOnce the standard STF help text has been generated the automations help() method is called.\n\nThe help method has two responsibilites. Firstly, it should provide a short summary about\nthe purpose of the test. It's purpose is to remind the reader about the test and maybe\nrefer them to full documentation which is held elsewhere.\nThe second purpose of the help is to supply a summary about any test specific arguments.\n\n"
    },
    "43": {
      "metadata": {
        "chunk_id": "0e8469fda0da81d319f913b01e1a9c7e003e92091056d7c755c62c92b6e35921",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "For example:\n``` java\npublic void help(HelpTextGenerator help) throws StfException {\n  help.outputSection(\"MathLoadTest test\");\n  help.outputText(\"MathLoadTest runs workloads of Math related tests, \"\n      + \"by default it runs all math tests if no workload is specified.\");\n\n  help.outputSection(\"MathLoadTest test options\");\n  help.outputArgName(\"workload\", \"NAME\");\n  help.outputArgDesc(\"This is the name of the workload to run, it supports \"\n      + \"the following workloads: math, bigdecimal, autosimd\");\n}\n```\n\n<a name=\"3.2.2\"></a>\n#### pluginInit method\n\nTo be completed.\n\n<a name=\"3.2.3\"></a>\n#### setUp method\n\nTo be completed.\n\n<a name=\"3.2.4\"></a>\n#### execute method\nThe execute method is the key part of the automation. It lists the actions that need to\nbe performed to actually run the test. The steps in the execute method are only executed\nif setUp ran without any errors.\n\nTo help with test development/debugging the actions in the execute stage should be\nable to be run repeatedly.\n\nAs with the setUp stage, the failure of any action results in the termination of the stage.\n\n<a name=\"3.2.5\"></a>\n#### tearDown method\n\nTo be completed.\n\n<a name=\"3.2.6\"></a>\n#### STF Structure\nThe following diagram shows the keys components for STF based test automation.\n\nIt shows the test automation code at the top of the diagram and its interaction with\nSTF through the extension classes and the environment class.\n\nThe left hand side of the diagram shows that both the developer and STF both have access\nto the file system and property file.\nTowards the bottom of the diagram, in the 'perl code' box, STF provides insight into the\ntest run by revealing the generated perl code, whose execution is going to implement the\nsteps described in the automation code.\n\n<img src=\"./images/STF-Structure.jpg\" hspace=\"20\" width=\"600\">\n\n<a name=\"3.3\"></a>\n### STF actions\n\nTo be completed.\n\n<a name=\"3.4\"></a>\n### File system access\n\nTo be completed.\n\n<a name=\"3.5\"></a>\n### New test development\n\nTo be completed.\n\n<a name=\"3.6\"></a>\n### Porting existing tests\n\nTo be completed.\n\n<a name=\"4\"></a>\n## Process Execution\n\n<a name=\"4.1\"></a>\n### Overview\nSTF provides 4 key methods for controlling process execution:\n- doRunForegroundProcess() - run a process synchronously.\n- doRunBackgroundProcess() - start running one or more processes in the background.\n- doMonitorProcess() - wait for process completion.\n- doKillProcess() - kill a running process.\n\ndoRunForegroundProcess() provides a pretty conventional method to synchronously run a process.\nSTF starts the process and then waits until it finishes.\nThis method operates independently from the remaining three methods as it is completely\nself contained.\n\nThe remaining three methods: doRunBackgroundProcess, doMonitorProcess and doKillProcess, usually operate\ntogether to control concurrent execution. Typically multiple processes\nare started with several doStart calls, which is followed by a doMonitor call\nuntil completion, with a doKill sometimes being used to kill processes\nwhich would otherwise never complete.<br>\n\nSTF tracks the state of created processes and will abort the test before\nexecution starts if it detects an invalid or illogical sequence of calls, for\nexample attempting to kill a process which has already completed. For more\ndetails on this see the section titled 'STF process state checking'.\n\nIf any of the process control methods fail (and exit with a non zero value)\nthen STF will kill all processes which could be running at that point.\n\nSee the following sample programs for examples on using these methods:\n- SampleRunProcess.java - synchronously runs a Java process\n- SampleConcurrentProcesses.java - Concurrently runs several processes\n- SampleClientServer.java - runs with a server that never completes\n- SampleClientServer2.java - variation of SampleClientServer.java. Runs a process which is expected to complete with non-zero exit value\n\n<a name=\"4.2\"></a>\n### Single threaded execution\n\nMost STF based tests run processes using the single-threaded model, running the\nsteps one process at a time, and not starting a process until the previous one has\ncompleted.\n\nThis is the mode in which the basic actions, such as doMkdir, doUnzip,\ndoFileEdit, etc, operate. They run sequentially in the same order as\nspecified in the test automation code.\n\n",
        "start_line": 136,
        "end_line": 258,
        "chunk_index": 3,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 965,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687355"
      },
      "text": "For example:\n``` java\npublic void help(HelpTextGenerator help) throws StfException {\n  help.outputSection(\"MathLoadTest test\");\n  help.outputText(\"MathLoadTest runs workloads of Math related tests, \"\n      + \"by default it runs all math tests if no workload is specified.\");\n\n  help.outputSection(\"MathLoadTest test options\");\n  help.outputArgName(\"workload\", \"NAME\");\n  help.outputArgDesc(\"This is the name of the workload to run, it supports \"\n      + \"the following workloads: math, bigdecimal, autosimd\");\n}\n```\n\n<a name=\"3.2.2\"></a>\n#### pluginInit method\n\nTo be completed.\n\n<a name=\"3.2.3\"></a>\n#### setUp method\n\nTo be completed.\n\n<a name=\"3.2.4\"></a>\n#### execute method\nThe execute method is the key part of the automation. It lists the actions that need to\nbe performed to actually run the test. The steps in the execute method are only executed\nif setUp ran without any errors.\n\nTo help with test development/debugging the actions in the execute stage should be\nable to be run repeatedly.\n\nAs with the setUp stage, the failure of any action results in the termination of the stage.\n\n<a name=\"3.2.5\"></a>\n#### tearDown method\n\nTo be completed.\n\n<a name=\"3.2.6\"></a>\n#### STF Structure\nThe following diagram shows the keys components for STF based test automation.\n\nIt shows the test automation code at the top of the diagram and its interaction with\nSTF through the extension classes and the environment class.\n\nThe left hand side of the diagram shows that both the developer and STF both have access\nto the file system and property file.\nTowards the bottom of the diagram, in the 'perl code' box, STF provides insight into the\ntest run by revealing the generated perl code, whose execution is going to implement the\nsteps described in the automation code.\n\n<img src=\"./images/STF-Structure.jpg\" hspace=\"20\" width=\"600\">\n\n<a name=\"3.3\"></a>\n### STF actions\n\nTo be completed.\n\n<a name=\"3.4\"></a>\n### File system access\n\nTo be completed.\n\n<a name=\"3.5\"></a>\n### New test development\n\nTo be completed.\n\n<a name=\"3.6\"></a>\n### Porting existing tests\n\nTo be completed.\n\n<a name=\"4\"></a>\n## Process Execution\n\n<a name=\"4.1\"></a>\n### Overview\nSTF provides 4 key methods for controlling process execution:\n- doRunForegroundProcess() - run a process synchronously.\n- doRunBackgroundProcess() - start running one or more processes in the background.\n- doMonitorProcess() - wait for process completion.\n- doKillProcess() - kill a running process.\n\ndoRunForegroundProcess() provides a pretty conventional method to synchronously run a process.\nSTF starts the process and then waits until it finishes.\nThis method operates independently from the remaining three methods as it is completely\nself contained.\n\nThe remaining three methods: doRunBackgroundProcess, doMonitorProcess and doKillProcess, usually operate\ntogether to control concurrent execution. Typically multiple processes\nare started with several doStart calls, which is followed by a doMonitor call\nuntil completion, with a doKill sometimes being used to kill processes\nwhich would otherwise never complete.<br>\n\nSTF tracks the state of created processes and will abort the test before\nexecution starts if it detects an invalid or illogical sequence of calls, for\nexample attempting to kill a process which has already completed. For more\ndetails on this see the section titled 'STF process state checking'.\n\nIf any of the process control methods fail (and exit with a non zero value)\nthen STF will kill all processes which could be running at that point.\n\nSee the following sample programs for examples on using these methods:\n- SampleRunProcess.java - synchronously runs a Java process\n- SampleConcurrentProcesses.java - Concurrently runs several processes\n- SampleClientServer.java - runs with a server that never completes\n- SampleClientServer2.java - variation of SampleClientServer.java. Runs a process which is expected to complete with non-zero exit value\n\n<a name=\"4.2\"></a>\n### Single threaded execution\n\nMost STF based tests run processes using the single-threaded model, running the\nsteps one process at a time, and not starting a process until the previous one has\ncompleted.\n\nThis is the mode in which the basic actions, such as doMkdir, doUnzip,\ndoFileEdit, etc, operate. They run sequentially in the same order as\nspecified in the test automation code.\n\n"
    },
    "44": {
      "metadata": {
        "chunk_id": "be0b64532b835df3639dfb2ca20a00adf6a4b740f35e910c222ca37b510ed70a",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "The following example synchronously runs a java process which is expected to complete with an exit value of 3:\n``` java\ntest.doRunForegroundProcess(\"Run client\", \"CL\", ECHO_ON, ExpectedOutcome.exitValue(3).within(\"10s\"),\n    test.createJavaProcessDefinition()\n        .addJvmOption(\"-Xmx100M\")\n        .addProjectToClasspath(\"sampleProject2\")\n        .runClass(MiniClient.class)\n        .addArg(\"3\"));\n```\n\nIn this case the Java process runs in the foreground until one of the following occours:\n- The process completes with the expected exit code. The happy case.\n- The process completes with an unexpected exit code. Test failure.\n- Java produces a core/dump file. Test failure.\n- The process exceeds its allowed run time. The process is then killed. Test failure.\n\nThe arguments passed to doRunForegroundProcess are:\n- Comment - a short summary stating why the process is being run.\n- Mnemonic - an abbreviation to identify the process in the STF output. Also used as a prefix when process output is echoed.\n- Echo setting - to turn on/off echoing of process output to STF output.\n- ExpectedOutcome - describes what the test expects to happy when the process is executed. See below for examples.\n- A process definition - describes how to run the process. Again, see below.\n\nProcess which are expected to complete must specify their maximum run\ntime. This is encoded as a string value, using 'h', 'm' and 's' characters\nto specify how long the process can run before it is killed and the test\nis marked as a failure. Here are some examples showing the 4 different\ntypes of expected outcome:\n``` java\nExpectedOutcome.cleanRun().within(\"10s\")  // we expect exit code 0\nExpectedOutcome.exitValue(3).within(\"1m30s\")\nExpectedOutcome.crashes().within(\"3h15m\")\nExpectedOutcome.neverCompletes()\n```\n\nThe Java process definition is built up by using a series of calls to a\nfluent style interface. When STF executes the test it converts the\nJavaProcessDefinition into a String which executes the process. The\nconstructed value is visible in the setup.pl or execute.pl script.\nThe java process definition object allows the caller to specify:\n- JVM options, such as '-Xmx50M' or '-Xverbosegclog:...'\n- Classpath construction, using workspace projects, jar files or directories.\n- The java class to be run.\n- Arguments to the java process.\n- Data from another process as an argument (see addPerlProcessData)\n\nOutput from all running processes is written to 2 files in the results directory: &lt;mnemonic&gt;.stdout and &lt;mnemonic&gt;.stderr.<br>\n<br>\n\n<a name=\"4.3\"></a>\n### Concurrent execution\n\n<a name=\"4.3.1\"></a>\n#### Starting processes\n\nAny number of processes can be started by calling doRunBackgroundProcess. This method takes the same arguments as doRunForegroundProcess, so to avoid repetition on the arguments please see the previous section on 'Single threaded execution'.\n\nThe key difference between doRunBackgoundProcess and doRunForegroundProcess is that foreground method waits for the process to complete before moving on to the next step. The background method initiates the process in the background but does not wait for it complete. Any number of processes can be\nstarted.\n\nThe second key difference is that doRunBackgroundProcess returns an object to represent the running process. This object internally tracks the state of the process and allows the test to monitor the running process or kill it when it is no longer required.\n\nIf you need to start several processes with the same invocation\nconfiguration and arguments then this can be done by using the\ndoRunBackgroundProcesses method. This is basically the same as doRunBackgroundProcess except that it has an extra argument, which is the number of processes that should be started. This returns an array of StfProcess objects can be used to monitor or kill the processes as a batch. Having access to the StfProcess object does allow different handling of each child process, but as they have all be started with the same arguments, it's normal practice to treat them as a block of processes, with all of them being\nmonitored or killed at the same time. A unique per-process mnemonic is created by appending the instance number onto the process mnemonic, so if 3 client processes which use the 'CL' mnemonic are started, then the full mnemonic names would be CL1, CL2 and CL3.\n\n",
        "start_line": 259,
        "end_line": 326,
        "chunk_index": 4,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 944,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687360"
      },
      "text": "The following example synchronously runs a java process which is expected to complete with an exit value of 3:\n``` java\ntest.doRunForegroundProcess(\"Run client\", \"CL\", ECHO_ON, ExpectedOutcome.exitValue(3).within(\"10s\"),\n    test.createJavaProcessDefinition()\n        .addJvmOption(\"-Xmx100M\")\n        .addProjectToClasspath(\"sampleProject2\")\n        .runClass(MiniClient.class)\n        .addArg(\"3\"));\n```\n\nIn this case the Java process runs in the foreground until one of the following occours:\n- The process completes with the expected exit code. The happy case.\n- The process completes with an unexpected exit code. Test failure.\n- Java produces a core/dump file. Test failure.\n- The process exceeds its allowed run time. The process is then killed. Test failure.\n\nThe arguments passed to doRunForegroundProcess are:\n- Comment - a short summary stating why the process is being run.\n- Mnemonic - an abbreviation to identify the process in the STF output. Also used as a prefix when process output is echoed.\n- Echo setting - to turn on/off echoing of process output to STF output.\n- ExpectedOutcome - describes what the test expects to happy when the process is executed. See below for examples.\n- A process definition - describes how to run the process. Again, see below.\n\nProcess which are expected to complete must specify their maximum run\ntime. This is encoded as a string value, using 'h', 'm' and 's' characters\nto specify how long the process can run before it is killed and the test\nis marked as a failure. Here are some examples showing the 4 different\ntypes of expected outcome:\n``` java\nExpectedOutcome.cleanRun().within(\"10s\")  // we expect exit code 0\nExpectedOutcome.exitValue(3).within(\"1m30s\")\nExpectedOutcome.crashes().within(\"3h15m\")\nExpectedOutcome.neverCompletes()\n```\n\nThe Java process definition is built up by using a series of calls to a\nfluent style interface. When STF executes the test it converts the\nJavaProcessDefinition into a String which executes the process. The\nconstructed value is visible in the setup.pl or execute.pl script.\nThe java process definition object allows the caller to specify:\n- JVM options, such as '-Xmx50M' or '-Xverbosegclog:...'\n- Classpath construction, using workspace projects, jar files or directories.\n- The java class to be run.\n- Arguments to the java process.\n- Data from another process as an argument (see addPerlProcessData)\n\nOutput from all running processes is written to 2 files in the results directory: &lt;mnemonic&gt;.stdout and &lt;mnemonic&gt;.stderr.<br>\n<br>\n\n<a name=\"4.3\"></a>\n### Concurrent execution\n\n<a name=\"4.3.1\"></a>\n#### Starting processes\n\nAny number of processes can be started by calling doRunBackgroundProcess. This method takes the same arguments as doRunForegroundProcess, so to avoid repetition on the arguments please see the previous section on 'Single threaded execution'.\n\nThe key difference between doRunBackgoundProcess and doRunForegroundProcess is that foreground method waits for the process to complete before moving on to the next step. The background method initiates the process in the background but does not wait for it complete. Any number of processes can be\nstarted.\n\nThe second key difference is that doRunBackgroundProcess returns an object to represent the running process. This object internally tracks the state of the process and allows the test to monitor the running process or kill it when it is no longer required.\n\nIf you need to start several processes with the same invocation\nconfiguration and arguments then this can be done by using the\ndoRunBackgroundProcesses method. This is basically the same as doRunBackgroundProcess except that it has an extra argument, which is the number of processes that should be started. This returns an array of StfProcess objects can be used to monitor or kill the processes as a batch. Having access to the StfProcess object does allow different handling of each child process, but as they have all be started with the same arguments, it's normal practice to treat them as a block of processes, with all of them being\nmonitored or killed at the same time. A unique per-process mnemonic is created by appending the instance number onto the process mnemonic, so if 3 client processes which use the 'CL' mnemonic are started, then the full mnemonic names would be CL1, CL2 and CL3.\n\n"
    },
    "45": {
      "metadata": {
        "chunk_id": "21a4456351c0e84faf7c508cc15ca7debd800852b0faede26d12d2f33e150a75",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "This code starts four 'client' processes which all run MiniClient with the same arguments and expectations:\n``` java\nStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"),\n    test.createJavaProcessDefinition()\n        .addProjectToClasspath(\"sampleProject2\")\n        .runClass(MiniClient.class));\n```\n\n<a name=\"4.3.2\"></a>\n#### Monitoring processes\n\nOnce one or more processes have been started you'll need to wait for their completion. This is done by calling the doMonitor method, which waits until it either detects a failure or all processes complete successfully. The following example of its usage has been copied from SampleClientServer2.java:\n``` java\nStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_ON, ExpectedOutcome.cleanRun().within(\"10s\"),\n    test.createJavaProcessDefinition()\n        .addProjectToClasspath(\"sampleProject2\")\n        .runClass(MiniClient.class));\n\n// Wait for clients to complete.\ntest.doMonitorProcesses(\"Wait for clients to complete\", server, clients, failingClient);\n```\n\nThe most important task of monitoring is to synchronise the test, so we can wait for the completion of child processes before moving to the next part of the the test, but it also performs several other functions:\n\n- Fails the step if any of the monitored processes do not complete as expected.\n- Echos output from processes started with ECHO_ON to the STF output.\n- Checks each processes runtime against its limit. Fails as soon as one of the processes exceeds its limit.\n\nMonitoring can check processes which are expected to complete as well as those which are not expected to complete, for example in SampleClientSever we start a server process which runs an endless loop and a client which is going to complete after several seconds. Calling doMonitor(server,client) in necessary in such situations as we must wait for the client process, but it's also good to be able to fail the test if the server crashes. The doMonitor command will run until it either detects a failure or the successful completion of all the processes which are expected to complete. The implication\nof this logic is the server process (or any other which is not expected to complete) will still be running at the end of the doMonitor. This can be surprising at first but is needed to provide both a monitoring capability for endless processes and the ability to have tests which don't run forever.\n\n``` java\nwhile (true) {\n    echo output from processes with echo=on to STF output\n\n    for (all processes being monitored) {\n        check for core files\n\n        if (process completed but not as expected) {\n            error.\n            return -1\n        }\n\n        if (process exceeded maximum runtime) {\n            error\n            return -1\n        }\n    }\n\n    if (all process expected to complete have already completed) {\n        return 0;\n    }\n}\n```\n\ndoMonitor doesn't really care if processes exit cleanly with a zero value, or crash, or run forever; it cares about whether or not its observable behaviour matches the expectation of the test. If the test expects a process to, say, crash then monitoring will only be\nregarded as passing when that process does crash. If the process is expected to crash but doesn't then that is a test failure.\n\nAs with all of the do methods, any detected failure in monitoring will cause it exit with a non zero value, which will lead to all outstanding processes being killed and the failure of the test.\n\n<a name=\"4.3.3\"></a>\n#### Killing processes\n\nRunning processes can be terminated by running doKill. This is typically used towards the end of a test to stop those processes which would otherwise run forever.\n\nThis can kill any number of processes, but the following example shows the killing of just a single process:\n``` java\ntest.doKillProcesses(\"Stop server process\", server);\n```\n\n<a name=\"4.4\"></a>\n### STF process state checking\nSTF tracks the potential state of each process so that it can catch logic errors in the test code. The errors which be detected by this static analysis are:\n- Leaving an orphan process. i.e. a process which has been started but has neither been monitored nor killed.\n- Attempting to monitor a terminal process which has already been monitored (and must therefore either have failed or have completed).\n- Killing a process which has already completed or has been killed.\n- Attempting to run doMonitor for processes when all of the processes are not going to complete (as the test would the run forever).\n\n",
        "start_line": 327,
        "end_line": 405,
        "chunk_index": 5,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 960,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687364"
      },
      "text": "This code starts four 'client' processes which all run MiniClient with the same arguments and expectations:\n``` java\nStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"),\n    test.createJavaProcessDefinition()\n        .addProjectToClasspath(\"sampleProject2\")\n        .runClass(MiniClient.class));\n```\n\n<a name=\"4.3.2\"></a>\n#### Monitoring processes\n\nOnce one or more processes have been started you'll need to wait for their completion. This is done by calling the doMonitor method, which waits until it either detects a failure or all processes complete successfully. The following example of its usage has been copied from SampleClientServer2.java:\n``` java\nStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_ON, ExpectedOutcome.cleanRun().within(\"10s\"),\n    test.createJavaProcessDefinition()\n        .addProjectToClasspath(\"sampleProject2\")\n        .runClass(MiniClient.class));\n\n// Wait for clients to complete.\ntest.doMonitorProcesses(\"Wait for clients to complete\", server, clients, failingClient);\n```\n\nThe most important task of monitoring is to synchronise the test, so we can wait for the completion of child processes before moving to the next part of the the test, but it also performs several other functions:\n\n- Fails the step if any of the monitored processes do not complete as expected.\n- Echos output from processes started with ECHO_ON to the STF output.\n- Checks each processes runtime against its limit. Fails as soon as one of the processes exceeds its limit.\n\nMonitoring can check processes which are expected to complete as well as those which are not expected to complete, for example in SampleClientSever we start a server process which runs an endless loop and a client which is going to complete after several seconds. Calling doMonitor(server,client) in necessary in such situations as we must wait for the client process, but it's also good to be able to fail the test if the server crashes. The doMonitor command will run until it either detects a failure or the successful completion of all the processes which are expected to complete. The implication\nof this logic is the server process (or any other which is not expected to complete) will still be running at the end of the doMonitor. This can be surprising at first but is needed to provide both a monitoring capability for endless processes and the ability to have tests which don't run forever.\n\n``` java\nwhile (true) {\n    echo output from processes with echo=on to STF output\n\n    for (all processes being monitored) {\n        check for core files\n\n        if (process completed but not as expected) {\n            error.\n            return -1\n        }\n\n        if (process exceeded maximum runtime) {\n            error\n            return -1\n        }\n    }\n\n    if (all process expected to complete have already completed) {\n        return 0;\n    }\n}\n```\n\ndoMonitor doesn't really care if processes exit cleanly with a zero value, or crash, or run forever; it cares about whether or not its observable behaviour matches the expectation of the test. If the test expects a process to, say, crash then monitoring will only be\nregarded as passing when that process does crash. If the process is expected to crash but doesn't then that is a test failure.\n\nAs with all of the do methods, any detected failure in monitoring will cause it exit with a non zero value, which will lead to all outstanding processes being killed and the failure of the test.\n\n<a name=\"4.3.3\"></a>\n#### Killing processes\n\nRunning processes can be terminated by running doKill. This is typically used towards the end of a test to stop those processes which would otherwise run forever.\n\nThis can kill any number of processes, but the following example shows the killing of just a single process:\n``` java\ntest.doKillProcesses(\"Stop server process\", server);\n```\n\n<a name=\"4.4\"></a>\n### STF process state checking\nSTF tracks the potential state of each process so that it can catch logic errors in the test code. The errors which be detected by this static analysis are:\n- Leaving an orphan process. i.e. a process which has been started but has neither been monitored nor killed.\n- Attempting to monitor a terminal process which has already been monitored (and must therefore either have failed or have completed).\n- Killing a process which has already completed or has been killed.\n- Attempting to run doMonitor for processes when all of the processes are not going to complete (as the test would the run forever).\n\n"
    },
    "46": {
      "metadata": {
        "chunk_id": "85fbe56ee1d75cfcc8870adb5c390ab9bab3b2477c1287179598678a958d2d3a",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "The following diagram shows the state transitions for a process which is expected to complete. Any actions apart from those labelled will result in a runtime failure:\n<img src=\"./images/StateTransition1.jpg\" hspace=\"60\">\n\nThe following diagram shows the state transitions for a process which is not expected to complete. This shows that it can be monitored any number of times but must be killed to prevent the test leaving behind an orphaned process. Again, any attempt to deviate from the transitions shown results in a runtime error.\n<img src=\"./images/StateTransition2.jpg\" hspace=\"60\">\n\nThe STF logic which checks for illogical and incorrect sequences of calls runs before the actual test execution. If you get such an error you will notice that none of the tests processes have been run and there is no output for the usual setup, execute and teardown stages.\n\n<a name=\"4.5\"></a>\n### STF process output\nProcess output is always written to two files in the results directory:\n<mnemonic>.stdout and <mnemonic>.stderr.\n\nSTF echos the output of processes started with ECHO_ON during the following calls:\n- doMonitorProcesses()\n- doKillProcesses()\n\nNo output from processes started with ECHO_OFF is echoed by STF. Regardless of the echo setting, all output from child processes can be found in their stdout and stderr files in the results directory.\n\nThe implementation of process echoing means that there a few details\nto be aware of when debugging. Firstly, output from multiple processes may appear out of sequence. This is because output from each process is echoed in turn. For example, if we are monitoring processes X and Y, and process Y produces output and then process X produces output, then exactly which output is echoed first will depend on which process is the next one to be checked. If process X is checked first then its new output will be echoed, even though process Y has some older output.\n\nThe second point to bear in mind is that processes may not produce their output immediately, as it depends on how frequently they flush their log file output. This obviously adds an unpredictable time lag to the echo.\n\nAnd finally, it should be remembered that output is only echoed during the monitor and kill commands. If a time consuming action is run after starting some processes then their output will build up and not be visible until the entering a doMonitor/doKill.\n\n<a name=\"5\"></a>\n## Test Actions\n\n<a name=\"5.1\"></a>\n### File system actions\n<a name=\"5.1.1\"></a>\n- **doRm** - remove a file\n<a name=\"5.1.2\"></a>\n- **doRm** - remove a directory\n<a name=\"5.1.3\"></a>\n- **doCp** - copy a file\n<a name=\"5.1.4\"></a>\n- **doCpDir** - copy a directory\n<a name=\"5.1.5\"></a>\n- **doMkdir** - create a directory\n<a name=\"5.1.6\"></a>\n- **doCd** - change current directory\n<a name=\"5.1.7\"></a>\n- **doUnzip** - unpack an archive\n<a name=\"5.1.8\"></a>\n- **doWriteFile** - create a file\n<a name=\"5.1.9\"></a>\n- **doFileEdit** - update an existing file\n<a name=\"5.1.10\"></a>\n- **doJarUpdate** - update a jar file\n<a name=\"5.1.11\"></a>\n- **doValidateFileExists** - confirm file exists\n\n<a name=\"5.2\"></a>\n### Process management actions\n\nThe synchronous or asynchronous running of multiple processes is covered in the Process Management section.\n\nThe core methods to support process execution are:\n- **doRunForegroundProcess** - synchronously run single process\n- **doRunForegroundProcesses** - synchronously run multiple processes\n- **doRunBackgroundProcess** - synchronously run single process\n- **doRunBackgroundProcesses** - synchronously run multiple processes\n- **doMonitorProcesses** - wait for process completion\n- **doKillProcesses** - kill a process\n\n<a name=\"5.3\"></a>\n### Test results actions\n\n<a name=\"5.3.1\"></a>\n- **doReportFilteredTestResults** - filter test results\n\n<a name=\"5.4\"></a>\n### Miscellaneous actions\n\n<a name=\"5.4.1\"></a>\n- **doVerifyDisplayAvailable** - confirm display connected\n\n<a name=\"5.5\"></a>\n### Process creation\n\n",
        "start_line": 406,
        "end_line": 488,
        "chunk_index": 6,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 946,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687369"
      },
      "text": "The following diagram shows the state transitions for a process which is expected to complete. Any actions apart from those labelled will result in a runtime failure:\n<img src=\"./images/StateTransition1.jpg\" hspace=\"60\">\n\nThe following diagram shows the state transitions for a process which is not expected to complete. This shows that it can be monitored any number of times but must be killed to prevent the test leaving behind an orphaned process. Again, any attempt to deviate from the transitions shown results in a runtime error.\n<img src=\"./images/StateTransition2.jpg\" hspace=\"60\">\n\nThe STF logic which checks for illogical and incorrect sequences of calls runs before the actual test execution. If you get such an error you will notice that none of the tests processes have been run and there is no output for the usual setup, execute and teardown stages.\n\n<a name=\"4.5\"></a>\n### STF process output\nProcess output is always written to two files in the results directory:\n<mnemonic>.stdout and <mnemonic>.stderr.\n\nSTF echos the output of processes started with ECHO_ON during the following calls:\n- doMonitorProcesses()\n- doKillProcesses()\n\nNo output from processes started with ECHO_OFF is echoed by STF. Regardless of the echo setting, all output from child processes can be found in their stdout and stderr files in the results directory.\n\nThe implementation of process echoing means that there a few details\nto be aware of when debugging. Firstly, output from multiple processes may appear out of sequence. This is because output from each process is echoed in turn. For example, if we are monitoring processes X and Y, and process Y produces output and then process X produces output, then exactly which output is echoed first will depend on which process is the next one to be checked. If process X is checked first then its new output will be echoed, even though process Y has some older output.\n\nThe second point to bear in mind is that processes may not produce their output immediately, as it depends on how frequently they flush their log file output. This obviously adds an unpredictable time lag to the echo.\n\nAnd finally, it should be remembered that output is only echoed during the monitor and kill commands. If a time consuming action is run after starting some processes then their output will build up and not be visible until the entering a doMonitor/doKill.\n\n<a name=\"5\"></a>\n## Test Actions\n\n<a name=\"5.1\"></a>\n### File system actions\n<a name=\"5.1.1\"></a>\n- **doRm** - remove a file\n<a name=\"5.1.2\"></a>\n- **doRm** - remove a directory\n<a name=\"5.1.3\"></a>\n- **doCp** - copy a file\n<a name=\"5.1.4\"></a>\n- **doCpDir** - copy a directory\n<a name=\"5.1.5\"></a>\n- **doMkdir** - create a directory\n<a name=\"5.1.6\"></a>\n- **doCd** - change current directory\n<a name=\"5.1.7\"></a>\n- **doUnzip** - unpack an archive\n<a name=\"5.1.8\"></a>\n- **doWriteFile** - create a file\n<a name=\"5.1.9\"></a>\n- **doFileEdit** - update an existing file\n<a name=\"5.1.10\"></a>\n- **doJarUpdate** - update a jar file\n<a name=\"5.1.11\"></a>\n- **doValidateFileExists** - confirm file exists\n\n<a name=\"5.2\"></a>\n### Process management actions\n\nThe synchronous or asynchronous running of multiple processes is covered in the Process Management section.\n\nThe core methods to support process execution are:\n- **doRunForegroundProcess** - synchronously run single process\n- **doRunForegroundProcesses** - synchronously run multiple processes\n- **doRunBackgroundProcess** - synchronously run single process\n- **doRunBackgroundProcesses** - synchronously run multiple processes\n- **doMonitorProcesses** - wait for process completion\n- **doKillProcesses** - kill a process\n\n<a name=\"5.3\"></a>\n### Test results actions\n\n<a name=\"5.3.1\"></a>\n- **doReportFilteredTestResults** - filter test results\n\n<a name=\"5.4\"></a>\n### Miscellaneous actions\n\n<a name=\"5.4.1\"></a>\n- **doVerifyDisplayAvailable** - confirm display connected\n\n<a name=\"5.5\"></a>\n### Process creation\n\n"
    },
    "47": {
      "metadata": {
        "chunk_id": "ef6f5bc92385209ffcb6bd857675011af6b417b6e609deeef02e622026d1af73",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "This section covers the methods used to define how to run a process. They are not strictly speaking action methods, but they are described here as they really have the same importance. Were it not for the split between defining a process and running it, they\ncould equally well have been implemented as 'do' methods.\n\nOnce the test code has a process definition then it can be used to synchronously or asynchronously start one or more instances of the process.\n\nThe Process Management section has some examples of running single and multiple concurrent processes.\n\n<a name=\"5.5.1\"></a>\n#### createJavaProcessDefinition\n\nThis method provides a fluent style interface to allow the capture of the information needed to start a Java process.\n\nThe following example shows the use of the key methods to define a platform independent description of the information needed to run a Java process:\n\n``` java\nJavaProcessDefinition clientJavaInvocation = stfCore.createJavaProcessDefinition()\n    .addJarToClasspath(equinoxLauncherJar)\n    .addProjectToClasspath(\"test.jlm\")\n    .addJvmOption(\"-Djavax.net.ssl.keyStoreType=JKS\")\n    .addJvmOption(\"-Djavax.net.ssl.keyStorePassword=change1t\")\n    .addJvmOption(\"-Dcom.sun.management.jmxremote.ssl.need.client.auth=true\")\n    .runClass(MemoryProfiler.class)\n    .addArg(\"proxy\")\n    .addArg(statsFile)\n    .addArg(\"localhost\");\n```  \n\nOther useful JavaProcessDefinition methods:\n- addPerlProcessData(StfProcess,Integer)\n-- his method is useful for taking data relating to one StfProcess, and passing that data to another Java process as an argument.\n-- e.g. addPerlProcessData(<StfProcess>,StfConstants.PERL_PROCESS_PID) will add \tthe process ID from <StfProcess> to your Java command as an argument. See StfConstants.PERL_PROCESS_DATA for a full list of available process data.\n\n<a name=\"5.5.2\"></a>\n#### createJUnitProcessDefinition\n\nThis method creates a JavaProcessDefinition object which is prepopulated to allow the running of JUnit tests.\n\nThis example synchronously runs a JUnit test:\n``` java\n// Build a description of how to run JUnit\nJavaProcessDefinition junitProcessDefinition = test.createJUnitProcessDefinition(\"stf\", null,\n    TestArgumentProcessing.class,\n    TestResultsProcessor.class);\n\n// Synchronously run the JUnit tests\ntest.doRunForegroundProcess(\"Run JUnit tests\", \"J\", ECHO_ON,\n    ExpectedOutcome.cleanRun().within(\"1m\"),\n    junitProcessDefinition);\n```\n\ncreateJUnitProcessDefinition() actually sets things up to run a STF utility class called JUnitRunner instead of the standard JUnit runner. STF has its own class to run JUnit tests because the default JUnit runners always completes with a zero exit value.\nSTF is driven by process exit codes, so this obviously makes it impossible for STF to know if the JUnit tests have passed or failed. Hence the need for a class which can run the JUnit test but also complete with a non-zero return value when a test fails.\n\nThe responsibilities of the JUnitRunner class are:\n- *exit value*. Returns 0 if all tests pass, otherwise 1. As already mentioned, this is the primary reason for the existence of JUnitRunner.java\n- *test exclusions*. JUnitRunner supports the supply of an exclusions file, which lists all of the tests which are allowed to fail. This is useful if a test needs to run third party code which is known to fail.\n- *live output*. It reports the start & end of each test. This makes\nit much easier to see what is happening, identify which method is producing which output, etc.\n\nSTF is not doing any analysis on the JUnit output. It's not at all uncommon for tests to deliberately create exceptions, so it's really not possible to parse this is in a generic way. Besides, testing frameworks like JUnit are driven by assertions in the test code, so it's fundamentally wrong for another piece of software to parse their output and try to make another judgement about whether or not a test has passed or failed.\n\n<a name=\"5.5.3\"></a>\n#### createJDKToolProcessDefinition\n\nThis variant creates a JavaProcessDefinition needed to run a JDK tool or utility in the jdk bin directory. For example, keytool, jar, etc.\n\nThe following example creates a keystore and generates a key pair.\n\n",
        "start_line": 489,
        "end_line": 557,
        "chunk_index": 7,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 928,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687373"
      },
      "text": "This section covers the methods used to define how to run a process. They are not strictly speaking action methods, but they are described here as they really have the same importance. Were it not for the split between defining a process and running it, they\ncould equally well have been implemented as 'do' methods.\n\nOnce the test code has a process definition then it can be used to synchronously or asynchronously start one or more instances of the process.\n\nThe Process Management section has some examples of running single and multiple concurrent processes.\n\n<a name=\"5.5.1\"></a>\n#### createJavaProcessDefinition\n\nThis method provides a fluent style interface to allow the capture of the information needed to start a Java process.\n\nThe following example shows the use of the key methods to define a platform independent description of the information needed to run a Java process:\n\n``` java\nJavaProcessDefinition clientJavaInvocation = stfCore.createJavaProcessDefinition()\n    .addJarToClasspath(equinoxLauncherJar)\n    .addProjectToClasspath(\"test.jlm\")\n    .addJvmOption(\"-Djavax.net.ssl.keyStoreType=JKS\")\n    .addJvmOption(\"-Djavax.net.ssl.keyStorePassword=change1t\")\n    .addJvmOption(\"-Dcom.sun.management.jmxremote.ssl.need.client.auth=true\")\n    .runClass(MemoryProfiler.class)\n    .addArg(\"proxy\")\n    .addArg(statsFile)\n    .addArg(\"localhost\");\n```  \n\nOther useful JavaProcessDefinition methods:\n- addPerlProcessData(StfProcess,Integer)\n-- his method is useful for taking data relating to one StfProcess, and passing that data to another Java process as an argument.\n-- e.g. addPerlProcessData(<StfProcess>,StfConstants.PERL_PROCESS_PID) will add \tthe process ID from <StfProcess> to your Java command as an argument. See StfConstants.PERL_PROCESS_DATA for a full list of available process data.\n\n<a name=\"5.5.2\"></a>\n#### createJUnitProcessDefinition\n\nThis method creates a JavaProcessDefinition object which is prepopulated to allow the running of JUnit tests.\n\nThis example synchronously runs a JUnit test:\n``` java\n// Build a description of how to run JUnit\nJavaProcessDefinition junitProcessDefinition = test.createJUnitProcessDefinition(\"stf\", null,\n    TestArgumentProcessing.class,\n    TestResultsProcessor.class);\n\n// Synchronously run the JUnit tests\ntest.doRunForegroundProcess(\"Run JUnit tests\", \"J\", ECHO_ON,\n    ExpectedOutcome.cleanRun().within(\"1m\"),\n    junitProcessDefinition);\n```\n\ncreateJUnitProcessDefinition() actually sets things up to run a STF utility class called JUnitRunner instead of the standard JUnit runner. STF has its own class to run JUnit tests because the default JUnit runners always completes with a zero exit value.\nSTF is driven by process exit codes, so this obviously makes it impossible for STF to know if the JUnit tests have passed or failed. Hence the need for a class which can run the JUnit test but also complete with a non-zero return value when a test fails.\n\nThe responsibilities of the JUnitRunner class are:\n- *exit value*. Returns 0 if all tests pass, otherwise 1. As already mentioned, this is the primary reason for the existence of JUnitRunner.java\n- *test exclusions*. JUnitRunner supports the supply of an exclusions file, which lists all of the tests which are allowed to fail. This is useful if a test needs to run third party code which is known to fail.\n- *live output*. It reports the start & end of each test. This makes\nit much easier to see what is happening, identify which method is producing which output, etc.\n\nSTF is not doing any analysis on the JUnit output. It's not at all uncommon for tests to deliberately create exceptions, so it's really not possible to parse this is in a generic way. Besides, testing frameworks like JUnit are driven by assertions in the test code, so it's fundamentally wrong for another piece of software to parse their output and try to make another judgement about whether or not a test has passed or failed.\n\n<a name=\"5.5.3\"></a>\n#### createJDKToolProcessDefinition\n\nThis variant creates a JavaProcessDefinition needed to run a JDK tool or utility in the jdk bin directory. For example, keytool, jar, etc.\n\nThe following example creates a keystore and generates a key pair.\n\n"
    },
    "48": {
      "metadata": {
        "chunk_id": "29a9eeb5d62acdb9957459ea8c6e3af42075c0b48abafc0bb2263380b78b7961",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "``` java\nStfProcess keytool = test.doRunBackgroundProcess(\"Run keytool\", \"KEY\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"10s\"),\ntest.doRunForegroundProcess(\"Run keytool\", \"KEY\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"10s\"),\n    test.createJDKToolProcessDefinition()\n        .setJDKToolOrUtility(\"keytool\")\n        .addArg(\"-genkeypair\")\n        .addArg(\"-dname\")\n        .addArg(\"\\\"cn=John Example, ou=Java, o=IBM, c=UK\\\"\")\n        .addArg(\"-alias\")\n        .addArg(\"business\")\n        .addArg(\"-keypass\")\n        .addArg(\"secret-password\")\n        .addArg(\"-keystore\")\n        .addArg(test.env().getTmpDir().childFile(\"mykeystore\").getSpec())\n        .addArg(\"-storepass\")\n        .addArg(\"new-keystore-pw\")\n        .addArg(\"-validity\")\n        .addArg(\"180\"))\n```\n\n<a name=\"6\"></a>\n## Test Development\n\n- Non synchronous processes\n- Test specific arguments\n- Expected test failures\n- Custom extensions\n\n- Running from local build\n\n<a name=\"7\"></a>\n## Advanced and Unusual cases\n\n<a name=\"7.1\"></a>\n### Classpath management for non-Eclipse projects\n\nWhen running automation code from the Eclipse workspace STF uses the contents of the projects .classpath file to determine the projects dependencies. STF is also able to use .classpath file when running an automation plugin from output of the build process.\n\nThere are some occasions in which the automation code is not being compiled by Eclipse, and there is therefore no need to have a valid .classpath file. The most typical case would be when a project needs to use a newer Java version than that supported by Eclipse.\n\n<a name=\"7.1.1\"></a>\n#### stfclasspath.xml file\n\nThe solution to this problem is for the project to have a top level 'stfclasspath.xml' file instead of the usual '.classpath' file. This 'stfclasspath.xml' file is in the\nsame format as a standard '.classpath' file, and references the projects dependent projects and/or jar files. STF will use this file when there is no '.classpath' file.\n\nThis situation effectively means that a workspace contains 2 different types of projects. Firstly, most projects are hopefully a standard java project which has a\n'.classpath' file, or secondly, a 'general' project which is not compiled by Eclipse, and contains a 'stfclasspath.xml' file. STF throws an exception if a project has both '.classpath' and 'stfclasspath.xml' files.\n\nProjects using Java 9 modularity may be building to a bin directory which contains 2 different classpath hierarchies. Files such as '.../bin/net/adoptopenjdk/x.class' are built in the traditional way with, in this case, a package of net.adoptopenjdk containing class 'x'. In java 9 the bin directory may also contain modular output, with say '.../bin/common-mods/com.hello/net/adoptopenjdk/y.class' being a compiled class for 'y.java' from the package in 'net.adoptopenjdk' in the 'com.hello' module. Note the extra level of directory called 'common-mods', which is used to structure\nthe compiled modules but is neither part of the module or class hierarchy.\n\nWhen such a structure is created through Ant scripts then the structure has to be described to STF. Multiple bin directories can be specified in stfclasspath.xml with\nthe 'j9output' kind. For example the following stfclasspath.xml could be created by copying a valid .classpath file and adding some j9output entries:\n\n``` xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;classpath&gt;\n\t&lt;classpathentry kind=\"src\" path=\"src/openjdk.test.modularity\"/&gt;\n\t&lt;classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"/&gt;\n\t&lt;classpathentry exported=\"true\" kind=\"lib\" path=\"/systemtest_prereqs/junit/junit.jar\"/&gt;\n\t&lt;classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"/stf.core\"/&gt;\n\t&lt;classpathentry kind=\"output\" path=\"bin\"/&gt;\n\t&lt;classpathentry kind=\"j9output\" path=\"bin/common-mods/displayService\"/&gt;\n\t&lt;classpathentry kind=\"j9output\" path=\"bin/common-mods/com.helper\"/&gt;\n\t&lt;classpathentry kind=\"j9output\" path=\"bin/tests\"/&gt;\n&lt;/classpath&gt;\n```\n\n",
        "start_line": 558,
        "end_line": 627,
        "chunk_index": 8,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 998,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687378"
      },
      "text": "``` java\nStfProcess keytool = test.doRunBackgroundProcess(\"Run keytool\", \"KEY\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"10s\"),\ntest.doRunForegroundProcess(\"Run keytool\", \"KEY\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"10s\"),\n    test.createJDKToolProcessDefinition()\n        .setJDKToolOrUtility(\"keytool\")\n        .addArg(\"-genkeypair\")\n        .addArg(\"-dname\")\n        .addArg(\"\\\"cn=John Example, ou=Java, o=IBM, c=UK\\\"\")\n        .addArg(\"-alias\")\n        .addArg(\"business\")\n        .addArg(\"-keypass\")\n        .addArg(\"secret-password\")\n        .addArg(\"-keystore\")\n        .addArg(test.env().getTmpDir().childFile(\"mykeystore\").getSpec())\n        .addArg(\"-storepass\")\n        .addArg(\"new-keystore-pw\")\n        .addArg(\"-validity\")\n        .addArg(\"180\"))\n```\n\n<a name=\"6\"></a>\n## Test Development\n\n- Non synchronous processes\n- Test specific arguments\n- Expected test failures\n- Custom extensions\n\n- Running from local build\n\n<a name=\"7\"></a>\n## Advanced and Unusual cases\n\n<a name=\"7.1\"></a>\n### Classpath management for non-Eclipse projects\n\nWhen running automation code from the Eclipse workspace STF uses the contents of the projects .classpath file to determine the projects dependencies. STF is also able to use .classpath file when running an automation plugin from output of the build process.\n\nThere are some occasions in which the automation code is not being compiled by Eclipse, and there is therefore no need to have a valid .classpath file. The most typical case would be when a project needs to use a newer Java version than that supported by Eclipse.\n\n<a name=\"7.1.1\"></a>\n#### stfclasspath.xml file\n\nThe solution to this problem is for the project to have a top level 'stfclasspath.xml' file instead of the usual '.classpath' file. This 'stfclasspath.xml' file is in the\nsame format as a standard '.classpath' file, and references the projects dependent projects and/or jar files. STF will use this file when there is no '.classpath' file.\n\nThis situation effectively means that a workspace contains 2 different types of projects. Firstly, most projects are hopefully a standard java project which has a\n'.classpath' file, or secondly, a 'general' project which is not compiled by Eclipse, and contains a 'stfclasspath.xml' file. STF throws an exception if a project has both '.classpath' and 'stfclasspath.xml' files.\n\nProjects using Java 9 modularity may be building to a bin directory which contains 2 different classpath hierarchies. Files such as '.../bin/net/adoptopenjdk/x.class' are built in the traditional way with, in this case, a package of net.adoptopenjdk containing class 'x'. In java 9 the bin directory may also contain modular output, with say '.../bin/common-mods/com.hello/net/adoptopenjdk/y.class' being a compiled class for 'y.java' from the package in 'net.adoptopenjdk' in the 'com.hello' module. Note the extra level of directory called 'common-mods', which is used to structure\nthe compiled modules but is neither part of the module or class hierarchy.\n\nWhen such a structure is created through Ant scripts then the structure has to be described to STF. Multiple bin directories can be specified in stfclasspath.xml with\nthe 'j9output' kind. For example the following stfclasspath.xml could be created by copying a valid .classpath file and adding some j9output entries:\n\n``` xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;classpath&gt;\n\t&lt;classpathentry kind=\"src\" path=\"src/openjdk.test.modularity\"/&gt;\n\t&lt;classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"/&gt;\n\t&lt;classpathentry exported=\"true\" kind=\"lib\" path=\"/systemtest_prereqs/junit/junit.jar\"/&gt;\n\t&lt;classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"/stf.core\"/&gt;\n\t&lt;classpathentry kind=\"output\" path=\"bin\"/&gt;\n\t&lt;classpathentry kind=\"j9output\" path=\"bin/common-mods/displayService\"/&gt;\n\t&lt;classpathentry kind=\"j9output\" path=\"bin/common-mods/com.helper\"/&gt;\n\t&lt;classpathentry kind=\"j9output\" path=\"bin/tests\"/&gt;\n&lt;/classpath&gt;\n```\n\n"
    },
    "49": {
      "metadata": {
        "chunk_id": "321d0f1c111559486d58fa5ddc2f72736c646445a1181d447a5427e7abb000bc",
        "file_path": "stf.core/docs/STF-Manual.md",
        "content": "So the suggested route for projects which require a newer version JVM level than the current level supported by Eclipse is:\n- Project starts as a 'general' project. This would be compiled through the build process with build.xml files, and use a 'stfclasspath.xml' file to allow the STF execution of automation plugins from the build output.\n- At some point in the future, when Eclipse has caught up, the project   can be converted to a Java project and the .classpath and .project files can be deleted. STF execution is then from either the Eclipse workspace or the build output.\n\nThis route has the advantage that the Eclipse workspace as always clean, allowing compile errors in other to be noticed, and also allowing STF execution of other projects directly from the Eclipse workspace.\n\nProjects will need to determine their own migration strategies for more complex situations. For example, perhaps some new tests should really be added to pre-existing project X but because of Eclipse JVM versioning problems would be added to general project Y, before eventually being moved to into their final location\nin project X.\n\n<a name=\"7.2\"></a>\n### Context based output file names\n\nSome tests will want to run a process which produces output files whose names need to be based on some runtime property of the execution. For example, a test may create the profile to run a Java process which is used multiple times in the test. If the executed process needs to create an output file, then the name of the file cannot be fixed, otherwise the second execution will overwrite the output of the first execution.\n\n<p>The dynamic creation of values for cases such as creating output file names is handled by using three magic value strings:\n- StfConstants.PLACEHOLDER_STF_COMMAND_NUMBER - This is replaced with the step number. Eg 1, 2, 3, etc\n- StfConstants.PLACEHOLDER_STF_COMMAND_MNEMONIC - The placeholder is replaced with the mnemonic of the command. Eg, SCL or XYZ, etc.\n- StfConstants.PLACEHOLDER_STF_PROCESS_INSTANCE - When running multiple concurrent processes this value is replaced with the instance number (1,2,3,etc). If used in a single instance process the placeholder is replaced with an empty string.\n\n\n\n",
        "start_line": 628,
        "end_line": 649,
        "chunk_index": 9,
        "total_chunks": 10,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 455,
        "node_type": null,
        "file_sha": "1ea8902ada3c1bda12bf4ff7656b1efd660db5d5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.687382"
      },
      "text": "So the suggested route for projects which require a newer version JVM level than the current level supported by Eclipse is:\n- Project starts as a 'general' project. This would be compiled through the build process with build.xml files, and use a 'stfclasspath.xml' file to allow the STF execution of automation plugins from the build output.\n- At some point in the future, when Eclipse has caught up, the project   can be converted to a Java project and the .classpath and .project files can be deleted. STF execution is then from either the Eclipse workspace or the build output.\n\nThis route has the advantage that the Eclipse workspace as always clean, allowing compile errors in other to be noticed, and also allowing STF execution of other projects directly from the Eclipse workspace.\n\nProjects will need to determine their own migration strategies for more complex situations. For example, perhaps some new tests should really be added to pre-existing project X but because of Eclipse JVM versioning problems would be added to general project Y, before eventually being moved to into their final location\nin project X.\n\n<a name=\"7.2\"></a>\n### Context based output file names\n\nSome tests will want to run a process which produces output files whose names need to be based on some runtime property of the execution. For example, a test may create the profile to run a Java process which is used multiple times in the test. If the executed process needs to create an output file, then the name of the file cannot be fixed, otherwise the second execution will overwrite the output of the first execution.\n\n<p>The dynamic creation of values for cases such as creating output file names is handled by using three magic value strings:\n- StfConstants.PLACEHOLDER_STF_COMMAND_NUMBER - This is replaced with the step number. Eg 1, 2, 3, etc\n- StfConstants.PLACEHOLDER_STF_COMMAND_MNEMONIC - The placeholder is replaced with the mnemonic of the command. Eg, SCL or XYZ, etc.\n- StfConstants.PLACEHOLDER_STF_PROCESS_INSTANCE - When running multiple concurrent processes this value is replaced with the instance number (1,2,3,etc). If used in a single instance process the placeholder is replaced with an empty string.\n\n\n\n"
    },
    "50": {
      "metadata": {
        "chunk_id": "6b7189bfafbb5abd048083b79c5097adfab030e3d2575261ab098ec184bac6d6",
        "file_path": "stf.core/scripts/formatExecutionLog.pl",
        "content": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# Script: formatExcecutionLog.pl\n# Support script to run the formatExecutionLog program.\n#\n\nuse strict;\nuse FindBin qw($Bin);\nuse lib \"$Bin/..\";\nuse Cwd qw(abs_path);\n\nmy $stf_root = abs_path(\"$Bin/../..\");\n\n# Bare command for running FormatExecutionLog class\nmy $cmd = $ENV{'JAVA_HOME'} . \"/bin/java\" .\n        \" -classpath $stf_root/stf.load/bin\" .\n        \" net.adoptopenjdk.loadTestAnalysis.FormatExecutionLog\";\n\n# Add all arguments as supplied to this script\nforeach my $argnum (0 .. $#ARGV) {\n    $cmd = $cmd . \" \" . $ARGV[$argnum];\n}\n\n# Run FormatExecutionLog\nsystem($cmd);",
        "start_line": 0,
        "end_line": 37,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 287,
        "node_type": null,
        "file_sha": "ab297f5338a6a49c8923bd9302f9cb48b9713294",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.692729"
      },
      "text": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# Script: formatExcecutionLog.pl\n# Support script to run the formatExecutionLog program.\n#\n\nuse strict;\nuse FindBin qw($Bin);\nuse lib \"$Bin/..\";\nuse Cwd qw(abs_path);\n\nmy $stf_root = abs_path(\"$Bin/../..\");\n\n# Bare command for running FormatExecutionLog class\nmy $cmd = $ENV{'JAVA_HOME'} . \"/bin/java\" .\n        \" -classpath $stf_root/stf.load/bin\" .\n        \" net.adoptopenjdk.loadTestAnalysis.FormatExecutionLog\";\n\n# Add all arguments as supplied to this script\nforeach my $argnum (0 .. $#ARGV) {\n    $cmd = $cmd . \" \" . $ARGV[$argnum];\n}\n\n# Run FormatExecutionLog\nsystem($cmd);"
    },
    "51": {
      "metadata": {
        "chunk_id": "667080549c40000658a76daef30891ae27f6c69e6a5262f6c503f904f2a90638",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# Script: stf.pl\n# Automation script for the System Test Framework.\n#\n#\n\n# import modules\nuse strict;\nuse FindBin qw($Bin);\nuse lib \"$Bin\";\n\n# standard perl modules\nuse File::Path qw(mkpath rmtree);\nuse File::Basename;\n\nuse stf::stfUtility;\nuse stf::Constants qw(:all);\nuse stf::Commands qw(:all);\nuse stfArguments;\n\nuse Cwd 'abs_path';\n\n# This constant controls the number of old results directories that are retained\nmy $results_retention_number = 10;\n# STF fails if the number of results directories exceeds this value\nmy $results_retention_limit = 20;\n\n\noutput_banner(\"STF\");\n\n$ENV{'loggingLevel'} = \"WARN\";\n\n# Set a platform specific default value for a temp directory.\n# This value is used for results-root, unless an alternative directory is specified on the command line. \n$ENV{'STF_TEMP'} = '/tmp/stf';\nif ( $^O eq 'MSWin32' ) {\n\t$ENV{'STF_TEMP'} = 'C:\\stf_temp';\n}\n\n# Locate the users optional STF property file\nmy $home_dir = stfArguments::get_home_dir();\nmy $stf_personal_properties = $home_dir . \"/.stf.properties\";\nif (!-e $stf_personal_properties) {\n    $stf_personal_properties = \"\";\n}\n\n# Locate the properties for this customisation of STF\n# Note: directory name is passed into abs_path to workaround old perl bug.\nmy $stf_defaults = abs_path($Bin . \"/../config\") . \"/stf.properties\";\n\n# Tell STF argument handling about the property files\nstfArguments::set_argument_data($stf_personal_properties, $stf_defaults);\n\n# Get the value for -systemtest-prereqs which may have been overridden on the command line, and validate it.\nmy $prereqs_root = stfArguments::get_argument(\"systemtest-prereqs\");\n# The existence of this directory inside one (or more) of the prereq roots proves their validity.\nmy $prereqs_root_validator = \"/junit\";\n\n# Here we ensure the systemtest-prereqs environment variable is equal to the command line option.\n# This way any test code can use whichever is the most convenient.\n# If systemtest-prereqs is not specified, we find the systemtest_prereqs folder by stepping up stf.pl's path.\n#\n# E.g. If stf.pl is in /tmp/git/stf/stf.core/scripts, then we evaluate these (in order) as potential prereqs directories:\n# /tmp/git/stf/stf.core/scripts/<dir>\n# /tmp/git/stf/stf.core/<dir>\n# /tmp/git/stf/<dir>\n# /tmp/git/<dir>\n# /tmp/<dir>\n# or \n# /<dir>\n#\n# Where <dir> is either systemtest_prereqs or prereq/(ascii|ebcdic)/systemtest_prereqs. The latter allows us to store both the \n# ascii and ebcdic versions of our systemtest_prereqs under a single parent folder, selecting one or the other at runtime.\n#\n# If that fails, we default to [home directory]/systemtest_prereqs.",
        "start_line": 0,
        "end_line": 88,
        "chunk_index": 0,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 816,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697468"
      },
      "text": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# Script: stf.pl\n# Automation script for the System Test Framework.\n#\n#\n\n# import modules\nuse strict;\nuse FindBin qw($Bin);\nuse lib \"$Bin\";\n\n# standard perl modules\nuse File::Path qw(mkpath rmtree);\nuse File::Basename;\n\nuse stf::stfUtility;\nuse stf::Constants qw(:all);\nuse stf::Commands qw(:all);\nuse stfArguments;\n\nuse Cwd 'abs_path';\n\n# This constant controls the number of old results directories that are retained\nmy $results_retention_number = 10;\n# STF fails if the number of results directories exceeds this value\nmy $results_retention_limit = 20;\n\n\noutput_banner(\"STF\");\n\n$ENV{'loggingLevel'} = \"WARN\";\n\n# Set a platform specific default value for a temp directory.\n# This value is used for results-root, unless an alternative directory is specified on the command line. \n$ENV{'STF_TEMP'} = '/tmp/stf';\nif ( $^O eq 'MSWin32' ) {\n\t$ENV{'STF_TEMP'} = 'C:\\stf_temp';\n}\n\n# Locate the users optional STF property file\nmy $home_dir = stfArguments::get_home_dir();\nmy $stf_personal_properties = $home_dir . \"/.stf.properties\";\nif (!-e $stf_personal_properties) {\n    $stf_personal_properties = \"\";\n}\n\n# Locate the properties for this customisation of STF\n# Note: directory name is passed into abs_path to workaround old perl bug.\nmy $stf_defaults = abs_path($Bin . \"/../config\") . \"/stf.properties\";\n\n# Tell STF argument handling about the property files\nstfArguments::set_argument_data($stf_personal_properties, $stf_defaults);\n\n# Get the value for -systemtest-prereqs which may have been overridden on the command line, and validate it.\nmy $prereqs_root = stfArguments::get_argument(\"systemtest-prereqs\");\n# The existence of this directory inside one (or more) of the prereq roots proves their validity.\nmy $prereqs_root_validator = \"/junit\";\n\n# Here we ensure the systemtest-prereqs environment variable is equal to the command line option.\n# This way any test code can use whichever is the most convenient.\n# If systemtest-prereqs is not specified, we find the systemtest_prereqs folder by stepping up stf.pl's path.\n#\n# E.g. If stf.pl is in /tmp/git/stf/stf.core/scripts, then we evaluate these (in order) as potential prereqs directories:\n# /tmp/git/stf/stf.core/scripts/<dir>\n# /tmp/git/stf/stf.core/<dir>\n# /tmp/git/stf/<dir>\n# /tmp/git/<dir>\n# /tmp/<dir>\n# or \n# /<dir>\n#\n# Where <dir> is either systemtest_prereqs or prereq/(ascii|ebcdic)/systemtest_prereqs. The latter allows us to store both the \n# ascii and ebcdic versions of our systemtest_prereqs under a single parent folder, selecting one or the other at runtime.\n#\n# If that fails, we default to [home directory]/systemtest_prereqs."
    },
    "52": {
      "metadata": {
        "chunk_id": "f2ea9a9a97e3756151e07e0a4bb59690c644063bb61f885327baee4e438f7944",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "if($prereqs_root eq \"null\") {\n\tif (defined $ENV{'SYSTEMTEST_PREREQS_ROOT'}) {\n\t\t#If we have an environment variable, use that.\n\t\t$prereqs_root = $ENV{'SYSTEMTEST_PREREQS_ROOT'};\n\t} else {\n\t\t# If systemtest-prereqs was not supplied at all, we search for it up the path.\n\t\tmy $prereqs_search = Cwd::abs_path($0);\n\t\tmy $search_finished = \"no\";\n\t\tmy $asciiOrEbcdic = \"ascii\";\n\t\tif (stf::stfUtility::getPlatform() eq \"zos\") {\n\t\t\t$asciiOrEbcdic = \"ebcdic\";\n\t\t}\n\t\tprint \"systemtest-prereqs not specified. Attempting to locate along the current working directory path.\\n\";\n\t\twhile (!($search_finished eq \"yes\")) {\n\t\t\tif (-d \"$prereqs_search/systemtest_prereqs$prereqs_root_validator\") {\n\t\t\t\t$prereqs_root = $prereqs_search . \"/systemtest_prereqs\";\n\t\t\t\t$search_finished = \"yes\";\n\t\t\t} elsif(-d ($prereqs_search . \"/prereqs/$asciiOrEbcdic/systemtest_prereqs$prereqs_root_validator\")) {\n\t\t\t\t$prereqs_root = $prereqs_search . \"/prereqs/$asciiOrEbcdic/systemtest_prereqs\";\n\t\t\t\t$search_finished = \"yes\";\n\t\t\t} elsif(($prereqs_search =~ /^[A-Za-z]\\:\\\\*$/) or ($prereqs_search =~ /^\\/*$/)) {\n\t\t\t\tprint \"Unable to find systemtest-prereqs along the current working directory path.\\n\";\n\t\t\t\t$prereqs_root = stfArguments::get_home_dir() . \"/systemtest_prereqs\";\n\t\t\t\tprint \"Defaulting to [home_directory]/systemtest_prereqs: \" . $prereqs_root . \"\\n\";\n\t\t\t\t$search_finished = \"yes\";\n\t\t\t} else {\n\t\t\t\t# Go up a step and try again.\n\t\t\t\tmy @prereqs_search_array = File::Spec->splitdir($prereqs_search);\n\t\t\t\tpop @prereqs_search_array;\n\t\t\t\t$prereqs_search = File::Spec->catdir(@prereqs_search_array);\n\t\t\t}\n\t\t}\n\t\tif (!($prereqs_root eq (stfArguments::get_home_dir() . \"/systemtest_prereqs\"))) {\n\t\t\tprint \"systemtest-prereqs was found here: \" . $prereqs_root . \"\\n\";\n\t\t}\n\t\t$ENV{'SYSTEMTEST_PREREQS_ROOT'} = $prereqs_root;\n\t}\n}\n\n#Now we validate each of the systemtest-prereqs we have, and make their directories absolute in case we change directory.\nmy $updated_systemtest_prereqs = make_paths_absolute(\"systemtest-prereqs\",$prereqs_root,$prereqs_root_validator);\n\nprint \"systemtest-prereqs has been processed, and set to: \" . $updated_systemtest_prereqs;\n\nmy $test_name = stfArguments::get_argument(\"test\");\nmy $help_arg = stfArguments::get_argument(\"help\");\nmy $test_list_arg = stfArguments::get_argument(\"list\");\n\n# If help has been requested, but there is not enough information to run up STF java\n# code, then explain that some minimal arguments need to be set.\nif (stfArguments::get_argument(\"help\") ne 'false') {\n    if ($test_name eq 'null') {\n        print \"To get STF help please run again with a '-test' argument.\\n\";\n        print \"This will allow STF to produce help on the extensions used by that test case.\\n\";\n        print \"Extra options specific to this perl script.\\n\";\n        print \"   -retain=nnn        Set the number of output directories to keep.\\n\";\n        print \"   -retain-limit=nnn  Set the maximum number of failed output\\n\";\n        print \"                      directories before a failure condition is declared\\n\";\n        exit 0;\n    }\n}\n\n# Make sure that a test name has been specified\nif ($test_name eq 'null' && $test_list_arg eq 'false') {\n    print \"** ERROR **  No test name specified. \\(Use '-test' argument. eg, '-test=xyz', or '-list' to find all tests\\)\\n\";\n    exit 0;\n}   \nif ($test_list_arg ne 'false') {\n    # STF has been run with something like 'stf -list', so force the name of the test to 'list'\n    $test_name = \"list\";\n}\n\n\n# Create a timestamp for the results directories for this run\n(my $sec,my $min,my $hour,my $mday,my $mon,my $year,my $wday, my $yday, my $isdst) = localtime();\nmy $timestamp = sprintf '%04d%02d%02d-%02d%02d%02d', $year+1900, $mon+1, $mday, $hour, $min, $sec;",
        "start_line": 89,
        "end_line": 164,
        "chunk_index": 1,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 1094,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697474"
      },
      "text": "if($prereqs_root eq \"null\") {\n\tif (defined $ENV{'SYSTEMTEST_PREREQS_ROOT'}) {\n\t\t#If we have an environment variable, use that.\n\t\t$prereqs_root = $ENV{'SYSTEMTEST_PREREQS_ROOT'};\n\t} else {\n\t\t# If systemtest-prereqs was not supplied at all, we search for it up the path.\n\t\tmy $prereqs_search = Cwd::abs_path($0);\n\t\tmy $search_finished = \"no\";\n\t\tmy $asciiOrEbcdic = \"ascii\";\n\t\tif (stf::stfUtility::getPlatform() eq \"zos\") {\n\t\t\t$asciiOrEbcdic = \"ebcdic\";\n\t\t}\n\t\tprint \"systemtest-prereqs not specified. Attempting to locate along the current working directory path.\\n\";\n\t\twhile (!($search_finished eq \"yes\")) {\n\t\t\tif (-d \"$prereqs_search/systemtest_prereqs$prereqs_root_validator\") {\n\t\t\t\t$prereqs_root = $prereqs_search . \"/systemtest_prereqs\";\n\t\t\t\t$search_finished = \"yes\";\n\t\t\t} elsif(-d ($prereqs_search . \"/prereqs/$asciiOrEbcdic/systemtest_prereqs$prereqs_root_validator\")) {\n\t\t\t\t$prereqs_root = $prereqs_search . \"/prereqs/$asciiOrEbcdic/systemtest_prereqs\";\n\t\t\t\t$search_finished = \"yes\";\n\t\t\t} elsif(($prereqs_search =~ /^[A-Za-z]\\:\\\\*$/) or ($prereqs_search =~ /^\\/*$/)) {\n\t\t\t\tprint \"Unable to find systemtest-prereqs along the current working directory path.\\n\";\n\t\t\t\t$prereqs_root = stfArguments::get_home_dir() . \"/systemtest_prereqs\";\n\t\t\t\tprint \"Defaulting to [home_directory]/systemtest_prereqs: \" . $prereqs_root . \"\\n\";\n\t\t\t\t$search_finished = \"yes\";\n\t\t\t} else {\n\t\t\t\t# Go up a step and try again.\n\t\t\t\tmy @prereqs_search_array = File::Spec->splitdir($prereqs_search);\n\t\t\t\tpop @prereqs_search_array;\n\t\t\t\t$prereqs_search = File::Spec->catdir(@prereqs_search_array);\n\t\t\t}\n\t\t}\n\t\tif (!($prereqs_root eq (stfArguments::get_home_dir() . \"/systemtest_prereqs\"))) {\n\t\t\tprint \"systemtest-prereqs was found here: \" . $prereqs_root . \"\\n\";\n\t\t}\n\t\t$ENV{'SYSTEMTEST_PREREQS_ROOT'} = $prereqs_root;\n\t}\n}\n\n#Now we validate each of the systemtest-prereqs we have, and make their directories absolute in case we change directory.\nmy $updated_systemtest_prereqs = make_paths_absolute(\"systemtest-prereqs\",$prereqs_root,$prereqs_root_validator);\n\nprint \"systemtest-prereqs has been processed, and set to: \" . $updated_systemtest_prereqs;\n\nmy $test_name = stfArguments::get_argument(\"test\");\nmy $help_arg = stfArguments::get_argument(\"help\");\nmy $test_list_arg = stfArguments::get_argument(\"list\");\n\n# If help has been requested, but there is not enough information to run up STF java\n# code, then explain that some minimal arguments need to be set.\nif (stfArguments::get_argument(\"help\") ne 'false') {\n    if ($test_name eq 'null') {\n        print \"To get STF help please run again with a '-test' argument.\\n\";\n        print \"This will allow STF to produce help on the extensions used by that test case.\\n\";\n        print \"Extra options specific to this perl script.\\n\";\n        print \"   -retain=nnn        Set the number of output directories to keep.\\n\";\n        print \"   -retain-limit=nnn  Set the maximum number of failed output\\n\";\n        print \"                      directories before a failure condition is declared\\n\";\n        exit 0;\n    }\n}\n\n# Make sure that a test name has been specified\nif ($test_name eq 'null' && $test_list_arg eq 'false') {\n    print \"** ERROR **  No test name specified. \\(Use '-test' argument. eg, '-test=xyz', or '-list' to find all tests\\)\\n\";\n    exit 0;\n}   \nif ($test_list_arg ne 'false') {\n    # STF has been run with something like 'stf -list', so force the name of the test to 'list'\n    $test_name = \"list\";\n}\n\n\n# Create a timestamp for the results directories for this run\n(my $sec,my $min,my $hour,my $mday,my $mon,my $year,my $wday, my $yday, my $isdst) = localtime();\nmy $timestamp = sprintf '%04d%02d%02d-%02d%02d%02d', $year+1900, $mon+1, $mday, $hour, $min, $sec;"
    },
    "53": {
      "metadata": {
        "chunk_id": "a6b516a0535978bfb6d2074acb24116c7915e5ed64e92476d26d0ce26d147b61",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "# Make sure that a test name has been specified\nif ($test_name eq 'null' && $test_list_arg eq 'false') {\n    print \"** ERROR **  No test name specified. \\(Use '-test' argument. eg, '-test=xyz', or '-list' to find all tests\\)\\n\";\n    exit 0;\n}   \nif ($test_list_arg ne 'false') {\n    # STF has been run with something like 'stf -list', so force the name of the test to 'list'\n    $test_name = \"list\";\n}\n\n\n# Create a timestamp for the results directories for this run\n(my $sec,my $min,my $hour,my $mday,my $mon,my $year,my $wday, my $yday, my $isdst) = localtime();\nmy $timestamp = sprintf '%04d%02d%02d-%02d%02d%02d', $year+1900, $mon+1, $mday, $hour, $min, $sec;\n\n# Work out where the working, temp and results directories are going\nmy $results_root  = stfArguments::get_and_check_argument(\"results-root\");\nmy $retain_number = stfArguments::get_and_check_argument(\"retain\");\nmy $retain_limit  = stfArguments::get_and_check_argument(\"retain-limit\");\nmy $test_dir = $results_root . \"/$timestamp-$test_name\";\nmy $debug_dir   = $test_dir . \"/debug\";\nmy $results_dir = $test_dir . \"/results\";\nmy $generation_dir = $test_dir . \"/generation\";\nmy $setup_dir      = $test_dir . \"/setUp\";\nmy $execute_dir    = $test_dir . \"/execute\";\nmy $teardown_dir   = $test_dir . \"/tearDown\";\nmy $delete_results_root = $FALSE;\n\nmy @results_dirs;\n\nif ( length $retain_limit ) {\n   $results_retention_limit = $retain_limit;\n}\n\nif ( length $retain_number ) {\n   $results_retention_number = $retain_number;\n   # Increase results_retention_limit in line, otherwise failures are likely\n   # User can override this with the retain-limit option if the wish to\n   if ( $results_retention_number > $results_retention_limit ) {\n      print \"WARNING: Overriding retain-limit to retain + 1\\n\";\n      $results_retention_limit = $results_retention_number+1;\n   }\n}\n\n# We are only going to remove results_root if it passes some basic checks.\n# So check its structure to verify it contains STF artifacts.\nif (-e $results_root) {\n\tmy @files = <'$results_root/*'>;\n\tmy $count = @files;\n    if ($count == 0) { \n        # No child directories yet, so structure is good\n        $delete_results_root = $TRUE;\n    } else {\n        # Found one or more child files/directories.\n        # Check that they are all STF directories.\n        foreach my $suspect_file (@files) {\n\t        if (-d $suspect_file) {\n\t\t    \t# Check contents of old results directory, if it is not empty\n\t\t    \tmy @subfiles = <'$suspect_file/*'>;\n\t\t\t\tmy $subfiles_count = @subfiles; \n\t\t\t\tif ($subfiles_count == 0) {\n\t\t\t\t    print \"Warning: Found empty results directory: $suspect_file\\n\";\n\t\t\t\t\t$delete_results_root = $TRUE;\n\t\t\t\t} else {\n\t\t\t        # Check the structure of the old test directory, to see if it contains expected STF files \n\t\t\t        my $setup_dir    = $suspect_file . \"/setUp\";\n\t\t\t        my $execute_dir  = $suspect_file . \"/execute\";\n\t\t\t        my $teardown_dir = $suspect_file . \"/tearDown\";\n\t\t\t        if (-d $setup_dir && -d $execute_dir && -d $teardown_dir) {\n\t\t\t            $delete_results_root = $TRUE;\n\t\t\t        } else {\n\t\t\t\t\t\tprint \"**FAILED** results directory '$suspect_file' does not contain expected setUp, execute and tearDown directories\\n\";\n\t\t\t\t\t\t$delete_results_root = $FALSE;\n\t\t\t\t\t\tlast;\n\t\t\t        }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t# Keep track of all result directories (allows deletion of oldest)\n\t\t\t\tif (! -l $suspect_file) {\n\t\t\t\t\tpush @results_dirs, $suspect_file;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint \"**FAILED** unexpected file found at '$suspect_file'. Results-root at '$results_root' is not a STF results directory\\n\";\n\t\t\t\t$delete_results_root = $FALSE;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n    }\n} else { # results-root does not exist\n    $delete_results_root = $TRUE;\n}",
        "start_line": 165,
        "end_line": 255,
        "chunk_index": 2,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 993,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697477"
      },
      "text": "# Make sure that a test name has been specified\nif ($test_name eq 'null' && $test_list_arg eq 'false') {\n    print \"** ERROR **  No test name specified. \\(Use '-test' argument. eg, '-test=xyz', or '-list' to find all tests\\)\\n\";\n    exit 0;\n}   \nif ($test_list_arg ne 'false') {\n    # STF has been run with something like 'stf -list', so force the name of the test to 'list'\n    $test_name = \"list\";\n}\n\n\n# Create a timestamp for the results directories for this run\n(my $sec,my $min,my $hour,my $mday,my $mon,my $year,my $wday, my $yday, my $isdst) = localtime();\nmy $timestamp = sprintf '%04d%02d%02d-%02d%02d%02d', $year+1900, $mon+1, $mday, $hour, $min, $sec;\n\n# Work out where the working, temp and results directories are going\nmy $results_root  = stfArguments::get_and_check_argument(\"results-root\");\nmy $retain_number = stfArguments::get_and_check_argument(\"retain\");\nmy $retain_limit  = stfArguments::get_and_check_argument(\"retain-limit\");\nmy $test_dir = $results_root . \"/$timestamp-$test_name\";\nmy $debug_dir   = $test_dir . \"/debug\";\nmy $results_dir = $test_dir . \"/results\";\nmy $generation_dir = $test_dir . \"/generation\";\nmy $setup_dir      = $test_dir . \"/setUp\";\nmy $execute_dir    = $test_dir . \"/execute\";\nmy $teardown_dir   = $test_dir . \"/tearDown\";\nmy $delete_results_root = $FALSE;\n\nmy @results_dirs;\n\nif ( length $retain_limit ) {\n   $results_retention_limit = $retain_limit;\n}\n\nif ( length $retain_number ) {\n   $results_retention_number = $retain_number;\n   # Increase results_retention_limit in line, otherwise failures are likely\n   # User can override this with the retain-limit option if the wish to\n   if ( $results_retention_number > $results_retention_limit ) {\n      print \"WARNING: Overriding retain-limit to retain + 1\\n\";\n      $results_retention_limit = $results_retention_number+1;\n   }\n}\n\n# We are only going to remove results_root if it passes some basic checks.\n# So check its structure to verify it contains STF artifacts.\nif (-e $results_root) {\n\tmy @files = <'$results_root/*'>;\n\tmy $count = @files;\n    if ($count == 0) { \n        # No child directories yet, so structure is good\n        $delete_results_root = $TRUE;\n    } else {\n        # Found one or more child files/directories.\n        # Check that they are all STF directories.\n        foreach my $suspect_file (@files) {\n\t        if (-d $suspect_file) {\n\t\t    \t# Check contents of old results directory, if it is not empty\n\t\t    \tmy @subfiles = <'$suspect_file/*'>;\n\t\t\t\tmy $subfiles_count = @subfiles; \n\t\t\t\tif ($subfiles_count == 0) {\n\t\t\t\t    print \"Warning: Found empty results directory: $suspect_file\\n\";\n\t\t\t\t\t$delete_results_root = $TRUE;\n\t\t\t\t} else {\n\t\t\t        # Check the structure of the old test directory, to see if it contains expected STF files \n\t\t\t        my $setup_dir    = $suspect_file . \"/setUp\";\n\t\t\t        my $execute_dir  = $suspect_file . \"/execute\";\n\t\t\t        my $teardown_dir = $suspect_file . \"/tearDown\";\n\t\t\t        if (-d $setup_dir && -d $execute_dir && -d $teardown_dir) {\n\t\t\t            $delete_results_root = $TRUE;\n\t\t\t        } else {\n\t\t\t\t\t\tprint \"**FAILED** results directory '$suspect_file' does not contain expected setUp, execute and tearDown directories\\n\";\n\t\t\t\t\t\t$delete_results_root = $FALSE;\n\t\t\t\t\t\tlast;\n\t\t\t        }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t# Keep track of all result directories (allows deletion of oldest)\n\t\t\t\tif (! -l $suspect_file) {\n\t\t\t\t\tpush @results_dirs, $suspect_file;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint \"**FAILED** unexpected file found at '$suspect_file'. Results-root at '$results_root' is not a STF results directory\\n\";\n\t\t\t\t$delete_results_root = $FALSE;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n    }\n} else { # results-root does not exist\n    $delete_results_root = $TRUE;\n}"
    },
    "54": {
      "metadata": {
        "chunk_id": "f01c724e9a9193dc7d8148b31bca45216d7a8fc414f080d94d9bcaef4421e1da",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "# Abort the run if it is not safe to delete the results-root directory \nif ($delete_results_root == $FALSE) {\n    # List files in the alleged STF directory to allow debugging\n    print \"Files/Directories at results root:\\n\";\n    print \"  \" . describe_file($results_root) . \" \" . \"$results_root\\n\";\n\tmy @files = <'$results_root/*'>;\n    foreach my $file (@files) {\n        print \"    \" . describe_file($file) . \" \" . \"$file\\n\";\n        if (-d $file) {\n            my @child_files = <'$file/*'>;\n            foreach my $child_file (@child_files) {\n                print \"      \" . describe_file($child_file) . \" \" . \"$child_file\\n\";\n            }\n        }\n    }\n    \n\t# We don't want to trash a box just because of an incorrect argument, so abort the run\n    print \"Abort: Can't proceed as the results-root at '$results_root' does not appear to be a valid STF results directory\\n\"; \n    exit 1;\n}\n\n\n## Remove old STF results directories.\n## First move to the same directory as this script, just in case the current working \n## directory is inside the results tree (which would cause the rmtree to fail)\nmy $num_to_delete = $#results_dirs -$results_retention_number;\nif ($num_to_delete >= 0) {\n    my $current_script_path = Cwd::abs_path($0);\n    chdir dirname($current_script_path) or die \"Failed to chdir to the stf.pl script directory $current_script_path\\n\";\n    my @results_to_delete = @results_dirs[0..$num_to_delete];\n    foreach my $results_root (@results_to_delete) {\n        _log(\"Deleting old STF results: $results_root\");\n        # Some files may be longer than the Windows MAX_PATH value - e.g. the JCK run creates files\n        # longer than that in the results directory. rmtree cannot delete those files, so use rmtree\n        # instead.\n        deleteDirectory($results_root);\n    }\n}\n\n# Find out if the current machine supports symbolic links\nmy $symlink_supported = eval { symlink(\"\",\"\"); 1 };\n\n# Now remove any orphaned symbolic links\nif (defined $symlink_supported && $symlink_supported eq 1) {\n\tmy @results_dir_content = <'$results_root/*'>;\n    foreach my $file (@results_dir_content) {\n        # Check to see if the current file is a link which has no directory\n    \tif (-l $file && ! -d $file) {\n    \t    _log(\"Deleting orphan results link: $file\");\n    \t    unlink $file;\n    \t}\n    }\n}\n\n# To allow for easier running on a Windows machine we may have ignored the failure to delete\n# a results directory. \n# We can tolerate a having a few directories directories which are not deleteable, but once a \n# predefined limit is set we abort the test run.\n# Hopefully having this buffer zone, and giving Windows more time to free its handles, will\n# allow STF to keep running.  \nmy $num_result_dirs = 0;\nmy @files = <'$results_root/*'>;\nforeach my $file (@files) {\n    if (-d $file && ! -l $file) {\n        # Found a directory which is not a symbolic link.\n        # See if it contains a timestamp, eg /stf/20160706-092421-list\n        if ($file =~ /20[0-9]{6}-[0-9]{6}/) {\n        \t$num_result_dirs++;\n        }  \n    }\n}\nif ($num_result_dirs > $results_retention_limit) {\n    print \"**FAILED** Too many result directories. Limit is $num_result_dirs. Currently have $num_result_dirs directories at $results_root\\n\";\n    exit 2;\n}\n\n\n# Create directory structure for this run\nmkpath($debug_dir);\nmkpath($generation_dir);\nmkpath($setup_dir);\nmkpath($execute_dir);\nmkpath($teardown_dir);\nmkpath($results_dir);\n\n# On Unix type systems create a symbolic link to the results directory.\n# This allows terminals/editors to retain the same file name over multiple executions.\n# Firstly find out if enabled (not enabled by default)\nmy $createResultsSymLinks = stfArguments::get_argument(\"create-results-sym-links\");",
        "start_line": 256,
        "end_line": 344,
        "chunk_index": 3,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 928,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697479"
      },
      "text": "# Abort the run if it is not safe to delete the results-root directory \nif ($delete_results_root == $FALSE) {\n    # List files in the alleged STF directory to allow debugging\n    print \"Files/Directories at results root:\\n\";\n    print \"  \" . describe_file($results_root) . \" \" . \"$results_root\\n\";\n\tmy @files = <'$results_root/*'>;\n    foreach my $file (@files) {\n        print \"    \" . describe_file($file) . \" \" . \"$file\\n\";\n        if (-d $file) {\n            my @child_files = <'$file/*'>;\n            foreach my $child_file (@child_files) {\n                print \"      \" . describe_file($child_file) . \" \" . \"$child_file\\n\";\n            }\n        }\n    }\n    \n\t# We don't want to trash a box just because of an incorrect argument, so abort the run\n    print \"Abort: Can't proceed as the results-root at '$results_root' does not appear to be a valid STF results directory\\n\"; \n    exit 1;\n}\n\n\n## Remove old STF results directories.\n## First move to the same directory as this script, just in case the current working \n## directory is inside the results tree (which would cause the rmtree to fail)\nmy $num_to_delete = $#results_dirs -$results_retention_number;\nif ($num_to_delete >= 0) {\n    my $current_script_path = Cwd::abs_path($0);\n    chdir dirname($current_script_path) or die \"Failed to chdir to the stf.pl script directory $current_script_path\\n\";\n    my @results_to_delete = @results_dirs[0..$num_to_delete];\n    foreach my $results_root (@results_to_delete) {\n        _log(\"Deleting old STF results: $results_root\");\n        # Some files may be longer than the Windows MAX_PATH value - e.g. the JCK run creates files\n        # longer than that in the results directory. rmtree cannot delete those files, so use rmtree\n        # instead.\n        deleteDirectory($results_root);\n    }\n}\n\n# Find out if the current machine supports symbolic links\nmy $symlink_supported = eval { symlink(\"\",\"\"); 1 };\n\n# Now remove any orphaned symbolic links\nif (defined $symlink_supported && $symlink_supported eq 1) {\n\tmy @results_dir_content = <'$results_root/*'>;\n    foreach my $file (@results_dir_content) {\n        # Check to see if the current file is a link which has no directory\n    \tif (-l $file && ! -d $file) {\n    \t    _log(\"Deleting orphan results link: $file\");\n    \t    unlink $file;\n    \t}\n    }\n}\n\n# To allow for easier running on a Windows machine we may have ignored the failure to delete\n# a results directory. \n# We can tolerate a having a few directories directories which are not deleteable, but once a \n# predefined limit is set we abort the test run.\n# Hopefully having this buffer zone, and giving Windows more time to free its handles, will\n# allow STF to keep running.  \nmy $num_result_dirs = 0;\nmy @files = <'$results_root/*'>;\nforeach my $file (@files) {\n    if (-d $file && ! -l $file) {\n        # Found a directory which is not a symbolic link.\n        # See if it contains a timestamp, eg /stf/20160706-092421-list\n        if ($file =~ /20[0-9]{6}-[0-9]{6}/) {\n        \t$num_result_dirs++;\n        }  \n    }\n}\nif ($num_result_dirs > $results_retention_limit) {\n    print \"**FAILED** Too many result directories. Limit is $num_result_dirs. Currently have $num_result_dirs directories at $results_root\\n\";\n    exit 2;\n}\n\n\n# Create directory structure for this run\nmkpath($debug_dir);\nmkpath($generation_dir);\nmkpath($setup_dir);\nmkpath($execute_dir);\nmkpath($teardown_dir);\nmkpath($results_dir);\n\n# On Unix type systems create a symbolic link to the results directory.\n# This allows terminals/editors to retain the same file name over multiple executions.\n# Firstly find out if enabled (not enabled by default)\nmy $createResultsSymLinks = stfArguments::get_argument(\"create-results-sym-links\");"
    },
    "55": {
      "metadata": {
        "chunk_id": "5ca2c9f8dcd524a2fd45fcae064df24e87527a6cc392c531c7b4a67b42a9a072",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "# Create directory structure for this run\nmkpath($debug_dir);\nmkpath($generation_dir);\nmkpath($setup_dir);\nmkpath($execute_dir);\nmkpath($teardown_dir);\nmkpath($results_dir);\n\n# On Unix type systems create a symbolic link to the results directory.\n# This allows terminals/editors to retain the same file name over multiple executions.\n# Firstly find out if enabled (not enabled by default)\nmy $createResultsSymLinks = stfArguments::get_argument(\"create-results-sym-links\");\n\n# If symbolic links are supported and required then create the link\n# eg, /tmp/stf/UtilLoadTest -> /tmp/stf/20160704-115233-UtilLoadTest\nif (defined $symlink_supported && $symlink_supported eq 1 && $createResultsSymLinks ne 'false') {\n    my $new_link_name = $results_root . \"/$test_name\";\n    unlink $new_link_name; \n\tsymlink($test_dir, $new_link_name);\n}\n\n# On Windows, assign T: to the test directory.\n# Some tests (e.g. the JCK) have been known to create very long paths which can exceed the Win32 limit of 260 chars.\n# Using a substituted drive letter instead avoids the limit.\n#if ($^O eq 'MSWin32') {\n#    # subst might not work with forward slashes or escaped backslashes, so remove any that are there.\n#    $test_dir =~ s,/,\\\\,g;\n#    $test_dir =~ s,\\\\\\\\,\\\\,g;\n#    print \"Substituting test_dir $test_dir with T: to avoid long path lengths\\n\";\n\n#    my $cmd = \"subst T: /d\";\n#    print \"Running $cmd\\n\";\n#    my @subst_output = `$cmd 2>&1`;\n#    my $rc = $?;\n#    print \"$cmd returned: $rc\\n\";\n#    if ( $rc != 0 ) {\n#        foreach my $line ( @subst_output ) {\n#           print \"$line\";\n#        }\n#    }\n\n#    $cmd = \"subst T: $test_dir\";\n#    print \"Running $cmd\\n\";\n#    @subst_output = `$cmd 2>&1`;\n#    $rc = $?;\n#    print \"$cmd returned: $rc\\n\";\n#    if ( $rc != 0 ) {\n#        foreach my $line ( @subst_output ) {\n#           print \"$line\";\n#        }\n#    }\n#    $test_dir = \"T:/\";\n#}\n\n\n# Check whether we have enough space available. If not inform the user and fail the test, \n# unless we are on z/OS, where may be on a dynamic, growable file system, like ZFS.\nmy $mb_free = check_free_space ($results_root);\nif ( $mb_free < 3072 && stf::stfUtility::getPlatform() ne \"zos\") {\n\tprint \"\nTest machine has only $mb_free Mb free on drive containing $results_root.\\n\nThere must be at least 3Gb (3072Mb) free to be sure of capturing diagnostics\nfiles in the event of a test failure.\\n\nExiting.\\n\";\n\texit 1;\n}\n\n\n# $now used as a unique id\nmy ($now, $date, $time) = stf::stfUtility->getNow(date => $TRUE, time => $TRUE);\n\n\toutput_banner(\"GENERATION\");\n\n    # if any test root starts with '..' then resolve it now, before we change directory\n    my $test_root = stfArguments::get_argument(\"test-root\");\n\tmy $updated_test_root = make_paths_absolute(\"test-root\",$test_root,\"\");\n    \n    \n    # Abort run if any test root contains a space character.\n    # (This causes lots of class loading problems on windows)\n    if ($test_root =~ / /) {\n\t    _log(\"**FAILED** STF cannot use any test root with a space character in its path: $test_root\\n\");\n\t    exit 1;\n\t}\n    \n    \n    # Write the stf arguments to a properties file\n    my $stf_parameters = $test_dir . \"/stf_parameters.properties\";\n    stfArguments::write_arguments_to_file $stf_parameters, $Bin, $updated_test_root, $updated_systemtest_prereqs;\n\n\t# Move to the output directory\n\tchdir($generation_dir);\n\n    # Decide if java debug has been enabled\n\tmy $java_debug_settings = \"\";\n    if (stfArguments::get_boolean_argument(\"debug-generation\")) {\n        $java_debug_settings = stfArguments::get_argument(\"java-debug-args\");\n\t}",
        "start_line": 345,
        "end_line": 442,
        "chunk_index": 4,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 974,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697482"
      },
      "text": "# Create directory structure for this run\nmkpath($debug_dir);\nmkpath($generation_dir);\nmkpath($setup_dir);\nmkpath($execute_dir);\nmkpath($teardown_dir);\nmkpath($results_dir);\n\n# On Unix type systems create a symbolic link to the results directory.\n# This allows terminals/editors to retain the same file name over multiple executions.\n# Firstly find out if enabled (not enabled by default)\nmy $createResultsSymLinks = stfArguments::get_argument(\"create-results-sym-links\");\n\n# If symbolic links are supported and required then create the link\n# eg, /tmp/stf/UtilLoadTest -> /tmp/stf/20160704-115233-UtilLoadTest\nif (defined $symlink_supported && $symlink_supported eq 1 && $createResultsSymLinks ne 'false') {\n    my $new_link_name = $results_root . \"/$test_name\";\n    unlink $new_link_name; \n\tsymlink($test_dir, $new_link_name);\n}\n\n# On Windows, assign T: to the test directory.\n# Some tests (e.g. the JCK) have been known to create very long paths which can exceed the Win32 limit of 260 chars.\n# Using a substituted drive letter instead avoids the limit.\n#if ($^O eq 'MSWin32') {\n#    # subst might not work with forward slashes or escaped backslashes, so remove any that are there.\n#    $test_dir =~ s,/,\\\\,g;\n#    $test_dir =~ s,\\\\\\\\,\\\\,g;\n#    print \"Substituting test_dir $test_dir with T: to avoid long path lengths\\n\";\n\n#    my $cmd = \"subst T: /d\";\n#    print \"Running $cmd\\n\";\n#    my @subst_output = `$cmd 2>&1`;\n#    my $rc = $?;\n#    print \"$cmd returned: $rc\\n\";\n#    if ( $rc != 0 ) {\n#        foreach my $line ( @subst_output ) {\n#           print \"$line\";\n#        }\n#    }\n\n#    $cmd = \"subst T: $test_dir\";\n#    print \"Running $cmd\\n\";\n#    @subst_output = `$cmd 2>&1`;\n#    $rc = $?;\n#    print \"$cmd returned: $rc\\n\";\n#    if ( $rc != 0 ) {\n#        foreach my $line ( @subst_output ) {\n#           print \"$line\";\n#        }\n#    }\n#    $test_dir = \"T:/\";\n#}\n\n\n# Check whether we have enough space available. If not inform the user and fail the test, \n# unless we are on z/OS, where may be on a dynamic, growable file system, like ZFS.\nmy $mb_free = check_free_space ($results_root);\nif ( $mb_free < 3072 && stf::stfUtility::getPlatform() ne \"zos\") {\n\tprint \"\nTest machine has only $mb_free Mb free on drive containing $results_root.\\n\nThere must be at least 3Gb (3072Mb) free to be sure of capturing diagnostics\nfiles in the event of a test failure.\\n\nExiting.\\n\";\n\texit 1;\n}\n\n\n# $now used as a unique id\nmy ($now, $date, $time) = stf::stfUtility->getNow(date => $TRUE, time => $TRUE);\n\n\toutput_banner(\"GENERATION\");\n\n    # if any test root starts with '..' then resolve it now, before we change directory\n    my $test_root = stfArguments::get_argument(\"test-root\");\n\tmy $updated_test_root = make_paths_absolute(\"test-root\",$test_root,\"\");\n    \n    \n    # Abort run if any test root contains a space character.\n    # (This causes lots of class loading problems on windows)\n    if ($test_root =~ / /) {\n\t    _log(\"**FAILED** STF cannot use any test root with a space character in its path: $test_root\\n\");\n\t    exit 1;\n\t}\n    \n    \n    # Write the stf arguments to a properties file\n    my $stf_parameters = $test_dir . \"/stf_parameters.properties\";\n    stfArguments::write_arguments_to_file $stf_parameters, $Bin, $updated_test_root, $updated_systemtest_prereqs;\n\n\t# Move to the output directory\n\tchdir($generation_dir);\n\n    # Decide if java debug has been enabled\n\tmy $java_debug_settings = \"\";\n    if (stfArguments::get_boolean_argument(\"debug-generation\")) {\n        $java_debug_settings = stfArguments::get_argument(\"java-debug-args\");\n\t}"
    },
    "56": {
      "metadata": {
        "chunk_id": "beee2b08b356e342a968b3a5ca59d0918ae3224eefa0f2ee3469125b1138cd5d",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "# Move to the output directory\n\tchdir($generation_dir);\n\n    # Decide if java debug has been enabled\n\tmy $java_debug_settings = \"\";\n    if (stfArguments::get_boolean_argument(\"debug-generation\")) {\n        $java_debug_settings = stfArguments::get_argument(\"java-debug-args\");\n\t}\n\n\t# Find the location of java to be used in the generation step\n\tmy $javahome_generation = stfArguments::get_and_check_argument(\"javahome-generation\");\n\tvalidate_jvm($javahome_generation, \"javahome-generation\");\n\t\n    # Build the command to run RunTestRunner - to generate the setup, execute and teardown scripts.\n    # The generation step needs a custom class loader so that classes used by the plugin can be loaded.\n    my $sep = stf::stfUtility->getPathSeparator;\n    my $log4j_core_dir = findElement($prereqs_root, \"/log4j/log4j-core.jar\");\n    my $log4j_api_dir = findElement($prereqs_root, \"/log4j/log4j-api.jar\");\n    my $asm_jar = findElement($prereqs_root, \"/asm/asm.jar\");\n    my $asm_commons_jar = findElement($prereqs_root, \"/asm/asm-commons.jar\");\n    my $cmd = \"$javahome_generation/bin/java \" .\n              \"$java_debug_settings\" .\n              \" -Dlog4j.skipJansi=true\" .  # Suppress warning on Windows\n              \" -Djava.system.class.loader=net.adoptopenjdk.stf.runner.StfClassLoader\" .\n              \" -Dload.agent.path=$Bin/../../stf.load/bin/stf.load.jar\" .\n              \" -classpath $asm_jar\" . $sep . \"$asm_commons_jar\" . $sep . \"$log4j_api_dir\" . $sep . \"$log4j_core_dir\" . $sep . \"$Bin/../bin\" .\n              \" net.adoptopenjdk.stf.runner.StfRunner\" .\n              \" -properties \\\"$stf_parameters, $stf_personal_properties, $stf_defaults\\\"\" .\n              \" -testDir \\\"$test_dir\\\"\";\n\n    _log(\"Starting process to generate scripts: $cmd\");\n    my ($rc, $process) = stf::Commands->run_process(\n          \tmnemonic  => \"GEN\",\n            command   => $cmd,\n            logName   => \"$generation_dir\" . \"/generation\",\n            uid       => $now,\n            echo      => $TRUE,\n            prefix_on => $TRUE,\n            runtime   => 900);\n    if ($rc != 0) {\n        print \"Generation failed\\n\";\n        exit 1;\n    }",
        "start_line": 443,
        "end_line": 485,
        "chunk_index": 5,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 566,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697484"
      },
      "text": "# Move to the output directory\n\tchdir($generation_dir);\n\n    # Decide if java debug has been enabled\n\tmy $java_debug_settings = \"\";\n    if (stfArguments::get_boolean_argument(\"debug-generation\")) {\n        $java_debug_settings = stfArguments::get_argument(\"java-debug-args\");\n\t}\n\n\t# Find the location of java to be used in the generation step\n\tmy $javahome_generation = stfArguments::get_and_check_argument(\"javahome-generation\");\n\tvalidate_jvm($javahome_generation, \"javahome-generation\");\n\t\n    # Build the command to run RunTestRunner - to generate the setup, execute and teardown scripts.\n    # The generation step needs a custom class loader so that classes used by the plugin can be loaded.\n    my $sep = stf::stfUtility->getPathSeparator;\n    my $log4j_core_dir = findElement($prereqs_root, \"/log4j/log4j-core.jar\");\n    my $log4j_api_dir = findElement($prereqs_root, \"/log4j/log4j-api.jar\");\n    my $asm_jar = findElement($prereqs_root, \"/asm/asm.jar\");\n    my $asm_commons_jar = findElement($prereqs_root, \"/asm/asm-commons.jar\");\n    my $cmd = \"$javahome_generation/bin/java \" .\n              \"$java_debug_settings\" .\n              \" -Dlog4j.skipJansi=true\" .  # Suppress warning on Windows\n              \" -Djava.system.class.loader=net.adoptopenjdk.stf.runner.StfClassLoader\" .\n              \" -Dload.agent.path=$Bin/../../stf.load/bin/stf.load.jar\" .\n              \" -classpath $asm_jar\" . $sep . \"$asm_commons_jar\" . $sep . \"$log4j_api_dir\" . $sep . \"$log4j_core_dir\" . $sep . \"$Bin/../bin\" .\n              \" net.adoptopenjdk.stf.runner.StfRunner\" .\n              \" -properties \\\"$stf_parameters, $stf_personal_properties, $stf_defaults\\\"\" .\n              \" -testDir \\\"$test_dir\\\"\";\n\n    _log(\"Starting process to generate scripts: $cmd\");\n    my ($rc, $process) = stf::Commands->run_process(\n          \tmnemonic  => \"GEN\",\n            command   => $cmd,\n            logName   => \"$generation_dir\" . \"/generation\",\n            uid       => $now,\n            echo      => $TRUE,\n            prefix_on => $TRUE,\n            runtime   => 900);\n    if ($rc != 0) {\n        print \"Generation failed\\n\";\n        exit 1;\n    }"
    },
    "57": {
      "metadata": {
        "chunk_id": "81bd9b4e7ae39d39847b19734615a89263f33464b940ddaba0cc6f31f0432de7",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "_log(\"Starting process to generate scripts: $cmd\");\n    my ($rc, $process) = stf::Commands->run_process(\n          \tmnemonic  => \"GEN\",\n            command   => $cmd,\n            logName   => \"$generation_dir\" . \"/generation\",\n            uid       => $now,\n            echo      => $TRUE,\n            prefix_on => $TRUE,\n            runtime   => 900);\n    if ($rc != 0) {\n        print \"Generation failed\\n\";\n        exit 1;\n    }\n\n    # If we are just running to provide help or a list of all tests then finish.\n    if ($help_arg ne 'false') {\n\t    exit 0;\n\t}   \n    if ($test_list_arg ne 'false') {\n\t    exit 0;\n\t}   \n\t\n\t\n\t_log(\"\");\n    _log(\"Script generation completed\");\n    _log(\"\");\n   \n    # Read names of execute scripts to run from text file\n    my @executeStages = ();\n    my $filename = \"$test_dir/executeStages.txt\";\n    open(my $fh, '<', $filename) or die \"Could not open file '$filename' $!\";\n    while (my $row = <$fh>) {\n        chomp $row;\n        push(@executeStages, \"$row\");\n    }\n    close($fh);\n   \n    # Build the perl commands needed to run the test\n    my $setupCmd    = \"perl $test_dir/setUp.pl\";\n    my $teardownCmd = \"perl $test_dir/tearDown.pl\";\n   \n\tmy $dry_run = stfArguments::get_boolean_argument(\"dry-run\");\n\tif ($dry_run) {\n        _log(\"*Not* executing scripts, as dryRun mode set\");\n        _log(\"Commands to execute scripts are:\");\n        _log(\"  $setupCmd\");\n        foreach (@executeStages) {\n            _log(\"  perl $test_dir/$_.pl\");\n        }\n        _log(\"  $teardownCmd\");\n        exit 0;\n       \n    } else {\n        my $rc_setup    = 0;\n        my $rc_execute  = 0;\n        my @rc_executes = ();\n        my $rc_teardown = 0;\n          \n        $rc_setup = runScript($setupCmd, $setup_dir, \"setup\");\n        # Only run the test itself if the setup was successful\n        my $rc_execute_total = 0;\n        if ($rc_setup == 0) {\n            for my $i (0 .. $#executeStages) {\n                my $stageName = $executeStages[$i];\n                my $cmd = \"perl $test_dir/$stageName.pl\";\n                my $rc = runScript($cmd, $execute_dir, $stageName);\n                push(@rc_executes, $rc);\n                $rc_execute_total = $rc_execute_total + $rc;\n            }\n        }\n       \n        $rc_teardown = runScript($teardownCmd, $teardown_dir, \"teardown\");\n   \n        _log(\"\");\n        output_banner(\"results\");\n        \n        # Find the longest stage name (so that the results can be neatly formatted)\n        my $longestStageName = length \"teardown\";\n        for my $i (0 .. $#executeStages) {\n            my $currStageLen = length $executeStages[$i];\n            if ($currStageLen > $longestStageName) {\n                $longestStageName = $currStageLen;\n            }\n        }\n        \n        # Report pass/fail for each stage\n        _log(\"Stage results:\");\n        reportStageResult(\"setUp\", $rc_setup, $longestStageName);\n        for my $i (0 .. $#rc_executes) {\n            reportStageResult($executeStages[$i], $rc_executes[$i], $longestStageName);\n        }\n        reportStageResult(\"teardown\", $rc_setup, $longestStageName);\n\n        # Output an overall pass/fail status message\n   \t\tmy $rc_overall = $rc_setup + $rc_execute_total + $rc_teardown;\n   \t\t_log(\"\");\n   \t\tif ($rc_overall == 0) {\n\t        _log(\"Overall result: PASSED\");\n\t        # If the --rm-pass option was specified, delete the results directory because the test passed.\n\t        if (stfArguments::get_boolean_argument(\"rm-pass\")) {\n\t            _log(\"Deleting the results directory because no failures were detected.\");\n\t            chdir $results_root;\n\t            deleteDirectory($test_dir);\n\t        }\n\t    } else {\n\t    \t$rc_overall = 1;\n\t        _log(\"Overall result: **FAILED**\");\n\t    }\n\t    \n\t    exit $rc_overall; \n   }",
        "start_line": 486,
        "end_line": 596,
        "chunk_index": 6,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 972,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697486"
      },
      "text": "_log(\"Starting process to generate scripts: $cmd\");\n    my ($rc, $process) = stf::Commands->run_process(\n          \tmnemonic  => \"GEN\",\n            command   => $cmd,\n            logName   => \"$generation_dir\" . \"/generation\",\n            uid       => $now,\n            echo      => $TRUE,\n            prefix_on => $TRUE,\n            runtime   => 900);\n    if ($rc != 0) {\n        print \"Generation failed\\n\";\n        exit 1;\n    }\n\n    # If we are just running to provide help or a list of all tests then finish.\n    if ($help_arg ne 'false') {\n\t    exit 0;\n\t}   \n    if ($test_list_arg ne 'false') {\n\t    exit 0;\n\t}   \n\t\n\t\n\t_log(\"\");\n    _log(\"Script generation completed\");\n    _log(\"\");\n   \n    # Read names of execute scripts to run from text file\n    my @executeStages = ();\n    my $filename = \"$test_dir/executeStages.txt\";\n    open(my $fh, '<', $filename) or die \"Could not open file '$filename' $!\";\n    while (my $row = <$fh>) {\n        chomp $row;\n        push(@executeStages, \"$row\");\n    }\n    close($fh);\n   \n    # Build the perl commands needed to run the test\n    my $setupCmd    = \"perl $test_dir/setUp.pl\";\n    my $teardownCmd = \"perl $test_dir/tearDown.pl\";\n   \n\tmy $dry_run = stfArguments::get_boolean_argument(\"dry-run\");\n\tif ($dry_run) {\n        _log(\"*Not* executing scripts, as dryRun mode set\");\n        _log(\"Commands to execute scripts are:\");\n        _log(\"  $setupCmd\");\n        foreach (@executeStages) {\n            _log(\"  perl $test_dir/$_.pl\");\n        }\n        _log(\"  $teardownCmd\");\n        exit 0;\n       \n    } else {\n        my $rc_setup    = 0;\n        my $rc_execute  = 0;\n        my @rc_executes = ();\n        my $rc_teardown = 0;\n          \n        $rc_setup = runScript($setupCmd, $setup_dir, \"setup\");\n        # Only run the test itself if the setup was successful\n        my $rc_execute_total = 0;\n        if ($rc_setup == 0) {\n            for my $i (0 .. $#executeStages) {\n                my $stageName = $executeStages[$i];\n                my $cmd = \"perl $test_dir/$stageName.pl\";\n                my $rc = runScript($cmd, $execute_dir, $stageName);\n                push(@rc_executes, $rc);\n                $rc_execute_total = $rc_execute_total + $rc;\n            }\n        }\n       \n        $rc_teardown = runScript($teardownCmd, $teardown_dir, \"teardown\");\n   \n        _log(\"\");\n        output_banner(\"results\");\n        \n        # Find the longest stage name (so that the results can be neatly formatted)\n        my $longestStageName = length \"teardown\";\n        for my $i (0 .. $#executeStages) {\n            my $currStageLen = length $executeStages[$i];\n            if ($currStageLen > $longestStageName) {\n                $longestStageName = $currStageLen;\n            }\n        }\n        \n        # Report pass/fail for each stage\n        _log(\"Stage results:\");\n        reportStageResult(\"setUp\", $rc_setup, $longestStageName);\n        for my $i (0 .. $#rc_executes) {\n            reportStageResult($executeStages[$i], $rc_executes[$i], $longestStageName);\n        }\n        reportStageResult(\"teardown\", $rc_setup, $longestStageName);\n\n        # Output an overall pass/fail status message\n   \t\tmy $rc_overall = $rc_setup + $rc_execute_total + $rc_teardown;\n   \t\t_log(\"\");\n   \t\tif ($rc_overall == 0) {\n\t        _log(\"Overall result: PASSED\");\n\t        # If the --rm-pass option was specified, delete the results directory because the test passed.\n\t        if (stfArguments::get_boolean_argument(\"rm-pass\")) {\n\t            _log(\"Deleting the results directory because no failures were detected.\");\n\t            chdir $results_root;\n\t            deleteDirectory($test_dir);\n\t        }\n\t    } else {\n\t    \t$rc_overall = 1;\n\t        _log(\"Overall result: **FAILED**\");\n\t    }\n\t    \n\t    exit $rc_overall; \n   }"
    },
    "58": {
      "metadata": {
        "chunk_id": "21a3b16f497bf9ae05e95c5b749eb5b849e7a570650a80160c622cabf16636d0",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "sub describe_file {\n    my $file = shift;\n    \n    if (-f $file) {\n        return \"f\";\n    } elsif (-d $file) {\n        return \"d\";\n    }\n    \n    return \"?\";\n}\n\n\nsub runScript {\n\n    # Runtime for the setup.pl, execute.pl and teardown.pl execution\n    # is set to a week (7 days).\n    # Tests should be setting timeouts for the processes within each script\n    # according to their expectations, but setting a very long timeout here\n    # at least stops automation machines being tied up for ever.\n\n    my $script = shift;\n    my $results_dir = shift;\n    my $script_name = shift;\n\n    _log(\"\");\n\toutput_banner($script_name);\n\t\n    _log(\"Running $script_name: $script\");\n    \n    my $return_code = 0;\n    my ($rc, $process) = stf::Commands->run_process(\n          mnemonic\t=> \"STF\",\n          command   => $script,\n          logName    => \"$results_dir\" . \"/$script_name\",\n          uid       => $now,\n          echo      => $TRUE,\n          prefix_on => $FALSE,\n          runtime   => 604800);\n          \n    if ($rc != 0) {\n        _log(\"**FAILED** $script_name script failed. Expected return value=0 Actual=$rc\");\n        $return_code = $rc;\n    }\n    \n    return $return_code;\n}\n\n\n# This subroutine produces banner text which divide the output into sections.\n# It aims to make it easier to quickly visually parse the output.\n# We have found that capitalising the stage string and adding extra spaces makes\n# the most effective divider.\n# For example, given the text of 'executeJunit' it outputs:\n#   ==============   E X E C U T E - J U N I T   ==============\n#\nsub output_banner {\n    my $bannerText = shift;\n    \n    # Make the text more readable for execute methods\n    $bannerText =~ s/^execute/execute-/;\n    \n    # Work out how many padding characters to add on either side of the banner text    \n    my $targetWidth = 80;\n    my $timestampWidth = 20;\n    my $titlePadding = 3;\n    my $expandedTextLength = ((length $bannerText) *2) -1;  # Allow for space insertion\n    my $numHighlight = ($targetWidth -$timestampWidth -$titlePadding - $expandedTextLength -$titlePadding) / 2;\n    \n    # Make sure that we always have some highlighting characters\n    if ($numHighlight < 5) {\n        $numHighlight = 5;\n    }\n    \n    # Create highlight string, with repeating '=' characters\n    my $highlight=\"\";\n    my $i;\n    for ($i=0; $i<$numHighlight; $i++) {\n        $highlight = $highlight . \"=\";\n    }\n       \n    # Format the banner text. Capitalise and add spacing    \n    my $formattedBannerText=\"\";\n    for ($i=0; $i<length $bannerText; $i++) {\n        $formattedBannerText = $formattedBannerText . uc substr($bannerText, $i, 1);\n        if ($i != (length $bannerText) -1) {\n            $formattedBannerText = $formattedBannerText . \" \";  # Add space between characters of banner text\n        }\n    }\n\n\t# Build full banner text\n    my $bannerLine = \"$highlight   $formattedBannerText   $highlight\";\n    \n    _log($bannerLine);\n}\n\n\n# Output overall pass/fail from running a stage \nsub reportStageResult {\n    my $stageName = shift() . \":\";\n    my $rc = shift;\n    my $stageNameLen = shift;\n    $stageNameLen += 1;  # to allow for the ':'\n    \n    # Work out result status text\n    my $resultText;\n    if ($rc == 0) {\n        $resultText = \" pass\";\n    } else {\n        $resultText = \"*fail*\";\n    }\n\n    my $resultLine = sprintf(\"  %-${stageNameLen}s %s\", $stageName, $resultText);\n    _log($resultLine); \n}\n        \n\n# This subroutine validates the JVM to be used for running STF for perl code generation.\n# It checks that javahome points at a directory containing a 'java' file.",
        "start_line": 597,
        "end_line": 715,
        "chunk_index": 7,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 923,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697492"
      },
      "text": "sub describe_file {\n    my $file = shift;\n    \n    if (-f $file) {\n        return \"f\";\n    } elsif (-d $file) {\n        return \"d\";\n    }\n    \n    return \"?\";\n}\n\n\nsub runScript {\n\n    # Runtime for the setup.pl, execute.pl and teardown.pl execution\n    # is set to a week (7 days).\n    # Tests should be setting timeouts for the processes within each script\n    # according to their expectations, but setting a very long timeout here\n    # at least stops automation machines being tied up for ever.\n\n    my $script = shift;\n    my $results_dir = shift;\n    my $script_name = shift;\n\n    _log(\"\");\n\toutput_banner($script_name);\n\t\n    _log(\"Running $script_name: $script\");\n    \n    my $return_code = 0;\n    my ($rc, $process) = stf::Commands->run_process(\n          mnemonic\t=> \"STF\",\n          command   => $script,\n          logName    => \"$results_dir\" . \"/$script_name\",\n          uid       => $now,\n          echo      => $TRUE,\n          prefix_on => $FALSE,\n          runtime   => 604800);\n          \n    if ($rc != 0) {\n        _log(\"**FAILED** $script_name script failed. Expected return value=0 Actual=$rc\");\n        $return_code = $rc;\n    }\n    \n    return $return_code;\n}\n\n\n# This subroutine produces banner text which divide the output into sections.\n# It aims to make it easier to quickly visually parse the output.\n# We have found that capitalising the stage string and adding extra spaces makes\n# the most effective divider.\n# For example, given the text of 'executeJunit' it outputs:\n#   ==============   E X E C U T E - J U N I T   ==============\n#\nsub output_banner {\n    my $bannerText = shift;\n    \n    # Make the text more readable for execute methods\n    $bannerText =~ s/^execute/execute-/;\n    \n    # Work out how many padding characters to add on either side of the banner text    \n    my $targetWidth = 80;\n    my $timestampWidth = 20;\n    my $titlePadding = 3;\n    my $expandedTextLength = ((length $bannerText) *2) -1;  # Allow for space insertion\n    my $numHighlight = ($targetWidth -$timestampWidth -$titlePadding - $expandedTextLength -$titlePadding) / 2;\n    \n    # Make sure that we always have some highlighting characters\n    if ($numHighlight < 5) {\n        $numHighlight = 5;\n    }\n    \n    # Create highlight string, with repeating '=' characters\n    my $highlight=\"\";\n    my $i;\n    for ($i=0; $i<$numHighlight; $i++) {\n        $highlight = $highlight . \"=\";\n    }\n       \n    # Format the banner text. Capitalise and add spacing    \n    my $formattedBannerText=\"\";\n    for ($i=0; $i<length $bannerText; $i++) {\n        $formattedBannerText = $formattedBannerText . uc substr($bannerText, $i, 1);\n        if ($i != (length $bannerText) -1) {\n            $formattedBannerText = $formattedBannerText . \" \";  # Add space between characters of banner text\n        }\n    }\n\n\t# Build full banner text\n    my $bannerLine = \"$highlight   $formattedBannerText   $highlight\";\n    \n    _log($bannerLine);\n}\n\n\n# Output overall pass/fail from running a stage \nsub reportStageResult {\n    my $stageName = shift() . \":\";\n    my $rc = shift;\n    my $stageNameLen = shift;\n    $stageNameLen += 1;  # to allow for the ':'\n    \n    # Work out result status text\n    my $resultText;\n    if ($rc == 0) {\n        $resultText = \" pass\";\n    } else {\n        $resultText = \"*fail*\";\n    }\n\n    my $resultLine = sprintf(\"  %-${stageNameLen}s %s\", $stageName, $resultText);\n    _log($resultLine); \n}\n        \n\n# This subroutine validates the JVM to be used for running STF for perl code generation.\n# It checks that javahome points at a directory containing a 'java' file."
    },
    "59": {
      "metadata": {
        "chunk_id": "ed2cbad96f9c6a2cb44d555a89141a5c4407182df3caab81d2cc79aa19cded3c",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "sub reportStageResult {\n    my $stageName = shift() . \":\";\n    my $rc = shift;\n    my $stageNameLen = shift;\n    $stageNameLen += 1;  # to allow for the ':'\n    \n    # Work out result status text\n    my $resultText;\n    if ($rc == 0) {\n        $resultText = \" pass\";\n    } else {\n        $resultText = \"*fail*\";\n    }\n\n    my $resultLine = sprintf(\"  %-${stageNameLen}s %s\", $stageName, $resultText);\n    _log($resultLine); \n}\n        \n\n# This subroutine validates the JVM to be used for running STF for perl code generation.\n# It checks that javahome points at a directory containing a 'java' file.\nsub validate_jvm {\n    my $javahome = shift;\n    my $javahome_name = shift;\n \n    _log(\"Checking JVM: $javahome\" );\n\n\t# Process execution goes wrong if java installed into a directory with spaces. Prevent execution.\n    if ($javahome =~ / /) {\n\t    _log(\"**FAILED** Cannot run due to space character in \\$JAVA_HOME: $javahome\\n\");\n\t    exit 1;\n\t}\n    \n    # Firstly check that there is 'java' file in the expected place below javahome\n    if (!-e \"$javahome/bin/java\" && !-e \"$javahome/bin/java.exe\" ) {\n        _log(\"**FAILED** JVM for '$javahome_name' is not pointing at a valid JVM build: $javahome\\n\" );\n        exit 1;\n    }\n}\n\n# This subroutine retrieves the available space on results-root.\n#\n# On unix, run df -k.\n# df -k <file|dir> returns the amount of free space on the file system which <file|dir> is on.\n# The output is different for unix variants.\n# The code below caters for:\n# Linux:\n# Filesystem     1K-blocks    Used Available Use% Mounted on\n# /dev/sda1       59464844 9812524  46608636  18% /\n# AIX: df shipped with AIX:\n# Filesystem    1024-blocks      Free %Used    Iused %Iused Mounted on\n# /dev/hd3          5242880   4410064   16%    11291     1% /tmp \n# AIX: freeware df which may be installed:\n# Filesystem           1K-blocks      Used Available Use% Mounted on\n# /dev/hd3               5242880    832816   4410064  16% /tmp\n# zOS:\n# Mounted on     Filesystem                Avail/Total    Files      Status\n# /xxxxxx       (xxxxxxx)             579397092/1290153920 31238576   Available\n#\n# On Windows use dir <results_root>:\n# C:\\git\\aqa-systemtest>dir\n# Volume in drive C has no label.\n# Volume Serial Number is xxxx-xxxx\n#\n# Directory of C:\\git\\aqa-systemtest\n#\n#02/02/2017  15:23    <DIR>          .\n#02/02/2017  15:23    <DIR>          ..\n#02/02/2017  15:23               766 .gitattributes\n#02/02/2017  15:23                30 .gitignore\n#02/02/2017  15:23    <DIR>          aqa-systemtest\n#               2 File(s)            796 bytes\n#               3 Dir(s)  214,264,049,664 bytes free",
        "start_line": 716,
        "end_line": 788,
        "chunk_index": 8,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 805,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697494"
      },
      "text": "sub reportStageResult {\n    my $stageName = shift() . \":\";\n    my $rc = shift;\n    my $stageNameLen = shift;\n    $stageNameLen += 1;  # to allow for the ':'\n    \n    # Work out result status text\n    my $resultText;\n    if ($rc == 0) {\n        $resultText = \" pass\";\n    } else {\n        $resultText = \"*fail*\";\n    }\n\n    my $resultLine = sprintf(\"  %-${stageNameLen}s %s\", $stageName, $resultText);\n    _log($resultLine); \n}\n        \n\n# This subroutine validates the JVM to be used for running STF for perl code generation.\n# It checks that javahome points at a directory containing a 'java' file.\nsub validate_jvm {\n    my $javahome = shift;\n    my $javahome_name = shift;\n \n    _log(\"Checking JVM: $javahome\" );\n\n\t# Process execution goes wrong if java installed into a directory with spaces. Prevent execution.\n    if ($javahome =~ / /) {\n\t    _log(\"**FAILED** Cannot run due to space character in \\$JAVA_HOME: $javahome\\n\");\n\t    exit 1;\n\t}\n    \n    # Firstly check that there is 'java' file in the expected place below javahome\n    if (!-e \"$javahome/bin/java\" && !-e \"$javahome/bin/java.exe\" ) {\n        _log(\"**FAILED** JVM for '$javahome_name' is not pointing at a valid JVM build: $javahome\\n\" );\n        exit 1;\n    }\n}\n\n# This subroutine retrieves the available space on results-root.\n#\n# On unix, run df -k.\n# df -k <file|dir> returns the amount of free space on the file system which <file|dir> is on.\n# The output is different for unix variants.\n# The code below caters for:\n# Linux:\n# Filesystem     1K-blocks    Used Available Use% Mounted on\n# /dev/sda1       59464844 9812524  46608636  18% /\n# AIX: df shipped with AIX:\n# Filesystem    1024-blocks      Free %Used    Iused %Iused Mounted on\n# /dev/hd3          5242880   4410064   16%    11291     1% /tmp \n# AIX: freeware df which may be installed:\n# Filesystem           1K-blocks      Used Available Use% Mounted on\n# /dev/hd3               5242880    832816   4410064  16% /tmp\n# zOS:\n# Mounted on     Filesystem                Avail/Total    Files      Status\n# /xxxxxx       (xxxxxxx)             579397092/1290153920 31238576   Available\n#\n# On Windows use dir <results_root>:\n# C:\\git\\aqa-systemtest>dir\n# Volume in drive C has no label.\n# Volume Serial Number is xxxx-xxxx\n#\n# Directory of C:\\git\\aqa-systemtest\n#\n#02/02/2017  15:23    <DIR>          .\n#02/02/2017  15:23    <DIR>          ..\n#02/02/2017  15:23               766 .gitattributes\n#02/02/2017  15:23                30 .gitignore\n#02/02/2017  15:23    <DIR>          aqa-systemtest\n#               2 File(s)            796 bytes\n#               3 Dir(s)  214,264,049,664 bytes free"
    },
    "60": {
      "metadata": {
        "chunk_id": "bfd14a72b47a17f0b734eb9c628b023493065759d1dc608491f5bea708661843",
        "file_path": "stf.core/scripts/stf.pl",
        "content": "sub findElement {\n\tmy $stringOfPaths = shift;\n\tmy $elementName = shift;\n\t\n\tmy $elementPath = \"null\";\n\tmy @paths_array = split(/;/,$stringOfPaths);\n\tmy $one_path;\n\t\n\tforeach $one_path (@paths_array)\n\t{\n\t\tif ((-e \"$one_path$elementName\") and ($elementPath eq \"null\")) {\n\t\t\t$elementPath = \"$one_path$elementName\";\n\t\t}\n\t}\n\tdie \"Could not find \" . $elementName . \" in any of these supplied paths: \" . $stringOfPaths . \"\\n\" unless (!($elementPath eq \"null\")); \n\t    \n\treturn $elementPath;\n}\n\n# Takes a single directory and attempts to delete it, along with any contents.\n\nsub deleteDirectory {\n\tmy $doomed_directory = shift;\n\tif ( $^O eq 'MSWin32' ) {\n        \tmy $cmd = \"cmd /c rmdir /s /q \\\"$doomed_directory\\\"\";\n            `$cmd`;\n            if ( $? ) {\n                die \"Error running $cmd: $!\";\n            } \n        }\n        else {\n            rmtree($doomed_directory, {keep_root => 1}, {error => \\my $err} );\n            if ((defined $err) and (@$err)) {\n                for my $diag (@$err) {\n                    my ($file, $message) = %$diag;\n                    if ($file eq '') {\n                        _log(\"  general error: $message\");\n                    } else {\n                        _log(\"  problem unlinking $file: $message\");\n                    }\n                }\n            }\n        }\n}\n\n# Simple internal method for logging.\n# For use when code only wants to log something.\n# Expects a single argument which contains the message to log.\nsub _log {\n    my $messageText = shift;\n    \n    stf::stfUtility->logMsg(message => $messageText);\n}\n\n \n#===============================================================================\n# Usage\n#===============================================================================\nsub usage\n{\n   exit 1;\n}",
        "start_line": 789,
        "end_line": 850,
        "chunk_index": 9,
        "total_chunks": 10,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 415,
        "node_type": null,
        "file_sha": "c8898f3e9aaf6c444b90dc3b00cf534e3f130b10",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.697496"
      },
      "text": "sub findElement {\n\tmy $stringOfPaths = shift;\n\tmy $elementName = shift;\n\t\n\tmy $elementPath = \"null\";\n\tmy @paths_array = split(/;/,$stringOfPaths);\n\tmy $one_path;\n\t\n\tforeach $one_path (@paths_array)\n\t{\n\t\tif ((-e \"$one_path$elementName\") and ($elementPath eq \"null\")) {\n\t\t\t$elementPath = \"$one_path$elementName\";\n\t\t}\n\t}\n\tdie \"Could not find \" . $elementName . \" in any of these supplied paths: \" . $stringOfPaths . \"\\n\" unless (!($elementPath eq \"null\")); \n\t    \n\treturn $elementPath;\n}\n\n# Takes a single directory and attempts to delete it, along with any contents.\n\nsub deleteDirectory {\n\tmy $doomed_directory = shift;\n\tif ( $^O eq 'MSWin32' ) {\n        \tmy $cmd = \"cmd /c rmdir /s /q \\\"$doomed_directory\\\"\";\n            `$cmd`;\n            if ( $? ) {\n                die \"Error running $cmd: $!\";\n            } \n        }\n        else {\n            rmtree($doomed_directory, {keep_root => 1}, {error => \\my $err} );\n            if ((defined $err) and (@$err)) {\n                for my $diag (@$err) {\n                    my ($file, $message) = %$diag;\n                    if ($file eq '') {\n                        _log(\"  general error: $message\");\n                    } else {\n                        _log(\"  problem unlinking $file: $message\");\n                    }\n                }\n            }\n        }\n}\n\n# Simple internal method for logging.\n# For use when code only wants to log something.\n# Expects a single argument which contains the message to log.\nsub _log {\n    my $messageText = shift;\n    \n    stf::stfUtility->logMsg(message => $messageText);\n}\n\n \n#===============================================================================\n# Usage\n#===============================================================================\nsub usage\n{\n   exit 1;\n}"
    },
    "61": {
      "metadata": {
        "chunk_id": "bed0c5a89334f5a1ec3557d62cf657e6d7d7771e022b1add506ecc49888f9129",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#----------------------------------------------------------------------------------#\n# Commands.pm\n#\n# This library manages processes allowing the caller to run, kill and monitor processes in a\n# platform independent way.\n#\n# The caller has the choice of calling the \"run\" subroutine to run processes synchronously where \n# processes run in parallel and are monitored to completion or start a process, monitor and kill \n# as separate calls using the other external subroutines. There's also dump monitoring, logging \n# the ability to specify an expected outcome from a process and run several instances of a given\n# command.\n#\n# The library was written to aid the automation of multi process test scenarios.\n#\n# Some usage examples:\n#\n# Example 1 - Start a simple process (java -version)\n#  my ($rc, $process) = stf::Commands->start_process(mnemonic => \"Java\", command => \"java\", args => \"-version\", logName => $logName);\n#\n# Example 2 - Run 10 java processes in parallel, monitored to completion with a timeout value of 5 mins\n#  my $rc = stf::Commands->run({mnemonic => \"JAVA\", command => \"java\", args => @args, logName => $logName, runtime => 300, instances => 10});\n#\n# Example 3 - Run 2 separate (unrelated) processes in parallel, monitored to completion\n#  my $rc = stf::Commands->run({mnemonic => \"Java\", command => \"java\", args => @java_args, logName => $logName},\n#\t\t\t\t\t\t\t   {mnemonic => \"Perl\", command => \"perl\", args => @perl_args, logName => $logName});\n#\n# Example 4 - Start a process that is expected to create a dump for a RAS test\n#  my $rc = stf::Commands->run({mnemonic => \"CRASH\", command => \"java\", args => @args, logName => $logName, expectedOutcome=crashes});\n#\n# Example 5 - Start a ORB server that is expected to never complete\n#  my ($rc, $process) = stf::Commands->start_process(mnemonic => \"ORBS\", command => \"java\", args => @args, logName => $logName, expectedOutcome=never);\n#\n# Example 6 - Run a Node command that is expected to end with return code 11\n#  my $rc = stf::Commands->run({mnemonic => \"Node\", command => \"node\", args => @args, logName => $logName, expectedOutcome=exitValue:11});\n#\n# Example 7 - Start a couple of ORB servers and 3 clients\n#  my ($rc, %process_list) = stf::Commands->start_processes({mnemonic => \"ORBS\", command => \"java\", args => @server_args, logName => $logName, instances => 2, expectedOutcome=never},\n#\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{mnemonic => \"ORBC\", command => \"java\", args => @client_args, logName => $logName, instances => 3});\n#\n# Example 8 - Monitor a list of processes/single process\n#  my $rc = stf::Commands->monitor_processes(%process_list);\n#  my $rc = stf::Commands->monitor_processes($process);\n#\n# Example 9 - Kill a list of processes/single process\n#  my $rc = stf::Commands->kill_processes(%process_list);\n#  my $rc = stf::Commands->kill_processes($process);\n#----------------------------------------------------------------------------------#\npackage stf::Commands;\n\n# Core Perl modules\n#use strict;\nuse Time::Local;\nuse File::Spec::Functions qw{catfile};\nuse File::Basename;\nuse File::Temp qw{tempfile};\nuse File::Path qw(mkpath);\nuse Cwd;\nuse Cwd qw(abs_path);\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END); #SEEK_SET=0 SEEK_CUR=1 ...\n\n# For dev\nuse FindBin qw($Bin);\nuse lib \"$Bin/..\";\nuse Data::Dumper;\n\n",
        "start_line": 0,
        "end_line": 76,
        "chunk_index": 0,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 980,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704707"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#----------------------------------------------------------------------------------#\n# Commands.pm\n#\n# This library manages processes allowing the caller to run, kill and monitor processes in a\n# platform independent way.\n#\n# The caller has the choice of calling the \"run\" subroutine to run processes synchronously where \n# processes run in parallel and are monitored to completion or start a process, monitor and kill \n# as separate calls using the other external subroutines. There's also dump monitoring, logging \n# the ability to specify an expected outcome from a process and run several instances of a given\n# command.\n#\n# The library was written to aid the automation of multi process test scenarios.\n#\n# Some usage examples:\n#\n# Example 1 - Start a simple process (java -version)\n#  my ($rc, $process) = stf::Commands->start_process(mnemonic => \"Java\", command => \"java\", args => \"-version\", logName => $logName);\n#\n# Example 2 - Run 10 java processes in parallel, monitored to completion with a timeout value of 5 mins\n#  my $rc = stf::Commands->run({mnemonic => \"JAVA\", command => \"java\", args => @args, logName => $logName, runtime => 300, instances => 10});\n#\n# Example 3 - Run 2 separate (unrelated) processes in parallel, monitored to completion\n#  my $rc = stf::Commands->run({mnemonic => \"Java\", command => \"java\", args => @java_args, logName => $logName},\n#\t\t\t\t\t\t\t   {mnemonic => \"Perl\", command => \"perl\", args => @perl_args, logName => $logName});\n#\n# Example 4 - Start a process that is expected to create a dump for a RAS test\n#  my $rc = stf::Commands->run({mnemonic => \"CRASH\", command => \"java\", args => @args, logName => $logName, expectedOutcome=crashes});\n#\n# Example 5 - Start a ORB server that is expected to never complete\n#  my ($rc, $process) = stf::Commands->start_process(mnemonic => \"ORBS\", command => \"java\", args => @args, logName => $logName, expectedOutcome=never);\n#\n# Example 6 - Run a Node command that is expected to end with return code 11\n#  my $rc = stf::Commands->run({mnemonic => \"Node\", command => \"node\", args => @args, logName => $logName, expectedOutcome=exitValue:11});\n#\n# Example 7 - Start a couple of ORB servers and 3 clients\n#  my ($rc, %process_list) = stf::Commands->start_processes({mnemonic => \"ORBS\", command => \"java\", args => @server_args, logName => $logName, instances => 2, expectedOutcome=never},\n#\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{mnemonic => \"ORBC\", command => \"java\", args => @client_args, logName => $logName, instances => 3});\n#\n# Example 8 - Monitor a list of processes/single process\n#  my $rc = stf::Commands->monitor_processes(%process_list);\n#  my $rc = stf::Commands->monitor_processes($process);\n#\n# Example 9 - Kill a list of processes/single process\n#  my $rc = stf::Commands->kill_processes(%process_list);\n#  my $rc = stf::Commands->kill_processes($process);\n#----------------------------------------------------------------------------------#\npackage stf::Commands;\n\n# Core Perl modules\n#use strict;\nuse Time::Local;\nuse File::Spec::Functions qw{catfile};\nuse File::Basename;\nuse File::Temp qw{tempfile};\nuse File::Path qw(mkpath);\nuse Cwd;\nuse Cwd qw(abs_path);\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END); #SEEK_SET=0 SEEK_CUR=1 ...\n\n# For dev\nuse FindBin qw($Bin);\nuse lib \"$Bin/..\";\nuse Data::Dumper;\n\n"
    },
    "62": {
      "metadata": {
        "chunk_id": "4f9924f8a3eae9ce7eee6380d96fff4b6bfe134d8b9a0643bb656d5391598de7",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "# STF modules\nuse stf::ProcessMgmt;\nuse stf::Constants qw(:all);\nuse stf::stfUtility;\n\nmy $useHiRes = $TRUE;\neval \"use Time::HiRes\";\nif ($@) {\n     $useHiRes = $FALSE;\n}\n\nmy $delimiter = stf::stfUtility->getDelimiter;\n\n# Heartbeat parameters\nmy $heartbeat = $TRUE; # If TRUE print heartbeat every 5 minutes\nmy $heartbeat_period = 300;\nmy $nextbeat = time + $heartbeat_period; # Time of next heartbeat\n\n#----------------------------------------------------------------------------------#\n# validate_args\n#\n# This is an internal subroutine that interprets and validates the supplied process arguments \n# to ensure that the arguments provided are sane. It also defines stderr/stdout and sets \n# process attributes required internally. \n#\n# Usage:\n#  %process_args = validate_args(%process_args); \n#\n# Arguments:\n#  %process_args = A hash that contains the supplied process attributes\n#\n# Returns:\n#  %process_args = A hash with the validated process attributes \n#----------------------------------------------------------------------------------#\nsub validate_args {\n\tmy %process_args = @_;\n\n\ttrace(\"validate_args subroutine - \\%process_args:\" . Dumper(\\%process_args));\n\n\tmy $rc = 0;\n\n\t# Ensure process mnemonic, command and logdir parameters are supllied as these parameters \n\t# are required for monitoring and logging.\n\tunless (defined $process_args{command}) {\n\t\twarn \"Process command (\\$command) must be defined\";\n\n\t\t$rc = 1;\n\t}\n\n\tunless (defined $process_args{mnemonic}) {\n\t\twarn \"Process name (\\$mnemonic) must be defined\";\n\n\t\t$rc = 1;\t\t\n\t}\n\n\tunless (defined $process_args{logName}) {\n\t\twarn \"Process logName (\\$logName) must be defined\";\n\n\t\t$rc = 1;\t\t\t\t\n\t}\n\n\t# Extract the log directory from logName\n\t$process_args{logdir} = dirname($process_args{logName});\n\n\t# Ensure the process mnemonic and logName are unique if we running multiple instances of the same command\n\tif (defined $instance) {\n\t\t$process_args{mnemonic} = $process_args{mnemonic} . \"$instance\";\n\t\t$process_args{logName} = $process_args{logName} . \"$instance\";\n\t}\n\n\t# Pad the mnemonic with spaces for a consisted output\n\twhile (length($process_args{mnemonic}) < 3) {\n\t\t$process_args{mnemonic} .= \" \";\n\t}\n\n\t# Default prefix_on to $TRUE (1) for the echoing\n\t$process_args{prefix_on} = $TRUE unless (defined $process_args{prefix_on});\n\n\t# Default dump_found to $FALSE (0)\n\t$process_args{dump_found} = $FALSE;\n\n\t# Default echo to $FALSE (0)\n\t$process_args{echo} = $FALSE unless (defined $process_args{echo});\n\n\t# Define expectedOutcome by default to avoid warnings\n\t$process_args{expectedOutcome} = defined unless (defined $process_args{expectedOutcome});\n\n\t# Use the mnemonic parameter as the uid\t\n\t$process_args{uid} = $process_args{mnemonic};\n\n\t# Set the logs\n\tif (defined $process_args{singleLog} && $process_args{singleLog} == $TRUE) {\n\t\t$process_args{stderr} = $process_args{logName};\n\t\t$process_args{stdout} = $process_args{logName};\n\t} else {\n\t\t$process_args{stderr} = $process_args{logName} . \".stderr\";\n\t\t$process_args{stdout} = $process_args{logName} . \".stdout\";\n\t}\n\n\t# Ensure we start from a clean state\n\tunlink $process_args{stderr} if (exists $process_args{stderr});\n\tunlink $process_args{stdout} if (exists $process_args{stdout});\n\n\t# If the parameter args is not defined, assume the command parameter includes the arguments \n\tunless (defined $process_args{args}) {\n\t\tmy @cmd_elements = split( \" \", $process_args{command} );\n\n\t\t$process_args{command}  = shift @cmd_elements;\n\n\t\t@{$process_args{args}}  = @cmd_elements;\n\t}\n\n\t# The inwards of the Process object expect an array of arguments,\n\t# convert args to an array if we are given args as a string (scalar).\n\tif ((ref \\$process_args{args}) =~ \"SCALAR\") {\n\t\tmy @args_elements = split( \" \", $process_args{args} );\n\n\t\t$process_args{args} = \\@args_elements;\n\t}\n\n",
        "start_line": 77,
        "end_line": 197,
        "chunk_index": 1,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 1000,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704718"
      },
      "text": "# STF modules\nuse stf::ProcessMgmt;\nuse stf::Constants qw(:all);\nuse stf::stfUtility;\n\nmy $useHiRes = $TRUE;\neval \"use Time::HiRes\";\nif ($@) {\n     $useHiRes = $FALSE;\n}\n\nmy $delimiter = stf::stfUtility->getDelimiter;\n\n# Heartbeat parameters\nmy $heartbeat = $TRUE; # If TRUE print heartbeat every 5 minutes\nmy $heartbeat_period = 300;\nmy $nextbeat = time + $heartbeat_period; # Time of next heartbeat\n\n#----------------------------------------------------------------------------------#\n# validate_args\n#\n# This is an internal subroutine that interprets and validates the supplied process arguments \n# to ensure that the arguments provided are sane. It also defines stderr/stdout and sets \n# process attributes required internally. \n#\n# Usage:\n#  %process_args = validate_args(%process_args); \n#\n# Arguments:\n#  %process_args = A hash that contains the supplied process attributes\n#\n# Returns:\n#  %process_args = A hash with the validated process attributes \n#----------------------------------------------------------------------------------#\nsub validate_args {\n\tmy %process_args = @_;\n\n\ttrace(\"validate_args subroutine - \\%process_args:\" . Dumper(\\%process_args));\n\n\tmy $rc = 0;\n\n\t# Ensure process mnemonic, command and logdir parameters are supllied as these parameters \n\t# are required for monitoring and logging.\n\tunless (defined $process_args{command}) {\n\t\twarn \"Process command (\\$command) must be defined\";\n\n\t\t$rc = 1;\n\t}\n\n\tunless (defined $process_args{mnemonic}) {\n\t\twarn \"Process name (\\$mnemonic) must be defined\";\n\n\t\t$rc = 1;\t\t\n\t}\n\n\tunless (defined $process_args{logName}) {\n\t\twarn \"Process logName (\\$logName) must be defined\";\n\n\t\t$rc = 1;\t\t\t\t\n\t}\n\n\t# Extract the log directory from logName\n\t$process_args{logdir} = dirname($process_args{logName});\n\n\t# Ensure the process mnemonic and logName are unique if we running multiple instances of the same command\n\tif (defined $instance) {\n\t\t$process_args{mnemonic} = $process_args{mnemonic} . \"$instance\";\n\t\t$process_args{logName} = $process_args{logName} . \"$instance\";\n\t}\n\n\t# Pad the mnemonic with spaces for a consisted output\n\twhile (length($process_args{mnemonic}) < 3) {\n\t\t$process_args{mnemonic} .= \" \";\n\t}\n\n\t# Default prefix_on to $TRUE (1) for the echoing\n\t$process_args{prefix_on} = $TRUE unless (defined $process_args{prefix_on});\n\n\t# Default dump_found to $FALSE (0)\n\t$process_args{dump_found} = $FALSE;\n\n\t# Default echo to $FALSE (0)\n\t$process_args{echo} = $FALSE unless (defined $process_args{echo});\n\n\t# Define expectedOutcome by default to avoid warnings\n\t$process_args{expectedOutcome} = defined unless (defined $process_args{expectedOutcome});\n\n\t# Use the mnemonic parameter as the uid\t\n\t$process_args{uid} = $process_args{mnemonic};\n\n\t# Set the logs\n\tif (defined $process_args{singleLog} && $process_args{singleLog} == $TRUE) {\n\t\t$process_args{stderr} = $process_args{logName};\n\t\t$process_args{stdout} = $process_args{logName};\n\t} else {\n\t\t$process_args{stderr} = $process_args{logName} . \".stderr\";\n\t\t$process_args{stdout} = $process_args{logName} . \".stdout\";\n\t}\n\n\t# Ensure we start from a clean state\n\tunlink $process_args{stderr} if (exists $process_args{stderr});\n\tunlink $process_args{stdout} if (exists $process_args{stdout});\n\n\t# If the parameter args is not defined, assume the command parameter includes the arguments \n\tunless (defined $process_args{args}) {\n\t\tmy @cmd_elements = split( \" \", $process_args{command} );\n\n\t\t$process_args{command}  = shift @cmd_elements;\n\n\t\t@{$process_args{args}}  = @cmd_elements;\n\t}\n\n\t# The inwards of the Process object expect an array of arguments,\n\t# convert args to an array if we are given args as a string (scalar).\n\tif ((ref \\$process_args{args}) =~ \"SCALAR\") {\n\t\tmy @args_elements = split( \" \", $process_args{args} );\n\n\t\t$process_args{args} = \\@args_elements;\n\t}\n\n"
    },
    "63": {
      "metadata": {
        "chunk_id": "0c472d669ef2d61984a31a81058791fd98924cb6e3d172c5d7e84e5e2f2175b0",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "    # Create value for the current instnance number, with empty string if only\n    # running 1 instance of the process.\t\n\tmy $instanceId = '';\n\tif (defined $instance) {\n\t    $instanceId = $instance;\n\t}\n\n\t# If the process we are about to run needs to know its instance number then replace \n\t# the placeholder now with the actual instance number. See StfConstants.java.\n   \tfor $argIndex (0..@{$process_args{args}}) {\n   \t    if (defined @{$process_args{args}}[$argIndex]) {\n    \t\ts/\\$\\{\\{STF-PROCESS-INSTANCE\\}\\}/$instanceId/ for @{$process_args{args}}[$argIndex]; \n    \t}\n    }\n\n\tinfo(\"Running command: $process_args{command} \" . join(\" \", @{$process_args{args}}));\n\n\tinfo(\"Redirecting stderr to $process_args{stderr}\");\n\n\tinfo(\"Redirecting stdout to $process_args{stdout}\");\n\n\t# Pre-define the logs last byte, these attributes are required for the process_logs function.\n\t$process_args{stderr_last_byte} = 0;\n\t$process_args{stdout_last_byte} = 0;\n\n\treturn ($rc, %process_args);\n}\n\n#----------------------------------------------------------------------------------#\n# start_process\n#\n# This is an external subroutine that starts a process, it expects a hash of arguments and \n# returns a process object and a return code.\n#\n# Usage:\n#  my ($rc, $process) = start_process(%process_args); \n#  my ($rc, $process) = start_process(mnemonic => \"java\", command => \"java -version\", logName => $logName);\n#\n# Arguments:\n#  mnemonic\t\t= The process mnemonic, to be used as the process identifier\n#  command \t\t= The process command, it supports command args too\n#  args\t\t\t= Optional, for more complex command args, it can be either a string or an array of args\n#  logName \t\t= The name of the log where the results are written\n#  echo\t\t\t= Optional, set to 1 to echo the stderr/stdout to the console screen/Axxon\n#  runtime     \t= Optional, the expected test runtime in seconds, if set, the test will be marked failed if it overruns\n#  kill\t\t\t= Optional, if set to 1, processes will be killed when they timeout, defaults to 1\n#  instances=<number>\t= Optional, use to launch multiple instances of a given command. The process mnemonic \n#\t\t\t\twill have the instance number appended to it\n#  prefix_on\t= Optional, set to use a prefix during the echoing of stderr/sdtout, defaults to 1\n#  expectedOutcome=never\t= Set when the expected outcome is for the process to run in the background and never\n# \t\t\t\tterminate, the test will be marked failed if the process monitor library detects that the process is not running\n#  expectedOutcome=crashes\t= Set when the expected outcome is for the process to crash, the test will be marked \n# \t\t\t\tfailed if the process monitor library detects that the process completes without a crash occuring\n#  expectedOutcome=exitValue:<value>\t= Use to explicitly set an expected return/exit code, the test will be marked \n# \t\t\t\tfailed if the process monitor library detects that the process completes with a different return/exit code\n#\n# Returns:\n#  $rc = The return code, 0 pass, 1 failure\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub start_process {\n\tmy ($self, %process_args) = @_;\n\n\ttrace(\"start_process subroutine - \\%process_args: \" . Dumper(\\%process_args));\n\n\t$rc = 0;\n\t($rc, %process_args) = validate_args(%process_args);\n\n\tmy $process = new stf::ProcessMgmt(%process_args);\n\n\tunless ($process->start()) {\n\t\twarn \"Could not start \\\"$process->{command} \" . join(\" \", @{$process->{args}}) . \"\\\". Error message: \" . $process->err_msg() . \"\\n\";\n\n\t\t$rc = 1;\n\t}\n\n\t$self->process_logs($process);\n\n\treturn ($rc, $process);\n}\n\n",
        "start_line": 198,
        "end_line": 279,
        "chunk_index": 2,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 906,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704725"
      },
      "text": "    # Create value for the current instnance number, with empty string if only\n    # running 1 instance of the process.\t\n\tmy $instanceId = '';\n\tif (defined $instance) {\n\t    $instanceId = $instance;\n\t}\n\n\t# If the process we are about to run needs to know its instance number then replace \n\t# the placeholder now with the actual instance number. See StfConstants.java.\n   \tfor $argIndex (0..@{$process_args{args}}) {\n   \t    if (defined @{$process_args{args}}[$argIndex]) {\n    \t\ts/\\$\\{\\{STF-PROCESS-INSTANCE\\}\\}/$instanceId/ for @{$process_args{args}}[$argIndex]; \n    \t}\n    }\n\n\tinfo(\"Running command: $process_args{command} \" . join(\" \", @{$process_args{args}}));\n\n\tinfo(\"Redirecting stderr to $process_args{stderr}\");\n\n\tinfo(\"Redirecting stdout to $process_args{stdout}\");\n\n\t# Pre-define the logs last byte, these attributes are required for the process_logs function.\n\t$process_args{stderr_last_byte} = 0;\n\t$process_args{stdout_last_byte} = 0;\n\n\treturn ($rc, %process_args);\n}\n\n#----------------------------------------------------------------------------------#\n# start_process\n#\n# This is an external subroutine that starts a process, it expects a hash of arguments and \n# returns a process object and a return code.\n#\n# Usage:\n#  my ($rc, $process) = start_process(%process_args); \n#  my ($rc, $process) = start_process(mnemonic => \"java\", command => \"java -version\", logName => $logName);\n#\n# Arguments:\n#  mnemonic\t\t= The process mnemonic, to be used as the process identifier\n#  command \t\t= The process command, it supports command args too\n#  args\t\t\t= Optional, for more complex command args, it can be either a string or an array of args\n#  logName \t\t= The name of the log where the results are written\n#  echo\t\t\t= Optional, set to 1 to echo the stderr/stdout to the console screen/Axxon\n#  runtime     \t= Optional, the expected test runtime in seconds, if set, the test will be marked failed if it overruns\n#  kill\t\t\t= Optional, if set to 1, processes will be killed when they timeout, defaults to 1\n#  instances=<number>\t= Optional, use to launch multiple instances of a given command. The process mnemonic \n#\t\t\t\twill have the instance number appended to it\n#  prefix_on\t= Optional, set to use a prefix during the echoing of stderr/sdtout, defaults to 1\n#  expectedOutcome=never\t= Set when the expected outcome is for the process to run in the background and never\n# \t\t\t\tterminate, the test will be marked failed if the process monitor library detects that the process is not running\n#  expectedOutcome=crashes\t= Set when the expected outcome is for the process to crash, the test will be marked \n# \t\t\t\tfailed if the process monitor library detects that the process completes without a crash occuring\n#  expectedOutcome=exitValue:<value>\t= Use to explicitly set an expected return/exit code, the test will be marked \n# \t\t\t\tfailed if the process monitor library detects that the process completes with a different return/exit code\n#\n# Returns:\n#  $rc = The return code, 0 pass, 1 failure\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub start_process {\n\tmy ($self, %process_args) = @_;\n\n\ttrace(\"start_process subroutine - \\%process_args: \" . Dumper(\\%process_args));\n\n\t$rc = 0;\n\t($rc, %process_args) = validate_args(%process_args);\n\n\tmy $process = new stf::ProcessMgmt(%process_args);\n\n\tunless ($process->start()) {\n\t\twarn \"Could not start \\\"$process->{command} \" . join(\" \", @{$process->{args}}) . \"\\\". Error message: \" . $process->err_msg() . \"\\n\";\n\n\t\t$rc = 1;\n\t}\n\n\t$self->process_logs($process);\n\n\treturn ($rc, $process);\n}\n\n"
    },
    "64": {
      "metadata": {
        "chunk_id": "ad1aa883f19c4cfbe1c16a113a82573460a739eb6d8eda2e5bbc34ae80f8dca8",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "#----------------------------------------------------------------------------------#\n# start_processes\n#\n# This is an external subroutine to start multiple processes, it expects a list of hashes for process\n# arguments, it returns a list of process objects and a return code.\n#\n# Usage:\n#  my ($rc, %list) = stf::Commands->start_processes(\\%command1, \\%command2);\n#  my ($rc, %list) = stf::Commands->start_processes({mnemonic => \"Java1\", command => \"java\", args => @args1, logName => $logName}, \n#\t\t\t\t\t\t\t\t\t\t\t \t\t {mnemonic => \"Java2\", command => \"java\", args => @args2, logName => $logName});\n#\n# Arguments:\n#  A list of hashes where each hash contains the process args required to instanciate a process object.\n#\n# Returns:\n#  $rc = The return code, 0 pass, 1 failure\n#  %list = A list (hash) of process objects, where the process mnemonic is the key and the process object is the value\n#\n# Notes:\n#  See the start_process description for the arguments required to start a process.\n#----------------------------------------------------------------------------------#\nsub start_processes {\n\tmy %process_list;\n\n\tmy ($self, @commands) = @_;\n\n\ttrace(\"start_processes subroutine - \\@commands: \" . Dumper(\\@commands));\n\n\tmy $status = 0;\n\n\t\t#Run our commands\n\t\tforeach my $this_command (@commands) {\n                my %process_args = %{$this_command};\n\n                if (defined $this_command->{instances}) {\n                \t# Run multiple instances of the same command if required\n\n                \tfor $instance (1..$this_command->{instances}) {\n\t\t\t\t\t\tmy ($rc, $process) = $self->start_process(%process_args);\n\n                        # Assign $process object to the process_list hash, use the process uid as it's key.\n                        $process_list{$process->{uid}} = $process;\n\n                        $status = $rc unless ($rc == 0);\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tmy ($rc, $process) = $self->start_process(%process_args);\n\n\t\t\t\t\t# Assign $process object to the process_list hash, use the process uid as it's key.\n\t\t\t\t\t$process_list{$process->{uid}} = $process;\n\n\t\t\t\t\t$status = $rc unless ($rc == 0);\n                }\n        }\n\treturn ($status, %process_list);\n}\n\n#----------------------------------------------------------------------------------#\n# monitor_processes\n#\n# This is an external subroutine to monitor processes for dumps, it checks if they overrun and then \n# later checks if the processes complete with the expected outcome\n#\n# Usage:\n#  my $rc = stf::Commands->monitor_processes($process);\n#  my $rc = stf::Commands->monitor_processes(%list);\n#\n# Arguments:\n#  $process/%list = A process object or a list of process objects\n#\n# Returns:\n#  $rc = The return code, 0 pass, 1 failure\n#----------------------------------------------------------------------------------#\nsub monitor_processes {\n\tmy $self = shift; \n\n\tmy %process_list;\t\n\n\t# Iterate through the parsed arguments to ensure that we are given a valid object \n\t# or a list of objects, this approach allows for the end-user to call the monitor_processes \n\t# directly with either a single object, an array of objects or a hash of objects.\n\tforeach $obj (@_) {\n\t\tif (ref ($obj) =~ \"stf::ProcessMgmt:\") {\n\t\t\t$process_list{$obj->{uid}} = $obj;\n\t\t}\n\t}\n\n\tunless(keys %process_list) {\n\t\twarn \"Internal error: No process ids supplied to monitor_processes function\" ;\n\n \t\treturn 1;\n\t}\n\n \tinfo(\"Monitoring processes: \" . join(\" \", sort keys %process_list));\n\n \ttrace(\"monitor_processes - \\%process_list: \" . Dumper(\\%process_list));\n\n\tmy %results;\n\n\tmy $not_all_finished = 1;\n\n\t# Monitor processes whilst they are still running.\n\twhile($not_all_finished == 1) {\n\t\t$not_all_finished = 0;\n\n\t\twhile ((my $uid, my $process) = each(%process_list)) {\n\t\t\t# process logs\n\t\t\t$self->process_logs($process);\n\n\t\t\t# Monitor the process for timeout and dumps\n\t\t\t($elapsed, %results) = stf::ProcessMgmt->monitorProcess($process, %results);\n\n\t\t\tif (defined $results{status} and $results{status} == $FAILURE) {\n\t\t\t\tdebug(\"Failure detected, exiting early!\");\n\n\t\t\t\t# Create dumps if the process has timed out or hung\n\t\t\t\tif ($process->{hung} or $process->{timeout}) {\n\t\t\t\t\t$self->create_dumps($process);\n\t\t\t\t}\n\n",
        "start_line": 280,
        "end_line": 401,
        "chunk_index": 3,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 998,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704732"
      },
      "text": "#----------------------------------------------------------------------------------#\n# start_processes\n#\n# This is an external subroutine to start multiple processes, it expects a list of hashes for process\n# arguments, it returns a list of process objects and a return code.\n#\n# Usage:\n#  my ($rc, %list) = stf::Commands->start_processes(\\%command1, \\%command2);\n#  my ($rc, %list) = stf::Commands->start_processes({mnemonic => \"Java1\", command => \"java\", args => @args1, logName => $logName}, \n#\t\t\t\t\t\t\t\t\t\t\t \t\t {mnemonic => \"Java2\", command => \"java\", args => @args2, logName => $logName});\n#\n# Arguments:\n#  A list of hashes where each hash contains the process args required to instanciate a process object.\n#\n# Returns:\n#  $rc = The return code, 0 pass, 1 failure\n#  %list = A list (hash) of process objects, where the process mnemonic is the key and the process object is the value\n#\n# Notes:\n#  See the start_process description for the arguments required to start a process.\n#----------------------------------------------------------------------------------#\nsub start_processes {\n\tmy %process_list;\n\n\tmy ($self, @commands) = @_;\n\n\ttrace(\"start_processes subroutine - \\@commands: \" . Dumper(\\@commands));\n\n\tmy $status = 0;\n\n\t\t#Run our commands\n\t\tforeach my $this_command (@commands) {\n                my %process_args = %{$this_command};\n\n                if (defined $this_command->{instances}) {\n                \t# Run multiple instances of the same command if required\n\n                \tfor $instance (1..$this_command->{instances}) {\n\t\t\t\t\t\tmy ($rc, $process) = $self->start_process(%process_args);\n\n                        # Assign $process object to the process_list hash, use the process uid as it's key.\n                        $process_list{$process->{uid}} = $process;\n\n                        $status = $rc unless ($rc == 0);\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tmy ($rc, $process) = $self->start_process(%process_args);\n\n\t\t\t\t\t# Assign $process object to the process_list hash, use the process uid as it's key.\n\t\t\t\t\t$process_list{$process->{uid}} = $process;\n\n\t\t\t\t\t$status = $rc unless ($rc == 0);\n                }\n        }\n\treturn ($status, %process_list);\n}\n\n#----------------------------------------------------------------------------------#\n# monitor_processes\n#\n# This is an external subroutine to monitor processes for dumps, it checks if they overrun and then \n# later checks if the processes complete with the expected outcome\n#\n# Usage:\n#  my $rc = stf::Commands->monitor_processes($process);\n#  my $rc = stf::Commands->monitor_processes(%list);\n#\n# Arguments:\n#  $process/%list = A process object or a list of process objects\n#\n# Returns:\n#  $rc = The return code, 0 pass, 1 failure\n#----------------------------------------------------------------------------------#\nsub monitor_processes {\n\tmy $self = shift; \n\n\tmy %process_list;\t\n\n\t# Iterate through the parsed arguments to ensure that we are given a valid object \n\t# or a list of objects, this approach allows for the end-user to call the monitor_processes \n\t# directly with either a single object, an array of objects or a hash of objects.\n\tforeach $obj (@_) {\n\t\tif (ref ($obj) =~ \"stf::ProcessMgmt:\") {\n\t\t\t$process_list{$obj->{uid}} = $obj;\n\t\t}\n\t}\n\n\tunless(keys %process_list) {\n\t\twarn \"Internal error: No process ids supplied to monitor_processes function\" ;\n\n \t\treturn 1;\n\t}\n\n \tinfo(\"Monitoring processes: \" . join(\" \", sort keys %process_list));\n\n \ttrace(\"monitor_processes - \\%process_list: \" . Dumper(\\%process_list));\n\n\tmy %results;\n\n\tmy $not_all_finished = 1;\n\n\t# Monitor processes whilst they are still running.\n\twhile($not_all_finished == 1) {\n\t\t$not_all_finished = 0;\n\n\t\twhile ((my $uid, my $process) = each(%process_list)) {\n\t\t\t# process logs\n\t\t\t$self->process_logs($process);\n\n\t\t\t# Monitor the process for timeout and dumps\n\t\t\t($elapsed, %results) = stf::ProcessMgmt->monitorProcess($process, %results);\n\n\t\t\tif (defined $results{status} and $results{status} == $FAILURE) {\n\t\t\t\tdebug(\"Failure detected, exiting early!\");\n\n\t\t\t\t# Create dumps if the process has timed out or hung\n\t\t\t\tif ($process->{hung} or $process->{timeout}) {\n\t\t\t\t\t$self->create_dumps($process);\n\t\t\t\t}\n\n"
    },
    "65": {
      "metadata": {
        "chunk_id": "d9b991da3ecb1f73c119ae5e277867476cf615fa3c496fd72d109e9298c6e00d",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "\t\t\t\t$not_all_finished = 0;\n\t\t\t\tlast;\n\t\t\t}\n\n\t\t\t# Check if the process is still running\n\t\t\tif ($process->{state} == 2) { \t# State 2 means the process is still running\n\t\t\t\ttrace(\"Process $process->{uid} is still running\");\n\t\t\t\t_heartbeat($process);\n\n\t\t\t\t# Leave the loop if the expected outcome is to never complete.\n\t\t\t\tnext if ($process->{expectedOutcome} eq \"never\");\n\n\t\t\t\t$not_all_finished = 1;\n\t\t\t}\n\t\t}\n\n\t\tif ($not_all_finished == 1) {\n\t\t\t# Use the HiRes perl module if available otherwise sleep for 1 sec\n\t\t\tif ($useHiRes) {\n\t\t\t\t# Work out how long to sleep for. This tries to strike a balance between avoiding \n\t\t\t\t# wasting time waiting for short runs, vs checking too frequently on long runs.\n\t\t\t\t# Note that 'elapsed' is in seconds, so after running for 15s the sleep time would be .150s or 150ms.  \n\t\t\t\tmy $sleeptime = $elapsed / 100;\n\n\t\t\t\tif ($sleeptime < 0.020) {\n\t\t    \t\t\t$sleeptime = 0.005;\n\t\t\t\t} \n\t\t\t\telsif ($sleeptime > 0.500) {\n\t\t    \t\t\t$sleeptime = 0.500;\n\t\t\t\t}\n\t    \t\tTime::HiRes::sleep($sleeptime);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsleep 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdebug(\"Stopped monitoring\");\n\t\t}\n\t}\n\n\t# Make sure we echo the output of all the processes before exiting the monitoring\n\tforeach my $uid (sort keys %process_list) {\n\t\tmy $process = $process_list{$uid};\n\n\t\t$self->process_logs($process);\n\t}\n\n\tmy $rc = report(\\%results, %process_list);\n\n\treturn $rc;\n}\n\nsub report {\n\tmy $results = shift;\n\n\tmy %process_list = @_;\n\n\tmy $run_status = 0;\n\n\tinfo(\"Monitoring Report Summary:\");\n\n\t# Evaluate the processes' outcome and report \n\tforeach my $uid (sort keys %process_list) {\n\t\tmy $process = $process_list{$uid};\n\n\t\t\t# Check if a process has crashed\n\t\t\tif ($process->{dump_found} == $TRUE) {\n\n\t\t\t\tif ($process->{expectedOutcome} eq \"crashes\") {\n\t\t\t\t\t\tinfo(\"  o Process $process->{uid} caused dumps as expected\");\n\n\t\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\tinfo(\"  o Process $process->{uid} has crashed unexpectedly\");\n\n\t\t\t\t\t\t$run_status = 1;\n\t\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t} \t\t\n\n\t\t\t# Ensure that a process that is expected to crash has indeed crashed.\n\t\t\tif ($process->{expectedOutcome} eq \"crashes\" && $process->{dump_found} == $FALSE) {\n\t\t\t\tinfo(\"  o Process $process->{uid} was expected to crash but no dumps were found\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t} \n\n\t\t\t# Ensure that a process that in not meant to complete is still running.\n\t\t\tif ($process->{expectedOutcome} eq \"never\" && $process->{state} == 3) {\n\t\t\t\tinfo(\"  o Process $process->{uid} has ended unexpectedly\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t# Check if the process has timed out.\n\t\t\tif ($process->{timeout}) {\n\t\t\t\tinfo(\"  o Process $process->{uid} has timed out\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t# Check if the process has hung.\n\t\t\tif ($process->{hung}) {\n\t\t\t\tinfo(\"  o Process $process->{uid} has hung\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t# Check if the process has been killed\n\t\t\tif ($process->{killed}) {\n\t\t\t\tinfo(\"  o Process $process->{uid} has been killed\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\tif($process->poll()) {\n\t\t\tif ($process->{expectedOutcome} eq \"never\") {\n\t\t\t\tinfo(\"  o Process $process->{uid} is still running as expected\");\n\n\t\t\t\tnext;\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinfo(\"  o Process $process->{uid} is still running\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t}\t\t\t\n\t\t} \n\t\telse {\n\t\t\t# Get the process return code\n\t\t\tmy $rc =  $process->{result}->{return_code}; \n\n",
        "start_line": 402,
        "end_line": 540,
        "chunk_index": 4,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 965,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704740"
      },
      "text": "\t\t\t\t$not_all_finished = 0;\n\t\t\t\tlast;\n\t\t\t}\n\n\t\t\t# Check if the process is still running\n\t\t\tif ($process->{state} == 2) { \t# State 2 means the process is still running\n\t\t\t\ttrace(\"Process $process->{uid} is still running\");\n\t\t\t\t_heartbeat($process);\n\n\t\t\t\t# Leave the loop if the expected outcome is to never complete.\n\t\t\t\tnext if ($process->{expectedOutcome} eq \"never\");\n\n\t\t\t\t$not_all_finished = 1;\n\t\t\t}\n\t\t}\n\n\t\tif ($not_all_finished == 1) {\n\t\t\t# Use the HiRes perl module if available otherwise sleep for 1 sec\n\t\t\tif ($useHiRes) {\n\t\t\t\t# Work out how long to sleep for. This tries to strike a balance between avoiding \n\t\t\t\t# wasting time waiting for short runs, vs checking too frequently on long runs.\n\t\t\t\t# Note that 'elapsed' is in seconds, so after running for 15s the sleep time would be .150s or 150ms.  \n\t\t\t\tmy $sleeptime = $elapsed / 100;\n\n\t\t\t\tif ($sleeptime < 0.020) {\n\t\t    \t\t\t$sleeptime = 0.005;\n\t\t\t\t} \n\t\t\t\telsif ($sleeptime > 0.500) {\n\t\t    \t\t\t$sleeptime = 0.500;\n\t\t\t\t}\n\t    \t\tTime::HiRes::sleep($sleeptime);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsleep 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdebug(\"Stopped monitoring\");\n\t\t}\n\t}\n\n\t# Make sure we echo the output of all the processes before exiting the monitoring\n\tforeach my $uid (sort keys %process_list) {\n\t\tmy $process = $process_list{$uid};\n\n\t\t$self->process_logs($process);\n\t}\n\n\tmy $rc = report(\\%results, %process_list);\n\n\treturn $rc;\n}\n\nsub report {\n\tmy $results = shift;\n\n\tmy %process_list = @_;\n\n\tmy $run_status = 0;\n\n\tinfo(\"Monitoring Report Summary:\");\n\n\t# Evaluate the processes' outcome and report \n\tforeach my $uid (sort keys %process_list) {\n\t\tmy $process = $process_list{$uid};\n\n\t\t\t# Check if a process has crashed\n\t\t\tif ($process->{dump_found} == $TRUE) {\n\n\t\t\t\tif ($process->{expectedOutcome} eq \"crashes\") {\n\t\t\t\t\t\tinfo(\"  o Process $process->{uid} caused dumps as expected\");\n\n\t\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\tinfo(\"  o Process $process->{uid} has crashed unexpectedly\");\n\n\t\t\t\t\t\t$run_status = 1;\n\t\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t} \t\t\n\n\t\t\t# Ensure that a process that is expected to crash has indeed crashed.\n\t\t\tif ($process->{expectedOutcome} eq \"crashes\" && $process->{dump_found} == $FALSE) {\n\t\t\t\tinfo(\"  o Process $process->{uid} was expected to crash but no dumps were found\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t} \n\n\t\t\t# Ensure that a process that in not meant to complete is still running.\n\t\t\tif ($process->{expectedOutcome} eq \"never\" && $process->{state} == 3) {\n\t\t\t\tinfo(\"  o Process $process->{uid} has ended unexpectedly\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t# Check if the process has timed out.\n\t\t\tif ($process->{timeout}) {\n\t\t\t\tinfo(\"  o Process $process->{uid} has timed out\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t# Check if the process has hung.\n\t\t\tif ($process->{hung}) {\n\t\t\t\tinfo(\"  o Process $process->{uid} has hung\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t# Check if the process has been killed\n\t\t\tif ($process->{killed}) {\n\t\t\t\tinfo(\"  o Process $process->{uid} has been killed\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\tif($process->poll()) {\n\t\t\tif ($process->{expectedOutcome} eq \"never\") {\n\t\t\t\tinfo(\"  o Process $process->{uid} is still running as expected\");\n\n\t\t\t\tnext;\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinfo(\"  o Process $process->{uid} is still running\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t}\t\t\t\n\t\t} \n\t\telse {\n\t\t\t# Get the process return code\n\t\t\tmy $rc =  $process->{result}->{return_code}; \n\n"
    },
    "66": {
      "metadata": {
        "chunk_id": "0910385b0c43fce6e1ca8804b58e91fb4949cf944a0e14a6bfd02f9eefb38bb7",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "\t\t\t# In unix the return code is complicated and the exit code might not be the same as the return code.\n\t\t\t# For example, a kill -9 will create a 9 exit code but the return code will remain unchanged. \n\t\t\t# So if we have an exit code we say the return code is the exit code to avoid false positives.\n\t\t\t$rc = $process->{result}->{code} if ((defined $process->{result}->{code}) && ($process->{result}->{code} != 0));\n\n\t\t\t# Check if the process exited with the expected exit code.\n\t\t\tif ($process->{expectedOutcome} =~ \"exitValue:\") {\n\t\t\t\t(my $expected_exit_codes = $process->{expectedOutcome}) =~ s/exitValue:/$1/g;\n\n\t\t\t\t# Get the real exit code\t\n\t\t\t\tmy $exit_code =  $process->get_result()->exit_code();\n\n\t\t\t\t# We may be given an expected exit code or a list of expected exit codes\n\t\t\t\tmy @codes = split(',', $expected_exit_codes);\n\t\t\t\tmy $expected_exit_code_met;\n\t\t\t\tforeach my $expected_exit_code (@codes) {\n\t\t\t\t\tif ($exit_code == $expected_exit_code) {\n\t\t\t\t\t\tinfo(\"  o Process $process->{uid} ended with the expected exit code ($expected_exit_code)\");\n\n\t\t\t\t\t\t$expected_exit_code_met = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($expected_exit_code_met) {\t\t\t\n\t\t\t\t\t$rc = 0;\n\n\t\t\t\t\tnext;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinfo(\"  o Process $process->{uid} ended with exit code ($exit_code) and not the expected exit code/s ($expected_exit_codes)\");\n\n\t\t\t\t\t$run_status = 1;\n\t\t\t\t\tnext;\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Check if there's a non 0 return code.\n\t\t\tif ($rc != 0 ) {\n\t\t\t\tinfo(\"  o Process $process->{uid} ended with return code $rc\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinfo(\"  o Process $process->{uid} ended sucessfully\");\n\t\t\t}\n\n\t\t\ttrace(Dumper(\\$process));\n\t\t}\n\t}\n\n\tdebug(\"Fail - At least one process returned an error code or ended with an unexpected outcome.\") unless ($run_status == 0);\n\n\ttrace(\"report subroutine - \\$results: \" . Dumper(\\$results));\n\ttrace(\"report subroutine - \\%process_list) \" . Dumper(\\%process_list));\n\n\treturn $run_status;\n}\n\n#----------------------------------------------------------------------------------#\n# process_logs\n#\n# This is an internal subroutine that:\n# - Echos the stderr/stdout to the screen/Axxon when the process \"echo\" attribute is set. \n# Note by default the stderr/stdout is redirected to the logs only. \n# - Scans the logs for hangs\n#\n# Usage:\n#  $self->process_logs($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub process_logs {\n\tmy ($self, $process) = @_;\n\n\tforeach my $output (\"stdout\", \"stderr\") {\n\t\topen LOG, \"<$process->{$output}\" or die \"Could not open file '$process->{$output}' $!\";\n\n\t\t# Find the last byte of the log\n\t\tmy $target_byte=$process->{$output . \"_last_byte\"};\n\n\t\t# Add a prefix to each line to make it easy to identify where the stderr/stdout\n\t\t# is coming from. This is particulary useful when running several processes in parallel. \n\t\tmy $prefix;\t\t\n\t\tif ($process->{prefix_on} == $TRUE) {\n\t\t\tif ($output eq \"stderr\") {\n\t\t\t\t$prefix = \"$process->{uid} $output \";\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$prefix = \"$process->{uid} \";\t\t\t\t\t\n\t\t\t}\t\t\n\t\t}\n\t\telse {\n\t\t\t$prefix = \"\";\t\n\t\t}\n\n\t\tseek(LOG,$target_byte,SEEK_CUR);\n\n\t\twhile (<LOG>) {\n\t\t    my $finalChar = substr $_, -1;\n\t\t    if ($finalChar eq \"\\n\") {\n\t    \t\tif ($process->{echo} == $TRUE) {\n\t\t\t        # Found a complete line. Echo it.\n\t\t\t\t\t# Note, both stderr and stdout are printed to stdout, this is deliberate. \n\t\t\t\t\t# Autoflush STDOUT to prevent buffering.\n\t\t\t\t\t$| = 1;\n\t\t\t\t\tselect(STDOUT);\n\t\t\t\t\tprint STDOUT \"$prefix\" . \"$_\";\t\t\t\n\t    \t\t}\n\n",
        "start_line": 541,
        "end_line": 651,
        "chunk_index": 5,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 930,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704748"
      },
      "text": "\t\t\t# In unix the return code is complicated and the exit code might not be the same as the return code.\n\t\t\t# For example, a kill -9 will create a 9 exit code but the return code will remain unchanged. \n\t\t\t# So if we have an exit code we say the return code is the exit code to avoid false positives.\n\t\t\t$rc = $process->{result}->{code} if ((defined $process->{result}->{code}) && ($process->{result}->{code} != 0));\n\n\t\t\t# Check if the process exited with the expected exit code.\n\t\t\tif ($process->{expectedOutcome} =~ \"exitValue:\") {\n\t\t\t\t(my $expected_exit_codes = $process->{expectedOutcome}) =~ s/exitValue:/$1/g;\n\n\t\t\t\t# Get the real exit code\t\n\t\t\t\tmy $exit_code =  $process->get_result()->exit_code();\n\n\t\t\t\t# We may be given an expected exit code or a list of expected exit codes\n\t\t\t\tmy @codes = split(',', $expected_exit_codes);\n\t\t\t\tmy $expected_exit_code_met;\n\t\t\t\tforeach my $expected_exit_code (@codes) {\n\t\t\t\t\tif ($exit_code == $expected_exit_code) {\n\t\t\t\t\t\tinfo(\"  o Process $process->{uid} ended with the expected exit code ($expected_exit_code)\");\n\n\t\t\t\t\t\t$expected_exit_code_met = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($expected_exit_code_met) {\t\t\t\n\t\t\t\t\t$rc = 0;\n\n\t\t\t\t\tnext;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinfo(\"  o Process $process->{uid} ended with exit code ($exit_code) and not the expected exit code/s ($expected_exit_codes)\");\n\n\t\t\t\t\t$run_status = 1;\n\t\t\t\t\tnext;\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Check if there's a non 0 return code.\n\t\t\tif ($rc != 0 ) {\n\t\t\t\tinfo(\"  o Process $process->{uid} ended with return code $rc\");\n\n\t\t\t\t$run_status = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinfo(\"  o Process $process->{uid} ended sucessfully\");\n\t\t\t}\n\n\t\t\ttrace(Dumper(\\$process));\n\t\t}\n\t}\n\n\tdebug(\"Fail - At least one process returned an error code or ended with an unexpected outcome.\") unless ($run_status == 0);\n\n\ttrace(\"report subroutine - \\$results: \" . Dumper(\\$results));\n\ttrace(\"report subroutine - \\%process_list) \" . Dumper(\\%process_list));\n\n\treturn $run_status;\n}\n\n#----------------------------------------------------------------------------------#\n# process_logs\n#\n# This is an internal subroutine that:\n# - Echos the stderr/stdout to the screen/Axxon when the process \"echo\" attribute is set. \n# Note by default the stderr/stdout is redirected to the logs only. \n# - Scans the logs for hangs\n#\n# Usage:\n#  $self->process_logs($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub process_logs {\n\tmy ($self, $process) = @_;\n\n\tforeach my $output (\"stdout\", \"stderr\") {\n\t\topen LOG, \"<$process->{$output}\" or die \"Could not open file '$process->{$output}' $!\";\n\n\t\t# Find the last byte of the log\n\t\tmy $target_byte=$process->{$output . \"_last_byte\"};\n\n\t\t# Add a prefix to each line to make it easy to identify where the stderr/stdout\n\t\t# is coming from. This is particulary useful when running several processes in parallel. \n\t\tmy $prefix;\t\t\n\t\tif ($process->{prefix_on} == $TRUE) {\n\t\t\tif ($output eq \"stderr\") {\n\t\t\t\t$prefix = \"$process->{uid} $output \";\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$prefix = \"$process->{uid} \";\t\t\t\t\t\n\t\t\t}\t\t\n\t\t}\n\t\telse {\n\t\t\t$prefix = \"\";\t\n\t\t}\n\n\t\tseek(LOG,$target_byte,SEEK_CUR);\n\n\t\twhile (<LOG>) {\n\t\t    my $finalChar = substr $_, -1;\n\t\t    if ($finalChar eq \"\\n\") {\n\t    \t\tif ($process->{echo} == $TRUE) {\n\t\t\t        # Found a complete line. Echo it.\n\t\t\t\t\t# Note, both stderr and stdout are printed to stdout, this is deliberate. \n\t\t\t\t\t# Autoflush STDOUT to prevent buffering.\n\t\t\t\t\t$| = 1;\n\t\t\t\t\tselect(STDOUT);\n\t\t\t\t\tprint STDOUT \"$prefix\" . \"$_\";\t\t\t\n\t    \t\t}\n\n"
    },
    "67": {
      "metadata": {
        "chunk_id": "af8d7b7368181180579de293b7062ba0e5cb9849a8afb2c1e0652ce518209738",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "\t\t\t\t# Scan the logs for hangs but ignore logs from STF (the parent process) as otherwise STF\n\t\t\t\t# gets declared hung closely after the child process hangs and it gets killed prematurely.\n\t\t\t\tif ($process->{mnemonic} ne \"STF\" && \"$_\" =~ \"POSSIBLE HANG DETECTED\") {\n\t\t\t\t\t$process->{hung} = $TRUE;\n\t\t\t\t}\n\n\t\t\t\t# Store the last processed byte of the log\n\t\t\t\t$process->{$output . \"_last_byte\"}=tell(LOG);\n\n\t\t    } else {\n\t\t    \t# Abandon the echoing for this file. \n\t\t    \t# It looks like all we can see is a partial line of output.\n\t\t    \t# If we were to echo the partial line then we risk injecting the process mnemonic\n\t\t    \t# part way through a line.\n\t\t    \tlast;\n\t\t    }\n\t\t}\n\n\t\tclose LOG;\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# kill_process\n#\n# This is an intermal subroutine that terminates a process, it first attempts to stop the process \n# and then kills the process if it is still running. If the process is terminated the process \n# object \"kill\" attribute is set to 1, otherwise 0.\n#\n# Usage:\n#  $self->kill_process($process1);\n#\n# Arguments:\n#  $process = A process object\n#\n# Returns:\n#  0 for pass and 1 for failure\n#----------------------------------------------------------------------------------#\nsub kill_process {\n    my ($self, $process) = @_;\n\n\tmy $rc;\n\n\tmy $ppid = $process->{pid};\n\n\t$process->{killed} = $FALSE;\n\n\tunless ($process->poll()) {\n\t\tinfo(\"  o Process $process->{uid} pid $ppid is not running\");\n\t\treturn;\n\t}\n\n\tmy $attempt = 1;\n\n\twhile($attempt < 6) {\n\t\tinfo(\"  o Process clean up attempt $attempt for $process->{uid} pid $ppid\");\n\n\t\tinfo(\"  o Process $process->{uid} pid $ppid stop()\");\n\t\t$process->stop();\n\n\t\tif($process->poll()) {\n\t\t\tinfo(\"  o Process $process->{uid} pid $ppid terminate()\");\n\t\t\t$process->terminate();\n\t\t}\n\n\t\tif($process->poll()) {\n\t\t\tif ($^O eq 'os390') {\n\t\t\t\t# Z/OS has another more forcefull kill option to try.\n\t\t\t\tif ($process->poll()) {\n\t\t\t\t\tsleep(5); # The kill -K doesn't work unless you give it some time after a kill -9. See the Z/OS documentation.\n\n\t\t\t\t\tinfo(\"  o kill -9 didn't work. Trying kill -K\");\n\n\t\t\t\t\tmy $kill_command = \"kill -K $ppid\";\n\n\t\t\t\t\t$self->start_process(\n\t\t\t\t\t\tmnemonic => \"KILL\",\n\t\t\t\t\t\tlogName\t => $process->{logdir} . $delimiter . \"kill_k\",\n\t\t\t\t\t\tcommand  => $kill_command,\n\t\t\t\t\t\truntime  => 300\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif($process->poll()) {\n\t\t\t$attempt++;\n\t\t} else {\n\t\t\tlast;\n\t\t}\n\t}\n\n\tif($process->poll()) {\n\t\tinfo(\"  o Process $process->{uid} terminate() pid $ppid didn't work, manual cleanup required\");\n\t}\n\telse {\n\t\tinfo(\"  o Process $process->{uid} pid $ppid killed\");\n\t\t$process->{killed} = $TRUE;\n\t}\n\n\t# Echo any remaining stdout/stderr\n\t$self->process_logs($process);\n\n\tif ($process->{killed}) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# kill_processes\n#\n# This is an external subroutine that terminates a process or a list of process, it calls the \n# kill_process internally, see it's description for further info.\n#\n# Usage:\n#  my $rc = stf::Commands->kill_processes($process)\n#  my $rc = stf::Commands->kill_processes(%list);\n#\n# Arguments:\n#  $process/%list = A process object or a list of process objects\n#\n# Returns:\n#  0 for pass and 1 for failure\n#----------------------------------------------------------------------------------#\nsub kill_processes {\n\tmy $self = shift;\n\n\tmy %process_list;\n\n",
        "start_line": 652,
        "end_line": 784,
        "chunk_index": 6,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 905,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704751"
      },
      "text": "\t\t\t\t# Scan the logs for hangs but ignore logs from STF (the parent process) as otherwise STF\n\t\t\t\t# gets declared hung closely after the child process hangs and it gets killed prematurely.\n\t\t\t\tif ($process->{mnemonic} ne \"STF\" && \"$_\" =~ \"POSSIBLE HANG DETECTED\") {\n\t\t\t\t\t$process->{hung} = $TRUE;\n\t\t\t\t}\n\n\t\t\t\t# Store the last processed byte of the log\n\t\t\t\t$process->{$output . \"_last_byte\"}=tell(LOG);\n\n\t\t    } else {\n\t\t    \t# Abandon the echoing for this file. \n\t\t    \t# It looks like all we can see is a partial line of output.\n\t\t    \t# If we were to echo the partial line then we risk injecting the process mnemonic\n\t\t    \t# part way through a line.\n\t\t    \tlast;\n\t\t    }\n\t\t}\n\n\t\tclose LOG;\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# kill_process\n#\n# This is an intermal subroutine that terminates a process, it first attempts to stop the process \n# and then kills the process if it is still running. If the process is terminated the process \n# object \"kill\" attribute is set to 1, otherwise 0.\n#\n# Usage:\n#  $self->kill_process($process1);\n#\n# Arguments:\n#  $process = A process object\n#\n# Returns:\n#  0 for pass and 1 for failure\n#----------------------------------------------------------------------------------#\nsub kill_process {\n    my ($self, $process) = @_;\n\n\tmy $rc;\n\n\tmy $ppid = $process->{pid};\n\n\t$process->{killed} = $FALSE;\n\n\tunless ($process->poll()) {\n\t\tinfo(\"  o Process $process->{uid} pid $ppid is not running\");\n\t\treturn;\n\t}\n\n\tmy $attempt = 1;\n\n\twhile($attempt < 6) {\n\t\tinfo(\"  o Process clean up attempt $attempt for $process->{uid} pid $ppid\");\n\n\t\tinfo(\"  o Process $process->{uid} pid $ppid stop()\");\n\t\t$process->stop();\n\n\t\tif($process->poll()) {\n\t\t\tinfo(\"  o Process $process->{uid} pid $ppid terminate()\");\n\t\t\t$process->terminate();\n\t\t}\n\n\t\tif($process->poll()) {\n\t\t\tif ($^O eq 'os390') {\n\t\t\t\t# Z/OS has another more forcefull kill option to try.\n\t\t\t\tif ($process->poll()) {\n\t\t\t\t\tsleep(5); # The kill -K doesn't work unless you give it some time after a kill -9. See the Z/OS documentation.\n\n\t\t\t\t\tinfo(\"  o kill -9 didn't work. Trying kill -K\");\n\n\t\t\t\t\tmy $kill_command = \"kill -K $ppid\";\n\n\t\t\t\t\t$self->start_process(\n\t\t\t\t\t\tmnemonic => \"KILL\",\n\t\t\t\t\t\tlogName\t => $process->{logdir} . $delimiter . \"kill_k\",\n\t\t\t\t\t\tcommand  => $kill_command,\n\t\t\t\t\t\truntime  => 300\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif($process->poll()) {\n\t\t\t$attempt++;\n\t\t} else {\n\t\t\tlast;\n\t\t}\n\t}\n\n\tif($process->poll()) {\n\t\tinfo(\"  o Process $process->{uid} terminate() pid $ppid didn't work, manual cleanup required\");\n\t}\n\telse {\n\t\tinfo(\"  o Process $process->{uid} pid $ppid killed\");\n\t\t$process->{killed} = $TRUE;\n\t}\n\n\t# Echo any remaining stdout/stderr\n\t$self->process_logs($process);\n\n\tif ($process->{killed}) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# kill_processes\n#\n# This is an external subroutine that terminates a process or a list of process, it calls the \n# kill_process internally, see it's description for further info.\n#\n# Usage:\n#  my $rc = stf::Commands->kill_processes($process)\n#  my $rc = stf::Commands->kill_processes(%list);\n#\n# Arguments:\n#  $process/%list = A process object or a list of process objects\n#\n# Returns:\n#  0 for pass and 1 for failure\n#----------------------------------------------------------------------------------#\nsub kill_processes {\n\tmy $self = shift;\n\n\tmy %process_list;\n\n"
    },
    "68": {
      "metadata": {
        "chunk_id": "ff63f0bf8f618e8bf4ddd3b0629e84dcb0cce4ae0325521a49a590cf86ffb5e6",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "\t# Iterate through the parsed arguments to ensure that we are given a valid object \n\t# or a list of objects, this approach allows for the end-user call the kill_processes \n\t# directly with either a single object, an array of objects or a hash of objects.\n\tforeach $obj (@_) {\n\t\tif (ref ($obj) =~ \"stf::ProcessMgmt:\") {\n\t\t\t$process_list{$obj->{uid}} = $obj;\n\t\t}\n\t}\n\n\tunless(keys %process_list) {\n\t\twarn \"Internal error: No process ids supplied to kill_processes\";\n\n\t\treturn 1;\n\t}\n\n \twarn(\"Killing processes: \" . join(\" \", sort keys %process_list));\n\n\t# Expect all processes to be killed, switch \n\t# to false if it fails to kill a process\n\tmy $all_processes_killed = $TRUE;\n\twhile ((my $uid, my $process) = each(%process_list)) {\n\n\t\t$all_processes_killed = $FALSE if ($self->kill_process($process));\n\t}\n\n\tif ($all_processes_killed) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# run_process\n#\n# This is an external method to run a command or a series of commands, they will run in parallel and\n# be monitored (for dumps and timeout) to completion.  It calls start_processes and monitor_processes \n# internally, see their description for further info.\n# If the process does not complete before it's time limit it will be left running and we return 1. \n#\n# Usage:\n#  my ($rc, $process) = stf::Commands->run_process({mnemonic => \"Java\", command => \"java\", args => @args, logName => $logName});\n# \n# Arguments:\n#  A hash or a list of hashes where each hash contains the process args required to instanciate a process object\n#\n# Returns:\n#  $rc = 0 for pass and 1 for failure\n#\n# Notes:\n#  See the start_process description for the arguments required to start a process\n#----------------------------------------------------------------------------------#\nsub run_process {\n\tmy ($self, @commands) = @_;\n\n\tmy $status = 0;\n\n\tmy ($rc, $process) = $self->start_process(@commands);\n\n\t$status = $rc unless ($rc == 0);\n\n\t$rc = $self->monitor_processes($process);\n\n\t$status = $rc unless ($rc == 0);\n\n\treturn ($status, $process);\n}\n\n#----------------------------------------------------------------------------------#\n# run_processes\n#\n# This is an external method to run multiple instances of the same command, which will run in parallel and\n# be monitored (for dumps and timeout) to completion.  It calls start_processes and monitor_processes \n# internally, see their description for further info.\n# If one or more of the process does not complete before it's time limit it will be left running and we return 1. \n#\n# Usage:\n#  my ($rc, %process_list) = stf::Commands->run_processes({mnemonic => \"Java\", command => \"java\", args => @args, logName => $logName});\n# \n# Arguments:\n#  A hash or a list of hashes where each hash contains the process args required to instanciate a process object\n#\n# Returns:\n#  $rc = 0 for pass and 1 for failure\n#\n# Notes:\n#  See the start_process description for the arguments required to start a process\n#----------------------------------------------------------------------------------#\nsub run_processes {\n\tmy ($self, @commands) = @_;\n\n\ttrace(\"run_processes subroutine - \\@commands: \" . Dumper(\\@commands));\n\n\tmy $status = 0;\n\n\tmy ($rc, %process_list) = $self->start_processes(@commands);\n\n\t$status = $rc unless ($rc == 0);\n\n\t$rc = $self->monitor_processes(%process_list);\n\n\t$status = $rc unless ($rc == 0);\n\n\treturn ($status, %process_list);\n}\n\n#----------------------------------------------------------------------------------#\n# create_dumps\n# \n# This is an external subroutine that attempts to create dumps. \n#\n# Usage:\n#  stf::Commands->create_dumps($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub create_dumps {\n    my ($self, $process) = @_;\n\tmy $attempts    = 3;\n\tmy $interval    = \"30\"; \t# to allow javacore/core file to be written out.\n\n\twarn(\"Collecting dumps for: \" . $process->{mnemonic});\n\n\tREPEAT: for $attempt (1..$attempts) {\t\t\t\n\t\t$self->generate_process_diagnostics($process);\n\n",
        "start_line": 785,
        "end_line": 913,
        "chunk_index": 7,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 986,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704755"
      },
      "text": "\t# Iterate through the parsed arguments to ensure that we are given a valid object \n\t# or a list of objects, this approach allows for the end-user call the kill_processes \n\t# directly with either a single object, an array of objects or a hash of objects.\n\tforeach $obj (@_) {\n\t\tif (ref ($obj) =~ \"stf::ProcessMgmt:\") {\n\t\t\t$process_list{$obj->{uid}} = $obj;\n\t\t}\n\t}\n\n\tunless(keys %process_list) {\n\t\twarn \"Internal error: No process ids supplied to kill_processes\";\n\n\t\treturn 1;\n\t}\n\n \twarn(\"Killing processes: \" . join(\" \", sort keys %process_list));\n\n\t# Expect all processes to be killed, switch \n\t# to false if it fails to kill a process\n\tmy $all_processes_killed = $TRUE;\n\twhile ((my $uid, my $process) = each(%process_list)) {\n\n\t\t$all_processes_killed = $FALSE if ($self->kill_process($process));\n\t}\n\n\tif ($all_processes_killed) {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# run_process\n#\n# This is an external method to run a command or a series of commands, they will run in parallel and\n# be monitored (for dumps and timeout) to completion.  It calls start_processes and monitor_processes \n# internally, see their description for further info.\n# If the process does not complete before it's time limit it will be left running and we return 1. \n#\n# Usage:\n#  my ($rc, $process) = stf::Commands->run_process({mnemonic => \"Java\", command => \"java\", args => @args, logName => $logName});\n# \n# Arguments:\n#  A hash or a list of hashes where each hash contains the process args required to instanciate a process object\n#\n# Returns:\n#  $rc = 0 for pass and 1 for failure\n#\n# Notes:\n#  See the start_process description for the arguments required to start a process\n#----------------------------------------------------------------------------------#\nsub run_process {\n\tmy ($self, @commands) = @_;\n\n\tmy $status = 0;\n\n\tmy ($rc, $process) = $self->start_process(@commands);\n\n\t$status = $rc unless ($rc == 0);\n\n\t$rc = $self->monitor_processes($process);\n\n\t$status = $rc unless ($rc == 0);\n\n\treturn ($status, $process);\n}\n\n#----------------------------------------------------------------------------------#\n# run_processes\n#\n# This is an external method to run multiple instances of the same command, which will run in parallel and\n# be monitored (for dumps and timeout) to completion.  It calls start_processes and monitor_processes \n# internally, see their description for further info.\n# If one or more of the process does not complete before it's time limit it will be left running and we return 1. \n#\n# Usage:\n#  my ($rc, %process_list) = stf::Commands->run_processes({mnemonic => \"Java\", command => \"java\", args => @args, logName => $logName});\n# \n# Arguments:\n#  A hash or a list of hashes where each hash contains the process args required to instanciate a process object\n#\n# Returns:\n#  $rc = 0 for pass and 1 for failure\n#\n# Notes:\n#  See the start_process description for the arguments required to start a process\n#----------------------------------------------------------------------------------#\nsub run_processes {\n\tmy ($self, @commands) = @_;\n\n\ttrace(\"run_processes subroutine - \\@commands: \" . Dumper(\\@commands));\n\n\tmy $status = 0;\n\n\tmy ($rc, %process_list) = $self->start_processes(@commands);\n\n\t$status = $rc unless ($rc == 0);\n\n\t$rc = $self->monitor_processes(%process_list);\n\n\t$status = $rc unless ($rc == 0);\n\n\treturn ($status, %process_list);\n}\n\n#----------------------------------------------------------------------------------#\n# create_dumps\n# \n# This is an external subroutine that attempts to create dumps. \n#\n# Usage:\n#  stf::Commands->create_dumps($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub create_dumps {\n    my ($self, $process) = @_;\n\tmy $attempts    = 3;\n\tmy $interval    = \"30\"; \t# to allow javacore/core file to be written out.\n\n\twarn(\"Collecting dumps for: \" . $process->{mnemonic});\n\n\tREPEAT: for $attempt (1..$attempts) {\t\t\t\n\t\t$self->generate_process_diagnostics($process);\n\n"
    },
    "69": {
      "metadata": {
        "chunk_id": "8485eb43ec6fc5250211afcf0d55c365a99d7ab3b953c7d32426dd930e34151f",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "\t\tinfo(\"Pausing for \" . $interval . \" seconds\");\t\t\t\t\t\n\t\tsleep $interval;\n\n\t\tif ($process->get_state eq \"completed\") {\n\t\t\tinfo(\"Process \" . $process->{mnemonic} . \" (pid \" . $process->{pid} . \") is no longer running. Abandoning dump collection.\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t$self->generate_OS_dumps($process);\n}\n\n#----------------------------------------------------------------------------------#\n# generate_process_diagnostics\n# \n# This subroutine generates process diagnostics.\n# On Windows it uses jcmd for J9 jdks if it is available, otherwise procdump,\n# to generate .DMP files. For the other platforms it uses kill signals to generate\n# javacore/core files.\n#\n# Usage:\n#  $self->generate_process_diagnostics($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub generate_process_diagnostics {\n    my ($self, $process) = @_;\n\tmy $platform = stf::stfUtility->getPlatform();\n\n\t# If on Windows and running an OpenJ9 jdk, use jcmd to generate .DMP files,\n\t# otherwise use procdump.exe.\n\t# If not on Windows try generating javacores using kill signals.\n\n\tif ($platform eq \"win\") {\n\t\tmy $java;\n\t\tmy $jcmd;\n\n\t\t$java = catfile($ENV{JAVA_HOME}, 'bin', 'java.exe');\n\t\t$jcmd = catfile($ENV{JAVA_HOME}, 'bin', 'jcmd.exe');\n\n\t\tmy %getJavaProperties_options = ();\n\t\t$getJavaProperties_options{'PATH'} = $command_line_options{$java};\n\t\t%java_properties = stf::stfUtility->getJavaProperties(%getJavaProperties_options);\n\n\t\tif (-f $jcmd && $java_properties{'java.vm.name'} =~ /J9/ ) {\n\t\t\t# Use jcmd to generate dumps\n\t\t\tinfo(\"Using jcmd.exe to generate .DMP files\");\n\t\t\tmy $command = catfile(\"$sysinternals_dir\", \"procdump\" . $bits . \".exe\" );\n\t\t\tmy $output_file = $process->{logName} . \".jvmdump\";\n\n\t\t\tmy $dump_args = [$process->{pid}, \"Dump.java\"];\n\t\t\t$self->start_process(\n\t\t\t\tmnemonic => \"JCMD1\",\n\t\t\t\tcommand  => $jcmd,\n\t\t\t\targs     => $dump_args,\n\t\t\t\techo\t => $TRUE,\n\t\t\t\tlogName  => $output_file\n\t\t\t);\n\n\t\t\t$dump_args = [$process->{pid}, \"Dump.system\"];\n\t\t\t$self->start_process(\n\t\t\t\tmnemonic => \"JCMD2\",\n\t\t\t\tcommand  => $jcmd,\n\t\t\t\targs     => $dump_args,\n\t\t\t\techo\t => $TRUE,\n\t\t\t\tlogName  => $output_file\n\t\t\t);\n\t\t} else {\n\t\t\t# Use procdump to generate dumps\n\t\t\t# procdump.exe only works on Vista or later\n\t\t\t# Best way to work this out appears to be the build number\n\t\t\t# Vista is 6000, so look for something smaller\n\t\t\t#   C:\\WINNT\\system32>wmic os get BuildNumber\n\t\t\t#   BuildNumber\n\t\t\t#   3790\n\t\t\tmy $output = `echo foo | wmic os get BuildNumber 2>&1`;\n\t\t\tif ($output =~ /BuildNumber[^0-9]+(\\d+)/s) {\n\t\t\t\tmy $buildNumber = $1;\n\t\t\t\tif ($buildNumber < 6000) {\n\t\t\t\t\tinfo(\"Not able to generate javacores/core files on Windows builds earlier than Vista\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t# Determine if we need to run the 32 or 64 bit version by looking at the java build\n\t\t\t# if the first java on the PATH has a jre/lib/AMD64 directory then run the 64bit version\n\t\t\tmy $bits = '';\n\t\t\tmy $amd64_dir = catfile($java, '..', '..', 'lib', 'amd64');\n\t\t\tif (-e $amd64_dir) {\n\t\t\t\t$bits='64';\n\t\t\t}\n\n\t\t\tmy $sysinternals_dir = $ENV{'WINDOWS_SYSINTERNALS_ROOT'};\n\t\t\tmy $command \t = catfile(\"$sysinternals_dir\", \"procdump\" . $bits . \".exe\" );\n\t\t\tmy $dump_args \t = [\"-accepteula\", \"-ma\", $process->{pid}];\n\t\t\tmy $output_file  = $process->{logName} . \".jvmdump\";\n\n",
        "start_line": 914,
        "end_line": 1011,
        "chunk_index": 8,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 960,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704759"
      },
      "text": "\t\tinfo(\"Pausing for \" . $interval . \" seconds\");\t\t\t\t\t\n\t\tsleep $interval;\n\n\t\tif ($process->get_state eq \"completed\") {\n\t\t\tinfo(\"Process \" . $process->{mnemonic} . \" (pid \" . $process->{pid} . \") is no longer running. Abandoning dump collection.\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t$self->generate_OS_dumps($process);\n}\n\n#----------------------------------------------------------------------------------#\n# generate_process_diagnostics\n# \n# This subroutine generates process diagnostics.\n# On Windows it uses jcmd for J9 jdks if it is available, otherwise procdump,\n# to generate .DMP files. For the other platforms it uses kill signals to generate\n# javacore/core files.\n#\n# Usage:\n#  $self->generate_process_diagnostics($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub generate_process_diagnostics {\n    my ($self, $process) = @_;\n\tmy $platform = stf::stfUtility->getPlatform();\n\n\t# If on Windows and running an OpenJ9 jdk, use jcmd to generate .DMP files,\n\t# otherwise use procdump.exe.\n\t# If not on Windows try generating javacores using kill signals.\n\n\tif ($platform eq \"win\") {\n\t\tmy $java;\n\t\tmy $jcmd;\n\n\t\t$java = catfile($ENV{JAVA_HOME}, 'bin', 'java.exe');\n\t\t$jcmd = catfile($ENV{JAVA_HOME}, 'bin', 'jcmd.exe');\n\n\t\tmy %getJavaProperties_options = ();\n\t\t$getJavaProperties_options{'PATH'} = $command_line_options{$java};\n\t\t%java_properties = stf::stfUtility->getJavaProperties(%getJavaProperties_options);\n\n\t\tif (-f $jcmd && $java_properties{'java.vm.name'} =~ /J9/ ) {\n\t\t\t# Use jcmd to generate dumps\n\t\t\tinfo(\"Using jcmd.exe to generate .DMP files\");\n\t\t\tmy $command = catfile(\"$sysinternals_dir\", \"procdump\" . $bits . \".exe\" );\n\t\t\tmy $output_file = $process->{logName} . \".jvmdump\";\n\n\t\t\tmy $dump_args = [$process->{pid}, \"Dump.java\"];\n\t\t\t$self->start_process(\n\t\t\t\tmnemonic => \"JCMD1\",\n\t\t\t\tcommand  => $jcmd,\n\t\t\t\targs     => $dump_args,\n\t\t\t\techo\t => $TRUE,\n\t\t\t\tlogName  => $output_file\n\t\t\t);\n\n\t\t\t$dump_args = [$process->{pid}, \"Dump.system\"];\n\t\t\t$self->start_process(\n\t\t\t\tmnemonic => \"JCMD2\",\n\t\t\t\tcommand  => $jcmd,\n\t\t\t\targs     => $dump_args,\n\t\t\t\techo\t => $TRUE,\n\t\t\t\tlogName  => $output_file\n\t\t\t);\n\t\t} else {\n\t\t\t# Use procdump to generate dumps\n\t\t\t# procdump.exe only works on Vista or later\n\t\t\t# Best way to work this out appears to be the build number\n\t\t\t# Vista is 6000, so look for something smaller\n\t\t\t#   C:\\WINNT\\system32>wmic os get BuildNumber\n\t\t\t#   BuildNumber\n\t\t\t#   3790\n\t\t\tmy $output = `echo foo | wmic os get BuildNumber 2>&1`;\n\t\t\tif ($output =~ /BuildNumber[^0-9]+(\\d+)/s) {\n\t\t\t\tmy $buildNumber = $1;\n\t\t\t\tif ($buildNumber < 6000) {\n\t\t\t\t\tinfo(\"Not able to generate javacores/core files on Windows builds earlier than Vista\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t# Determine if we need to run the 32 or 64 bit version by looking at the java build\n\t\t\t# if the first java on the PATH has a jre/lib/AMD64 directory then run the 64bit version\n\t\t\tmy $bits = '';\n\t\t\tmy $amd64_dir = catfile($java, '..', '..', 'lib', 'amd64');\n\t\t\tif (-e $amd64_dir) {\n\t\t\t\t$bits='64';\n\t\t\t}\n\n\t\t\tmy $sysinternals_dir = $ENV{'WINDOWS_SYSINTERNALS_ROOT'};\n\t\t\tmy $command \t = catfile(\"$sysinternals_dir\", \"procdump\" . $bits . \".exe\" );\n\t\t\tmy $dump_args \t = [\"-accepteula\", \"-ma\", $process->{pid}];\n\t\t\tmy $output_file  = $process->{logName} . \".jvmdump\";\n\n"
    },
    "70": {
      "metadata": {
        "chunk_id": "1ce03b269d38cd98211779a2a333f60bf7a813565fe1fe1afd5bdff4667fd10f",
        "file_path": "stf.core/scripts/stf/Commands.pm",
        "content": "\t\t\tinfo(\"Using procdump.exe to generate .DMP files\");\n\t\t\t$self->start_process(\n\t\t\t\tmnemonic => \"PROC\",\n\t\t\t\tcommand  => $command,\n\t\t\t\targs     => $dump_args,\n\t\t\t\techo\t => $TRUE,\n\t\t\t\tlogName  => $output_file\n\t\t\t);\n\t\t}\n\t} else {\n  \t\tinfo(\"Sending SIG 3 to the java process to generate a javacore\");\n  \t\t$self->send_signal($process, 3);     \n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# generate_OS_dumps\n# \n# This subroutine generates OS core dumps on non-windows platforms.\n#\n# Usage:\n#  $self->generate_OS_dumps($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub generate_OS_dumps {\n    my ($self, $process) = @_;\n\tmy $platform = stf::stfUtility->getPlatform();\n\n\tif ($platform eq \"win\") {\n\t\treturn; # Currently there's no way of generating an OS core on Windows \n \t} else {\n     \tinfo(\"Sending SIGABRT (kill -6) to the java process to generate a core\");\n\t\t$self->send_signal($process, 6);\n\n\t\tinfo(\"Pausing for 30 seconds\");\t\t\n\t\tsleep 30;\n\n    \t# Add another level of kill.  If the generation of the javacore has hung, then the \n    \t# SIGABRT won't process, and we need to use the OS in order to generate a dump.\n    \tinfo(\"Sending SIGXCPU (kill -24) to the java process to generate an OS dump\");\n\t\t$self->send_signal($process, 24);\n   \t}\n}\n\n#----------------------------------------------------------------------------------#\n# send_signal\n# \n# This subroutine sends kill signals to a non-windows process.\n#\n# Usage:\n#  $self->send_signal($process, $signal);\n#\n# Arguments:\n#  $process = A process object\n#  $signal  = kill signal\n#----------------------------------------------------------------------------------#\nsub send_signal {\n    my ($self, $process, $signal) = @_;\t\n\tmy $command     = \"kill -\" . $signal . \" \" . $process->{pid};\n\tmy $output_file = $process->{logName} . \".kill_\" . $signal;\n\tmy $platform \t= stf::stfUtility->getPlatform();\n\n\tif ($platform ne \"win\") {\n\t   \t$self->start_process(\n\t\t\tmnemonic => \"KILL\",\n\t\t\tcommand  => $command,\n\t\t\techo     => $TRUE,\n\t\t\tlogName  => $output_file\n\t\t);\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# _heartbeat\n# \n# This is an internal subroutine used to produce an heartbeat message to stdout \n# indicating that process X is still running. \n#\n# Usage:\n#  _heartbeat($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub _heartbeat {\n    my $process = shift;\n\n  \tif ($heartbeat) {\n\t\tmy $timedif = $nextbeat - time;\n\n\t\tif ($timedif <= 0) {\n\t\t\t# autoflush the heart beat to prevent axxon timeouts, as windows + perl\n\t\t\t# sometimes buffers output\n\t\t\tlocal $| = 1;\n\t\t\tinfo(\"Heartbeat: Process $process->{uid} is still running\");\n\t\t\t$nextbeat = time + $heartbeat_period; #HEARTBEAT_PERIOD;\n\t\t}\n\t}\n}\n1;\n\n\n\n",
        "start_line": 1012,
        "end_line": 1117,
        "chunk_index": 9,
        "total_chunks": 10,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 729,
        "node_type": null,
        "file_sha": "08e100281346e42868327025379d36e372e0b7b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.704763"
      },
      "text": "\t\t\tinfo(\"Using procdump.exe to generate .DMP files\");\n\t\t\t$self->start_process(\n\t\t\t\tmnemonic => \"PROC\",\n\t\t\t\tcommand  => $command,\n\t\t\t\targs     => $dump_args,\n\t\t\t\techo\t => $TRUE,\n\t\t\t\tlogName  => $output_file\n\t\t\t);\n\t\t}\n\t} else {\n  \t\tinfo(\"Sending SIG 3 to the java process to generate a javacore\");\n  \t\t$self->send_signal($process, 3);     \n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# generate_OS_dumps\n# \n# This subroutine generates OS core dumps on non-windows platforms.\n#\n# Usage:\n#  $self->generate_OS_dumps($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub generate_OS_dumps {\n    my ($self, $process) = @_;\n\tmy $platform = stf::stfUtility->getPlatform();\n\n\tif ($platform eq \"win\") {\n\t\treturn; # Currently there's no way of generating an OS core on Windows \n \t} else {\n     \tinfo(\"Sending SIGABRT (kill -6) to the java process to generate a core\");\n\t\t$self->send_signal($process, 6);\n\n\t\tinfo(\"Pausing for 30 seconds\");\t\t\n\t\tsleep 30;\n\n    \t# Add another level of kill.  If the generation of the javacore has hung, then the \n    \t# SIGABRT won't process, and we need to use the OS in order to generate a dump.\n    \tinfo(\"Sending SIGXCPU (kill -24) to the java process to generate an OS dump\");\n\t\t$self->send_signal($process, 24);\n   \t}\n}\n\n#----------------------------------------------------------------------------------#\n# send_signal\n# \n# This subroutine sends kill signals to a non-windows process.\n#\n# Usage:\n#  $self->send_signal($process, $signal);\n#\n# Arguments:\n#  $process = A process object\n#  $signal  = kill signal\n#----------------------------------------------------------------------------------#\nsub send_signal {\n    my ($self, $process, $signal) = @_;\t\n\tmy $command     = \"kill -\" . $signal . \" \" . $process->{pid};\n\tmy $output_file = $process->{logName} . \".kill_\" . $signal;\n\tmy $platform \t= stf::stfUtility->getPlatform();\n\n\tif ($platform ne \"win\") {\n\t   \t$self->start_process(\n\t\t\tmnemonic => \"KILL\",\n\t\t\tcommand  => $command,\n\t\t\techo     => $TRUE,\n\t\t\tlogName  => $output_file\n\t\t);\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# _heartbeat\n# \n# This is an internal subroutine used to produce an heartbeat message to stdout \n# indicating that process X is still running. \n#\n# Usage:\n#  _heartbeat($process);\n#\n# Arguments:\n#  $process = A process object\n#----------------------------------------------------------------------------------#\nsub _heartbeat {\n    my $process = shift;\n\n  \tif ($heartbeat) {\n\t\tmy $timedif = $nextbeat - time;\n\n\t\tif ($timedif <= 0) {\n\t\t\t# autoflush the heart beat to prevent axxon timeouts, as windows + perl\n\t\t\t# sometimes buffers output\n\t\t\tlocal $| = 1;\n\t\t\tinfo(\"Heartbeat: Process $process->{uid} is still running\");\n\t\t\t$nextbeat = time + $heartbeat_period; #HEARTBEAT_PERIOD;\n\t\t}\n\t}\n}\n1;\n\n\n\n"
    },
    "71": {
      "metadata": {
        "chunk_id": "274261f92595b8c16a8786b7385025ae6456e9273fde79ae29087de5339c2029",
        "file_path": "stf.core/scripts/stf/Constants.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# This module contains constant definitions used in many other modules.\n\npackage stf::Constants;\n\nuse strict;\nuse warnings;\nuse Config;\n\nour @ISA = qw(Exporter);\nour @EXPORT = qw();\nour @EXPORT_OK = qw($ps $sl $SUCCESS $FAILURE $TRUE $FALSE); \nour %EXPORT_TAGS = (\tall => \\@EXPORT_OK,\n\t\t\t);\n\n# define booleans\nour $SUCCESS = 1;\nour $FAILURE = 0;\nour $TRUE    = 1;\nour $FALSE   = 0;\n\n1;\n\n\n",
        "start_line": 0,
        "end_line": 35,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 232,
        "node_type": null,
        "file_sha": "bb4ea654b180192507641a35aec10c1bf27e6873",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.711848"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# This module contains constant definitions used in many other modules.\n\npackage stf::Constants;\n\nuse strict;\nuse warnings;\nuse Config;\n\nour @ISA = qw(Exporter);\nour @EXPORT = qw();\nour @EXPORT_OK = qw($ps $sl $SUCCESS $FAILURE $TRUE $FALSE); \nour %EXPORT_TAGS = (\tall => \\@EXPORT_OK,\n\t\t\t);\n\n# define booleans\nour $SUCCESS = 1;\nour $FAILURE = 0;\nour $TRUE    = 1;\nour $FALSE   = 0;\n\n1;\n\n\n"
    },
    "72": {
      "metadata": {
        "chunk_id": "de25a2744de9aa20aa6957757488a7aeb1ac009618461e000698c05608686fda",
        "file_path": "stf.core/scripts/stf/ProcessMgmt.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt;\n\nuse strict;\n#use warnings;\nuse Cwd;\nuse Data::Dumper; # For debug\nuse File::Spec::Functions qw{catfile}; # For cat\nuse Time::Local; # For time functions\n\nuse stf::Constants qw(:all); # For $TRUE and $FALSE\nuse stf::stfUtility; # For log\nuse stf::Commands; # For start_process\n\n#Define some constants for state\nuse constant STATE_UNSTARTED => 1;\nuse constant STATE_STARTED => 2;\nuse constant STATE_COMPLETED => 3;\nuse constant STATE_ERROR => 4;\n\nour %STATE_DESCRIPTION = (STATE_UNSTARTED, 'unstarted',\n\t\t\t\t\t\t  STATE_STARTED, 'started',\n\t\t\t\t\t\t  STATE_COMPLETED, 'completed',\n\t\t\t\t\t\t  STATE_ERROR, 'error'\n);\n\n#Time of next heartbeat\nmy $nextbeat = time;\nmy $heartbeat_period = 300;\n\n#------------------------------------------------------------#\n# Constructor\n#------------------------------------------------------------#\nsub new {\n\tmy $class = shift;\n\tmy %args = @_;\n\n\t#This constructor is inherited by the subclasses. It performs two different functions\n\t#depending on the context it is called in.\n\t#\n\t#It either acts as a switch board, locating and loading the correct subclass to\n\t#be used on this platform or it is the constructor used for the subclasses\n\tif($class eq 'stf::ProcessMgmt') {\n\t\t#This is the base class constructor\n\t\t#Need to work out what platform I'm on and return an instance of the appropriate\n\t\t#sub class\n\n\t\tif($^O eq 'MSWin32') {\n\t\t\trequire stf::ProcessMgmt::Windows;\n\n\t\t\treturn new stf::ProcessMgmt::Windows(%args);\n\t\t}\n\t\telse {\n\t\t\trequire stf::ProcessMgmt::UNIX;\n\n\t\t\treturn new stf::ProcessMgmt::UNIX(%args);\t\t\t\n\t\t}\n\t}\n\telse {\n\t\t#This is the sub class constructor\n\n\t\t#Do some basic arguments parsing\n\t\tif(! defined($args{command})) {\n\t\t\tcroak(\"**Error** you didn't specify the command argument to the stf::ProcessMgmt constructor.\");\n\t\t}\n\n\t\tmy $self = \\%args;\n\n\t\tbless $self => $class;\n\n\t\t$self->_qualify_command();\n\n\t\t$self->{state} = STATE_UNSTARTED;\n\n\t\treturn $self;\n\t}\n}\n\n#------------------------------------------------------------#\n# _get_description_for_state\n# \n# Internal subroutine to get the description for a given state\n#------------------------------------------------------------#\nsub _get_description_for_state {\n\tmy $state = shift;\n\n\treturn $STATE_DESCRIPTION{$state};\n}\n\n#------------------------------------------------------------#\n# _touch_file\n# \n# Internal subroutine to touch a file\n#------------------------------------------------------------#\nsub _touch_file {\n\tmy ($self, $filename) = @_;\n\n\treturn if -f $filename;\n\n\topen(my $fh,'>',$filename) or die \"Could not touch file $filename: $!\";\n\n\tclose($fh);\n}\n\n",
        "start_line": 0,
        "end_line": 115,
        "chunk_index": 0,
        "total_chunks": 7,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 746,
        "node_type": null,
        "file_sha": "619bc12bbc1630fd7f9b2566c6a3478470758ed7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.717166"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt;\n\nuse strict;\n#use warnings;\nuse Cwd;\nuse Data::Dumper; # For debug\nuse File::Spec::Functions qw{catfile}; # For cat\nuse Time::Local; # For time functions\n\nuse stf::Constants qw(:all); # For $TRUE and $FALSE\nuse stf::stfUtility; # For log\nuse stf::Commands; # For start_process\n\n#Define some constants for state\nuse constant STATE_UNSTARTED => 1;\nuse constant STATE_STARTED => 2;\nuse constant STATE_COMPLETED => 3;\nuse constant STATE_ERROR => 4;\n\nour %STATE_DESCRIPTION = (STATE_UNSTARTED, 'unstarted',\n\t\t\t\t\t\t  STATE_STARTED, 'started',\n\t\t\t\t\t\t  STATE_COMPLETED, 'completed',\n\t\t\t\t\t\t  STATE_ERROR, 'error'\n);\n\n#Time of next heartbeat\nmy $nextbeat = time;\nmy $heartbeat_period = 300;\n\n#------------------------------------------------------------#\n# Constructor\n#------------------------------------------------------------#\nsub new {\n\tmy $class = shift;\n\tmy %args = @_;\n\n\t#This constructor is inherited by the subclasses. It performs two different functions\n\t#depending on the context it is called in.\n\t#\n\t#It either acts as a switch board, locating and loading the correct subclass to\n\t#be used on this platform or it is the constructor used for the subclasses\n\tif($class eq 'stf::ProcessMgmt') {\n\t\t#This is the base class constructor\n\t\t#Need to work out what platform I'm on and return an instance of the appropriate\n\t\t#sub class\n\n\t\tif($^O eq 'MSWin32') {\n\t\t\trequire stf::ProcessMgmt::Windows;\n\n\t\t\treturn new stf::ProcessMgmt::Windows(%args);\n\t\t}\n\t\telse {\n\t\t\trequire stf::ProcessMgmt::UNIX;\n\n\t\t\treturn new stf::ProcessMgmt::UNIX(%args);\t\t\t\n\t\t}\n\t}\n\telse {\n\t\t#This is the sub class constructor\n\n\t\t#Do some basic arguments parsing\n\t\tif(! defined($args{command})) {\n\t\t\tcroak(\"**Error** you didn't specify the command argument to the stf::ProcessMgmt constructor.\");\n\t\t}\n\n\t\tmy $self = \\%args;\n\n\t\tbless $self => $class;\n\n\t\t$self->_qualify_command();\n\n\t\t$self->{state} = STATE_UNSTARTED;\n\n\t\treturn $self;\n\t}\n}\n\n#------------------------------------------------------------#\n# _get_description_for_state\n# \n# Internal subroutine to get the description for a given state\n#------------------------------------------------------------#\nsub _get_description_for_state {\n\tmy $state = shift;\n\n\treturn $STATE_DESCRIPTION{$state};\n}\n\n#------------------------------------------------------------#\n# _touch_file\n# \n# Internal subroutine to touch a file\n#------------------------------------------------------------#\nsub _touch_file {\n\tmy ($self, $filename) = @_;\n\n\treturn if -f $filename;\n\n\topen(my $fh,'>',$filename) or die \"Could not touch file $filename: $!\";\n\n\tclose($fh);\n}\n\n"
    },
    "73": {
      "metadata": {
        "chunk_id": "7275c7f6764abd00701c3246e5e9afc77aefb7d36d74e1d4415c5b788d25dcb5",
        "file_path": "stf.core/scripts/stf/ProcessMgmt.pm",
        "content": "#------------------------------------------------------------#\n# monitorProcess\n#\n# External subroutine thats monitors a process for dumps and checks if it overruns\n#\n# Usage:\n#\t($elapsed, $results) = monitorProcess($process, $results)\n#\n# Arguments:\n#\t$process    = the process\n#\t%results    = (status => $status, javacore => @javacore, drwatson =>\n#                   @drwatson, core => @core, heap => @heap, snap => @snap)\n#\n# Returns:\n#\t$elapsed    = the test elapsed time\n#\t%results    = (status => $status, \t\t= flag indicating if the monitor found dumps\n#\t\t\t\t\tjavacore => @javacore,\t= array of javacore files (if found) \n#\t\t\t\t\tdrwatson => @drwatson,\t= array of the drwatson files (if found\n#\t\t\t\t\tcore => @core,\t\t\t= array of the core/user.dmp files (if found)\n#\t\t\t\t\theap => @heap,\t\t\t= array of the heap files (if found)\n#\t\t\t\t\tsnap => @snap)\t\t\t= array of the snap files (if found)\n#\n# Notes:\n#\tThe process object is expected to have the following attributes set:\n#\n#\t$command    = The command the process is running\n#\t$runtime    = Optional, the expected test runtime in minutes, if set, the process \"timeout\"\n#                 attribute will be set to 1 after the runtime elapsed\n#\t$starttime  = The time the process began\n#\t$rename     = Optional, rename dumps if set to 1, default to 0\n#\t$coredir    = Optional, the directory where the core files are written, default logdir\n#\t$logdir     = The directory where the results are written\n#\t$uid        = Optional, process unique id, default pid\n#\t$heartbeat  = Optional, default to 0\n#\t$stderr     = The process stderr\n#\t$moveTDUMP  = Optional, default to 0 but set to 1 if on ZOs\n#------------------------------------------------------------#\nsub monitorProcess {\n\t# print Dumper(\\@_);\n\n\tmy ($self, $p, %results) = @_;\n\n\t# Interpret the process object attributes\n\n\tmy $stderr = $p->{stderr};\n\n\tmy $command = $p->{command};\n\n\tmy $runtime = $p->{runtime};\n\n\tmy $starttime = $p->{starttime};\n\n\tmy $monitorDumps;\n\tif (defined $p->{monitorDumps}) {\n\t\t$monitorDumps = $p->{monitorDumps};\n\t} else {\n\t\t$monitorDumps = $TRUE;\n\t}\n\n\tmy $rename;\n\tif (defined $p->{rename}) {\n\t\t$rename = $p->{rename};\n\t} else {\n\t\t$rename = $FALSE;\n\t}\n\n\tmy $coredir;\n\tif (defined $p->{coredir}) {\n\t\t$coredir = $p->{coredir};\n\t} else {\n\t\t$coredir = $p->{logdir};\n\t}\n\n\tmy $logdir;\n\tif (defined $p->{logdir}) {\n\t\t$logdir = $p->{logdir};\n\t} else {\n\t\tdie \"The process must define a logdir directory.\";\n\t}\n\n\tmy $uid;\n\tif (defined $p->{uid}) {\n\t\t$uid = $p->{uid};\n\t} else {\n\t\t# Use process pid as a unique identifier\n\t\t$uid = $p->{pid};\n\t}\n\n\tmy $heartbeat;\n\tif (defined $p->{heartbeat}) {\n\t\t$heartbeat = $p->{heartbeat};\n\t} else {\n\t\t$heartbeat = $FALSE;\n\t}\n\n\tmy $elapsed = timelocal( localtime() ) - $starttime;\n\n\tunless($p->poll()) {\n\t\t# Leave earlier if the process has completed and been triaged\n\t\treturn ($elapsed, %results) if ((_get_description_for_state($p->{state}) eq \"completed\") && $p->{triaged});\n\t}\n\n\tif ($monitorDumps) {\n\t\tmy $any_dumps_found = $FALSE; \n\n\t\t# Look for cross platform dumps\n\t\tforeach my $dump_type (\"javacore\", \"core\", \"heap\", \"snap\") {\n\t\t\tmy $dump_file = $dump_type;\n\n\t\t\t$dump_file = \"heapdump\" if ($dump_type eq \"heap\");\n\t\t\t$dump_file = \"Snap\" \tif ($dump_type eq \"snap\");\n\n",
        "start_line": 116,
        "end_line": 228,
        "chunk_index": 1,
        "total_chunks": 7,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 950,
        "node_type": null,
        "file_sha": "619bc12bbc1630fd7f9b2566c6a3478470758ed7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.717173"
      },
      "text": "#------------------------------------------------------------#\n# monitorProcess\n#\n# External subroutine thats monitors a process for dumps and checks if it overruns\n#\n# Usage:\n#\t($elapsed, $results) = monitorProcess($process, $results)\n#\n# Arguments:\n#\t$process    = the process\n#\t%results    = (status => $status, javacore => @javacore, drwatson =>\n#                   @drwatson, core => @core, heap => @heap, snap => @snap)\n#\n# Returns:\n#\t$elapsed    = the test elapsed time\n#\t%results    = (status => $status, \t\t= flag indicating if the monitor found dumps\n#\t\t\t\t\tjavacore => @javacore,\t= array of javacore files (if found) \n#\t\t\t\t\tdrwatson => @drwatson,\t= array of the drwatson files (if found\n#\t\t\t\t\tcore => @core,\t\t\t= array of the core/user.dmp files (if found)\n#\t\t\t\t\theap => @heap,\t\t\t= array of the heap files (if found)\n#\t\t\t\t\tsnap => @snap)\t\t\t= array of the snap files (if found)\n#\n# Notes:\n#\tThe process object is expected to have the following attributes set:\n#\n#\t$command    = The command the process is running\n#\t$runtime    = Optional, the expected test runtime in minutes, if set, the process \"timeout\"\n#                 attribute will be set to 1 after the runtime elapsed\n#\t$starttime  = The time the process began\n#\t$rename     = Optional, rename dumps if set to 1, default to 0\n#\t$coredir    = Optional, the directory where the core files are written, default logdir\n#\t$logdir     = The directory where the results are written\n#\t$uid        = Optional, process unique id, default pid\n#\t$heartbeat  = Optional, default to 0\n#\t$stderr     = The process stderr\n#\t$moveTDUMP  = Optional, default to 0 but set to 1 if on ZOs\n#------------------------------------------------------------#\nsub monitorProcess {\n\t# print Dumper(\\@_);\n\n\tmy ($self, $p, %results) = @_;\n\n\t# Interpret the process object attributes\n\n\tmy $stderr = $p->{stderr};\n\n\tmy $command = $p->{command};\n\n\tmy $runtime = $p->{runtime};\n\n\tmy $starttime = $p->{starttime};\n\n\tmy $monitorDumps;\n\tif (defined $p->{monitorDumps}) {\n\t\t$monitorDumps = $p->{monitorDumps};\n\t} else {\n\t\t$monitorDumps = $TRUE;\n\t}\n\n\tmy $rename;\n\tif (defined $p->{rename}) {\n\t\t$rename = $p->{rename};\n\t} else {\n\t\t$rename = $FALSE;\n\t}\n\n\tmy $coredir;\n\tif (defined $p->{coredir}) {\n\t\t$coredir = $p->{coredir};\n\t} else {\n\t\t$coredir = $p->{logdir};\n\t}\n\n\tmy $logdir;\n\tif (defined $p->{logdir}) {\n\t\t$logdir = $p->{logdir};\n\t} else {\n\t\tdie \"The process must define a logdir directory.\";\n\t}\n\n\tmy $uid;\n\tif (defined $p->{uid}) {\n\t\t$uid = $p->{uid};\n\t} else {\n\t\t# Use process pid as a unique identifier\n\t\t$uid = $p->{pid};\n\t}\n\n\tmy $heartbeat;\n\tif (defined $p->{heartbeat}) {\n\t\t$heartbeat = $p->{heartbeat};\n\t} else {\n\t\t$heartbeat = $FALSE;\n\t}\n\n\tmy $elapsed = timelocal( localtime() ) - $starttime;\n\n\tunless($p->poll()) {\n\t\t# Leave earlier if the process has completed and been triaged\n\t\treturn ($elapsed, %results) if ((_get_description_for_state($p->{state}) eq \"completed\") && $p->{triaged});\n\t}\n\n\tif ($monitorDumps) {\n\t\tmy $any_dumps_found = $FALSE; \n\n\t\t# Look for cross platform dumps\n\t\tforeach my $dump_type (\"javacore\", \"core\", \"heap\", \"snap\") {\n\t\t\tmy $dump_file = $dump_type;\n\n\t\t\t$dump_file = \"heapdump\" if ($dump_type eq \"heap\");\n\t\t\t$dump_file = \"Snap\" \tif ($dump_type eq \"snap\");\n\n"
    },
    "74": {
      "metadata": {
        "chunk_id": "7aa4b6c8ec3ee7769a54707ae11e68d710ae27775b00e3bb4836b9b387d5e822",
        "file_path": "stf.core/scripts/stf/ProcessMgmt.pm",
        "content": "\t\t\ttrace(\"Checking for undetected \" . $dump_file .\" files\");\n\t\t\t($any_dumps_found, $results{$dump_type}) = stf::ProcessMgmt->detectDumpFile(\n\t\t\t\t$results{$dump_type},\t\t\n\t\t\t\t$logdir,\n\t\t\t\t$dump_file,\t\n\t\t\t\t$stderr,            \n\t\t\t\t$any_dumps_found, \n\t\t\t\t$rename\n\t\t\t);\n\t\t}\n\n\t\t# Look for platform specific dumps\n\t\tif ($^O eq 'os390') {\n\t\t\ttrace(\"Checking for undetected CEEDUMP files\");\n\t\t\t($any_dumps_found, $results{ceedump}) = stf::ProcessMgmt->detectDumpFile(\n\t\t\t\t$results{ceedump},\t\t\n\t\t\t\t$logdir,\n\t\t\t\t\"CEEDUMP\",\t\n\t\t\t\t$stderr,            \n\t\t\t\t$any_dumps_found, \n\t\t\t\t$rename\n\t\t\t);\n\t\t\ttrace(\"Checking for undetected TDUMP files\");\n\t\t\t($any_dumps_found, $results{tdump}) = stf::ProcessMgmt->detectDumpFile(\n\t\t\t\t$results{tdump},\t\t\n\t\t\t\t$logdir,\n\t\t\t\t\"TDUMP\",\t\n\t\t\t\t$stderr,            \n\t\t\t\t$any_dumps_found, \n\t\t\t\t$rename\n\t\t\t);\n\t\t} elsif ($^O eq 'MSWin32') {\n\t\t\ttrace(\"checking for undetected dr watson files\");\n\t\t\t($any_dumps_found, $results{drwatson}) = stf::ProcessMgmt->detectDumpFile(\n\t\t\t\t$results{drwatson},\t\t\n\t\t\t\t$logdir,\n\t\t\t\t\"drwtsn32\",\t\n\t\t\t\t$stderr,            \n\t\t\t\t$any_dumps_found, \n\t\t\t\t$rename\n\t\t\t);\n\t\t}\n\n\t\tif ($any_dumps_found) {\n\t\t\t$p->{dump_found} = $TRUE;\n\t\t}\n\t}\n\n\t# Check if the process has timed out\n\tif ($runtime) {\n\t\tif ($elapsed > $runtime) {\n\t\t\t$p->{timeout} = $TRUE;\n\n\t\t\terr(\"**FAILED** Process $p->{uid} has timed out\");\n\n\t\t\t$results{status} = $FAILURE;\n\t\t}\n\t}\n\n\t# Check if the process has hung\n\tif (defined $p->{hung} && $p->{hung} == $TRUE) {\n\t\terr(\"**FAILED** Process $p->{uid} has hung\");\n\n\t\t$results{status} = $FAILURE;\n\t}\n\n\t# if heartbeat is $TRUE then beat ever 5 minutes and print time stamp\n  \tif ($heartbeat) {\n\t\tmy $timedif = $nextbeat - time;\n\t\tif ($timedif <= 0) {\n\t\t\t# autoflush the heart beat to prevent axxon timeouts, as windows + perl\n\t\t\t# sometimes buffers output\n\t\t\tlocal $| = 1;\n\n\t\t\twarn(\"Heart-beat. Java process is still running.\");\n\t\t\t$nextbeat = time + $heartbeat_period; #HEARTBEAT_PERIOD;\n\t\t}\n\t}\n\n\t# Triage a completed process\n\tif (_get_description_for_state($p->{state}) eq \"completed\") {\n\t\tdebug(\"Triaging process $p->{uid}...\");\n\n\t\tif (defined $p->{expectedOutcome} && $p->{expectedOutcome} eq \"never\") {\n\t\t\terr(\"**FAILED** Process $p->{uid} has ended unexpectedly\");\n\n\t\t\t$results{status} = $FAILURE;\n\t\t}\n\n\t\t# Ensure that a process that is expected to crash has indeed crashed.\n\t\tif (defined $p->{expectedOutcome} && $p->{expectedOutcome} eq \"crashes\" && $p->{dump_found} == $FALSE) {\n\t\t\terr(\"**FAILED** Process $p->{uid} was expected to crash but no dumps were found!\");\n\n\t\t\t$results{status} = $FAILURE;\n\t\t}\n\n\t\t# Check if the process exited with the expected exit code.\n\t\tif (defined $p->{expectedOutcome} && $p->{expectedOutcome} =~ \"exitValue:\") {\n\t\t\t(my $expected_exit_codes = $p->{expectedOutcome}) =~ s/exitValue:/$1/g;\n\n\t\t\t# Get the real exit code\t\n\t\t\tmy $exit_code =  $p->get_result()->exit_code();\n\n\t\t\t# We may be given an expected exit code or a list of expected exit codes\n\t\t\tmy @codes = split(',', $expected_exit_codes);\n\t\t\tmy $expected_exit_code_met;\n\t\t\tforeach my $expected_exit_code (@codes) {\n\t\t\t\t$expected_exit_code_met = 1 if ($exit_code == $expected_exit_code);\n\t\t\t}\n\n",
        "start_line": 229,
        "end_line": 339,
        "chunk_index": 2,
        "total_chunks": 7,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 968,
        "node_type": null,
        "file_sha": "619bc12bbc1630fd7f9b2566c6a3478470758ed7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.717176"
      },
      "text": "\t\t\ttrace(\"Checking for undetected \" . $dump_file .\" files\");\n\t\t\t($any_dumps_found, $results{$dump_type}) = stf::ProcessMgmt->detectDumpFile(\n\t\t\t\t$results{$dump_type},\t\t\n\t\t\t\t$logdir,\n\t\t\t\t$dump_file,\t\n\t\t\t\t$stderr,            \n\t\t\t\t$any_dumps_found, \n\t\t\t\t$rename\n\t\t\t);\n\t\t}\n\n\t\t# Look for platform specific dumps\n\t\tif ($^O eq 'os390') {\n\t\t\ttrace(\"Checking for undetected CEEDUMP files\");\n\t\t\t($any_dumps_found, $results{ceedump}) = stf::ProcessMgmt->detectDumpFile(\n\t\t\t\t$results{ceedump},\t\t\n\t\t\t\t$logdir,\n\t\t\t\t\"CEEDUMP\",\t\n\t\t\t\t$stderr,            \n\t\t\t\t$any_dumps_found, \n\t\t\t\t$rename\n\t\t\t);\n\t\t\ttrace(\"Checking for undetected TDUMP files\");\n\t\t\t($any_dumps_found, $results{tdump}) = stf::ProcessMgmt->detectDumpFile(\n\t\t\t\t$results{tdump},\t\t\n\t\t\t\t$logdir,\n\t\t\t\t\"TDUMP\",\t\n\t\t\t\t$stderr,            \n\t\t\t\t$any_dumps_found, \n\t\t\t\t$rename\n\t\t\t);\n\t\t} elsif ($^O eq 'MSWin32') {\n\t\t\ttrace(\"checking for undetected dr watson files\");\n\t\t\t($any_dumps_found, $results{drwatson}) = stf::ProcessMgmt->detectDumpFile(\n\t\t\t\t$results{drwatson},\t\t\n\t\t\t\t$logdir,\n\t\t\t\t\"drwtsn32\",\t\n\t\t\t\t$stderr,            \n\t\t\t\t$any_dumps_found, \n\t\t\t\t$rename\n\t\t\t);\n\t\t}\n\n\t\tif ($any_dumps_found) {\n\t\t\t$p->{dump_found} = $TRUE;\n\t\t}\n\t}\n\n\t# Check if the process has timed out\n\tif ($runtime) {\n\t\tif ($elapsed > $runtime) {\n\t\t\t$p->{timeout} = $TRUE;\n\n\t\t\terr(\"**FAILED** Process $p->{uid} has timed out\");\n\n\t\t\t$results{status} = $FAILURE;\n\t\t}\n\t}\n\n\t# Check if the process has hung\n\tif (defined $p->{hung} && $p->{hung} == $TRUE) {\n\t\terr(\"**FAILED** Process $p->{uid} has hung\");\n\n\t\t$results{status} = $FAILURE;\n\t}\n\n\t# if heartbeat is $TRUE then beat ever 5 minutes and print time stamp\n  \tif ($heartbeat) {\n\t\tmy $timedif = $nextbeat - time;\n\t\tif ($timedif <= 0) {\n\t\t\t# autoflush the heart beat to prevent axxon timeouts, as windows + perl\n\t\t\t# sometimes buffers output\n\t\t\tlocal $| = 1;\n\n\t\t\twarn(\"Heart-beat. Java process is still running.\");\n\t\t\t$nextbeat = time + $heartbeat_period; #HEARTBEAT_PERIOD;\n\t\t}\n\t}\n\n\t# Triage a completed process\n\tif (_get_description_for_state($p->{state}) eq \"completed\") {\n\t\tdebug(\"Triaging process $p->{uid}...\");\n\n\t\tif (defined $p->{expectedOutcome} && $p->{expectedOutcome} eq \"never\") {\n\t\t\terr(\"**FAILED** Process $p->{uid} has ended unexpectedly\");\n\n\t\t\t$results{status} = $FAILURE;\n\t\t}\n\n\t\t# Ensure that a process that is expected to crash has indeed crashed.\n\t\tif (defined $p->{expectedOutcome} && $p->{expectedOutcome} eq \"crashes\" && $p->{dump_found} == $FALSE) {\n\t\t\terr(\"**FAILED** Process $p->{uid} was expected to crash but no dumps were found!\");\n\n\t\t\t$results{status} = $FAILURE;\n\t\t}\n\n\t\t# Check if the process exited with the expected exit code.\n\t\tif (defined $p->{expectedOutcome} && $p->{expectedOutcome} =~ \"exitValue:\") {\n\t\t\t(my $expected_exit_codes = $p->{expectedOutcome}) =~ s/exitValue:/$1/g;\n\n\t\t\t# Get the real exit code\t\n\t\t\tmy $exit_code =  $p->get_result()->exit_code();\n\n\t\t\t# We may be given an expected exit code or a list of expected exit codes\n\t\t\tmy @codes = split(',', $expected_exit_codes);\n\t\t\tmy $expected_exit_code_met;\n\t\t\tforeach my $expected_exit_code (@codes) {\n\t\t\t\t$expected_exit_code_met = 1 if ($exit_code == $expected_exit_code);\n\t\t\t}\n\n"
    },
    "75": {
      "metadata": {
        "chunk_id": "965d504e1e3951a5eb2053ce0b5c04514f301ff0c3b74a7b9950b2cf5627a002",
        "file_path": "stf.core/scripts/stf/ProcessMgmt.pm",
        "content": "\t\t\tunless ($expected_exit_code_met) {\n\t\t\t\terr(\"**FAILED** Process $p->{uid} ended with exit code ($exit_code) and not the expected exit code/s ($expected_exit_codes)\");\n\n\t\t\t\t$results{status} = $FAILURE;\n\t\t\t}\n\t\t}\n\n\t\t# We only want to triage a process after completion once so that we dont \n\t\t# waste resources monitoring processes that have already completed\n\t\t$p->{triaged} = $TRUE;\n\t}\n\n\treturn ($elapsed, %results);\n}\n\n#------------------------------------------------------------#\n# detectDumpFile\n#\n# Internal subroutine that moves and renames the dump files (of type specified) \n# to the specified directory\n#\n# Usage:\n#\t($status, $newdump) = detectDumpFile($dumps, $homedir, $dumptype, $stderr, $status, $rename)\n#\n# Arguments:\n#\n#\t$dumps      = dump array\n#\t$homedir    = the directory where the dumps are created\n#\t$dumptype   = the type of dumpfile (core, javacore, drwtsn32, user.dmp)\n#\t$stderr     = the stderr log\n#\t$status     = the current status\n#\t$rename     = $TRUE/$FALSE\n#\n# Returns:\n#\t$status     = the new status\n#\t$newdump    = the name of the dump moved\n#\n# Notes:\n#\tThis function is intended to be used only by other functions in this module.\n#------------------------------------------------------------#\nsub detectDumpFile {\n\t#print Dumper(\\@_);\n\n\tmy ($self, $dumps, $homedir, $dumptype, $stderr, $any_dumps_found, $rename) = @_;\n\n\tmy $cwd      = getcwd();\n\tmy $now      = stf::stfUtility->getNow();\n\tmy $newdump  = \"\";\n\tmy @dumplist = ();\n\n\t# change to the directory we expect the files in\n\tchdir $homedir;\n\n\tif ($dumptype eq \"TDUMP\") {\t\n\t\t\tdebug(\"log file name to scan for tdumps is: \" . $stderr);\n\n\t\t\t# Use a hash to ensure that each tdump is only dealt with once\n\t\t\tmy %parsedNames = ();\n\n\t\t\tmy $file = stf::stfUtility->readFileIntoArray($stderr);\n\t    \tmy $tdump;\t\n\t    \tforeach my $line (@{$file}) {\n\t\t\t   \tif ($line =~ /IEATDUMP success for DSN=/ or $line =~ /IEATDUMP failure for DSN=/) {\n\t\t    \t\t($tdump) = $line =~ /DSN='(.*)'/;\n\n\t\t    \t\t$parsedNames{$tdump} = 1; \n\t\t\t\t}\n\t\t\t}\n\n\t\tpush(@dumplist, keys(%parsedNames));\n\t}\n\telse {\n\t\t# The JVM creates its core using the system core and then renames it, \n\t\t# so we don't want to detect these before they are renamed. To achieve\n\t\t# this look for a core with dmp at the end, as the raw core is just \"core\".\n\t\tmy $globLine ;\n\t\tif ($dumptype eq \"core\") {\n\t\t\t$globLine = catfile($homedir,\"${dumptype}*dmp\");\n\t\t}\n\t\telse {\n\t\t\t$globLine = catfile($homedir,\"${dumptype}*\");\n\t\t}\n\n\t\t$globLine =~ s/\\s/\\?/g; #replace any spaces in the path.\n\t\tmy @dumpNames = glob(\"${globLine}\");\n\n\t\t# The dump names above are not fully qualified path names but those in @dumps are\n\t\t# Correct this here by adding on the full directory path\t\n\t\tforeach my $dump (@dumpNames) {\n\t\t\t#$dump = catfile($homedir, $dump); #No need to correct, they now already have the homedir in place.\n\t\t\tpush (@dumplist, $dump);\n\t\t}\n\t}\n\n\t# Create a hash of the dumps already detected and processed on previous runs using the passed $dumps array ref\n\tmy %alreadyDetected;\n\tforeach my $dump (@{$dumps}) { \n\t\t$alreadyDetected{$dump} = $TRUE;\n\t}\n\n\t# Ignore the dumps we already knew about and create a list of the new ones\n\tmy @newDumps;\n\tforeach my $detectedDump (@dumplist) {\n\t\tif(!$alreadyDetected{$detectedDump}) {\n\t\t\tpush(@newDumps, $detectedDump);\n\t\t}\n\t}\n\n",
        "start_line": 340,
        "end_line": 448,
        "chunk_index": 3,
        "total_chunks": 7,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 974,
        "node_type": null,
        "file_sha": "619bc12bbc1630fd7f9b2566c6a3478470758ed7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.717178"
      },
      "text": "\t\t\tunless ($expected_exit_code_met) {\n\t\t\t\terr(\"**FAILED** Process $p->{uid} ended with exit code ($exit_code) and not the expected exit code/s ($expected_exit_codes)\");\n\n\t\t\t\t$results{status} = $FAILURE;\n\t\t\t}\n\t\t}\n\n\t\t# We only want to triage a process after completion once so that we dont \n\t\t# waste resources monitoring processes that have already completed\n\t\t$p->{triaged} = $TRUE;\n\t}\n\n\treturn ($elapsed, %results);\n}\n\n#------------------------------------------------------------#\n# detectDumpFile\n#\n# Internal subroutine that moves and renames the dump files (of type specified) \n# to the specified directory\n#\n# Usage:\n#\t($status, $newdump) = detectDumpFile($dumps, $homedir, $dumptype, $stderr, $status, $rename)\n#\n# Arguments:\n#\n#\t$dumps      = dump array\n#\t$homedir    = the directory where the dumps are created\n#\t$dumptype   = the type of dumpfile (core, javacore, drwtsn32, user.dmp)\n#\t$stderr     = the stderr log\n#\t$status     = the current status\n#\t$rename     = $TRUE/$FALSE\n#\n# Returns:\n#\t$status     = the new status\n#\t$newdump    = the name of the dump moved\n#\n# Notes:\n#\tThis function is intended to be used only by other functions in this module.\n#------------------------------------------------------------#\nsub detectDumpFile {\n\t#print Dumper(\\@_);\n\n\tmy ($self, $dumps, $homedir, $dumptype, $stderr, $any_dumps_found, $rename) = @_;\n\n\tmy $cwd      = getcwd();\n\tmy $now      = stf::stfUtility->getNow();\n\tmy $newdump  = \"\";\n\tmy @dumplist = ();\n\n\t# change to the directory we expect the files in\n\tchdir $homedir;\n\n\tif ($dumptype eq \"TDUMP\") {\t\n\t\t\tdebug(\"log file name to scan for tdumps is: \" . $stderr);\n\n\t\t\t# Use a hash to ensure that each tdump is only dealt with once\n\t\t\tmy %parsedNames = ();\n\n\t\t\tmy $file = stf::stfUtility->readFileIntoArray($stderr);\n\t    \tmy $tdump;\t\n\t    \tforeach my $line (@{$file}) {\n\t\t\t   \tif ($line =~ /IEATDUMP success for DSN=/ or $line =~ /IEATDUMP failure for DSN=/) {\n\t\t    \t\t($tdump) = $line =~ /DSN='(.*)'/;\n\n\t\t    \t\t$parsedNames{$tdump} = 1; \n\t\t\t\t}\n\t\t\t}\n\n\t\tpush(@dumplist, keys(%parsedNames));\n\t}\n\telse {\n\t\t# The JVM creates its core using the system core and then renames it, \n\t\t# so we don't want to detect these before they are renamed. To achieve\n\t\t# this look for a core with dmp at the end, as the raw core is just \"core\".\n\t\tmy $globLine ;\n\t\tif ($dumptype eq \"core\") {\n\t\t\t$globLine = catfile($homedir,\"${dumptype}*dmp\");\n\t\t}\n\t\telse {\n\t\t\t$globLine = catfile($homedir,\"${dumptype}*\");\n\t\t}\n\n\t\t$globLine =~ s/\\s/\\?/g; #replace any spaces in the path.\n\t\tmy @dumpNames = glob(\"${globLine}\");\n\n\t\t# The dump names above are not fully qualified path names but those in @dumps are\n\t\t# Correct this here by adding on the full directory path\t\n\t\tforeach my $dump (@dumpNames) {\n\t\t\t#$dump = catfile($homedir, $dump); #No need to correct, they now already have the homedir in place.\n\t\t\tpush (@dumplist, $dump);\n\t\t}\n\t}\n\n\t# Create a hash of the dumps already detected and processed on previous runs using the passed $dumps array ref\n\tmy %alreadyDetected;\n\tforeach my $dump (@{$dumps}) { \n\t\t$alreadyDetected{$dump} = $TRUE;\n\t}\n\n\t# Ignore the dumps we already knew about and create a list of the new ones\n\tmy @newDumps;\n\tforeach my $detectedDump (@dumplist) {\n\t\tif(!$alreadyDetected{$detectedDump}) {\n\t\t\tpush(@newDumps, $detectedDump);\n\t\t}\n\t}\n\n"
    },
    "76": {
      "metadata": {
        "chunk_id": "60bcfd18960c52b19db78b2ab1e0de2d2795c9868df3830d9aab1a7995bea2f6",
        "file_path": "stf.core/scripts/stf/ProcessMgmt.pm",
        "content": "\tmy $newlyFoundDumps   = scalar(@newDumps);\n\tmy $existingDumpCount = scalar(@{$dumps});\n\n\t# Now check if we have found any new dumps\n\tif ($newlyFoundDumps ne 0) {\n\t\t$any_dumps_found = $TRUE;\n\t\tdebug(\"DetectDumps given [\".$existingDumpCount.\"] $dumptype dumps and found [\".$newlyFoundDumps.\"] additional undetected $dumptype dumps.\");\n\t} else {\n\t\tchdir $cwd;\n\t\treturn ($any_dumps_found, $dumps);\n\t}\n\n\tif ($dumptype eq \"TDUMP\") {\n\t\t# On ZOs TDUMPS are saved outside the Unix layer\n\t\t# moveTDUMPS will attempt to move them to the file system\n  \t\t$self->moveTDUMPS($stderr, $homedir, \\@newDumps);\n\n  \t\tforeach my $dump (@newDumps) {\t\n  \t\t\tif (grep(/\\Q${dump}\\E/, @{$dumps}) == 0) {\n\t\t\t\tpush( @{$dumps}, $dump );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tforeach my $dump (@newDumps) {\t\t\n\t\t\tif (-e $dump) {\n\t\t\t\twarn(\"Found dump at: $dump\");\n\t\t\t} else {\n\t\t\t\terr(\"Found a dump that doesn't exist: $dump\");\n\t\t\t}\n\n\t\t\t$newdump = $dump;\n\n\t\t\tif (($rename == $TRUE) and ($dump =~ /$dumptype\\.\\D/ or $dump =~ /$dumptype/)) {\n\t\t\t\tmy ($n, $p, $t) = fileparse( $dump, '\\.[\\w\\-\\+]*' );\n\n\t\t\t\t$newdump = catfile( $homedir, \"${n}_${now}${t}\" );\n\n\t\t\t\tmy $cnt = 0;\n\t\t\t\twhile ((-e $dump) and ($cnt < 90)) {\n\t\t\t\t\trename( $dump, $newdump );\n\n\t\t\t\t\tsleep 10;\n\n\t\t\t\t\t$cnt++;\n\t\t\t\t}\n\n\t\t\t\tif (-e $dump) {\n\t\t\t\t\t$newdump = $dump;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstf::stfUtility->writeToFile (\n\t\t\t\t\t\t\t file    => $stderr,\n\t\t\t\t\t\t\t content => [\"${dumptype} file generated - ${newdump}\"],\n\t\t\t\t\t\t\t replace => $FALSE\n\t\t\t);\n\n\t\t\tif (grep(/\\Q${newdump}\\E/, @{$dumps}) == 0) {\n\t\t\t\tpush( @{$dumps}, $newdump );\n\t\t\t}\n\t\t}\n\t}\n\n\tchdir $cwd;\n\treturn ($any_dumps_found, $dumps);\n}\n\n#------------------------------------------------------------#\n# moveTDUMPS\n#\n# Internal subroutine that searches through the file looking for evidence of a TDUMP\n# and then attempts to move the TDUMP and any multiple dumps associated, returning an \n# array of all the dumpes moved. Can also take a list of known dump names.\n#\n# Usage:\n#  @dumplist = moveTDUMPS($filePath, $moveLocation, $dumpref, $joinDumps)\n#\n# Arguments:\n#\t$filePath = either a log file name or an array ref of log file names\n#\t            These will be scanned for IEATDUMP messages (can be null)\n#\t$moveLocation = the directory to move the dumps to\n#\t$dumpref = an array reference containing names of dumps to be moved (can be null)\n#\t$joinDumps = if true, then multi-part tdumps will be joined into a single part.\n#\n# Returns:\n#\t@dumplist = an array of dumps names found\n#\n# Notes:\n#\tThis function is intended to be used only by other functions in this module.\n#------------------------------------------------------------#\nsub moveTDUMPS {\n\tmy ($self, $stderr, $moveLocation, $dumpref, $joinDumps) = @_;\n\n\ttrace(\"moveTDUMPS subroutine - \\@_ : \" . Dumper(\\@_));\n\tdebug(\"Moving the TDUMPS to\" . $moveLocation);\n\n\tif ($^O ne 'os390') {\n\t\treturn;\n\t}\n\n\tmy @dumplist = @$dumpref;\n\tif (!@dumplist) {\n\t\tdebug(\"No dumps names found in logs/supplied\");\n\t\treturn; # Nothing to do;\n\t}\n\n\tdebug(\"Attempting to retrieve dumps with names: '\" . join(\"', '\", @dumplist), \"'\");\n\n\tmy %movedDumps \t   = (); \n\tmy $multipartIndex = 0;\t\t\n\tmy $file \t\t   = stf::stfUtility->readFileIntoArray($stderr);\n\n",
        "start_line": 449,
        "end_line": 561,
        "chunk_index": 4,
        "total_chunks": 7,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 967,
        "node_type": null,
        "file_sha": "619bc12bbc1630fd7f9b2566c6a3478470758ed7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.717180"
      },
      "text": "\tmy $newlyFoundDumps   = scalar(@newDumps);\n\tmy $existingDumpCount = scalar(@{$dumps});\n\n\t# Now check if we have found any new dumps\n\tif ($newlyFoundDumps ne 0) {\n\t\t$any_dumps_found = $TRUE;\n\t\tdebug(\"DetectDumps given [\".$existingDumpCount.\"] $dumptype dumps and found [\".$newlyFoundDumps.\"] additional undetected $dumptype dumps.\");\n\t} else {\n\t\tchdir $cwd;\n\t\treturn ($any_dumps_found, $dumps);\n\t}\n\n\tif ($dumptype eq \"TDUMP\") {\n\t\t# On ZOs TDUMPS are saved outside the Unix layer\n\t\t# moveTDUMPS will attempt to move them to the file system\n  \t\t$self->moveTDUMPS($stderr, $homedir, \\@newDumps);\n\n  \t\tforeach my $dump (@newDumps) {\t\n  \t\t\tif (grep(/\\Q${dump}\\E/, @{$dumps}) == 0) {\n\t\t\t\tpush( @{$dumps}, $dump );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tforeach my $dump (@newDumps) {\t\t\n\t\t\tif (-e $dump) {\n\t\t\t\twarn(\"Found dump at: $dump\");\n\t\t\t} else {\n\t\t\t\terr(\"Found a dump that doesn't exist: $dump\");\n\t\t\t}\n\n\t\t\t$newdump = $dump;\n\n\t\t\tif (($rename == $TRUE) and ($dump =~ /$dumptype\\.\\D/ or $dump =~ /$dumptype/)) {\n\t\t\t\tmy ($n, $p, $t) = fileparse( $dump, '\\.[\\w\\-\\+]*' );\n\n\t\t\t\t$newdump = catfile( $homedir, \"${n}_${now}${t}\" );\n\n\t\t\t\tmy $cnt = 0;\n\t\t\t\twhile ((-e $dump) and ($cnt < 90)) {\n\t\t\t\t\trename( $dump, $newdump );\n\n\t\t\t\t\tsleep 10;\n\n\t\t\t\t\t$cnt++;\n\t\t\t\t}\n\n\t\t\t\tif (-e $dump) {\n\t\t\t\t\t$newdump = $dump;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstf::stfUtility->writeToFile (\n\t\t\t\t\t\t\t file    => $stderr,\n\t\t\t\t\t\t\t content => [\"${dumptype} file generated - ${newdump}\"],\n\t\t\t\t\t\t\t replace => $FALSE\n\t\t\t);\n\n\t\t\tif (grep(/\\Q${newdump}\\E/, @{$dumps}) == 0) {\n\t\t\t\tpush( @{$dumps}, $newdump );\n\t\t\t}\n\t\t}\n\t}\n\n\tchdir $cwd;\n\treturn ($any_dumps_found, $dumps);\n}\n\n#------------------------------------------------------------#\n# moveTDUMPS\n#\n# Internal subroutine that searches through the file looking for evidence of a TDUMP\n# and then attempts to move the TDUMP and any multiple dumps associated, returning an \n# array of all the dumpes moved. Can also take a list of known dump names.\n#\n# Usage:\n#  @dumplist = moveTDUMPS($filePath, $moveLocation, $dumpref, $joinDumps)\n#\n# Arguments:\n#\t$filePath = either a log file name or an array ref of log file names\n#\t            These will be scanned for IEATDUMP messages (can be null)\n#\t$moveLocation = the directory to move the dumps to\n#\t$dumpref = an array reference containing names of dumps to be moved (can be null)\n#\t$joinDumps = if true, then multi-part tdumps will be joined into a single part.\n#\n# Returns:\n#\t@dumplist = an array of dumps names found\n#\n# Notes:\n#\tThis function is intended to be used only by other functions in this module.\n#------------------------------------------------------------#\nsub moveTDUMPS {\n\tmy ($self, $stderr, $moveLocation, $dumpref, $joinDumps) = @_;\n\n\ttrace(\"moveTDUMPS subroutine - \\@_ : \" . Dumper(\\@_));\n\tdebug(\"Moving the TDUMPS to\" . $moveLocation);\n\n\tif ($^O ne 'os390') {\n\t\treturn;\n\t}\n\n\tmy @dumplist = @$dumpref;\n\tif (!@dumplist) {\n\t\tdebug(\"No dumps names found in logs/supplied\");\n\t\treturn; # Nothing to do;\n\t}\n\n\tdebug(\"Attempting to retrieve dumps with names: '\" . join(\"', '\", @dumplist), \"'\");\n\n\tmy %movedDumps \t   = (); \n\tmy $multipartIndex = 0;\t\t\n\tmy $file \t\t   = stf::stfUtility->readFileIntoArray($stderr);\n\n"
    },
    "77": {
      "metadata": {
        "chunk_id": "a63c622c18a378f6b499563d7996556de76e405bc0f2b34dd692943f3e4af1a5",
        "file_path": "stf.core/scripts/stf/ProcessMgmt.pm",
        "content": "\tforeach my $dump (@dumplist) {\n\t\t# Check if there's been any failures during the the TDUMP generation\n\t\tforeach my $line (@{$file}) {\n\t\t\tif ($line =~ /IEATDUMP failure for DSN='$dump' RC=0x00000004 RSN=0x00000000/) {} # A partial dump has been created, even though it is a failure, dump still occurred and needs moving\n\n\t\t\tif ($line =~ /IEATDUMP failure for DSN='$dump' RC=0x00000008 RSN=0x00000026/) { # Dump failed due to no space left on the machine, so print out warning message and return\n\t\t\t\terr(\"**ERROR** TDUMP generation failed due to no space left on machine, manual cleanup required...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif($dump =~ /X&DS/) {\n\t\t\twarn(\"Naming of dump consistent with multiple dumps\");\n\t\t}\n\n\t\tif($dump !~ /X&DS/) {\n\t\t\tmy $cmd = \"mv \\\"//'${dump}'\\\" \". catfile($moveLocation, \"$dump\");\n\n\t\t\tmy $moveLog = $moveLocation . \"/move.log\";\n\n\t\t\tmy ($rc, $move_process) = stf::Commands->run_process(\n\t\t\t\tmnemonic     => \"MV\",\n\t\t\t\tcommand      => $cmd,\n\t\t\t\truntime      => 300,\n\t\t\t\tlogName      => $moveLog,\n\t\t\t\tmonitorDumps => $FALSE, \n\t\t\t\tsingleLog    => $TRUE,\n\t\t\t\techo         => $FALSE\n\t\t\t);\n\n\t\t\t$movedDumps{$dump} = 1;\t\t\n\n\t\t\t#  If there is anything in the move log assume something gone wrong\n\t\t\tif (! -z $moveLog) {\n\t\t\t\terr(\"**ERROR** Unable to move dump, attempting to move to dev null instead..\");\n\n\t\t\t\tmy $cmd = \"mv \\\"//'${dump}'\\\" /dev/null\";\n\n\t\t\t\tmy $deleteLog = $moveLocation . \"/delete.log\";\n\n\t\t\t\tmy ($rc, $delete_process) = stf::Commands->run_process(\n\t\t\t\t\tmnemonic     => \"DEL\",\n\t\t\t\t\tcommand      => $cmd,\n\t\t\t\t\truntime      => 300,\n\t\t\t\t\tlogName      => $deleteLog,\n\t\t\t\t\tmonitorDumps => $FALSE,\n\t\t\t\t\tsingleLog    => $TRUE,\n\t\t\t\t\techo         => $FALSE\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmy @parts;\n\n\t\t\tmy $i = 1;\n\n\t\t\tmy $multiFound = $TRUE;\n\n\t\t\t$dump =~ s/X&DS//;\n\n\t\t\twarn(\"Changed dump name to $dump\");\n\n\t\t\twarn(\"Will scan for dumps ${dump}.X00n , we expect a not-found failure at the end of this\");\n\n\t\t\twhile($multiFound == $TRUE && $i < 10) {\t\n\t\t\t\tmy $dump01 = $dump.\"X00\".$i;\n\n\t\t\t\twarn(\"Looking for multiple TDUMPs - $dump01\");\n\n\t\t\t\tmy $cmd = \"mv \\\"//'${dump01}'\\\" \". catfile($moveLocation, \"$dump01\");\n\n\t\t\t\tmy $moveLog = $moveLocation . \"/move_$i.log\";\n\n\t\t\t\tmy ($rc, $move_process) = stf::Commands->run_process(\n\t\t\t\t\tmnemonic     => \"MV$i\",\n\t\t\t\t\tcommand      => $cmd,\n\t\t\t\t\truntime      => 300,\n\t\t\t\t\tlogName      => $moveLog,\n\t\t\t\t\tmonitorDumps => $FALSE,\n\t\t\t\t\tsingleLog    => $TRUE,\n\t\t\t\t\techo         => $FALSE\n\t\t\t\t);\n\n\t\t\t\t#  If there is anything in the move log assume something gone wrong\n\t\t\t\tif (! -z $moveLog) {\n\t\t\t\t\twarn(\"**ERROR** Unable to move dump, attempting to move to dev null instead..\") if ($i == 1);\n\n\t\t\t\t\tmy $cmd = \"mv \\\"//'${dump}'\\\" /dev/null\";\n\n\t\t\t\t\tmy $deleteLog = $moveLocation . \"/delete_$i.log\";\n\n\t\t\t\t\tmy ($rc, $delete_process) = stf::Commands->run_process(\n\t\t\t\t\t\tmnemonic     => \"DEL$i\",\n\t\t\t\t\t\tcommand      => $cmd,\n\t\t\t\t\t\truntime      => 300,\n\t\t\t\t\t\tlogName      => $deleteLog,\n\t\t\t\t\t\tmonitorDumps => $FALSE,\n\t\t\t\t\t\tsingleLog    => $TRUE,\n\t\t\t\t\t\techo         => $FALSE\n\t\t\t\t\t);\n\n\t\t\t\t\t$multiFound = $FALSE;\n\t\t\t\t}\n\n\t\t\t\t# We will set multiFound to false if there is an error.\t\t\t\t\t\n\t\t\t\tif ($multiFound == $TRUE) {\n\t\t\t\t\twarn(\"Found multiple TDUMP named $dump01, moved to $moveLocation\");\n\n\t\t\t\t\tpush(@parts, $dump01);\n\n\t\t\t\t\tif($i < 2) {\n\t\t\t\t\t\twarn(\"Added $dump01 to dump array\");\n\n",
        "start_line": 562,
        "end_line": 675,
        "chunk_index": 5,
        "total_chunks": 7,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 999,
        "node_type": null,
        "file_sha": "619bc12bbc1630fd7f9b2566c6a3478470758ed7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.717182"
      },
      "text": "\tforeach my $dump (@dumplist) {\n\t\t# Check if there's been any failures during the the TDUMP generation\n\t\tforeach my $line (@{$file}) {\n\t\t\tif ($line =~ /IEATDUMP failure for DSN='$dump' RC=0x00000004 RSN=0x00000000/) {} # A partial dump has been created, even though it is a failure, dump still occurred and needs moving\n\n\t\t\tif ($line =~ /IEATDUMP failure for DSN='$dump' RC=0x00000008 RSN=0x00000026/) { # Dump failed due to no space left on the machine, so print out warning message and return\n\t\t\t\terr(\"**ERROR** TDUMP generation failed due to no space left on machine, manual cleanup required...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif($dump =~ /X&DS/) {\n\t\t\twarn(\"Naming of dump consistent with multiple dumps\");\n\t\t}\n\n\t\tif($dump !~ /X&DS/) {\n\t\t\tmy $cmd = \"mv \\\"//'${dump}'\\\" \". catfile($moveLocation, \"$dump\");\n\n\t\t\tmy $moveLog = $moveLocation . \"/move.log\";\n\n\t\t\tmy ($rc, $move_process) = stf::Commands->run_process(\n\t\t\t\tmnemonic     => \"MV\",\n\t\t\t\tcommand      => $cmd,\n\t\t\t\truntime      => 300,\n\t\t\t\tlogName      => $moveLog,\n\t\t\t\tmonitorDumps => $FALSE, \n\t\t\t\tsingleLog    => $TRUE,\n\t\t\t\techo         => $FALSE\n\t\t\t);\n\n\t\t\t$movedDumps{$dump} = 1;\t\t\n\n\t\t\t#  If there is anything in the move log assume something gone wrong\n\t\t\tif (! -z $moveLog) {\n\t\t\t\terr(\"**ERROR** Unable to move dump, attempting to move to dev null instead..\");\n\n\t\t\t\tmy $cmd = \"mv \\\"//'${dump}'\\\" /dev/null\";\n\n\t\t\t\tmy $deleteLog = $moveLocation . \"/delete.log\";\n\n\t\t\t\tmy ($rc, $delete_process) = stf::Commands->run_process(\n\t\t\t\t\tmnemonic     => \"DEL\",\n\t\t\t\t\tcommand      => $cmd,\n\t\t\t\t\truntime      => 300,\n\t\t\t\t\tlogName      => $deleteLog,\n\t\t\t\t\tmonitorDumps => $FALSE,\n\t\t\t\t\tsingleLog    => $TRUE,\n\t\t\t\t\techo         => $FALSE\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmy @parts;\n\n\t\t\tmy $i = 1;\n\n\t\t\tmy $multiFound = $TRUE;\n\n\t\t\t$dump =~ s/X&DS//;\n\n\t\t\twarn(\"Changed dump name to $dump\");\n\n\t\t\twarn(\"Will scan for dumps ${dump}.X00n , we expect a not-found failure at the end of this\");\n\n\t\t\twhile($multiFound == $TRUE && $i < 10) {\t\n\t\t\t\tmy $dump01 = $dump.\"X00\".$i;\n\n\t\t\t\twarn(\"Looking for multiple TDUMPs - $dump01\");\n\n\t\t\t\tmy $cmd = \"mv \\\"//'${dump01}'\\\" \". catfile($moveLocation, \"$dump01\");\n\n\t\t\t\tmy $moveLog = $moveLocation . \"/move_$i.log\";\n\n\t\t\t\tmy ($rc, $move_process) = stf::Commands->run_process(\n\t\t\t\t\tmnemonic     => \"MV$i\",\n\t\t\t\t\tcommand      => $cmd,\n\t\t\t\t\truntime      => 300,\n\t\t\t\t\tlogName      => $moveLog,\n\t\t\t\t\tmonitorDumps => $FALSE,\n\t\t\t\t\tsingleLog    => $TRUE,\n\t\t\t\t\techo         => $FALSE\n\t\t\t\t);\n\n\t\t\t\t#  If there is anything in the move log assume something gone wrong\n\t\t\t\tif (! -z $moveLog) {\n\t\t\t\t\twarn(\"**ERROR** Unable to move dump, attempting to move to dev null instead..\") if ($i == 1);\n\n\t\t\t\t\tmy $cmd = \"mv \\\"//'${dump}'\\\" /dev/null\";\n\n\t\t\t\t\tmy $deleteLog = $moveLocation . \"/delete_$i.log\";\n\n\t\t\t\t\tmy ($rc, $delete_process) = stf::Commands->run_process(\n\t\t\t\t\t\tmnemonic     => \"DEL$i\",\n\t\t\t\t\t\tcommand      => $cmd,\n\t\t\t\t\t\truntime      => 300,\n\t\t\t\t\t\tlogName      => $deleteLog,\n\t\t\t\t\t\tmonitorDumps => $FALSE,\n\t\t\t\t\t\tsingleLog    => $TRUE,\n\t\t\t\t\t\techo         => $FALSE\n\t\t\t\t\t);\n\n\t\t\t\t\t$multiFound = $FALSE;\n\t\t\t\t}\n\n\t\t\t\t# We will set multiFound to false if there is an error.\t\t\t\t\t\n\t\t\t\tif ($multiFound == $TRUE) {\n\t\t\t\t\twarn(\"Found multiple TDUMP named $dump01, moved to $moveLocation\");\n\n\t\t\t\t\tpush(@parts, $dump01);\n\n\t\t\t\t\tif($i < 2) {\n\t\t\t\t\t\twarn(\"Added $dump01 to dump array\");\n\n"
    },
    "78": {
      "metadata": {
        "chunk_id": "57fd0d1906df648adc8b5477dd3a529c89a3f882eab6cb8451e32796d1063c73",
        "file_path": "stf.core/scripts/stf/ProcessMgmt.pm",
        "content": "\t\t\t\t\t\t$movedDumps{$dump01} = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twarn(\"MULTIPLE DUMP found, this needs to be merged before continuing!\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t$i++;\t\n\t\t\t}\n\n\t\t\t# Join multipart dumps\n\t\t\tif ($joinDumps && scalar(@parts) > 1) {\n\t\t\t\t$multipartIndex++;\n\n\t\t\t\tmy $joinedDumpName = \"joined.\".$dump.\".\".$multipartIndex.\".dmp\"; \n\n\t\t\t\tmy $rv = join_dumps($moveLocation, \\@parts, $joinedDumpName);\n\n\t\t\t\tif ($rv) {\n\t\t\t\t\tmy $oldKey = $parts[0];\n\n\t\t\t\t\tdelete $movedDumps{$oldKey};\n\n\t\t\t\t\t$movedDumps{$joinedDumpName} = 1;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\t\t\t\t\t\t\t\t                  \t\t\t\t\n\t}\n\n\tmy @returnList = keys(%movedDumps);\n\n\twarn(\"TDUMP Summary:\");\n\n\tif (scalar(@returnList) eq 0) {\n\t\twarn(\"**ERROR** TDUMP/S not moved to file system.\");\n\t} else {\n\t\tforeach my $line (@returnList) {\n\t\t\twarn(\"$line\");\n\t\t}\n\t}\n\n\twarn(\"End of TDUMP Summary\");\n\n\treturn (@returnList);\t \t\t\n}\n\n#------------------------------------------------------------#\n# join_dumps\n#\n# Internal subroutine that re-joins the parts of a multipart tdump\n# On failure, the joined dump will be deleted.\n# \n# Usage:\n#\tmy $rv = join_dumps($sourceDir, $dumpNames, $newName);\n#\n# Arguments: \n#\t$sourceDir - where the dump parts are\n#\t$dumpNames - a reference to an ordered array of dump parts\n#\t$newName - the name for the joined dump\n#------------------------------------------------------------#\nsub join_dumps {\n\n\tmy ($sourceDir, $dumpNames, $newName) = @_;\n\n\twarn(\"Attempting to join dump parts: \" . join(',', @$dumpNames) . \" to file $newName\");\n\n\tmy $outputName = \"$sourceDir/$newName\";\n\n\tmy $seek = 0;\n\n\tforeach my $dumpName (@$dumpNames) {\n\t\twarn(\"Joining dump part $dumpName\");\n\n\t\tmy $command = \"dd if=$sourceDir/$dumpName of=$outputName bs=4160\";\n\n\t\tif ($seek) {\n\t\t\t$command = $command . \" seek=$seek\";\n\t\t}\n\n\t\twarn(\"Running command '$command'\");\n\n\t\tmy $output = `$command 2>&1`;\n\n\t\tif ($output =~ m/(\\d+)\\+(\\d)+ records out/) {\n\t\t\tmy $blocksWritten = $1;\n\n\t\t\tmy $extraBytesWritten = $2;\n\n\t\t\twarn(\"Seems to have worked, $blocksWritten blocks, $extraBytesWritten bytes\");\n\n\t\t\tif ($extraBytesWritten ne \"0\") {\n\t\t\t\terr(\"Number of blocks written wasn't a whole number. Can't cope !! Argh. Deleting output file\");\n\t\t\t\t`rm $outputName`;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t$seek = $seek + $blocksWritten;\n\t    }\n\t\telse {\n\t\t\terr(\"The dd command appears to have failed. Output was\\n$output\\nRemoving output file $outputName\");\n\t\t\t`rm $outputName`;\n\t\t\treturn 0;\n\t    }\n \t}\n  return 1;\n}\n\n1;\n__END__\n\n\n",
        "start_line": 676,
        "end_line": 788,
        "chunk_index": 6,
        "total_chunks": 7,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 711,
        "node_type": null,
        "file_sha": "619bc12bbc1630fd7f9b2566c6a3478470758ed7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.717185"
      },
      "text": "\t\t\t\t\t\t$movedDumps{$dump01} = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twarn(\"MULTIPLE DUMP found, this needs to be merged before continuing!\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t$i++;\t\n\t\t\t}\n\n\t\t\t# Join multipart dumps\n\t\t\tif ($joinDumps && scalar(@parts) > 1) {\n\t\t\t\t$multipartIndex++;\n\n\t\t\t\tmy $joinedDumpName = \"joined.\".$dump.\".\".$multipartIndex.\".dmp\"; \n\n\t\t\t\tmy $rv = join_dumps($moveLocation, \\@parts, $joinedDumpName);\n\n\t\t\t\tif ($rv) {\n\t\t\t\t\tmy $oldKey = $parts[0];\n\n\t\t\t\t\tdelete $movedDumps{$oldKey};\n\n\t\t\t\t\t$movedDumps{$joinedDumpName} = 1;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\t\t\t\t\t\t\t\t                  \t\t\t\t\n\t}\n\n\tmy @returnList = keys(%movedDumps);\n\n\twarn(\"TDUMP Summary:\");\n\n\tif (scalar(@returnList) eq 0) {\n\t\twarn(\"**ERROR** TDUMP/S not moved to file system.\");\n\t} else {\n\t\tforeach my $line (@returnList) {\n\t\t\twarn(\"$line\");\n\t\t}\n\t}\n\n\twarn(\"End of TDUMP Summary\");\n\n\treturn (@returnList);\t \t\t\n}\n\n#------------------------------------------------------------#\n# join_dumps\n#\n# Internal subroutine that re-joins the parts of a multipart tdump\n# On failure, the joined dump will be deleted.\n# \n# Usage:\n#\tmy $rv = join_dumps($sourceDir, $dumpNames, $newName);\n#\n# Arguments: \n#\t$sourceDir - where the dump parts are\n#\t$dumpNames - a reference to an ordered array of dump parts\n#\t$newName - the name for the joined dump\n#------------------------------------------------------------#\nsub join_dumps {\n\n\tmy ($sourceDir, $dumpNames, $newName) = @_;\n\n\twarn(\"Attempting to join dump parts: \" . join(',', @$dumpNames) . \" to file $newName\");\n\n\tmy $outputName = \"$sourceDir/$newName\";\n\n\tmy $seek = 0;\n\n\tforeach my $dumpName (@$dumpNames) {\n\t\twarn(\"Joining dump part $dumpName\");\n\n\t\tmy $command = \"dd if=$sourceDir/$dumpName of=$outputName bs=4160\";\n\n\t\tif ($seek) {\n\t\t\t$command = $command . \" seek=$seek\";\n\t\t}\n\n\t\twarn(\"Running command '$command'\");\n\n\t\tmy $output = `$command 2>&1`;\n\n\t\tif ($output =~ m/(\\d+)\\+(\\d)+ records out/) {\n\t\t\tmy $blocksWritten = $1;\n\n\t\t\tmy $extraBytesWritten = $2;\n\n\t\t\twarn(\"Seems to have worked, $blocksWritten blocks, $extraBytesWritten bytes\");\n\n\t\t\tif ($extraBytesWritten ne \"0\") {\n\t\t\t\terr(\"Number of blocks written wasn't a whole number. Can't cope !! Argh. Deleting output file\");\n\t\t\t\t`rm $outputName`;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t$seek = $seek + $blocksWritten;\n\t    }\n\t\telse {\n\t\t\terr(\"The dd command appears to have failed. Output was\\n$output\\nRemoving output file $outputName\");\n\t\t\t`rm $outputName`;\n\t\t\treturn 0;\n\t    }\n \t}\n  return 1;\n}\n\n1;\n__END__\n\n\n"
    },
    "79": {
      "metadata": {
        "chunk_id": "2b308d8473b20fa54339df25bce67e58b3cc5b291f06e04b3e19b979b2706104",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/Result.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt::Result;\n\nuse strict;\n\nuse warnings;\n\nsub new\n{\n\tmy $class = shift;\n\n\tmy @args = @_;\n\n\t#Return the appropriate subclass\n\tif($^O eq 'MSWin32')\n\t{\n\t\trequire stf::ProcessMgmt::Result::Windows;\n\n\t\treturn new stf::ProcessMgmt::Result::Windows(@args);\n\t}\n\telse\n\t{\n\t\trequire stf::ProcessMgmt::Result::UNIX;\n\n\t\treturn new stf::ProcessMgmt::Result::UNIX(@args);\n\t}\n}\n\n#We create default implementations of all the methods that puke\n#to define the interface and catch coding screw-ups later.\n\nsub return_code\n{\n\tdie \"return_code not implemented\";\n}\n\nsub exit_code\n{\n\tdie \"exit_code not implemented\";\n}\n\nsub signal\n{\n\tdie \"signal not implemented\";\n}\n\nsub core_dumped\n{\n\tdie \"core_dumped not implemented\";\n}\n\nsub message\n{\n\tdie \"message not implemented\";\n}\n\nsub get_summary\n{\n\tdie \"get_summary not implemented\";\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nstf::ProcessMgmt::Result - object representing a test result\n\n=head1 SYNOPSIS\n\n\tuse stf::ProcessMgmt::Result;\n\n\tmy $result = new stf::ProcessMgmt::Result($?);\n\n\tprint $result->get_summary();\n\n=head1 DESCRIPTION\n\nstf::ProcessMgmt::Result encapsulates the knowledge of how process return codes are interpretted on a\nparticular platform.\n\nThere are big differences in what information is encoded in the process return code between Windows\nand UNIX. For Windows, the process return code is the integer passed to the exit() function call. Some\nwindows exit codes have special meanings which are called the \"exit message\". Note that this messages\nare only meaningful if the application is playing along.\n\n=head1 METHODS\n\n=over 4\n\n=item new\n\nDefault constructor.\n\nTakes the process return code as its only argument.\n\n=item return_code\n\nReturns the unedited return code - i.e. what fell out of the process at the end of the run.\n\n=item exit_code\n\nReturns the process exit code - what was passed to System.exit() or the exit() library call.\n\n=item signal\n\nOn UNIX, if the process was terminated with a signal that wasn't handled this returns the signal number.\nIf a signal was not returned or we are running on Windows we return undef.\n\n=item core_dumped\n\nOn UNIX, if the process was terminated with a signal that caused the process to dump core, this method\nreturns true. If the core_dumped bit is not set or we are on Windows we return undef.\n\n=item message\n\nReturns the exit message for the particular exit code on Windows. On UNIX returns ''.\n\n=item get_summary\n\nReturns a text string containing a summary of the return code and its meaning.\n\n=back\n\n=cut\n\n\n",
        "start_line": 0,
        "end_line": 139,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 694,
        "node_type": null,
        "file_sha": "19d9e81318502879ba7b9812a9326f5e74479d83",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.723405"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt::Result;\n\nuse strict;\n\nuse warnings;\n\nsub new\n{\n\tmy $class = shift;\n\n\tmy @args = @_;\n\n\t#Return the appropriate subclass\n\tif($^O eq 'MSWin32')\n\t{\n\t\trequire stf::ProcessMgmt::Result::Windows;\n\n\t\treturn new stf::ProcessMgmt::Result::Windows(@args);\n\t}\n\telse\n\t{\n\t\trequire stf::ProcessMgmt::Result::UNIX;\n\n\t\treturn new stf::ProcessMgmt::Result::UNIX(@args);\n\t}\n}\n\n#We create default implementations of all the methods that puke\n#to define the interface and catch coding screw-ups later.\n\nsub return_code\n{\n\tdie \"return_code not implemented\";\n}\n\nsub exit_code\n{\n\tdie \"exit_code not implemented\";\n}\n\nsub signal\n{\n\tdie \"signal not implemented\";\n}\n\nsub core_dumped\n{\n\tdie \"core_dumped not implemented\";\n}\n\nsub message\n{\n\tdie \"message not implemented\";\n}\n\nsub get_summary\n{\n\tdie \"get_summary not implemented\";\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nstf::ProcessMgmt::Result - object representing a test result\n\n=head1 SYNOPSIS\n\n\tuse stf::ProcessMgmt::Result;\n\n\tmy $result = new stf::ProcessMgmt::Result($?);\n\n\tprint $result->get_summary();\n\n=head1 DESCRIPTION\n\nstf::ProcessMgmt::Result encapsulates the knowledge of how process return codes are interpretted on a\nparticular platform.\n\nThere are big differences in what information is encoded in the process return code between Windows\nand UNIX. For Windows, the process return code is the integer passed to the exit() function call. Some\nwindows exit codes have special meanings which are called the \"exit message\". Note that this messages\nare only meaningful if the application is playing along.\n\n=head1 METHODS\n\n=over 4\n\n=item new\n\nDefault constructor.\n\nTakes the process return code as its only argument.\n\n=item return_code\n\nReturns the unedited return code - i.e. what fell out of the process at the end of the run.\n\n=item exit_code\n\nReturns the process exit code - what was passed to System.exit() or the exit() library call.\n\n=item signal\n\nOn UNIX, if the process was terminated with a signal that wasn't handled this returns the signal number.\nIf a signal was not returned or we are running on Windows we return undef.\n\n=item core_dumped\n\nOn UNIX, if the process was terminated with a signal that caused the process to dump core, this method\nreturns true. If the core_dumped bit is not set or we are on Windows we return undef.\n\n=item message\n\nReturns the exit message for the particular exit code on Windows. On UNIX returns ''.\n\n=item get_summary\n\nReturns a text string containing a summary of the return code and its meaning.\n\n=back\n\n=cut\n\n\n"
    },
    "80": {
      "metadata": {
        "chunk_id": "bb02c82a40955702ee894ee6fa1d53ee2aa3bcda8b38cb4da096abf2df586c1c",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/Result/UNIX.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt::Result::UNIX;\n\nuse base qw{stf::ProcessMgmt::Result};\n\nuse strict;\n\nuse warnings;\n\nsub new\n{\n\tmy ($class,$rc) = @_;\n\n\tdie \"No return code supplied\" unless defined $rc;\n\n\tmy $self = {};\n\n\tbless $self => $class;\n\n    $self->{return_code} = $rc;\n\n    $self->{core_dumped} = $rc & 0x80;\n\n    $self->{code} = $rc >> 8;\n\n    $self->{signal} = $rc & 0x7f;\n\n\treturn $self;\n}\n\nsub return_code\n{\n\tmy $self = shift;\n\n\treturn $self->{return_code};\n}\n\nsub exit_code\n{\n\tmy $self = shift;\n\n\treturn $self->{code};\n}\n\nsub signal\n{\n\tmy $self = shift;\n\n\treturn $self->{signal};\n}\n\nsub core_dumped\n{\n\tmy $self = shift;\n\n\treturn $self->{core_dumped};\n}\n\nsub message\n{\n\treturn 'UNIX process status codes do not have corresponding messages';\n}\n\nsub get_summary\n{\n\tmy $self = shift;\n\n\tmy $rc = $self->return_code();\n\tmy $hex_string = sprintf(\"%04x\",$rc);\n\n\tmy $exit_code = $self->exit_code();\n\tmy $core_str = ($self->core_dumped()) ? 'Core bit set' : 'Core bit not set';\n\n\tmy $signal = $self->signal();\n\n\tmy $signal_string = ($signal == 0) ? 'No signal received.' : \"Signal $signal received.\";\n\n\treturn << \"SUMMARY\";\nThe 16 bit process exit status on UNIX encodes several pieces of data:\n\nThe top (most significant) 8 bits are the application exit code \nas passed to the exit() function in the program code. For Java, this may \nbe a value passed to System.exit() by the application or produced by \nthe VM itself.\n\nThe 8th bit is a flag indicating whether a core was dumped.\n\nThe bottom 7 bits are the signal number sent to the process - 0 indicates \nno signal was sent.\n\nWhen a signal is received by the JVM, the behaviour seems to be different\ndepending on whether the VM is capable of handling the signal. If it can\nhandle the signal it sets the application exit code and the signal number\nand core bit are set to 0.\n\nOnly if the JVM can't or doesn't handle the signal (a sig 9 or sig 24 for \nexample) do the signal number and core bit get set.\n\nProcess status code was: $rc (in hex: $hex_string)\nStatus code break down is:\nExit code: $exit_code\n$core_str\n$signal_string\nSUMMARY\n\n}\n\n1;\n\n\n",
        "start_line": 0,
        "end_line": 121,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 686,
        "node_type": null,
        "file_sha": "e03fcab880886cdea134ad3cc330ec191b94ecc8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.730401"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt::Result::UNIX;\n\nuse base qw{stf::ProcessMgmt::Result};\n\nuse strict;\n\nuse warnings;\n\nsub new\n{\n\tmy ($class,$rc) = @_;\n\n\tdie \"No return code supplied\" unless defined $rc;\n\n\tmy $self = {};\n\n\tbless $self => $class;\n\n    $self->{return_code} = $rc;\n\n    $self->{core_dumped} = $rc & 0x80;\n\n    $self->{code} = $rc >> 8;\n\n    $self->{signal} = $rc & 0x7f;\n\n\treturn $self;\n}\n\nsub return_code\n{\n\tmy $self = shift;\n\n\treturn $self->{return_code};\n}\n\nsub exit_code\n{\n\tmy $self = shift;\n\n\treturn $self->{code};\n}\n\nsub signal\n{\n\tmy $self = shift;\n\n\treturn $self->{signal};\n}\n\nsub core_dumped\n{\n\tmy $self = shift;\n\n\treturn $self->{core_dumped};\n}\n\nsub message\n{\n\treturn 'UNIX process status codes do not have corresponding messages';\n}\n\nsub get_summary\n{\n\tmy $self = shift;\n\n\tmy $rc = $self->return_code();\n\tmy $hex_string = sprintf(\"%04x\",$rc);\n\n\tmy $exit_code = $self->exit_code();\n\tmy $core_str = ($self->core_dumped()) ? 'Core bit set' : 'Core bit not set';\n\n\tmy $signal = $self->signal();\n\n\tmy $signal_string = ($signal == 0) ? 'No signal received.' : \"Signal $signal received.\";\n\n\treturn << \"SUMMARY\";\nThe 16 bit process exit status on UNIX encodes several pieces of data:\n\nThe top (most significant) 8 bits are the application exit code \nas passed to the exit() function in the program code. For Java, this may \nbe a value passed to System.exit() by the application or produced by \nthe VM itself.\n\nThe 8th bit is a flag indicating whether a core was dumped.\n\nThe bottom 7 bits are the signal number sent to the process - 0 indicates \nno signal was sent.\n\nWhen a signal is received by the JVM, the behaviour seems to be different\ndepending on whether the VM is capable of handling the signal. If it can\nhandle the signal it sets the application exit code and the signal number\nand core bit are set to 0.\n\nOnly if the JVM can't or doesn't handle the signal (a sig 9 or sig 24 for \nexample) do the signal number and core bit get set.\n\nProcess status code was: $rc (in hex: $hex_string)\nStatus code break down is:\nExit code: $exit_code\n$core_str\n$signal_string\nSUMMARY\n\n}\n\n1;\n\n\n"
    },
    "81": {
      "metadata": {
        "chunk_id": "4dd2fe893eff6184d336061b1504c8a28f6e6d8239e31a32ae4303b63d90c671",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/Result/Windows.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt::Result::Windows;\n\nuse base qw{stf::ProcessMgmt::Result};\n\nuse strict;\n\nuse warnings;\n\nuse Win32::API;\n\nsub new\n{\n\tmy ($class,$rc) = @_;\n\n\tdie \"No return code supplied\" unless defined $rc;\n\n\tmy $self = {};\n\n\tbless $self => $class;\n\n\t$self->{return_code} = $rc;\n\t$self->{message} = Win32::FormatMessage($rc);\n\n\tif(! defined($self->{message}))\n\t{\n\t\t$self->{message} = q{};\n\t}\n\n\treturn $self;\n}\n\nsub return_code\n{\n\tmy $self = shift;\n\n\treturn $self->{return_code};\n}\n\nsub exit_code\n{\n\tmy $self = shift;\n\n\t#The exit code is the return code on Windows\n\n\treturn $self->{return_code};\n}\n\nsub signal\n{\n\t#No signal information on Windows\n\treturn undef;\n}\n\nsub core_dumped\n{\n\t#No core_dumped information Windows\n\treturn undef;\n}\n\nsub message\n{\n\tmy $self = shift;\n\n\treturn $self->{message};\n}\n\nsub get_summary\n{\n\tmy $self = shift;\n\n\tmy $return_code = $self->return_code();\n\tmy $exit_code = $self->exit_code();\n\tmy $message = $self->message();\n\n\tchomp $message;\n\n\tmy $summary = << \"SUMMARY\";\nThe process completed with RC $return_code.\n\nUnlike UNIX where the return code is complicated, on Windows the return \ncode corresponds to the exit code (the value passed to exit() or \nSystem.exit()).\n\nThe corresponding Windows message for return code $return_code is: \n$message\n\nNote that the message will only be meaningful if the application is \nco-operative and deliberately returns the appropriate error code \nfor the situation.\n\nSUMMARY\n\n\treturn $summary;\n}\n\n1;\n\n__END__\n\n\n",
        "start_line": 0,
        "end_line": 112,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 495,
        "node_type": null,
        "file_sha": "2ff8bbf57f5e5d2054a3d519427eb38871be6a73",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.735976"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt::Result::Windows;\n\nuse base qw{stf::ProcessMgmt::Result};\n\nuse strict;\n\nuse warnings;\n\nuse Win32::API;\n\nsub new\n{\n\tmy ($class,$rc) = @_;\n\n\tdie \"No return code supplied\" unless defined $rc;\n\n\tmy $self = {};\n\n\tbless $self => $class;\n\n\t$self->{return_code} = $rc;\n\t$self->{message} = Win32::FormatMessage($rc);\n\n\tif(! defined($self->{message}))\n\t{\n\t\t$self->{message} = q{};\n\t}\n\n\treturn $self;\n}\n\nsub return_code\n{\n\tmy $self = shift;\n\n\treturn $self->{return_code};\n}\n\nsub exit_code\n{\n\tmy $self = shift;\n\n\t#The exit code is the return code on Windows\n\n\treturn $self->{return_code};\n}\n\nsub signal\n{\n\t#No signal information on Windows\n\treturn undef;\n}\n\nsub core_dumped\n{\n\t#No core_dumped information Windows\n\treturn undef;\n}\n\nsub message\n{\n\tmy $self = shift;\n\n\treturn $self->{message};\n}\n\nsub get_summary\n{\n\tmy $self = shift;\n\n\tmy $return_code = $self->return_code();\n\tmy $exit_code = $self->exit_code();\n\tmy $message = $self->message();\n\n\tchomp $message;\n\n\tmy $summary = << \"SUMMARY\";\nThe process completed with RC $return_code.\n\nUnlike UNIX where the return code is complicated, on Windows the return \ncode corresponds to the exit code (the value passed to exit() or \nSystem.exit()).\n\nThe corresponding Windows message for return code $return_code is: \n$message\n\nNote that the message will only be meaningful if the application is \nco-operative and deliberately returns the appropriate error code \nfor the situation.\n\nSUMMARY\n\n\treturn $summary;\n}\n\n1;\n\n__END__\n\n\n"
    },
    "82": {
      "metadata": {
        "chunk_id": "646f3f7e063bd4a30759986a8a1628ef01974648ae10c509d690e194ba25af99",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/UNIX.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt::UNIX;\n\nuse base qw{stf::ProcessMgmt};\n\nuse strict;\n\nuse warnings;\n\nuse stf::ProcessMgmt::Result;\n\nuse POSIX \"sys_wait_h\";\n\nuse File::Spec::Functions qw{catfile};\n\nuse Time::Local;\n\n#Method called in the constructor to qualify the command.\n#\n#Will take an unqualified command name (e.g. java) and produce a qualified\n#command (such as c:\\Program Files\\IBM\\Java5\\jre\\bin\\java.exe)\nsub _qualify_command {\n\tmy $self = shift;\n\n\tmy $cmd = $self->{command};\n\n#The command could be qualified already - if it points to a file that exists then finish\n\treturn if -f $cmd;\n\n\tmy @path_elements = split /[:]/, $ENV{PATH};\n\n\tforeach my $this_element (@path_elements) {\n\t\tmy $potential_file = catfile( $this_element, $cmd );\n\n\t\tif ( -f $potential_file ) {\n\t\t\t$self->{command} = $potential_file;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\twarn \"Error: cannot find command $cmd on PATH. PATH is $ENV{PATH}\";\n}\n\nsub _recreate_internal_structure\n{\n}\n\nsub start {\n\tmy $self = shift;\n\tmy $debug = 0;\n\n\t# Create a starttime object attribute\n\t$self->{starttime} = timelocal(localtime());\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_UNSTARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only start an unstarted process. Current state is: $state_name\";\n\n\t\treturn;\n\t}\n\n#To avoid tripping up tests which expect pristine STDERR. We output debug elsewhere..\n\n\tif ( defined $self->{stddbg} && $self->{stddbg} ne '' ) {\n\t\t$debug=1;\n\t\t#Open the new stream for append\n\t\topen( STDDBG, '>>', $self->{stddbg} )\n\t\t  or die \"Cannot open new stddbg $self->{stddbg}: $!\";\n\n\t\t#Enable autoflush\n\t\tselect STDDBG;\n\t\t$| = 1;\n\t}\n\n\tif ( defined $self->{debug}) {\n\t\t$debug = $self->{debug};\n\t}\n\n#To redirect the streams on UNIX we are going to open our I/O streams to the\n#target streams, spawn the process and then switch back to our originals for the parent.\n#\n\n\t#Save our current streams if we need to\n\tlocal ( *OLDIN, *OLDERR, *OLDOUT );\n\n\tif ( defined $self->{stdin} && $self->{stdin} ne '' ) {\n\t\topen( OLDIN, \"<&STDIN\" ) or die \"Cannot save current STDIN: $!\";\n\n\t\t#Create the stdin file if it doesn't already exist\n\t\t$self->_touch_file( $self->{stdin} );\n\n\t\t#Reopen STDIN from the stdin file\n\t\topen( STDIN, '<', $self->{stdin} )\n\t\t  or die \"Cannot open new stdin $self->{stdin}: $!\";\n\t}\n\t#  Do stdout LAST because it remains selected as default\n\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\topen( OLDERR, \">&STDERR\" ) or die \"Cannot save current STDERR: $!\";\n\n\t\t#Open the new stream for append\n\t\topen( STDERR, '>>', $self->{stderr} )\n\t\t  or die \"Cannot open new stderr $self->{stderr}: $!\";\n\n\t\t#Enable autoflush\n\t\tselect STDERR;\n\t\t$| = 1;\n\t}\n\n\tif ( defined $self->{stdout} && $self->{stdout} ne '' ) {\n\t\topen( OLDOUT, \">&STDOUT\" ) or die \"Cannot save current STDOUT: $!\";\n\n\t\t#Open the new stream for append\n\t\topen( STDOUT, '>>', $self->{stdout} )\n\t\t  or die \"Cannot open new stdout $self->{stdout}: $!\";\n\n",
        "start_line": 0,
        "end_line": 130,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 996,
        "node_type": null,
        "file_sha": "1e10c110e64b82ae6dc810d07b30f8cc03836513",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.742552"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stf::ProcessMgmt::UNIX;\n\nuse base qw{stf::ProcessMgmt};\n\nuse strict;\n\nuse warnings;\n\nuse stf::ProcessMgmt::Result;\n\nuse POSIX \"sys_wait_h\";\n\nuse File::Spec::Functions qw{catfile};\n\nuse Time::Local;\n\n#Method called in the constructor to qualify the command.\n#\n#Will take an unqualified command name (e.g. java) and produce a qualified\n#command (such as c:\\Program Files\\IBM\\Java5\\jre\\bin\\java.exe)\nsub _qualify_command {\n\tmy $self = shift;\n\n\tmy $cmd = $self->{command};\n\n#The command could be qualified already - if it points to a file that exists then finish\n\treturn if -f $cmd;\n\n\tmy @path_elements = split /[:]/, $ENV{PATH};\n\n\tforeach my $this_element (@path_elements) {\n\t\tmy $potential_file = catfile( $this_element, $cmd );\n\n\t\tif ( -f $potential_file ) {\n\t\t\t$self->{command} = $potential_file;\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\twarn \"Error: cannot find command $cmd on PATH. PATH is $ENV{PATH}\";\n}\n\nsub _recreate_internal_structure\n{\n}\n\nsub start {\n\tmy $self = shift;\n\tmy $debug = 0;\n\n\t# Create a starttime object attribute\n\t$self->{starttime} = timelocal(localtime());\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_UNSTARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only start an unstarted process. Current state is: $state_name\";\n\n\t\treturn;\n\t}\n\n#To avoid tripping up tests which expect pristine STDERR. We output debug elsewhere..\n\n\tif ( defined $self->{stddbg} && $self->{stddbg} ne '' ) {\n\t\t$debug=1;\n\t\t#Open the new stream for append\n\t\topen( STDDBG, '>>', $self->{stddbg} )\n\t\t  or die \"Cannot open new stddbg $self->{stddbg}: $!\";\n\n\t\t#Enable autoflush\n\t\tselect STDDBG;\n\t\t$| = 1;\n\t}\n\n\tif ( defined $self->{debug}) {\n\t\t$debug = $self->{debug};\n\t}\n\n#To redirect the streams on UNIX we are going to open our I/O streams to the\n#target streams, spawn the process and then switch back to our originals for the parent.\n#\n\n\t#Save our current streams if we need to\n\tlocal ( *OLDIN, *OLDERR, *OLDOUT );\n\n\tif ( defined $self->{stdin} && $self->{stdin} ne '' ) {\n\t\topen( OLDIN, \"<&STDIN\" ) or die \"Cannot save current STDIN: $!\";\n\n\t\t#Create the stdin file if it doesn't already exist\n\t\t$self->_touch_file( $self->{stdin} );\n\n\t\t#Reopen STDIN from the stdin file\n\t\topen( STDIN, '<', $self->{stdin} )\n\t\t  or die \"Cannot open new stdin $self->{stdin}: $!\";\n\t}\n\t#  Do stdout LAST because it remains selected as default\n\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\topen( OLDERR, \">&STDERR\" ) or die \"Cannot save current STDERR: $!\";\n\n\t\t#Open the new stream for append\n\t\topen( STDERR, '>>', $self->{stderr} )\n\t\t  or die \"Cannot open new stderr $self->{stderr}: $!\";\n\n\t\t#Enable autoflush\n\t\tselect STDERR;\n\t\t$| = 1;\n\t}\n\n\tif ( defined $self->{stdout} && $self->{stdout} ne '' ) {\n\t\topen( OLDOUT, \">&STDOUT\" ) or die \"Cannot save current STDOUT: $!\";\n\n\t\t#Open the new stream for append\n\t\topen( STDOUT, '>>', $self->{stdout} )\n\t\t  or die \"Cannot open new stdout $self->{stdout}: $!\";\n\n"
    },
    "83": {
      "metadata": {
        "chunk_id": "4e213506383583f988a997bccef42c6aff364d7ca77d3d25e1e0001f5743d79f",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/UNIX.pm",
        "content": "\t\t#Enable autoflush\n\t\tselect STDOUT;\n\t\t$| = 1;\n\t}\n\n\t#Now fork a process\n\n\tmy $pid = fork();\n\n\tif ( $pid > 0 ) {\n\n\t\t#This is the path taken by the parent\n\n#Reset all our streams back if we changed them\n#The error messages are a bit difficult because we have no way of reporting them\n#If nothing else they make the code a bit easier to understand\n\t\tif ( defined $self->{stdin} && $self->{stdin} ne '' ) {\n\t\t\topen( STDIN, \"<&OLDIN\" ) or die \"Cannot reset STDIN: $!\";\n\t\t}\n\n\t\tif ( defined $self->{stdout} && $self->{stdout} ne '' ) {\n\t\t\topen( STDOUT, \">&OLDOUT\" ) or die \"Cannot reset STDOUT: $!\";\n\t\t}\n\n\t\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\t\topen( STDERR, \">&OLDERR\" ) or die \"Cannot reset STDERR: $!\";\n\t\t}\n\n\t\t#Store the pid\n\t\t$self->{pid} = $pid;\n\n\t\t#Change the state\n\t\t$self->{state} = stf::ProcessMgmt::STATE_STARTED;\n\n\t\treturn 1;\n\t}\n\telsif ( defined $pid ) {\n\n\t\t#This is the path taken by the child\n\n\t\tmy @args;\n\n\t\tif ( defined $self->{args} ) {\n\t\t\t@args = @{ $self->{args} };\n\t\t}\n\n\t\tmy $command = $self->{command};\n\n\t\tif ( defined $self->{affinity} )\n\t\t{\n\t\t\tif ($^O eq 'linux')\n\t\t\t{\n\t\t\t\tunshift(@args, $self->{affinity}, $command);\n\t\t\t\t$command = \"taskset\";\t\t\t\t\t\n\t\t\t} elsif ($^O eq 'aix')\n\t\t\t{\n\t\t\t\tmy @available_processors = `bindprocessor -q`;\n\t\t\t\tif($available_processors[0] =~ /\\b$self->{affinity}\\b/)\n\t\t\t\t{\n\t\t\t\t\t# Requested processor was available in the list reported by the system\n\t\t\t\t\t`bindprocessor $$ $self->{affinity}`;\n\t\t\t\t\tif($? != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdie \"Couldn't bind process $$ to requested processor $self->{affinity}. Error : $!\";\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t} elsif ($^O eq 'os390')\n\t\t\t{\n\t\t\t\t#Dunno yet either\n\t\t\t} else\n\t\t\t{\n\t\t\t\tprint \"\\n\\n####################\\nSetting processor affinity on $^O is not yet supported\\n####################\\n\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif ( $debug ) {\n\t\t\tprint STDDBG \"exec($command @args\\n)\"; # Output did not even reveal the command we actually invoked\n\t\t}\n\n\t\t# Exec will not return if it works. If it doesn't work we need to print a message and die.\n\t\tif ( $self->{dontJoinArgs} )\n\t\t{\n\t\t\texec($command, @args) or do {\n\n\t\t\t\t#Sample the error code ($! will get overridden by open())\n\t\t\t\tmy $err_code = $!;\n\n\t\t\t\t#Reset the error stream\n\t\t\t\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\t\t\t\topen( STDERR, \">&OLDERR\" ) or die \"Cannot reset STDERR: $!\";\n\t\t\t\t}\n\n\t\t\t\tdie \"Could not execute command $command: $err_code\";\n\t\t\t};\t\t\t\n\t\t} else\n\t\t{\n\t\t\t$command = $self->{command} . ' ' . join( ' ', @args );\n\t\t\texec($command) or do {\n\n\t\t\t\t#Sample the error code ($! will get overridden by open())\n\t\t\t\tmy $err_code = $!;\n\n\t\t\t\t#Reset the error stream\n\t\t\t\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\t\t\t\topen( STDERR, \">&OLDERR\" ) or die \"Cannot reset STDERR: $!\";\n\t\t\t\t}\n\n\t\t\t\tdie \"Could not execute command $command: $err_code\";\n\t\t\t};\n\t\t}\n\t\tmy $print_command  = join( \" \", $command, @args );\n\t\tprint \"stf::ProcessMgmt::Unix.pm: Running command\\n\";\n\t\tprint \"$print_command \\n\";\n\n\t}\n\telse {\n\n\t\t#This is the path taken if the fork didn't work\n\t\t#Reset our streams, print a warning and return undef\n\n\t\tif ( defined $self->{stdin} && $self->{stdin} ne '' ) {\n\t\t\topen( STDIN, \"<&OLDIN\" ) or die \"Cannot reset STDIN: $!\";\n\t\t}\n\n",
        "start_line": 131,
        "end_line": 255,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 987,
        "node_type": null,
        "file_sha": "1e10c110e64b82ae6dc810d07b30f8cc03836513",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.742562"
      },
      "text": "\t\t#Enable autoflush\n\t\tselect STDOUT;\n\t\t$| = 1;\n\t}\n\n\t#Now fork a process\n\n\tmy $pid = fork();\n\n\tif ( $pid > 0 ) {\n\n\t\t#This is the path taken by the parent\n\n#Reset all our streams back if we changed them\n#The error messages are a bit difficult because we have no way of reporting them\n#If nothing else they make the code a bit easier to understand\n\t\tif ( defined $self->{stdin} && $self->{stdin} ne '' ) {\n\t\t\topen( STDIN, \"<&OLDIN\" ) or die \"Cannot reset STDIN: $!\";\n\t\t}\n\n\t\tif ( defined $self->{stdout} && $self->{stdout} ne '' ) {\n\t\t\topen( STDOUT, \">&OLDOUT\" ) or die \"Cannot reset STDOUT: $!\";\n\t\t}\n\n\t\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\t\topen( STDERR, \">&OLDERR\" ) or die \"Cannot reset STDERR: $!\";\n\t\t}\n\n\t\t#Store the pid\n\t\t$self->{pid} = $pid;\n\n\t\t#Change the state\n\t\t$self->{state} = stf::ProcessMgmt::STATE_STARTED;\n\n\t\treturn 1;\n\t}\n\telsif ( defined $pid ) {\n\n\t\t#This is the path taken by the child\n\n\t\tmy @args;\n\n\t\tif ( defined $self->{args} ) {\n\t\t\t@args = @{ $self->{args} };\n\t\t}\n\n\t\tmy $command = $self->{command};\n\n\t\tif ( defined $self->{affinity} )\n\t\t{\n\t\t\tif ($^O eq 'linux')\n\t\t\t{\n\t\t\t\tunshift(@args, $self->{affinity}, $command);\n\t\t\t\t$command = \"taskset\";\t\t\t\t\t\n\t\t\t} elsif ($^O eq 'aix')\n\t\t\t{\n\t\t\t\tmy @available_processors = `bindprocessor -q`;\n\t\t\t\tif($available_processors[0] =~ /\\b$self->{affinity}\\b/)\n\t\t\t\t{\n\t\t\t\t\t# Requested processor was available in the list reported by the system\n\t\t\t\t\t`bindprocessor $$ $self->{affinity}`;\n\t\t\t\t\tif($? != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdie \"Couldn't bind process $$ to requested processor $self->{affinity}. Error : $!\";\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t} elsif ($^O eq 'os390')\n\t\t\t{\n\t\t\t\t#Dunno yet either\n\t\t\t} else\n\t\t\t{\n\t\t\t\tprint \"\\n\\n####################\\nSetting processor affinity on $^O is not yet supported\\n####################\\n\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif ( $debug ) {\n\t\t\tprint STDDBG \"exec($command @args\\n)\"; # Output did not even reveal the command we actually invoked\n\t\t}\n\n\t\t# Exec will not return if it works. If it doesn't work we need to print a message and die.\n\t\tif ( $self->{dontJoinArgs} )\n\t\t{\n\t\t\texec($command, @args) or do {\n\n\t\t\t\t#Sample the error code ($! will get overridden by open())\n\t\t\t\tmy $err_code = $!;\n\n\t\t\t\t#Reset the error stream\n\t\t\t\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\t\t\t\topen( STDERR, \">&OLDERR\" ) or die \"Cannot reset STDERR: $!\";\n\t\t\t\t}\n\n\t\t\t\tdie \"Could not execute command $command: $err_code\";\n\t\t\t};\t\t\t\n\t\t} else\n\t\t{\n\t\t\t$command = $self->{command} . ' ' . join( ' ', @args );\n\t\t\texec($command) or do {\n\n\t\t\t\t#Sample the error code ($! will get overridden by open())\n\t\t\t\tmy $err_code = $!;\n\n\t\t\t\t#Reset the error stream\n\t\t\t\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\t\t\t\topen( STDERR, \">&OLDERR\" ) or die \"Cannot reset STDERR: $!\";\n\t\t\t\t}\n\n\t\t\t\tdie \"Could not execute command $command: $err_code\";\n\t\t\t};\n\t\t}\n\t\tmy $print_command  = join( \" \", $command, @args );\n\t\tprint \"stf::ProcessMgmt::Unix.pm: Running command\\n\";\n\t\tprint \"$print_command \\n\";\n\n\t}\n\telse {\n\n\t\t#This is the path taken if the fork didn't work\n\t\t#Reset our streams, print a warning and return undef\n\n\t\tif ( defined $self->{stdin} && $self->{stdin} ne '' ) {\n\t\t\topen( STDIN, \"<&OLDIN\" ) or die \"Cannot reset STDIN: $!\";\n\t\t}\n\n"
    },
    "84": {
      "metadata": {
        "chunk_id": "adef0d3fc673e7d9dbf66b8e32e6ee9828329e25dafd04a744967dcac5ad0d29",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/UNIX.pm",
        "content": "\t\tif ( defined $self->{stdout} && $self->{stdout} ne '' ) {\n\t\t\topen( STDOUT, \">&OLDOUT\" ) or die \"Cannot reset STDOUT: $!\";\n\t\t}\n\n\t\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\t\topen( STDERR, \">&OLDERR\" ) or die \"Cannot reset STDERR: $!\";\n\t\t}\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\n\t\t$self->{err_msg} = \"Couldn't fork\";\n\n\t\treturn undef;\n\t}\n}\n\nsub stop {\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_STARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only stop a started process. Current state is: $state_name\";\n\n\t\treturn undef;\n\t}\n\n\tmy $pid = $self->{pid};\n\n\tmy $kill_result = kill(1, $pid);\n\n\tif($kill_result > 0)\n\t{\n\t\t#The kill signalled something\n\n\t\t#Do a wait to get the process status\n\t\t#If it doesn't die in 10 seconds we'll return false\n\t\treturn $self->wait(10);\n\t}\n\telse\n\t{\n\t\t#The kill didn't signal anything\n\t\twarn \"Kill didn't signal any process (aimed at PID = $pid)\";\n\n\t\treturn undef;\n\t}\n}\n\nsub terminate {\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_STARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only terminated a started process. Current state is: $state_name\";\n\n\t\treturn undef;\n\t}\n\n\tmy $pid = $self->{pid};\n\n\tmy $kill_result = kill(9, $pid);\n\n\tif($kill_result > 0)\n\t{\n\t\t#The kill signalled something\n\n\t\t#Do a wait to get the process status\n\t\treturn $self->wait(10);\n\t}\n\telse\n\t{\n\t\t#The kill didn't signal anything\n\t\twarn \"Kill didn't signal any process (aimed at PID = $pid)\";\n\n\t\treturn undef;\n\t}\n}\n\nsub poll {\n\tmy $self = shift;\n\n\tif($self->{state} == stf::ProcessMgmt::STATE_COMPLETED)\n\t{\n\t\t#This process has already died\n\t\treturn undef;\n\t}\n\telsif($self->{state} == stf::ProcessMgmt::STATE_ERROR)\n\t{\n\t\t#We're in error - say the process has finished\n\t\treturn undef;\n\t}\n\telsif($self->{state} == stf::ProcessMgmt::STATE_UNSTARTED)\n\t{\n\t\twarn \"You can't poll an unstarted process.\";\n\n\t\treturn undef;\n\t}\n\n\tmy $wait_result = waitpid( $self->{pid}, &WNOHANG );\n\n\tif ( $wait_result == 0 ) {\n\n\t\t# A 0 return code means \"timeout\" for waitpid with WNOHANG,\n\t\t# implying that the child process is alive and still running.\n\t\t# We can exit with \"alive\" as a return code.\n\t\treturn 1;\n\t}\n\telsif ( $wait_result == -1 ) {\n\n\t\t# Shroedinger's cat . . .\n\t\t# We have no child processes at all. This does NOT mean\n\t\t# that the process we're polling for is alive or dead - we\n\t\t# need to do a kill -0 further down to find that out.\n\t}\n\telse {\n\n\t\t# waitpid returned something other than 0 or -1, so\n\t\t# the process was a child of ours, but is now dead.\n\t\t# We can return with a \"dead\" return code.\n\t\t# process has finished. save away its vital statistix.\n\t\t$self->{result} = new stf::ProcessMgmt::Result($?);\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_COMPLETED;\n\n\t\treturn undef;\n\t}\n\n\t# If we're here, then the waitpid was not informative.\n\t# This means we must use a kill -0 to test if the process\n\t# is still around.\n\tmy $res = kill 0, $self->{pid};\n\tif ( $res == 1 ) {\n\n",
        "start_line": 256,
        "end_line": 394,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 953,
        "node_type": null,
        "file_sha": "1e10c110e64b82ae6dc810d07b30f8cc03836513",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.742571"
      },
      "text": "\t\tif ( defined $self->{stdout} && $self->{stdout} ne '' ) {\n\t\t\topen( STDOUT, \">&OLDOUT\" ) or die \"Cannot reset STDOUT: $!\";\n\t\t}\n\n\t\tif ( defined $self->{stderr} && $self->{stderr} ne '' ) {\n\t\t\topen( STDERR, \">&OLDERR\" ) or die \"Cannot reset STDERR: $!\";\n\t\t}\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\n\t\t$self->{err_msg} = \"Couldn't fork\";\n\n\t\treturn undef;\n\t}\n}\n\nsub stop {\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_STARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only stop a started process. Current state is: $state_name\";\n\n\t\treturn undef;\n\t}\n\n\tmy $pid = $self->{pid};\n\n\tmy $kill_result = kill(1, $pid);\n\n\tif($kill_result > 0)\n\t{\n\t\t#The kill signalled something\n\n\t\t#Do a wait to get the process status\n\t\t#If it doesn't die in 10 seconds we'll return false\n\t\treturn $self->wait(10);\n\t}\n\telse\n\t{\n\t\t#The kill didn't signal anything\n\t\twarn \"Kill didn't signal any process (aimed at PID = $pid)\";\n\n\t\treturn undef;\n\t}\n}\n\nsub terminate {\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_STARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only terminated a started process. Current state is: $state_name\";\n\n\t\treturn undef;\n\t}\n\n\tmy $pid = $self->{pid};\n\n\tmy $kill_result = kill(9, $pid);\n\n\tif($kill_result > 0)\n\t{\n\t\t#The kill signalled something\n\n\t\t#Do a wait to get the process status\n\t\treturn $self->wait(10);\n\t}\n\telse\n\t{\n\t\t#The kill didn't signal anything\n\t\twarn \"Kill didn't signal any process (aimed at PID = $pid)\";\n\n\t\treturn undef;\n\t}\n}\n\nsub poll {\n\tmy $self = shift;\n\n\tif($self->{state} == stf::ProcessMgmt::STATE_COMPLETED)\n\t{\n\t\t#This process has already died\n\t\treturn undef;\n\t}\n\telsif($self->{state} == stf::ProcessMgmt::STATE_ERROR)\n\t{\n\t\t#We're in error - say the process has finished\n\t\treturn undef;\n\t}\n\telsif($self->{state} == stf::ProcessMgmt::STATE_UNSTARTED)\n\t{\n\t\twarn \"You can't poll an unstarted process.\";\n\n\t\treturn undef;\n\t}\n\n\tmy $wait_result = waitpid( $self->{pid}, &WNOHANG );\n\n\tif ( $wait_result == 0 ) {\n\n\t\t# A 0 return code means \"timeout\" for waitpid with WNOHANG,\n\t\t# implying that the child process is alive and still running.\n\t\t# We can exit with \"alive\" as a return code.\n\t\treturn 1;\n\t}\n\telsif ( $wait_result == -1 ) {\n\n\t\t# Shroedinger's cat . . .\n\t\t# We have no child processes at all. This does NOT mean\n\t\t# that the process we're polling for is alive or dead - we\n\t\t# need to do a kill -0 further down to find that out.\n\t}\n\telse {\n\n\t\t# waitpid returned something other than 0 or -1, so\n\t\t# the process was a child of ours, but is now dead.\n\t\t# We can return with a \"dead\" return code.\n\t\t# process has finished. save away its vital statistix.\n\t\t$self->{result} = new stf::ProcessMgmt::Result($?);\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_COMPLETED;\n\n\t\treturn undef;\n\t}\n\n\t# If we're here, then the waitpid was not informative.\n\t# This means we must use a kill -0 to test if the process\n\t# is still around.\n\tmy $res = kill 0, $self->{pid};\n\tif ( $res == 1 ) {\n\n"
    },
    "85": {
      "metadata": {
        "chunk_id": "a5451874edd3d8a01d10d33ae2eb708d3df0c1b64e57c67f4ebd40e2050b1a71",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/UNIX.pm",
        "content": "\t\t# We signalled one process successfully. This means that\n\t\t# the process must be alive in some sense. It could be a\n\t\t# zombie if it's not one of our children. (If it was one\n\t\t# our children, the waitpid further up would've reaped it).\n\t\treturn 1;\n\t}\n\telsif ( ( $res == 0 ) && ( $! == 1 ) ) {\n\n\t\t# EPERM = 1\n\t\t# The process was not signalled because we don't have\n\t\t# permission to send signals to it. It must be alive\n\t\t# or a zombie as detailed above.\n\t\treturn 1;\n\t}\n\telsif ( ( $res == 0 ) && ( $! == 3 ) ) {\n\n\t\t# ESRCH = 3\n\t\t# No process was found, therefore the process we're\n\t\t# looking for must be dead.\n\n #However, we have no means of getting the exit code so we'll call this an error\n #and warn people\n\t\twarn\n\"Error polling process $self->{pid}. Cannot find process completion code.\";\n\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\t\treturn undef;\n\t}\n\telse {\n\n\t\t# Something else has gone wrong :( Not sure how this\n\t\t# could happen.\n\t\twarn \"Unknown error polling process $self->{pid} : $!\";\n\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\n\t\treturn undef;\n\t}\n}\n\nsub wait {\n\tmy ( $self, $wait_time ) = @_;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_STARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only wait on a started process. Current state is: $state_name\";\n\n\t\treturn 1;\n\t}\n\n\tif ( defined $wait_time ) {\n\t\t$wait_time = int $wait_time;\n\n\t\tmy $start_time   = time();\n\t\tmy $give_up_time = $start_time + $wait_time;\n\n\t\twhile ( time() < $give_up_time ) {\n\n\t\t\t# If we've finished quit polling\n\t\t\tlast unless $self->poll();\n\n\t\t\tmy $seconds_been_waiting = time() - $start_time;\n\n\t\t\tif ( $seconds_been_waiting < 120 ) {\n\n\t\t\t\t# We've been waiting for less than 2 minutes\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\telsif ( $seconds_been_waiting < 3600 ) {\n\n\t\t\t\t# We've been waiting for less than an hour\n\t\t\t\tsleep(10);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t# If we've been waiting for more than an hour already\n\t\t\t\t# wait another minute before checking again\n\t\t\t\tsleep(60);\n\t\t\t}\n\t\t}\n\t\t# check if process has completed\n\t\tif ( $self->{state} == stf::ProcessMgmt::STATE_COMPLETED ) {\n\n\t\t\treturn 1;\n\t\t} else {\n\n\t\t\treturn undef;\n\t\t}\n\t}\n\telse {\n\n\t\t#Hard wait\n\t\tmy $rc = waitpid( $self->{pid}, 0 );\n\n\t\tif ( $rc == -1 ) {\n\t\t\twarn\n\"Error: process being waited for ($self->{pid}) is not a child of the current process\";\n\n\t\t\treturn undef;\n\t\t}\n\t\telsif ( $rc == 0 ) {\n\t\t\twarn\n\"Error: process being waited for ($self->{pid}) didn't return from an infinite wait.\";\n\n\t\t\treturn undef;\n\t\t}\n\t\telse {\n\n\t\t\t#We must have finished\n\t\t\t$self->{result} = new stf::ProcessMgmt::Result($?);\n\n\t\t\t$self->{state} = stf::ProcessMgmt::STATE_COMPLETED;\n\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\nsub err_msg {\n\tmy $self = shift;\n\n\treturn $self->{err_msg};\n}\n\nsub get_result {\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_COMPLETED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn \"Error: can only get result from a completed process. Current state is: $state_name\";\n\n\t\treturn undef;\n\t}\n\n\treturn $self->{result};\n}\n\nsub get_state {\n\tmy $self = shift;\n\n\t$self->poll();\n\n\treturn stf::ProcessMgmt::_get_description_for_state($self->{state});\n}\n\nsub pid {\n\tmy $self = shift;\n\n\treturn $self->{pid};\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\n",
        "start_line": 395,
        "end_line": 555,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 995,
        "node_type": null,
        "file_sha": "1e10c110e64b82ae6dc810d07b30f8cc03836513",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.742581"
      },
      "text": "\t\t# We signalled one process successfully. This means that\n\t\t# the process must be alive in some sense. It could be a\n\t\t# zombie if it's not one of our children. (If it was one\n\t\t# our children, the waitpid further up would've reaped it).\n\t\treturn 1;\n\t}\n\telsif ( ( $res == 0 ) && ( $! == 1 ) ) {\n\n\t\t# EPERM = 1\n\t\t# The process was not signalled because we don't have\n\t\t# permission to send signals to it. It must be alive\n\t\t# or a zombie as detailed above.\n\t\treturn 1;\n\t}\n\telsif ( ( $res == 0 ) && ( $! == 3 ) ) {\n\n\t\t# ESRCH = 3\n\t\t# No process was found, therefore the process we're\n\t\t# looking for must be dead.\n\n #However, we have no means of getting the exit code so we'll call this an error\n #and warn people\n\t\twarn\n\"Error polling process $self->{pid}. Cannot find process completion code.\";\n\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\t\treturn undef;\n\t}\n\telse {\n\n\t\t# Something else has gone wrong :( Not sure how this\n\t\t# could happen.\n\t\twarn \"Unknown error polling process $self->{pid} : $!\";\n\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\n\t\treturn undef;\n\t}\n}\n\nsub wait {\n\tmy ( $self, $wait_time ) = @_;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_STARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only wait on a started process. Current state is: $state_name\";\n\n\t\treturn 1;\n\t}\n\n\tif ( defined $wait_time ) {\n\t\t$wait_time = int $wait_time;\n\n\t\tmy $start_time   = time();\n\t\tmy $give_up_time = $start_time + $wait_time;\n\n\t\twhile ( time() < $give_up_time ) {\n\n\t\t\t# If we've finished quit polling\n\t\t\tlast unless $self->poll();\n\n\t\t\tmy $seconds_been_waiting = time() - $start_time;\n\n\t\t\tif ( $seconds_been_waiting < 120 ) {\n\n\t\t\t\t# We've been waiting for less than 2 minutes\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\telsif ( $seconds_been_waiting < 3600 ) {\n\n\t\t\t\t# We've been waiting for less than an hour\n\t\t\t\tsleep(10);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t# If we've been waiting for more than an hour already\n\t\t\t\t# wait another minute before checking again\n\t\t\t\tsleep(60);\n\t\t\t}\n\t\t}\n\t\t# check if process has completed\n\t\tif ( $self->{state} == stf::ProcessMgmt::STATE_COMPLETED ) {\n\n\t\t\treturn 1;\n\t\t} else {\n\n\t\t\treturn undef;\n\t\t}\n\t}\n\telse {\n\n\t\t#Hard wait\n\t\tmy $rc = waitpid( $self->{pid}, 0 );\n\n\t\tif ( $rc == -1 ) {\n\t\t\twarn\n\"Error: process being waited for ($self->{pid}) is not a child of the current process\";\n\n\t\t\treturn undef;\n\t\t}\n\t\telsif ( $rc == 0 ) {\n\t\t\twarn\n\"Error: process being waited for ($self->{pid}) didn't return from an infinite wait.\";\n\n\t\t\treturn undef;\n\t\t}\n\t\telse {\n\n\t\t\t#We must have finished\n\t\t\t$self->{result} = new stf::ProcessMgmt::Result($?);\n\n\t\t\t$self->{state} = stf::ProcessMgmt::STATE_COMPLETED;\n\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\nsub err_msg {\n\tmy $self = shift;\n\n\treturn $self->{err_msg};\n}\n\nsub get_result {\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_COMPLETED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn \"Error: can only get result from a completed process. Current state is: $state_name\";\n\n\t\treturn undef;\n\t}\n\n\treturn $self->{result};\n}\n\nsub get_state {\n\tmy $self = shift;\n\n\t$self->poll();\n\n\treturn stf::ProcessMgmt::_get_description_for_state($self->{state});\n}\n\nsub pid {\n\tmy $self = shift;\n\n\treturn $self->{pid};\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\n"
    },
    "86": {
      "metadata": {
        "chunk_id": "8a255f446289e4fd97e58c82dddb884a0bbb94124f901078f5b7541bfaeab4e8",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/UNIX.pm",
        "content": "stf::ProcessMgmt::UNIX - the UNIX-specific implementation of the ProcessMgmt interface\n\n=head1 DESCRIPTION\n\nContains all the logic for creating and managing processes on UNIX.\n\nYou should not try to create this directly - you should be using the stf::ProcessMgmt class instead.\n\n=cut\n\n\n",
        "start_line": 556,
        "end_line": 567,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 59,
        "node_type": null,
        "file_sha": "1e10c110e64b82ae6dc810d07b30f8cc03836513",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.742590"
      },
      "text": "stf::ProcessMgmt::UNIX - the UNIX-specific implementation of the ProcessMgmt interface\n\n=head1 DESCRIPTION\n\nContains all the logic for creating and managing processes on UNIX.\n\nYou should not try to create this directly - you should be using the stf::ProcessMgmt class instead.\n\n=cut\n\n\n"
    },
    "87": {
      "metadata": {
        "chunk_id": "978d7cd59cca28da0dadf8a1d160d520bae230dac42d7f277fd9224a66cbbdbd",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/Windows.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# stf::ProcessMgmt::Windows - the Windows-specific implementation of the ProcessMgmt interface\n# Contains all the logic for creating and managing processes on Windows.\n# You should not try to create this directly - you should be using the stf::ProcessMgmt class instead.\n\npackage stf::ProcessMgmt::Windows;\n\nuse base qw{stf::ProcessMgmt};\n\nuse strict;\n\nuse warnings;\n\nuse Win32::API;\n\nuse Win32::Process; #Specifies the constant INFINITE we need for waiting\n\nuse File::Spec::Functions qw{catfile};\n\nuse Time::Local;\n\nuse stf::ProcessMgmt::Result;\n\nuse Config;\n\n#Function prototypes\nsub _open_file;\n\n#A few useful constants\n\nuse constant GENERIC_READ  => 0x80000000;\nuse constant GENERIC_WRITE => 0x40000000;\n\nuse constant FILE_ATTRIBUTE_NORMAL => 128;\n\nuse constant FILE_SHARE_READ  => 1;\nuse constant FILE_SHARE_WRITE => 2;\n\nuse constant FILE_BEGIN   => 0;\nuse constant FILE_CURRENT => 1;\nuse constant FILE_END     => 2;\n\nuse constant OPEN_EXISTING => 3;\nuse constant OPEN_ALWAYS   => 4;\n\nuse constant HANDLE_FLAG_INHERIT            => 0x00000001;\nuse constant HANDLE_FLAG_PROTECT_FROM_CLOSE => 0x00000002;\n\nuse constant STD_INPUT_HANDLE  => -10;\nuse constant STD_OUTPUT_HANDLE => -11;\nuse constant STD_ERROR_HANDLE  => -12;\n\nuse constant SECURITY_WORLD_SID_AUTHORITY => \"\\0\\0\\0\\0\\0\\1\";\n\nuse constant ACL_REVISION => 2;\n\nuse constant OBJECT_INHERIT_ACE       => 0x1;\nuse constant CONTAINER_INHERIT_ACE    => 0x2;\nuse constant NO_PROPAGATE_INHERIT_ACE => 0x4;\nuse constant INHERIT_ONLY_ACE         => 0x8;\nuse constant INHERITED_ACE            => 0x10;\nuse constant VALID_INHERIT_FLAGS      => 0x1F;\n\nuse constant STANDARD_RIGHTS_REQUIRED => 0x000F0000;\nuse constant SYNCHRONIZE              => 0x00100000;\n\nuse constant FILE_ALL_ACCESS =>\n  ( STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3FF );\n\nuse constant SECURITY_DESCRIPTOR_REVISION => 1;\n\nuse constant PROCESS_ALL_ACCESS => 0x001F0FFF;\n\n#Define the various Win32 API calls we need to control processes\n\nmy $CreateFile = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\kernel32.dll', 'CreateFile',\n\t[ 'P', 'N', 'N', 'P', 'N', 'N', 'N' ], 'N'\n  )\n  or die \"Can't import API CreateFile: $!\\n\";\n\nmy $SetFilePointer =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'SetFilePointer', [ 'N', 'N', 'N', 'N' ], 'N' )\n  or die \"Can't import API SetFilePointer: $!\\n\";\n\nmy $SetHandleInformation =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'SetHandleInformation', [ 'N', 'N', 'N' ], 'N' )\n  or die \"Can't import API SetHandleInformation: $!\\n\";\n\nmy $GetStdHandle =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'GetStdHandle', ['N'], 'N' )\n  or die \"Can't import API GetStdHandle: $!\\n\";\n\nmy $CloseHandle = new Win32::API( $ENV{\"SystemRoot\"} . '\\system32\\kernel32.dll',\n\t'CloseHandle', ['N'], 'N' )\n  or die \"Can't import API CloseHandle: $!\\n\";\n\n",
        "start_line": 0,
        "end_line": 112,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 959,
        "node_type": null,
        "file_sha": "97f49fad50328c64999e4c56a92a9da7a561c4d9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.749596"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# stf::ProcessMgmt::Windows - the Windows-specific implementation of the ProcessMgmt interface\n# Contains all the logic for creating and managing processes on Windows.\n# You should not try to create this directly - you should be using the stf::ProcessMgmt class instead.\n\npackage stf::ProcessMgmt::Windows;\n\nuse base qw{stf::ProcessMgmt};\n\nuse strict;\n\nuse warnings;\n\nuse Win32::API;\n\nuse Win32::Process; #Specifies the constant INFINITE we need for waiting\n\nuse File::Spec::Functions qw{catfile};\n\nuse Time::Local;\n\nuse stf::ProcessMgmt::Result;\n\nuse Config;\n\n#Function prototypes\nsub _open_file;\n\n#A few useful constants\n\nuse constant GENERIC_READ  => 0x80000000;\nuse constant GENERIC_WRITE => 0x40000000;\n\nuse constant FILE_ATTRIBUTE_NORMAL => 128;\n\nuse constant FILE_SHARE_READ  => 1;\nuse constant FILE_SHARE_WRITE => 2;\n\nuse constant FILE_BEGIN   => 0;\nuse constant FILE_CURRENT => 1;\nuse constant FILE_END     => 2;\n\nuse constant OPEN_EXISTING => 3;\nuse constant OPEN_ALWAYS   => 4;\n\nuse constant HANDLE_FLAG_INHERIT            => 0x00000001;\nuse constant HANDLE_FLAG_PROTECT_FROM_CLOSE => 0x00000002;\n\nuse constant STD_INPUT_HANDLE  => -10;\nuse constant STD_OUTPUT_HANDLE => -11;\nuse constant STD_ERROR_HANDLE  => -12;\n\nuse constant SECURITY_WORLD_SID_AUTHORITY => \"\\0\\0\\0\\0\\0\\1\";\n\nuse constant ACL_REVISION => 2;\n\nuse constant OBJECT_INHERIT_ACE       => 0x1;\nuse constant CONTAINER_INHERIT_ACE    => 0x2;\nuse constant NO_PROPAGATE_INHERIT_ACE => 0x4;\nuse constant INHERIT_ONLY_ACE         => 0x8;\nuse constant INHERITED_ACE            => 0x10;\nuse constant VALID_INHERIT_FLAGS      => 0x1F;\n\nuse constant STANDARD_RIGHTS_REQUIRED => 0x000F0000;\nuse constant SYNCHRONIZE              => 0x00100000;\n\nuse constant FILE_ALL_ACCESS =>\n  ( STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3FF );\n\nuse constant SECURITY_DESCRIPTOR_REVISION => 1;\n\nuse constant PROCESS_ALL_ACCESS => 0x001F0FFF;\n\n#Define the various Win32 API calls we need to control processes\n\nmy $CreateFile = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\kernel32.dll', 'CreateFile',\n\t[ 'P', 'N', 'N', 'P', 'N', 'N', 'N' ], 'N'\n  )\n  or die \"Can't import API CreateFile: $!\\n\";\n\nmy $SetFilePointer =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'SetFilePointer', [ 'N', 'N', 'N', 'N' ], 'N' )\n  or die \"Can't import API SetFilePointer: $!\\n\";\n\nmy $SetHandleInformation =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'SetHandleInformation', [ 'N', 'N', 'N' ], 'N' )\n  or die \"Can't import API SetHandleInformation: $!\\n\";\n\nmy $GetStdHandle =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'GetStdHandle', ['N'], 'N' )\n  or die \"Can't import API GetStdHandle: $!\\n\";\n\nmy $CloseHandle = new Win32::API( $ENV{\"SystemRoot\"} . '\\system32\\kernel32.dll',\n\t'CloseHandle', ['N'], 'N' )\n  or die \"Can't import API CloseHandle: $!\\n\";\n\n"
    },
    "88": {
      "metadata": {
        "chunk_id": "4baba967e369c80ff51ea0e30faf87be52590941f2c89cbeb71150a1597c2833",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/Windows.pm",
        "content": "my $CreateProcess = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\kernel32.dll', 'CreateProcess',\n\t[ 'P', 'P', 'P', 'P', 'N', 'N', 'P', 'P', 'P', 'P' ], 'N'\n  )\n  or die \"Can't import API CreateProcess: $!\\n\";\n\nmy $SetProcessAffinityMask = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\kernel32.dll', 'SetProcessAffinityMask',\n\t[ 'N', 'N' ], 'N'\n  \t)\n  \tor die \"Can't import API SetProcessAffinityMask: $!\\n\";\n\nmy $GetProcessAffinityMask = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\kernel32.dll', 'GetProcessAffinityMask',\n\t[ 'N', 'P', 'P' ], 'N'\n  \t)\n  \tor die \"Can't import API GetProcessAffinityMask: $!\\n\";\n\nmy $AddAccessAllowedAceEx =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\advapi32.dll',\n\t'AddAccessAllowedAceEx', [ 'P', 'N', 'N', 'N', 'P' ], 'N' )\n  or die \"Can't import API AddAccessAllowedAceEx: $!\\n\";\n\nmy $InitializeAcl =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\advapi32.dll',\n\t'InitializeAcl', [ 'P', 'N', 'N' ], 'N' )\n  or die \"Can't import API InitializeAcl: $!\\n\";\n\nmy $InitializeSecurityDescriptor = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\advapi32.dll',\n\t'InitializeSecurityDescriptor',\n\t[ 'P', 'N' ], 'N'\n  )\n  or die \"Can't import API InitializeSecurityDescriptor: $!\\n\";\n\nmy $SetSecurityDescriptorDacl =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\advapi32.dll',\n\t'SetSecurityDescriptorDacl', [ 'P', 'N', 'P', 'N' ], 'N' )\n  or die \"Can't import API SetSecurityDescriptorDacl: $!\\n\";\n\nmy $TerminateProcess =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'TerminateProcess', [ 'N', 'N' ], 'N' )\n  or die \"Can't import API TerminateProcess: $!\\n\";\n\nmy $GetExitCodeProcess =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'GetExitCodeProcess', [ 'N', 'P' ], 'N' )\n  or die \"Can't import API GetExitCodeProcess: $!\\n\";\n\nmy $WaitForSingleObject = new Win32::API\n(\n  $ENV{'SystemRoot'}.'\\system32\\kernel32.dll',\n  'WaitForSingleObject',\n  ['N','N'],\n  'N'\n) or die \"Can't import API WaitForInputIdle: $!\\n\";\n\nmy $OpenProcess = new Win32::API\n(\n  $ENV{'SystemRoot'}.'\\system32\\kernel32.dll',\n  'OpenProcess',\n  ['N','N','N'],\n  'N'\n) or die \"Can't import API WaitForInputIdle: $!\\n\";\n\n#Constructor is inherited\n\nsub _recreate_internal_structure\n{\n\tmy $self = shift;\n\n\t#Convert PID to handle\n\n\t$self->{handle} = $OpenProcess->Call(PROCESS_ALL_ACCESS,0,$self->{pid});\n}\n\nsub start {\n\tmy $self = shift;\n\n\t# Create a starttime object attribute\n\t$self->{starttime} = timelocal(localtime());\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_UNSTARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only start an unstarted process. Current state is: $state_name\";\n\n\t\treturn;\n\t}\n\n\t# Save STDIN, STDOUT, STDERR file handles\n\topen (STDIN_OLD, '<&STDIN');\n\topen (STDOUT_OLD, '>&STDOUT');\n\topen (STDERR_OLD, '>&STDERR');\n\n",
        "start_line": 113,
        "end_line": 211,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 954,
        "node_type": null,
        "file_sha": "97f49fad50328c64999e4c56a92a9da7a561c4d9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.749606"
      },
      "text": "my $CreateProcess = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\kernel32.dll', 'CreateProcess',\n\t[ 'P', 'P', 'P', 'P', 'N', 'N', 'P', 'P', 'P', 'P' ], 'N'\n  )\n  or die \"Can't import API CreateProcess: $!\\n\";\n\nmy $SetProcessAffinityMask = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\kernel32.dll', 'SetProcessAffinityMask',\n\t[ 'N', 'N' ], 'N'\n  \t)\n  \tor die \"Can't import API SetProcessAffinityMask: $!\\n\";\n\nmy $GetProcessAffinityMask = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\kernel32.dll', 'GetProcessAffinityMask',\n\t[ 'N', 'P', 'P' ], 'N'\n  \t)\n  \tor die \"Can't import API GetProcessAffinityMask: $!\\n\";\n\nmy $AddAccessAllowedAceEx =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\advapi32.dll',\n\t'AddAccessAllowedAceEx', [ 'P', 'N', 'N', 'N', 'P' ], 'N' )\n  or die \"Can't import API AddAccessAllowedAceEx: $!\\n\";\n\nmy $InitializeAcl =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\advapi32.dll',\n\t'InitializeAcl', [ 'P', 'N', 'N' ], 'N' )\n  or die \"Can't import API InitializeAcl: $!\\n\";\n\nmy $InitializeSecurityDescriptor = new Win32::API(\n\t$ENV{'SystemRoot'} . '\\system32\\advapi32.dll',\n\t'InitializeSecurityDescriptor',\n\t[ 'P', 'N' ], 'N'\n  )\n  or die \"Can't import API InitializeSecurityDescriptor: $!\\n\";\n\nmy $SetSecurityDescriptorDacl =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\advapi32.dll',\n\t'SetSecurityDescriptorDacl', [ 'P', 'N', 'P', 'N' ], 'N' )\n  or die \"Can't import API SetSecurityDescriptorDacl: $!\\n\";\n\nmy $TerminateProcess =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'TerminateProcess', [ 'N', 'N' ], 'N' )\n  or die \"Can't import API TerminateProcess: $!\\n\";\n\nmy $GetExitCodeProcess =\n  new Win32::API( $ENV{'SystemRoot'} . '\\system32\\kernel32.dll',\n\t'GetExitCodeProcess', [ 'N', 'P' ], 'N' )\n  or die \"Can't import API GetExitCodeProcess: $!\\n\";\n\nmy $WaitForSingleObject = new Win32::API\n(\n  $ENV{'SystemRoot'}.'\\system32\\kernel32.dll',\n  'WaitForSingleObject',\n  ['N','N'],\n  'N'\n) or die \"Can't import API WaitForInputIdle: $!\\n\";\n\nmy $OpenProcess = new Win32::API\n(\n  $ENV{'SystemRoot'}.'\\system32\\kernel32.dll',\n  'OpenProcess',\n  ['N','N','N'],\n  'N'\n) or die \"Can't import API WaitForInputIdle: $!\\n\";\n\n#Constructor is inherited\n\nsub _recreate_internal_structure\n{\n\tmy $self = shift;\n\n\t#Convert PID to handle\n\n\t$self->{handle} = $OpenProcess->Call(PROCESS_ALL_ACCESS,0,$self->{pid});\n}\n\nsub start {\n\tmy $self = shift;\n\n\t# Create a starttime object attribute\n\t$self->{starttime} = timelocal(localtime());\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_UNSTARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only start an unstarted process. Current state is: $state_name\";\n\n\t\treturn;\n\t}\n\n\t# Save STDIN, STDOUT, STDERR file handles\n\topen (STDIN_OLD, '<&STDIN');\n\topen (STDOUT_OLD, '>&STDOUT');\n\topen (STDERR_OLD, '>&STDERR');\n\n"
    },
    "89": {
      "metadata": {
        "chunk_id": "3cbb507ef737ae0da95da1289519a7cf6effba24626d16efa47ce23df1aa1190",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/Windows.pm",
        "content": "\t# Redirect STDIN, STDOUT, STDERR as required\n\tif ( defined( $self->{stdin} ) && $self->{stdin} ne '' ) {\n\t   open STDIN, \"<$self->{stdin}\" or die \"Can't open \" . $self->{stdin} . \": $!\\n\";\n\t}\n\tif ( defined( $self->{stdout} ) && $self->{stdout} ne '' ) {\n\t   open STDOUT, \">>$self->{stdout}\" or die \"Can't open \" . $self->{stdout} . \": $!\\n\";\n\t}\n\tif ( defined( $self->{stderr} ) && $self->{stderr} ne '' ) {\n\t   open STDERR, \">>$self->{stderr}\" or die \"Can't open \" . $self->{stderr} . \": $!\\n\";\n\t}\n\n\tmy $StartupInfo = \"\\0\" x 68;\n\tmy $ProcessInformation = \"\\0\" x 40;\n\n\t# Convert the command in to the short path (8:3) format\n\t# We use GetLongPathName inside this because GetShortPathName does\n\t# not appear to work on paths that are not in the correct case.\n\t# For some reason GetLongPathName works and fixes this!\n\tmy $short_path_name =\n\t  Win32::GetShortPathName( Win32::GetLongPathName( $self->{command} ) );\n\n\t# If $short_path_name is the empty string then the file doesn't exist!\n\tif ( !$short_path_name ) {\n\t\tdie \"Command $self->{command} does not exist\";\n\t}\n\n\tif ( !defined $self->{args} ) {\n\t\t$self->{args} = [];\n\t}\n\n\tmy $long_path = Win32::GetLongPathName( $self->{command} ) . \"\\0\";\n\tmy $args      = join( \" \", $short_path_name, @{ $self->{args} } ) . \"\\0\";\n\tmy $print_command  = join( \" \", $long_path, @{ $self->{args} } );\n\n\t# print \"stf::ProcessMgmt::Windows.pm: Running command\\n\";\n\t# print \"$print_command \\n\";\n\n    my $result;\n\n    if ((defined $self->{new_console}) && ($self->{new_console} == 1))\n    {\n\t   $result = $CreateProcess->Call(\n\t\t  $long_path,\n\t\t  $args,\n\t\t  0,    #Was undef and causing complaints\n\t\t  0,    #Was undef and causing complaints\n\t\t  1,\n\t      CREATE_NEW_CONSOLE,\n\t\t  0,\n\t\t  \".\\0\",\n\t\t  $StartupInfo,\n\t\t  $ProcessInformation,\n\t   );\n    } else\n    {\n       $result = $CreateProcess->Call(\n\t\t  $long_path,\n\t\t  $args,\n\t\t  0,    #Was undef and causing complaints\n\t\t  0,    #Was undef and causing complaints\n\t\t  1,\n\t      0,\n\t\t  0,\n\t\t  \".\\0\",\n\t\t  $StartupInfo,\n\t\t  $ProcessInformation,\n\t   );\n    }\n\n\t# Restore STDIN, STDOUT, STDERR\n\topen (STDIN, '<&STDIN_OLD');\n\topen (STDOUT, '>>&STDOUT_OLD');\n\topen (STDERR, '>>&STDERR_OLD');\n\n\tif ($result) {\n\n\t\tmy $handle;\n\t\tmy $pid;\n\t\tif($Config{ptrsize} == 8) {\n\t\t\t( $handle, $pid ) = unpack \"Qx8L\", $ProcessInformation;\n\t\t}\n\t\telse {\n\t\t\t( $handle, $pid ) = unpack \"Lx4L\", $ProcessInformation;\n\t\t}\n\n\t\t$self->{handle} = $handle;\n\t\t$self->{pid}    = $pid;\n\n\t\tif($self->{affinity})\n\t\t{\n\t\t\tmy $processor_mask = \"\\0\"x4;\n\t\t\tmy $system_mask = \"\\0\"x4;\n\n\t\t\tmy $affinity_result = $GetProcessAffinityMask->Call($handle,$processor_mask,$system_mask);\n\n\t\t\tmy $processor_mask_value = unpack(\"L\",$processor_mask);\n \t\t\tmy $system_mask_value = unpack(\"L\",$system_mask);\t\t\t\n\n\t\t\tif ($self->{affinity} le $system_mask_value)\n\t\t\t{\n\t\t\t\tmy $set_affinity_result = $SetProcessAffinityMask->Call($handle,$self->{affinity});\n\n\t\t\t\tif (!$set_affinity_result)\n\t\t\t\t{\n\t\t\t\t\tmy $error_number = Win32::GetLastError();\n\n\t\t\t\t\tmy $error_string = Win32::FormatMessage($error_number);\n\n\t\t\t\t\tif ( $error_number == 193 ) {\n\t\t\t\t\t\t$error_string =\n\t\t\t    \t\t\t'Invalid Win32 application. If your command is a Perl '\n\t\t\t\t\t\t  . 'script you must use Perl as your command and your fully qualified '\n\t\t\t\t\t\t  . 'script as the first argument.';\n\t\t\t\t\t}\n\n",
        "start_line": 212,
        "end_line": 327,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 993,
        "node_type": null,
        "file_sha": "97f49fad50328c64999e4c56a92a9da7a561c4d9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.749610"
      },
      "text": "\t# Redirect STDIN, STDOUT, STDERR as required\n\tif ( defined( $self->{stdin} ) && $self->{stdin} ne '' ) {\n\t   open STDIN, \"<$self->{stdin}\" or die \"Can't open \" . $self->{stdin} . \": $!\\n\";\n\t}\n\tif ( defined( $self->{stdout} ) && $self->{stdout} ne '' ) {\n\t   open STDOUT, \">>$self->{stdout}\" or die \"Can't open \" . $self->{stdout} . \": $!\\n\";\n\t}\n\tif ( defined( $self->{stderr} ) && $self->{stderr} ne '' ) {\n\t   open STDERR, \">>$self->{stderr}\" or die \"Can't open \" . $self->{stderr} . \": $!\\n\";\n\t}\n\n\tmy $StartupInfo = \"\\0\" x 68;\n\tmy $ProcessInformation = \"\\0\" x 40;\n\n\t# Convert the command in to the short path (8:3) format\n\t# We use GetLongPathName inside this because GetShortPathName does\n\t# not appear to work on paths that are not in the correct case.\n\t# For some reason GetLongPathName works and fixes this!\n\tmy $short_path_name =\n\t  Win32::GetShortPathName( Win32::GetLongPathName( $self->{command} ) );\n\n\t# If $short_path_name is the empty string then the file doesn't exist!\n\tif ( !$short_path_name ) {\n\t\tdie \"Command $self->{command} does not exist\";\n\t}\n\n\tif ( !defined $self->{args} ) {\n\t\t$self->{args} = [];\n\t}\n\n\tmy $long_path = Win32::GetLongPathName( $self->{command} ) . \"\\0\";\n\tmy $args      = join( \" \", $short_path_name, @{ $self->{args} } ) . \"\\0\";\n\tmy $print_command  = join( \" \", $long_path, @{ $self->{args} } );\n\n\t# print \"stf::ProcessMgmt::Windows.pm: Running command\\n\";\n\t# print \"$print_command \\n\";\n\n    my $result;\n\n    if ((defined $self->{new_console}) && ($self->{new_console} == 1))\n    {\n\t   $result = $CreateProcess->Call(\n\t\t  $long_path,\n\t\t  $args,\n\t\t  0,    #Was undef and causing complaints\n\t\t  0,    #Was undef and causing complaints\n\t\t  1,\n\t      CREATE_NEW_CONSOLE,\n\t\t  0,\n\t\t  \".\\0\",\n\t\t  $StartupInfo,\n\t\t  $ProcessInformation,\n\t   );\n    } else\n    {\n       $result = $CreateProcess->Call(\n\t\t  $long_path,\n\t\t  $args,\n\t\t  0,    #Was undef and causing complaints\n\t\t  0,    #Was undef and causing complaints\n\t\t  1,\n\t      0,\n\t\t  0,\n\t\t  \".\\0\",\n\t\t  $StartupInfo,\n\t\t  $ProcessInformation,\n\t   );\n    }\n\n\t# Restore STDIN, STDOUT, STDERR\n\topen (STDIN, '<&STDIN_OLD');\n\topen (STDOUT, '>>&STDOUT_OLD');\n\topen (STDERR, '>>&STDERR_OLD');\n\n\tif ($result) {\n\n\t\tmy $handle;\n\t\tmy $pid;\n\t\tif($Config{ptrsize} == 8) {\n\t\t\t( $handle, $pid ) = unpack \"Qx8L\", $ProcessInformation;\n\t\t}\n\t\telse {\n\t\t\t( $handle, $pid ) = unpack \"Lx4L\", $ProcessInformation;\n\t\t}\n\n\t\t$self->{handle} = $handle;\n\t\t$self->{pid}    = $pid;\n\n\t\tif($self->{affinity})\n\t\t{\n\t\t\tmy $processor_mask = \"\\0\"x4;\n\t\t\tmy $system_mask = \"\\0\"x4;\n\n\t\t\tmy $affinity_result = $GetProcessAffinityMask->Call($handle,$processor_mask,$system_mask);\n\n\t\t\tmy $processor_mask_value = unpack(\"L\",$processor_mask);\n \t\t\tmy $system_mask_value = unpack(\"L\",$system_mask);\t\t\t\n\n\t\t\tif ($self->{affinity} le $system_mask_value)\n\t\t\t{\n\t\t\t\tmy $set_affinity_result = $SetProcessAffinityMask->Call($handle,$self->{affinity});\n\n\t\t\t\tif (!$set_affinity_result)\n\t\t\t\t{\n\t\t\t\t\tmy $error_number = Win32::GetLastError();\n\n\t\t\t\t\tmy $error_string = Win32::FormatMessage($error_number);\n\n\t\t\t\t\tif ( $error_number == 193 ) {\n\t\t\t\t\t\t$error_string =\n\t\t\t    \t\t\t'Invalid Win32 application. If your command is a Perl '\n\t\t\t\t\t\t  . 'script you must use Perl as your command and your fully qualified '\n\t\t\t\t\t\t  . 'script as the first argument.';\n\t\t\t\t\t}\n\n"
    },
    "90": {
      "metadata": {
        "chunk_id": "0c45b99ad1c0651615f536ca983be66c9ed7ecf44c073183910ec2fd213d7252",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/Windows.pm",
        "content": "\t\t\t\t\t$self->{err_msg} = $error_string;\n\n\t\t\t\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_STARTED;\n\n\t\treturn 1;\n\t}\n\telse {\n\t\tmy $error_number = Win32::GetLastError();\n\n\t\tmy $error_string = Win32::FormatMessage($error_number);\n\n\t\tif ( $error_number == 193 ) {\n\t\t\t$error_string =\n\t\t\t    'Invalid Win32 application. If your command is a Perl '\n\t\t\t  . 'script you must use Perl as your command and your fully qualified '\n\t\t\t  . 'script as the first argument.';\n\t\t}\n\n\t\t$self->{err_msg} = $error_string;\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\n\t\treturn undef;\n\t}\n}\n\nsub stop {\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_STARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only stop a started process. Current state is: $state_name\";\n\n\t\treturn;\n\t}\n\n\tif ( $TerminateProcess->Call( $self->{handle}, 9 ) ) {\n\t\tmy $code = \"\\0\" x 4;\n\t\t$GetExitCodeProcess->Call( $self->{handle}, $code );\n\t\t($code) = unpack \"L\", $code;\n\n\t\t$self->{result} = new stf::ProcessMgmt::Result($code);\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_COMPLETED;\n\n\t\t$CloseHandle->Call( $self->{handle} );\n\n\t\treturn 1;\n\t}\n\telse {\n\t\twarn \"Could not terminate process PID=$self->{pid}: \"\n\t\t  . Win32::FormatMessage( Win32::GetLastError() );\n\n\t\treturn undef;\n\t}\n}\n\nsub pid {\n\tmy $self = shift;\n\n\treturn $self->{pid};\n}\n\n#N.b. there is no difference between stop() and terminate() on Windows.\nsub terminate {\n\tmy $self = shift;\n\n\t$self->stop();\n}\n\nsub poll {\n\tmy $self = shift;\n\n\treturn !$self->wait(0);\n}\n\nsub wait {\n\tmy ( $self, $wait_time ) = @_;\n\n\tif($self->{state} == stf::ProcessMgmt::STATE_COMPLETED)\n\t{\n\t\t#This process has already died\n\t\treturn 1;\n\t}\n\telsif($self->{state} == stf::ProcessMgmt::STATE_ERROR)\n\t{\n\t\t#We're in error - say the process has finished\n\t\treturn 1;\n\t}\n\telsif($self->{state} == stf::ProcessMgmt::STATE_UNSTARTED)\n\t{\n\t\twarn \"You can't wait on an unstarted process.\";\n\n\t\treturn 1;\n\t}\n\n\tif ( defined $wait_time ) {\n\t\t$wait_time = 1000 * int $wait_time;\n\t}\n\telse {\n\t\t$wait_time = INFINITE;\n\t}\n\n\tif ( 0 == $WaitForSingleObject->Call( $self->{handle}, $wait_time ) ) {\n\t\t#Process ended - extract the result\n\t\tmy $code = \"\\0\" x 4;\n        my $ret = $GetExitCodeProcess->Call( $self->{handle}, $code );\n \t\tif($ret == 0)\n\t\t{\n\t\t\twarn \"GetExitCodeProcess failed (rc==0). Artificially setting return code as -1\";\n\t\t\t$code = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t($code) = unpack \"L\", $code;\t\t\n\t\t}\n\t\t$self->{result} = new stf::ProcessMgmt::Result($code);\n\t\t$CloseHandle->Call( $self->{handle} );\n\t\t$self->{state} = stf::ProcessMgmt::STATE_COMPLETED;\n\t\treturn 1;\n\t}\n\telse {\n\t\t#Process still running\n\t\treturn undef;\n\t}\n}\n\nsub err_msg {\n\tmy $self = shift;\n\n\treturn $self->{err_msg};\n}\n\nsub get_result\n{\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_COMPLETED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn \"Error: can only get result from a completed process. Current state is: $state_name\";\n\n\t\treturn undef;\n\t}\n\n\treturn $self->{result};\n}\n\nsub get_state {\n\tmy $self = shift;\n\n\t$self->poll();\n\n",
        "start_line": 328,
        "end_line": 492,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 995,
        "node_type": null,
        "file_sha": "97f49fad50328c64999e4c56a92a9da7a561c4d9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.749614"
      },
      "text": "\t\t\t\t\t$self->{err_msg} = $error_string;\n\n\t\t\t\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\n\t\t\t\t\treturn undef;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_STARTED;\n\n\t\treturn 1;\n\t}\n\telse {\n\t\tmy $error_number = Win32::GetLastError();\n\n\t\tmy $error_string = Win32::FormatMessage($error_number);\n\n\t\tif ( $error_number == 193 ) {\n\t\t\t$error_string =\n\t\t\t    'Invalid Win32 application. If your command is a Perl '\n\t\t\t  . 'script you must use Perl as your command and your fully qualified '\n\t\t\t  . 'script as the first argument.';\n\t\t}\n\n\t\t$self->{err_msg} = $error_string;\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_ERROR;\n\n\t\treturn undef;\n\t}\n}\n\nsub stop {\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_STARTED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn\n\"Error: can only stop a started process. Current state is: $state_name\";\n\n\t\treturn;\n\t}\n\n\tif ( $TerminateProcess->Call( $self->{handle}, 9 ) ) {\n\t\tmy $code = \"\\0\" x 4;\n\t\t$GetExitCodeProcess->Call( $self->{handle}, $code );\n\t\t($code) = unpack \"L\", $code;\n\n\t\t$self->{result} = new stf::ProcessMgmt::Result($code);\n\n\t\t$self->{state} = stf::ProcessMgmt::STATE_COMPLETED;\n\n\t\t$CloseHandle->Call( $self->{handle} );\n\n\t\treturn 1;\n\t}\n\telse {\n\t\twarn \"Could not terminate process PID=$self->{pid}: \"\n\t\t  . Win32::FormatMessage( Win32::GetLastError() );\n\n\t\treturn undef;\n\t}\n}\n\nsub pid {\n\tmy $self = shift;\n\n\treturn $self->{pid};\n}\n\n#N.b. there is no difference between stop() and terminate() on Windows.\nsub terminate {\n\tmy $self = shift;\n\n\t$self->stop();\n}\n\nsub poll {\n\tmy $self = shift;\n\n\treturn !$self->wait(0);\n}\n\nsub wait {\n\tmy ( $self, $wait_time ) = @_;\n\n\tif($self->{state} == stf::ProcessMgmt::STATE_COMPLETED)\n\t{\n\t\t#This process has already died\n\t\treturn 1;\n\t}\n\telsif($self->{state} == stf::ProcessMgmt::STATE_ERROR)\n\t{\n\t\t#We're in error - say the process has finished\n\t\treturn 1;\n\t}\n\telsif($self->{state} == stf::ProcessMgmt::STATE_UNSTARTED)\n\t{\n\t\twarn \"You can't wait on an unstarted process.\";\n\n\t\treturn 1;\n\t}\n\n\tif ( defined $wait_time ) {\n\t\t$wait_time = 1000 * int $wait_time;\n\t}\n\telse {\n\t\t$wait_time = INFINITE;\n\t}\n\n\tif ( 0 == $WaitForSingleObject->Call( $self->{handle}, $wait_time ) ) {\n\t\t#Process ended - extract the result\n\t\tmy $code = \"\\0\" x 4;\n        my $ret = $GetExitCodeProcess->Call( $self->{handle}, $code );\n \t\tif($ret == 0)\n\t\t{\n\t\t\twarn \"GetExitCodeProcess failed (rc==0). Artificially setting return code as -1\";\n\t\t\t$code = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t($code) = unpack \"L\", $code;\t\t\n\t\t}\n\t\t$self->{result} = new stf::ProcessMgmt::Result($code);\n\t\t$CloseHandle->Call( $self->{handle} );\n\t\t$self->{state} = stf::ProcessMgmt::STATE_COMPLETED;\n\t\treturn 1;\n\t}\n\telse {\n\t\t#Process still running\n\t\treturn undef;\n\t}\n}\n\nsub err_msg {\n\tmy $self = shift;\n\n\treturn $self->{err_msg};\n}\n\nsub get_result\n{\n\tmy $self = shift;\n\n\tif ( $self->{state} != stf::ProcessMgmt::STATE_COMPLETED ) {\n\t\tmy $state_name =\n\t\t  stf::ProcessMgmt::_get_description_for_state( $self->{state} );\n\n\t\twarn \"Error: can only get result from a completed process. Current state is: $state_name\";\n\n\t\treturn undef;\n\t}\n\n\treturn $self->{result};\n}\n\nsub get_state {\n\tmy $self = shift;\n\n\t$self->poll();\n\n"
    },
    "91": {
      "metadata": {
        "chunk_id": "b9d42c183b0c40236230adb95659cbe2689eb333e7cdb055f6e8c7c9c916144f",
        "file_path": "stf.core/scripts/stf/ProcessMgmt/Windows.pm",
        "content": "\treturn stf::ProcessMgmt::_get_description_for_state($self->{state});\n}\n\n#Method called in the constructor to qualify the command.\n#\n#Will take an unqualified command name (e.g. java) and produce a qualified\n#command (such as c:\\Program Files\\IBM\\Java5\\jre\\bin\\java.exe)\nsub _qualify_command {\n\tmy $self = shift;\n\n\tmy $cmd = $self->{command};\n\n#The command could be qualified already - if it points to a file that exists then finish\n\treturn if -f $cmd;\n\n    my @suffixes = ('.exe','.com','.bat','.cmd','');\n\n    foreach my $this_suffix (@suffixes) {\n       my $potential_file = \"$cmd$this_suffix\";\n       if ( -f $potential_file ) {\n          $self->{command} = $potential_file;\n          return;\n       }\n    }\n\n# If it doesn't exist, look for it on the path\n\n\tmy @path_elements = split /[;]/, $ENV{PATH};\n\n\tforeach my $this_element (@path_elements) {\n\t\t$this_element =~ s/\"//g;\n\t\tforeach my $this_suffix (@suffixes)\n\t\t{\n\t\t\tmy $potential_file = catfile( $this_element, $cmd.$this_suffix );\n\n\t\t\tif ( -f $potential_file ) {\n\t\t\t\t$self->{command} = $potential_file;\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\twarn \"Error: cannot find command $cmd on PATH. PATH is $ENV{PATH}\";\n}\n\n# Open a a file using the Windows API with the file sharing attributes set.\n#\nsub _open_file {\n\tmy ( $path, $mode ) = @_;\n\n\tmy $handle = $CreateFile->Call(\n\t\t$path . \"\\0\",    # Path of file\n\t\t( $mode eq 'rw' ? GENERIC_WRITE : GENERIC_READ ),    # File permissions\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE\n\t\t,       # We want FILE_SHARE_DELETE + FILE_SHARE_READ + FILE_SHARE_WRITE\n\t\t0,    # Default security descriptor\n\t\t( $mode eq 'rw' ? OPEN_ALWAYS : OPEN_EXISTING )\n\t\t,                         # If file exists append don't overwrite\n\t\tFILE_ATTRIBUTE_NORMAL,    # File attributes\n\t\t0                         # No template file\n\t) or return 0;\n\n\t# If we have opened the file for read-write move file pointer to the end\n\t# so that we append to the file.\n\tif ( $mode eq 'rw' ) {\n\t\t$SetFilePointer->Call( $handle, 0, 0, FILE_END );\n\t}\n\n\t$SetHandleInformation->Call( $handle, HANDLE_FLAG_INHERIT,\n\t\tHANDLE_FLAG_INHERIT )\n\t  or return 0;\n\treturn $handle;\n}\n\n1;\n\n__END__\n\n\n",
        "start_line": 493,
        "end_line": 573,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 590,
        "node_type": null,
        "file_sha": "97f49fad50328c64999e4c56a92a9da7a561c4d9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.749618"
      },
      "text": "\treturn stf::ProcessMgmt::_get_description_for_state($self->{state});\n}\n\n#Method called in the constructor to qualify the command.\n#\n#Will take an unqualified command name (e.g. java) and produce a qualified\n#command (such as c:\\Program Files\\IBM\\Java5\\jre\\bin\\java.exe)\nsub _qualify_command {\n\tmy $self = shift;\n\n\tmy $cmd = $self->{command};\n\n#The command could be qualified already - if it points to a file that exists then finish\n\treturn if -f $cmd;\n\n    my @suffixes = ('.exe','.com','.bat','.cmd','');\n\n    foreach my $this_suffix (@suffixes) {\n       my $potential_file = \"$cmd$this_suffix\";\n       if ( -f $potential_file ) {\n          $self->{command} = $potential_file;\n          return;\n       }\n    }\n\n# If it doesn't exist, look for it on the path\n\n\tmy @path_elements = split /[;]/, $ENV{PATH};\n\n\tforeach my $this_element (@path_elements) {\n\t\t$this_element =~ s/\"//g;\n\t\tforeach my $this_suffix (@suffixes)\n\t\t{\n\t\t\tmy $potential_file = catfile( $this_element, $cmd.$this_suffix );\n\n\t\t\tif ( -f $potential_file ) {\n\t\t\t\t$self->{command} = $potential_file;\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\twarn \"Error: cannot find command $cmd on PATH. PATH is $ENV{PATH}\";\n}\n\n# Open a a file using the Windows API with the file sharing attributes set.\n#\nsub _open_file {\n\tmy ( $path, $mode ) = @_;\n\n\tmy $handle = $CreateFile->Call(\n\t\t$path . \"\\0\",    # Path of file\n\t\t( $mode eq 'rw' ? GENERIC_WRITE : GENERIC_READ ),    # File permissions\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE\n\t\t,       # We want FILE_SHARE_DELETE + FILE_SHARE_READ + FILE_SHARE_WRITE\n\t\t0,    # Default security descriptor\n\t\t( $mode eq 'rw' ? OPEN_ALWAYS : OPEN_EXISTING )\n\t\t,                         # If file exists append don't overwrite\n\t\tFILE_ATTRIBUTE_NORMAL,    # File attributes\n\t\t0                         # No template file\n\t) or return 0;\n\n\t# If we have opened the file for read-write move file pointer to the end\n\t# so that we append to the file.\n\tif ( $mode eq 'rw' ) {\n\t\t$SetFilePointer->Call( $handle, 0, 0, FILE_END );\n\t}\n\n\t$SetHandleInformation->Call( $handle, HANDLE_FLAG_INHERIT,\n\t\tHANDLE_FLAG_INHERIT )\n\t  or return 0;\n\treturn $handle;\n}\n\n1;\n\n__END__\n\n\n"
    },
    "92": {
      "metadata": {
        "chunk_id": "d6da4a3da066d1573ed9cd1cc0d907a653ac6f286548c3ec3d927016e63d0f40",
        "file_path": "stf.core/scripts/stf/java_properties_check.pl",
        "content": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# java_properties_check.pl\n#\n# Display details about a Java.\n#\n# perl java_properties_check.pl\n# perl java_properties_check.pl -p JAVA_HOME\n# - Gets java propertiesfor the Java at the environment variable JAVA_HOME\n\n# perl java_properties_check.pl -p PATH\n# - Gets java propertiesfor the Java on the PATH\n#\n# perl java_properties_check.pl -p <path>\n# - Gets java propertiesfor the Java specified.  Assumes the directory provided in the one above bin/java\n\nuse strict;\nuse warnings;\n\nuse FindBin qw($Bin);\nuse lib \"$Bin/..\";\nuse Getopt::Long;\n\nuse stf::stfUtility;\nuse stf::Commands;\n\nmy %command_line_options = ();\nmy %java_properties = ();\n\nGetOptions(\n  'p=s'        => \\$command_line_options{'java_location'},\n  'H|h|help|?' => \\&usage\n);\n\nmy %getJavaProperties_options = ();\n\nif ( defined $command_line_options{'java_location'} ) {\n\tif ( $command_line_options{'java_location'} eq 'PATH' ) {\n\t\t$getJavaProperties_options{'PATH'} = 1;\n\t}\n\telsif ( $command_line_options{'java_location'} eq 'JAVA_HOME' ) {\n\t\t$getJavaProperties_options{'JAVA_HOME'} = 1;\n\t}\n\telse {\n\t\t$getJavaProperties_options{'PATH'} = $command_line_options{'java_location'};\n\t}\n}\n%java_properties = stf::stfUtility->getJavaProperties(%getJavaProperties_options);\n\nforeach my $key ( sort(keys(%java_properties) ) ) {\n\tprint $key . \": \" . $java_properties{$key} . \"\\n\";\n}\n\n\nsub usage {\n\tprint 'Usage:\n\nperl java_properties_check.pl\nperl java_properties_check.pl -p JAVA_HOME\n- Gets java properties for the Java at the environment variable JAVA_HOME\n\nperl java_properties_check.pl -p PATH\n- Gets java properties for the Java on the PATH\n\nperl java_properties_check.pl -p <path>\n- Gets java properties for the Java specified.  Assumes the directory provided in the one above bin/java\n';\n}",
        "start_line": 0,
        "end_line": 79,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 563,
        "node_type": null,
        "file_sha": "20157df84bca5865d6da4c1e9c71365597c410d9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.758809"
      },
      "text": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# java_properties_check.pl\n#\n# Display details about a Java.\n#\n# perl java_properties_check.pl\n# perl java_properties_check.pl -p JAVA_HOME\n# - Gets java propertiesfor the Java at the environment variable JAVA_HOME\n\n# perl java_properties_check.pl -p PATH\n# - Gets java propertiesfor the Java on the PATH\n#\n# perl java_properties_check.pl -p <path>\n# - Gets java propertiesfor the Java specified.  Assumes the directory provided in the one above bin/java\n\nuse strict;\nuse warnings;\n\nuse FindBin qw($Bin);\nuse lib \"$Bin/..\";\nuse Getopt::Long;\n\nuse stf::stfUtility;\nuse stf::Commands;\n\nmy %command_line_options = ();\nmy %java_properties = ();\n\nGetOptions(\n  'p=s'        => \\$command_line_options{'java_location'},\n  'H|h|help|?' => \\&usage\n);\n\nmy %getJavaProperties_options = ();\n\nif ( defined $command_line_options{'java_location'} ) {\n\tif ( $command_line_options{'java_location'} eq 'PATH' ) {\n\t\t$getJavaProperties_options{'PATH'} = 1;\n\t}\n\telsif ( $command_line_options{'java_location'} eq 'JAVA_HOME' ) {\n\t\t$getJavaProperties_options{'JAVA_HOME'} = 1;\n\t}\n\telse {\n\t\t$getJavaProperties_options{'PATH'} = $command_line_options{'java_location'};\n\t}\n}\n%java_properties = stf::stfUtility->getJavaProperties(%getJavaProperties_options);\n\nforeach my $key ( sort(keys(%java_properties) ) ) {\n\tprint $key . \": \" . $java_properties{$key} . \"\\n\";\n}\n\n\nsub usage {\n\tprint 'Usage:\n\nperl java_properties_check.pl\nperl java_properties_check.pl -p JAVA_HOME\n- Gets java properties for the Java at the environment variable JAVA_HOME\n\nperl java_properties_check.pl -p PATH\n- Gets java properties for the Java on the PATH\n\nperl java_properties_check.pl -p <path>\n- Gets java properties for the Java specified.  Assumes the directory provided in the one above bin/java\n';\n}"
    },
    "93": {
      "metadata": {
        "chunk_id": "0cc86b31a8ef600acb0038e916d5953c1258ec0e6c8f0a4c788d97ef5818e4ca",
        "file_path": "stf.core/scripts/stf/java_version_check.pl",
        "content": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# java_version_check.pl\n#\n# Display details about a Java.\n#\n# perl java_version_check.pl\n# perl java_version_check.pl -p JAVA_HOME\n# - Gets details for the Java at the environment variable JAVA_HOME\n\n# perl java_version_check.pl -p PATH\n# - Gets details for the Java on the PATH\n#\n# perl java_version_check.pl -p <path>\n# - Gets details for the Java specified.  Assumes the directory provided in the one above bin/java\n\nuse strict;\nuse warnings;\n\nuse FindBin qw($Bin);\nuse lib \"$Bin/..\";\nuse Getopt::Long;\n\nuse stf::stfUtility;\nuse stf::Commands;\n\nmy %command_line_options = ();\nmy %java_details = ();\n\nGetOptions(\n  'p=s'        => \\$command_line_options{'java_location'},\n  'H|h|help|?' => \\&usage\n);\n\nmy %getJavaVersionInfo_options = ();\n\nif ( defined $command_line_options{'java_location'} ) {\n\tif ( $command_line_options{'java_location'} eq 'PATH' ) {\n\t\t$getJavaVersionInfo_options{'PATH'} = 1;\n\t}\n\telsif ( $command_line_options{'java_location'} eq 'JAVA_HOME' ) {\n\t\t$getJavaVersionInfo_options{'JAVA_HOME'} = 1;\n\t}\n\telse {\n\t\t$getJavaVersionInfo_options{'PATH'} = $command_line_options{'java_location'};\n\t}\n}\n%java_details = stf::stfUtility->getJavaVersionInfo(%getJavaVersionInfo_options);\n\nforeach my $key ( sort(keys(%java_details) ) ) {\n\tprint $key . \": \" . $java_details{$key} . \"\\n\";\n}\n\n\nsub usage {\n\tprint 'Usage:\n\nperl java_version_check.pl\nperl java_version_check.pl -p JAVA_HOME\n- Gets details for the Java at the environment variable JAVA_HOME\n\nperl java_version_check.pl -p PATH\n- Gets details for the Java on the PATH\n\nperl java_version_check.pl -p <path>\n- Gets details for the Java specified.  Assumes the directory provided in the one above bin/java\n';\n}",
        "start_line": 0,
        "end_line": 79,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "perl",
        "chunk_type": "recursive",
        "token_count": 563,
        "node_type": null,
        "file_sha": "3982fe275f51b0f3a81c988e7c24d2c74137e642",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.765595"
      },
      "text": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# java_version_check.pl\n#\n# Display details about a Java.\n#\n# perl java_version_check.pl\n# perl java_version_check.pl -p JAVA_HOME\n# - Gets details for the Java at the environment variable JAVA_HOME\n\n# perl java_version_check.pl -p PATH\n# - Gets details for the Java on the PATH\n#\n# perl java_version_check.pl -p <path>\n# - Gets details for the Java specified.  Assumes the directory provided in the one above bin/java\n\nuse strict;\nuse warnings;\n\nuse FindBin qw($Bin);\nuse lib \"$Bin/..\";\nuse Getopt::Long;\n\nuse stf::stfUtility;\nuse stf::Commands;\n\nmy %command_line_options = ();\nmy %java_details = ();\n\nGetOptions(\n  'p=s'        => \\$command_line_options{'java_location'},\n  'H|h|help|?' => \\&usage\n);\n\nmy %getJavaVersionInfo_options = ();\n\nif ( defined $command_line_options{'java_location'} ) {\n\tif ( $command_line_options{'java_location'} eq 'PATH' ) {\n\t\t$getJavaVersionInfo_options{'PATH'} = 1;\n\t}\n\telsif ( $command_line_options{'java_location'} eq 'JAVA_HOME' ) {\n\t\t$getJavaVersionInfo_options{'JAVA_HOME'} = 1;\n\t}\n\telse {\n\t\t$getJavaVersionInfo_options{'PATH'} = $command_line_options{'java_location'};\n\t}\n}\n%java_details = stf::stfUtility->getJavaVersionInfo(%getJavaVersionInfo_options);\n\nforeach my $key ( sort(keys(%java_details) ) ) {\n\tprint $key . \": \" . $java_details{$key} . \"\\n\";\n}\n\n\nsub usage {\n\tprint 'Usage:\n\nperl java_version_check.pl\nperl java_version_check.pl -p JAVA_HOME\n- Gets details for the Java at the environment variable JAVA_HOME\n\nperl java_version_check.pl -p PATH\n- Gets details for the Java on the PATH\n\nperl java_version_check.pl -p <path>\n- Gets details for the Java specified.  Assumes the directory provided in the one above bin/java\n';\n}"
    },
    "94": {
      "metadata": {
        "chunk_id": "67da58bbcea90800d926c63967fac781f9024eb695b03335b38ede3e33088a73",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# \n# This script contains STF utility code.\n# The subroutines in this file are used by the test specific generated scripts\n# and the STF Perl modules.\n#----------------------------------------------------------------------------------#\n\nuse warnings;\nuse strict;\nuse Config;\n\npackage stf::stfUtility;\n\nour @ISA = qw(Exporter);\nour @EXPORT = qw(err warn info debug trace getDelimiter);\n\nuse Config;\nuse Cwd;\nuse Cwd 'abs_path';\nuse Data::Dumper;\nuse File::Basename;\nuse File::Copy;\nuse File::Path qw(mkpath rmtree);\nuse File::Spec::Functions qw(splitdir catfile);\nuse File::Temp;\nuse stf::Constants qw(:all);\n\nrequire stf::Commands;\n\n# Default logging level to INFO \n$ENV{loggingLevel} = \"INFO\" unless (defined $ENV{loggingLevel});\n\nmy $useHiRes = $TRUE;\neval \"use Time::HiRes\";\nif ($@) {\n     $useHiRes = $FALSE;\n}\n\n#----------------------------------------------------------------------------------#\n# listErrors\n#\n# Prints out errors from a given list.\n#\n# Usage:\n#  stf::stfUtility->listErrors(\\@error_list);\n#----------------------------------------------------------------------------------#\nsub listErrors {\n\tmy ($self, @error_list) = @_;\n\n\tfor my $diag ( @error_list ) {\n\t   if ( ref ($diag) eq 'HASH' ) {\n\t      my ($file, $message) = %$diag;\n\t      print \"Error: file='$file' message='$message'\\n\";\n\t   }\n\t   else {\n\t      print \"Error: message='$diag'\\n\";\n\t   }\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# readFileIntoArray\n#\n# Stores the contents of the supplied file into an array.\n#\n# Usage:\n#  stf::stfUtility->readFileIntoArray(file=>$filename);\n#\n# Returns:\n#  The array containing the lines in the supplied file.\n#----------------------------------------------------------------------------------#\nsub readFileIntoArray {\n\tmy ($self, $filename) = @_;\n\n\tmy @lines = ();\n\n\t# strip out any quotes...\n\t($filename) =~ s/\\\"//g;\n\n\t# check the file exists\n\tif (!(-e $filename)) {\n\t   stf::stfUtility->logMsg( message => \"stfUtility.pm::readFileIntoArray: File $filename does not exist.\");\n\t   return [];\n\t}\n\n\tif (!(-r $filename)) {\n\t   stf::stfUtility->logMsg( message => \"stfUtility.pm::readFileIntoArray: Cannot read file $filename.\");\n\t   return [];\n\t}\n\n\t# open file\n\topen (FILE, \"<$filename\");\n\n\t# search array\n\t@lines = <FILE>;\n\n\tclose FILE;\n\treturn \\@lines;\n}\n\n#------------------------------------------------------------#\n# writeToFile\n#\n# Writes a string array to the file passed to the method.\n#\n# Usage:\n#  writeToFile(%args)\n#  stf::stfUtility->writeToFile( file => $file, content => \\@lines, replace => $TRUE);\n#  stf::stfUtility->writeToFile( file => $msglog, content => [\"One line to append\"], replace => $FALSE );\n#\n# Arguments:\n#  %args        = (file => $file, content => $lines, replace => $replace)\n#  $file        = file name + path to write to\n#  $lines        = the lines to write to the file (array ref)\n#  $replace    = if set replace the file otherwise append to it\n#------------------------------------------------------------#\nsub writeToFile {\n\tmy ($self, %args) = @_;              # The args\n\tmy $file = \"\";                       # The name of the file to write to\n\tmy $lines = [];                      # The lines to write to the file\n\tmy $replace = $FALSE;                # If set to true replace the file\n\n\tif (exists $args{file}) {\n\t   $file = $args{file};         \n\t}\n\n\tif (exists $args{content}) {\n\t   $lines = $args{content};         \n\t}\n\n\tif (exists $args{replace}) {\n\t   $replace = $args{replace};\n\t}\n\n",
        "start_line": 0,
        "end_line": 147,
        "chunk_index": 0,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 986,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772755"
      },
      "text": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# \n# This script contains STF utility code.\n# The subroutines in this file are used by the test specific generated scripts\n# and the STF Perl modules.\n#----------------------------------------------------------------------------------#\n\nuse warnings;\nuse strict;\nuse Config;\n\npackage stf::stfUtility;\n\nour @ISA = qw(Exporter);\nour @EXPORT = qw(err warn info debug trace getDelimiter);\n\nuse Config;\nuse Cwd;\nuse Cwd 'abs_path';\nuse Data::Dumper;\nuse File::Basename;\nuse File::Copy;\nuse File::Path qw(mkpath rmtree);\nuse File::Spec::Functions qw(splitdir catfile);\nuse File::Temp;\nuse stf::Constants qw(:all);\n\nrequire stf::Commands;\n\n# Default logging level to INFO \n$ENV{loggingLevel} = \"INFO\" unless (defined $ENV{loggingLevel});\n\nmy $useHiRes = $TRUE;\neval \"use Time::HiRes\";\nif ($@) {\n     $useHiRes = $FALSE;\n}\n\n#----------------------------------------------------------------------------------#\n# listErrors\n#\n# Prints out errors from a given list.\n#\n# Usage:\n#  stf::stfUtility->listErrors(\\@error_list);\n#----------------------------------------------------------------------------------#\nsub listErrors {\n\tmy ($self, @error_list) = @_;\n\n\tfor my $diag ( @error_list ) {\n\t   if ( ref ($diag) eq 'HASH' ) {\n\t      my ($file, $message) = %$diag;\n\t      print \"Error: file='$file' message='$message'\\n\";\n\t   }\n\t   else {\n\t      print \"Error: message='$diag'\\n\";\n\t   }\n\t}\n}\n\n#----------------------------------------------------------------------------------#\n# readFileIntoArray\n#\n# Stores the contents of the supplied file into an array.\n#\n# Usage:\n#  stf::stfUtility->readFileIntoArray(file=>$filename);\n#\n# Returns:\n#  The array containing the lines in the supplied file.\n#----------------------------------------------------------------------------------#\nsub readFileIntoArray {\n\tmy ($self, $filename) = @_;\n\n\tmy @lines = ();\n\n\t# strip out any quotes...\n\t($filename) =~ s/\\\"//g;\n\n\t# check the file exists\n\tif (!(-e $filename)) {\n\t   stf::stfUtility->logMsg( message => \"stfUtility.pm::readFileIntoArray: File $filename does not exist.\");\n\t   return [];\n\t}\n\n\tif (!(-r $filename)) {\n\t   stf::stfUtility->logMsg( message => \"stfUtility.pm::readFileIntoArray: Cannot read file $filename.\");\n\t   return [];\n\t}\n\n\t# open file\n\topen (FILE, \"<$filename\");\n\n\t# search array\n\t@lines = <FILE>;\n\n\tclose FILE;\n\treturn \\@lines;\n}\n\n#------------------------------------------------------------#\n# writeToFile\n#\n# Writes a string array to the file passed to the method.\n#\n# Usage:\n#  writeToFile(%args)\n#  stf::stfUtility->writeToFile( file => $file, content => \\@lines, replace => $TRUE);\n#  stf::stfUtility->writeToFile( file => $msglog, content => [\"One line to append\"], replace => $FALSE );\n#\n# Arguments:\n#  %args        = (file => $file, content => $lines, replace => $replace)\n#  $file        = file name + path to write to\n#  $lines        = the lines to write to the file (array ref)\n#  $replace    = if set replace the file otherwise append to it\n#------------------------------------------------------------#\nsub writeToFile {\n\tmy ($self, %args) = @_;              # The args\n\tmy $file = \"\";                       # The name of the file to write to\n\tmy $lines = [];                      # The lines to write to the file\n\tmy $replace = $FALSE;                # If set to true replace the file\n\n\tif (exists $args{file}) {\n\t   $file = $args{file};         \n\t}\n\n\tif (exists $args{content}) {\n\t   $lines = $args{content};         \n\t}\n\n\tif (exists $args{replace}) {\n\t   $replace = $args{replace};\n\t}\n\n"
    },
    "95": {
      "metadata": {
        "chunk_id": "5692e8dad8bdd78e94f4c8a8bbbd4b9e94473814f3993b95a1cb94b0ba37a611",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "\t#if ($file eq \"\")\n\t#{\n\t#   stf::stfUtility->logMsg( message => \"ERROR: Unable to create file as no filename was specified (writeToFile(file => filename))\");\n\t#}\n\n\tif ($file eq \"\") {\n\t   return;\n\t}\n\n\tif ($replace == $TRUE) {\n\t   open FILE, \">$file\";\n\t}\n\telse {\n\t   open FILE, \">>$file\";\n\t}\n\n\tforeach my $line (@{$lines}) {\n\t    # check the line has a new line character if not add one\n\t    if (($line !~ /\\n/) and ($line !~ /\\r/) and ($line !~ /\\f/) and ($line !~ /\\e/)) {\n\t       $line = $line.\"\\n\";\n\t    }\n\t\tif ($file ne \"\") {\n\t       print FILE $line;\n\t    }\n\t    else {\n\t\t#\tprint $line;\n\t    }\n\t}\n\n\tclose FILE;\n}\n\n#------------------------------------------------------------#\n# getPathSeparator\n#\n# Returns a platform specific path separator.\n#\n# Usage:\n#  my $sep = stf::stfUtility->getPathSeparator;\n#\n# Returns:\n#  The path separator\n#------------------------------------------------------------#\nsub getPathSeparator {\n\tmy ($self) = @_;\n\n\tmy $ps = \":\";\n\tif ($^O eq 'MSWin32') {\n\t    $ps = \";\";\n\t}\n\n\treturn $ps;\n}\n\n#------------------------------------------------------------#\n# getPlatform\n#\n# Returns the current platform.\n#\n# Usage:\n#  my $platform = stf::stfUtility->getPlatform;\n#\n# Returns:\n#  win, linux, zos, aix, osx, or bsd\n#------------------------------------------------------------#\nsub getPlatform {\n\tif ($^O eq 'MSWin32') {\n\t\treturn \"win\";\n\t}\n\telsif ($^O eq 'linux') {\n\t\treturn \"linux\";\n\t}\n\telsif ($^O eq 'os390') {\n\t\treturn \"zos\";\n\t}\n\telsif ($^O eq 'aix') {\n\t\treturn \"aix\";\n\t}\n\telsif ($^O eq 'darwin') {\n\t\treturn \"osx\";\n\t}\n\telsif ($^O =~ 'solaris') {\n\t\treturn \"sunos\";\n\t} elsif ($^O =~ 'bsd') {\n\t\treturn \"bsd\";\n\t}\n\telse {\n\t\tdie \"Platform $^O is not yet supported\";\n\t}\n}\n\n#------------------------------------------------------------#\n# getPlatformArch\n#\n# Returns the current platform arch.\n#\n# Usage:\n#  my $platform = stf::stfUtility->getPlatformArch;\n#\n# Returns:\n#  x86, ppc, ppcle, 390, arm, riscv, loongarch or sparc\n#------------------------------------------------------------#\nsub getPlatformArch {\n\tmy $platform = stf::stfUtility->getPlatform;\n\n\tif ($platform eq 'win') {\n\t\treturn \"x86\";\n\t}\n\telsif ($platform eq 'linux') {\n\t\tif ($Config{archname} =~ 'x86') {\n\t\t\treturn \"x86\";\n\t\t}\n\t\tif ($Config{archname} =~ 'ppc64le') {\n\t\t\treturn \"ppcle\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'powerpc') {\n\t\t\treturn \"ppc\";\n\t\t}\n\t\telsif ($Config{archname} =~ '390') {\n\t\t\treturn \"390\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'arm') {\n\t\t\treturn \"arm\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'riscv') {\n\t\t\treturn \"riscv\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'loongarch') {\n\t\t\treturn \"loongarch\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'sparc') {\n\t\t\treturn \"sparc\";\n\t\t}\n\t\telse {\n\t\t\tdie \"Platform arch $Config{archname} is not yet supported\";\n\t\t}\n\t}\n\telsif ($platform eq 'zos') {\n\t\treturn \"390\";\n\t}\n\telsif ($platform eq 'aix') {\n\t\treturn \"ppc\";\n\t}\n\telsif ($platform eq 'bsd') {\n\t\t# This should be expanded per Linux to handle powerpc64 and aarch64\n\t\t return \"x86\";\n\t}\n\telse {\n\t\tdie \"Platform arch for $platform is not yet supported\";\n\t}\n}\n\n#------------------------------------------------------------#\n# getDelimiter\n#\n# Returns a platform specific delimiter.\n#\n# Usage:\n#  my $sep = stf::stfUtility->getDelimiter;\n#\n# Returns:\n#  The delimeter\n#------------------------------------------------------------#\nsub getDelimiter {\n\tmy ($self) = @_;\n\n\tmy $delimiter = '/';\n\tif ($^O eq \"MSWin32\") {\n\t\t$delimiter = '\\\\';\t\t\n\t}\n\n\treturn $delimiter;\n}\n\n",
        "start_line": 148,
        "end_line": 322,
        "chunk_index": 1,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 992,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772774"
      },
      "text": "\t#if ($file eq \"\")\n\t#{\n\t#   stf::stfUtility->logMsg( message => \"ERROR: Unable to create file as no filename was specified (writeToFile(file => filename))\");\n\t#}\n\n\tif ($file eq \"\") {\n\t   return;\n\t}\n\n\tif ($replace == $TRUE) {\n\t   open FILE, \">$file\";\n\t}\n\telse {\n\t   open FILE, \">>$file\";\n\t}\n\n\tforeach my $line (@{$lines}) {\n\t    # check the line has a new line character if not add one\n\t    if (($line !~ /\\n/) and ($line !~ /\\r/) and ($line !~ /\\f/) and ($line !~ /\\e/)) {\n\t       $line = $line.\"\\n\";\n\t    }\n\t\tif ($file ne \"\") {\n\t       print FILE $line;\n\t    }\n\t    else {\n\t\t#\tprint $line;\n\t    }\n\t}\n\n\tclose FILE;\n}\n\n#------------------------------------------------------------#\n# getPathSeparator\n#\n# Returns a platform specific path separator.\n#\n# Usage:\n#  my $sep = stf::stfUtility->getPathSeparator;\n#\n# Returns:\n#  The path separator\n#------------------------------------------------------------#\nsub getPathSeparator {\n\tmy ($self) = @_;\n\n\tmy $ps = \":\";\n\tif ($^O eq 'MSWin32') {\n\t    $ps = \";\";\n\t}\n\n\treturn $ps;\n}\n\n#------------------------------------------------------------#\n# getPlatform\n#\n# Returns the current platform.\n#\n# Usage:\n#  my $platform = stf::stfUtility->getPlatform;\n#\n# Returns:\n#  win, linux, zos, aix, osx, or bsd\n#------------------------------------------------------------#\nsub getPlatform {\n\tif ($^O eq 'MSWin32') {\n\t\treturn \"win\";\n\t}\n\telsif ($^O eq 'linux') {\n\t\treturn \"linux\";\n\t}\n\telsif ($^O eq 'os390') {\n\t\treturn \"zos\";\n\t}\n\telsif ($^O eq 'aix') {\n\t\treturn \"aix\";\n\t}\n\telsif ($^O eq 'darwin') {\n\t\treturn \"osx\";\n\t}\n\telsif ($^O =~ 'solaris') {\n\t\treturn \"sunos\";\n\t} elsif ($^O =~ 'bsd') {\n\t\treturn \"bsd\";\n\t}\n\telse {\n\t\tdie \"Platform $^O is not yet supported\";\n\t}\n}\n\n#------------------------------------------------------------#\n# getPlatformArch\n#\n# Returns the current platform arch.\n#\n# Usage:\n#  my $platform = stf::stfUtility->getPlatformArch;\n#\n# Returns:\n#  x86, ppc, ppcle, 390, arm, riscv, loongarch or sparc\n#------------------------------------------------------------#\nsub getPlatformArch {\n\tmy $platform = stf::stfUtility->getPlatform;\n\n\tif ($platform eq 'win') {\n\t\treturn \"x86\";\n\t}\n\telsif ($platform eq 'linux') {\n\t\tif ($Config{archname} =~ 'x86') {\n\t\t\treturn \"x86\";\n\t\t}\n\t\tif ($Config{archname} =~ 'ppc64le') {\n\t\t\treturn \"ppcle\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'powerpc') {\n\t\t\treturn \"ppc\";\n\t\t}\n\t\telsif ($Config{archname} =~ '390') {\n\t\t\treturn \"390\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'arm') {\n\t\t\treturn \"arm\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'riscv') {\n\t\t\treturn \"riscv\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'loongarch') {\n\t\t\treturn \"loongarch\";\n\t\t}\n\t\telsif ($Config{archname} =~ 'sparc') {\n\t\t\treturn \"sparc\";\n\t\t}\n\t\telse {\n\t\t\tdie \"Platform arch $Config{archname} is not yet supported\";\n\t\t}\n\t}\n\telsif ($platform eq 'zos') {\n\t\treturn \"390\";\n\t}\n\telsif ($platform eq 'aix') {\n\t\treturn \"ppc\";\n\t}\n\telsif ($platform eq 'bsd') {\n\t\t# This should be expanded per Linux to handle powerpc64 and aarch64\n\t\t return \"x86\";\n\t}\n\telse {\n\t\tdie \"Platform arch for $platform is not yet supported\";\n\t}\n}\n\n#------------------------------------------------------------#\n# getDelimiter\n#\n# Returns a platform specific delimiter.\n#\n# Usage:\n#  my $sep = stf::stfUtility->getDelimiter;\n#\n# Returns:\n#  The delimeter\n#------------------------------------------------------------#\nsub getDelimiter {\n\tmy ($self) = @_;\n\n\tmy $delimiter = '/';\n\tif ($^O eq \"MSWin32\") {\n\t\t$delimiter = '\\\\';\t\t\n\t}\n\n\treturn $delimiter;\n}\n\n"
    },
    "96": {
      "metadata": {
        "chunk_id": "c8d17bfc40efe9d8484bc58f547bf8d1cefa657f45f23915803adba8bfafb0c4",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "#------------------------------------------------------------#\n# getQuote \n#\n# Returns a platform specific quote.\n#\n# Usage:\n#  my $sep = stf::stfUtility->getQuote;\n#\n# Returns:\n#  The quote\n#------------------------------------------------------------#\nsub getQuote {\n\tmy ($self) = @_;\n\n\tmy $quote = \"\\'\";\n\tif ($^O eq 'MSWin32') {\n    \t$quote = \"\\\"\";\n\t}\n\n\treturn $quote;\n}\n\n#------------------------------------------------------------#\n# getNow \n#\n# Returns the current time in 3 different formats, see below.\n#\n# Usage:\n#  my ($now) = stf::stfUtility->getNow();\n#  my ($now, $date) = stf::stfUtility->getNow(date => $TRUE);\n#  my ($now, $time) = stf::stfUtility->getNow(time => $TRUE);\n#  my ($now, $date, $time) = stf::stfUtility->getNow(date => $TRUE, time => $TRUE);\n#\n# Returns up to three results:\n#  1. Always - time and date as a string format = yymmdd-hhmmss.\n#  2. If a date hash argument was received, the yymmdd part.\n#  3. If a time hash argument was received, the hhmmssd part.\n#------------------------------------------------------------#\nsub getNow {\n\tmy ($self, %args) = @_;\n\n\t#     0     1     2      3      4     5      6      7      8\n\tmy ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);\n\n\tmy $now  = sprintf(\"%02d\", $year - 100)\n\t         . sprintf(\"%02d\", $mon  + 1)\n\t         . sprintf(\"%02d\", $mday) . '-'\n\t         . sprintf(\"%02d\", $hour) \n\t         . sprintf(\"%02d\", $min) \n\t         . sprintf(\"%02d\", $sec);\n\n\tmy $date = \"\";\n\tmy $time = \"\";\n\tmy @data = ();\n\n\tif (exists $args{date}) {\n\t   $date = sprintf(\"%02d\", ($year % 100) ). '-'\n\t         . sprintf(\"%02d\", $mon + 1). '-'\n\t         . sprintf(\"%02d\", $mday); \n\n\t   push(@data, $date);\n\t}\n\n\tif (exists $args{time}) {\n\t   $time = sprintf(\"%02d\", $hour) . ':'\n\t         . sprintf(\"%02d\", $min) . ':' \n\t         . sprintf(\"%02d\", $sec);\n\n\t   push(@data, $time);\n\t}\n\n\tif (scalar @data > 0) {\n\t   unshift(@data, $now);\n\t   return @data;\n\t}\n\n\treturn $now;\n}\n\n#------------------------------------------------------------#\n# chmodPath \n#\n# Changes the permissions for a directory path.\n#\n# Usage:\n#  stf::stfUtility->chmodPath(path => $path, code => $code);\n#  stf::stfUtility->chmodPath(path => $path, code => $code, root => $root);\n#  stf::stfUtility->chmodPath(path => $path, code => $code, home => $TRUE);\n#  stf::stfUtility->chmodPath(path => $path, code => $code, root => $root, home => $TRUE);\n#------------------------------------------------------------#\nsub chmodPath {\n\tmy ($self, %args) = @_;\n\n    my $path = \"\";             # the path to change the permissions on\n    my $code = \"\";             # permission code\n    my $root = \"\";             # optional parameter added to the front of the path but not chmoded itself\n    my $home = $FALSE;         # if the path to be chmoded is the users home directory it will not be chmoded unless\n                               # this is set to TRUE\n\n\tif (exists $args{path}) {\n\t   $path = $args{path};         \n\t}\n\tif (exists $args{code}) {\n\t   $code = $args{code};         \n\t}\n\tif (exists $args{root}) {\n\t   $root = $args{root};         \n\t}\n\tif (exists $args{home}) {\n\t   $home = $args{home};         \n\t}\n\n\tmy @dirs = File::Spec->splitdir($path);\n\tshift(@dirs);\n\tmy @rootdirs = ();\n\tmy @list = ();\n\tmy $curdir = $root;\n\n",
        "start_line": 323,
        "end_line": 441,
        "chunk_index": 2,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 964,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772782"
      },
      "text": "#------------------------------------------------------------#\n# getQuote \n#\n# Returns a platform specific quote.\n#\n# Usage:\n#  my $sep = stf::stfUtility->getQuote;\n#\n# Returns:\n#  The quote\n#------------------------------------------------------------#\nsub getQuote {\n\tmy ($self) = @_;\n\n\tmy $quote = \"\\'\";\n\tif ($^O eq 'MSWin32') {\n    \t$quote = \"\\\"\";\n\t}\n\n\treturn $quote;\n}\n\n#------------------------------------------------------------#\n# getNow \n#\n# Returns the current time in 3 different formats, see below.\n#\n# Usage:\n#  my ($now) = stf::stfUtility->getNow();\n#  my ($now, $date) = stf::stfUtility->getNow(date => $TRUE);\n#  my ($now, $time) = stf::stfUtility->getNow(time => $TRUE);\n#  my ($now, $date, $time) = stf::stfUtility->getNow(date => $TRUE, time => $TRUE);\n#\n# Returns up to three results:\n#  1. Always - time and date as a string format = yymmdd-hhmmss.\n#  2. If a date hash argument was received, the yymmdd part.\n#  3. If a time hash argument was received, the hhmmssd part.\n#------------------------------------------------------------#\nsub getNow {\n\tmy ($self, %args) = @_;\n\n\t#     0     1     2      3      4     5      6      7      8\n\tmy ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);\n\n\tmy $now  = sprintf(\"%02d\", $year - 100)\n\t         . sprintf(\"%02d\", $mon  + 1)\n\t         . sprintf(\"%02d\", $mday) . '-'\n\t         . sprintf(\"%02d\", $hour) \n\t         . sprintf(\"%02d\", $min) \n\t         . sprintf(\"%02d\", $sec);\n\n\tmy $date = \"\";\n\tmy $time = \"\";\n\tmy @data = ();\n\n\tif (exists $args{date}) {\n\t   $date = sprintf(\"%02d\", ($year % 100) ). '-'\n\t         . sprintf(\"%02d\", $mon + 1). '-'\n\t         . sprintf(\"%02d\", $mday); \n\n\t   push(@data, $date);\n\t}\n\n\tif (exists $args{time}) {\n\t   $time = sprintf(\"%02d\", $hour) . ':'\n\t         . sprintf(\"%02d\", $min) . ':' \n\t         . sprintf(\"%02d\", $sec);\n\n\t   push(@data, $time);\n\t}\n\n\tif (scalar @data > 0) {\n\t   unshift(@data, $now);\n\t   return @data;\n\t}\n\n\treturn $now;\n}\n\n#------------------------------------------------------------#\n# chmodPath \n#\n# Changes the permissions for a directory path.\n#\n# Usage:\n#  stf::stfUtility->chmodPath(path => $path, code => $code);\n#  stf::stfUtility->chmodPath(path => $path, code => $code, root => $root);\n#  stf::stfUtility->chmodPath(path => $path, code => $code, home => $TRUE);\n#  stf::stfUtility->chmodPath(path => $path, code => $code, root => $root, home => $TRUE);\n#------------------------------------------------------------#\nsub chmodPath {\n\tmy ($self, %args) = @_;\n\n    my $path = \"\";             # the path to change the permissions on\n    my $code = \"\";             # permission code\n    my $root = \"\";             # optional parameter added to the front of the path but not chmoded itself\n    my $home = $FALSE;         # if the path to be chmoded is the users home directory it will not be chmoded unless\n                               # this is set to TRUE\n\n\tif (exists $args{path}) {\n\t   $path = $args{path};         \n\t}\n\tif (exists $args{code}) {\n\t   $code = $args{code};         \n\t}\n\tif (exists $args{root}) {\n\t   $root = $args{root};         \n\t}\n\tif (exists $args{home}) {\n\t   $home = $args{home};         \n\t}\n\n\tmy @dirs = File::Spec->splitdir($path);\n\tshift(@dirs);\n\tmy @rootdirs = ();\n\tmy @list = ();\n\tmy $curdir = $root;\n\n"
    },
    "97": {
      "metadata": {
        "chunk_id": "f9ae457651095580dd56a04cb7b44b61c844c02f9a616f641974ac6df27ce300",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "\t$root =~ s/\\\\/\\\\\\\\/g; #Escape the backslashes\n\t$root =~ s/\\//\\\\\\//g; #Escape the forwardslashes\n\t$path =~ s/\\\\/\\\\\\\\/g; #Escape the backslashes\n\t$path =~ s/\\//\\\\\\//g; #Escape the forwardslashes\n\n\tif (defined $root and $root ne \"\") {\n\t\t# Strip out slashes and convert to lower case because numbers of slashes\n\t\t# between directories may vary and on Windows the type of slash and case\n\t\t# may vary also.\n\t\tmy $comppath = lc($path);\n\t\tmy $comproot = lc($root);\n\t\t$comppath =~ s/\\\\//g;\n\t\t$comproot =~ s/\\\\//g;\n\t\t$comppath =~ s/\\///g;\n\t\t$comproot =~ s/\\///g;\n\n\t\tif ($comppath !~ /${comproot}.*/) {\n\t\t\tstf::stfUtility->logMsg( message => \"ERROR: Root directory ($root) does not appear in the path directory ($path)\");\n\t\t\treturn;\t  \t \t\n\t\t}\n\n\t\t@rootdirs = File::Spec->splitdir($root);\n\t\tshift(@rootdirs);\n\t}\n\telse {\n\t\tstf::stfUtility->logMsg( message => \"ERROR: Root directory argument is mandatory\");\n\t\treturn;\t\n\t} \n\n\tif (! defined $home or $home == $FALSE) {\n\t\tmy $home_dir = $ENV{HOME};\n\t\tif (!$home_dir) {\n\t\t\t$home_dir = \"\"; # prevent perl warnings when $HOME isn't set\n\t\t}\n\t\t$home_dir =~ s/\\\\/\\\\\\\\/g; #Escape the backslashes\n\t\t$home_dir =~ s/\\//\\\\\\//g; #Escape the forwardslashes\n\t\tif ($path =~ /$home_dir/ and $root !~ /$home_dir/) {\n\t\t\tstf::stfUtility->logMsg( message => \"ERROR: To change the access to the HOME directory supply \\$TRUE as the 4th argument \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmy $rootdir = \"\";\n\n\t# change the permissions on each directory\n\tDIR:foreach my $dir(@dirs) {\n\t   if (scalar @rootdirs > 0) {\n\t      $rootdir = shift(@rootdirs);\n\t      if ($rootdir = $dir) {\n\t         next DIR;\n\t      }\n\t   }\n\t   $curdir = catfile($curdir, $dir);\n\t   push(@list, $curdir);\n\t}\n\n\tunshift(@list, $code);\n\tchmod(@list);\n}\n\n#------------------------------------------------------------#\n# splatTree\n#\n# Removes the given directory. Takes account of directories on\n# windows that may have file names too long for rmtree to deal with\n#\n# Usage:\n#  stf::stfUtility->splatTree(dir => $dir);\n#------------------------------------------------------------#\nsub splatTree {\t\n\tmy ($self, %args) = @_; \n\n    my $dir = \"\";             # the directory tree to delete\n\n\tif (exists $args{dir}) {\n\t   $dir = $args{dir};\n\t}\n\n\tif ($dir eq \"\" ) {\n\t    die \"Error: stfUtility.pm: splatTree directory argument not supplied or blank\\n\";\n\t}\n\n\tif ($^O eq \"MSWin32\" ) {\n\t\t# Some tests create directories that are so long that rmtree will die\n\t\tstf::stfUtility->shortenPaths(dir => $dir);\n\t}\n\n\tmy $err;\n\n\trmtree( $dir, {error => \\$err});\n\tif (defined (@$err[0])) {\n\t    stf::stfUtility->list_errors( @$err);\n\t    die \"Error: splatTree failed running rmtree to delete $dir\\n\";\n\t}\n}\n\n#------------------------------------------------------------#\n# shortenPaths\n#\n# Used by splatTree above. Recursively descends into the given\n# directory and renames all directories to a single digit.\n#\n# Usage:\n#  stf::stfUtility->shortenPaths(dir => $dir);\n#------------------------------------------------------------#\nsub shortenPaths {\n\tmy ($self, %args) = @_;\n\n\tmy $longPath = \"\";\n\n\tif (exists $args{dir}) {\n\t   $longPath = $args{dir};\n\t}\n\n\tif ($longPath eq \"\" ) {\n\t    die \"Error: stfUtility.pm: shortenPaths directory argument not supplied or blank\\n\";\n\t}\n\n\topendir(DIR, $longPath) or return 0;\n\tmy @files = readdir(DIR);\n\tclosedir(DIR);\n\n",
        "start_line": 442,
        "end_line": 564,
        "chunk_index": 3,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 966,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772794"
      },
      "text": "\t$root =~ s/\\\\/\\\\\\\\/g; #Escape the backslashes\n\t$root =~ s/\\//\\\\\\//g; #Escape the forwardslashes\n\t$path =~ s/\\\\/\\\\\\\\/g; #Escape the backslashes\n\t$path =~ s/\\//\\\\\\//g; #Escape the forwardslashes\n\n\tif (defined $root and $root ne \"\") {\n\t\t# Strip out slashes and convert to lower case because numbers of slashes\n\t\t# between directories may vary and on Windows the type of slash and case\n\t\t# may vary also.\n\t\tmy $comppath = lc($path);\n\t\tmy $comproot = lc($root);\n\t\t$comppath =~ s/\\\\//g;\n\t\t$comproot =~ s/\\\\//g;\n\t\t$comppath =~ s/\\///g;\n\t\t$comproot =~ s/\\///g;\n\n\t\tif ($comppath !~ /${comproot}.*/) {\n\t\t\tstf::stfUtility->logMsg( message => \"ERROR: Root directory ($root) does not appear in the path directory ($path)\");\n\t\t\treturn;\t  \t \t\n\t\t}\n\n\t\t@rootdirs = File::Spec->splitdir($root);\n\t\tshift(@rootdirs);\n\t}\n\telse {\n\t\tstf::stfUtility->logMsg( message => \"ERROR: Root directory argument is mandatory\");\n\t\treturn;\t\n\t} \n\n\tif (! defined $home or $home == $FALSE) {\n\t\tmy $home_dir = $ENV{HOME};\n\t\tif (!$home_dir) {\n\t\t\t$home_dir = \"\"; # prevent perl warnings when $HOME isn't set\n\t\t}\n\t\t$home_dir =~ s/\\\\/\\\\\\\\/g; #Escape the backslashes\n\t\t$home_dir =~ s/\\//\\\\\\//g; #Escape the forwardslashes\n\t\tif ($path =~ /$home_dir/ and $root !~ /$home_dir/) {\n\t\t\tstf::stfUtility->logMsg( message => \"ERROR: To change the access to the HOME directory supply \\$TRUE as the 4th argument \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmy $rootdir = \"\";\n\n\t# change the permissions on each directory\n\tDIR:foreach my $dir(@dirs) {\n\t   if (scalar @rootdirs > 0) {\n\t      $rootdir = shift(@rootdirs);\n\t      if ($rootdir = $dir) {\n\t         next DIR;\n\t      }\n\t   }\n\t   $curdir = catfile($curdir, $dir);\n\t   push(@list, $curdir);\n\t}\n\n\tunshift(@list, $code);\n\tchmod(@list);\n}\n\n#------------------------------------------------------------#\n# splatTree\n#\n# Removes the given directory. Takes account of directories on\n# windows that may have file names too long for rmtree to deal with\n#\n# Usage:\n#  stf::stfUtility->splatTree(dir => $dir);\n#------------------------------------------------------------#\nsub splatTree {\t\n\tmy ($self, %args) = @_; \n\n    my $dir = \"\";             # the directory tree to delete\n\n\tif (exists $args{dir}) {\n\t   $dir = $args{dir};\n\t}\n\n\tif ($dir eq \"\" ) {\n\t    die \"Error: stfUtility.pm: splatTree directory argument not supplied or blank\\n\";\n\t}\n\n\tif ($^O eq \"MSWin32\" ) {\n\t\t# Some tests create directories that are so long that rmtree will die\n\t\tstf::stfUtility->shortenPaths(dir => $dir);\n\t}\n\n\tmy $err;\n\n\trmtree( $dir, {error => \\$err});\n\tif (defined (@$err[0])) {\n\t    stf::stfUtility->list_errors( @$err);\n\t    die \"Error: splatTree failed running rmtree to delete $dir\\n\";\n\t}\n}\n\n#------------------------------------------------------------#\n# shortenPaths\n#\n# Used by splatTree above. Recursively descends into the given\n# directory and renames all directories to a single digit.\n#\n# Usage:\n#  stf::stfUtility->shortenPaths(dir => $dir);\n#------------------------------------------------------------#\nsub shortenPaths {\n\tmy ($self, %args) = @_;\n\n\tmy $longPath = \"\";\n\n\tif (exists $args{dir}) {\n\t   $longPath = $args{dir};\n\t}\n\n\tif ($longPath eq \"\" ) {\n\t    die \"Error: stfUtility.pm: shortenPaths directory argument not supplied or blank\\n\";\n\t}\n\n\topendir(DIR, $longPath) or return 0;\n\tmy @files = readdir(DIR);\n\tclosedir(DIR);\n\n"
    },
    "98": {
      "metadata": {
        "chunk_id": "a18175996b12e234518838570936ad5098fee0d87a2fe2829735ed23951bae89",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "\tmy @subDirs;\n\tmy $newName = 0;\n\tforeach my $file(@files) {\n\t\tif ($file eq '.' || $file eq '..') {\n\t\t\tnext;\n\t\t}\n\n\t\tif (length($file) < 3) {\n\t\t\tnext;\n\t\t}\n\n\t\t$file = $longPath . \"/$file\";\n\t\tif (-f $file) {\n\t\t\tnext;\n\t\t}\n\n\t\tmy $newFile = $longPath . \"/$newName\";\n\t\t$newName++;\n\t\trename($file, $newFile) or next;\n\t\tpush(@subDirs, $newFile);\n\t}\n\n\tforeach my $subDir (@subDirs) {\n\t\tmy $rv = eval {\n\t\t\tstf::stfUtility->shortenPaths( dir => $subDir );\n\t\t\t1;\n\t\t};\n\n\t\tif (!(defined $rv)) {\n\t\t\tprint(\"Crashed trying to descend into $subDir\\n\")\n\t\t}\n\t}\n}\n\n#------------------------------------------------------------#\n# searchReplace\n#\n# Searches a file for every occurrence of a search string and\n# replaces them with the substitute string.\n#\n# Usage:\n#  my $number = stf::stfUtility->searchReplace(file => $filename, search => $search_string, replace => $replace_string)\n#\n# Returns:\n#  The number of replacements\n#------------------------------------------------------------#\nsub searchReplace {\n\tmy ($self, %args) = @_;\n\n\tmy $file = \"\";                       # the file to search\n\tmy $search_string = \"\";              # string representing the string to search the file for (use single quotes to quote string)\n\tmy $replace_string = \"\";             # substitute string\n\n\tif (exists $args{file}) {\n\t   $file = $args{file};\n\t}\n\tif (exists $args{search}) {\n\t   $search_string = $args{search};\n\t}\n\tif (exists $args{replace}) {\n\t   $replace_string = $args{replace};\n\t}\n\n\t# initialise replacement \n\tmy $cnt = 0;\n\n\t# Open the file in read and write mode     \n\topen (FILEIN, \"<$file\");\n\n\tmy @lines = ();\n\t# walk through the read file, creating a updated copy of the file...\n\tforeach my $line (<FILEIN>)\n\t{\n\t\tif ($line =~ /\\Q${search_string}\\E/)\n\t\t{    \n\t\t   ($line) =~ s/\\Q${search_string}\\E/${replace_string}/g;\n\t\t   $cnt++;\n\t\t}\n\t\tpush (@lines, $line);\n\t}\n\n\tclose FILEIN;\n\n\tstf::stfUtility->writeToFile(file => $file, content => \\@lines, replace => $TRUE);\n\treturn $cnt;\n}\n\n#------------------------------------------------------------#\n# err\n#\n# Prints messages at the error logging level.\n#\n# Usage:\n#  err(\"Unexpected dump found: \" . $dump);\n#------------------------------------------------------------#\nsub err {\n    my $messageText = shift;\n\n    if (defined $ENV{loggingLevel}) {\n    \tif ($ENV{loggingLevel} eq \"ERR\" || $ENV{loggingLevel} eq \"WARN\" || $ENV{loggingLevel} eq \"INFO\" || $ENV{loggingLevel} eq \"DEBUG\" || $ENV{loggingLevel} eq \"TRACE\") {\n\t\t\tstf::stfUtility->logMsg(message => $messageText);\n    \t}\n    } \n}\n\n#------------------------------------------------------------#\n# warn\n#\n# Prints messages at the warning logging level.\n#\n# Usage:\n#  warn(\"Killing processes: \" . join(\" \", sort keys %process_list));\n#------------------------------------------------------------#\nsub warn {\n    my $messageText = shift;\n\n    if (defined $ENV{loggingLevel}) {\n    \tif ($ENV{loggingLevel} eq \"WARN\" || $ENV{loggingLevel} eq \"INFO\" || $ENV{loggingLevel} eq \"DEBUG\" || $ENV{loggingLevel} eq \"TRACE\") {\n\t\t\tstf::stfUtility->logMsg(message => $messageText);\n    \t}\n    } \n}\n\n#------------------------------------------------------------#\n# info\n#\n# Prints messages at the info logging level.\n#\n# Usage:\n#  info(\"  o Process $process->{uid} is still running as expected\");\n#------------------------------------------------------------#\nsub info {\n    my $messageText = shift;\n\n    if (defined $ENV{loggingLevel}) {\n    \tif ($ENV{loggingLevel} eq \"INFO\" || $ENV{loggingLevel} eq \"DEBUG\" || $ENV{loggingLevel} eq \"TRACE\") {\n\t\t\tstf::stfUtility->logMsg(message => $messageText);\n    \t}\n    } \n}\n\n#------------------------------------------------------------#\n# debug\n#\n# Prints messages at the debug logging level.\n#\n# Usage:\n#  debug(\"The pskill tool ran without error\");\n#------------------------------------------------------------#\nsub debug {\n    my $messageText = shift;\n\n",
        "start_line": 565,
        "end_line": 717,
        "chunk_index": 4,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 998,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772801"
      },
      "text": "\tmy @subDirs;\n\tmy $newName = 0;\n\tforeach my $file(@files) {\n\t\tif ($file eq '.' || $file eq '..') {\n\t\t\tnext;\n\t\t}\n\n\t\tif (length($file) < 3) {\n\t\t\tnext;\n\t\t}\n\n\t\t$file = $longPath . \"/$file\";\n\t\tif (-f $file) {\n\t\t\tnext;\n\t\t}\n\n\t\tmy $newFile = $longPath . \"/$newName\";\n\t\t$newName++;\n\t\trename($file, $newFile) or next;\n\t\tpush(@subDirs, $newFile);\n\t}\n\n\tforeach my $subDir (@subDirs) {\n\t\tmy $rv = eval {\n\t\t\tstf::stfUtility->shortenPaths( dir => $subDir );\n\t\t\t1;\n\t\t};\n\n\t\tif (!(defined $rv)) {\n\t\t\tprint(\"Crashed trying to descend into $subDir\\n\")\n\t\t}\n\t}\n}\n\n#------------------------------------------------------------#\n# searchReplace\n#\n# Searches a file for every occurrence of a search string and\n# replaces them with the substitute string.\n#\n# Usage:\n#  my $number = stf::stfUtility->searchReplace(file => $filename, search => $search_string, replace => $replace_string)\n#\n# Returns:\n#  The number of replacements\n#------------------------------------------------------------#\nsub searchReplace {\n\tmy ($self, %args) = @_;\n\n\tmy $file = \"\";                       # the file to search\n\tmy $search_string = \"\";              # string representing the string to search the file for (use single quotes to quote string)\n\tmy $replace_string = \"\";             # substitute string\n\n\tif (exists $args{file}) {\n\t   $file = $args{file};\n\t}\n\tif (exists $args{search}) {\n\t   $search_string = $args{search};\n\t}\n\tif (exists $args{replace}) {\n\t   $replace_string = $args{replace};\n\t}\n\n\t# initialise replacement \n\tmy $cnt = 0;\n\n\t# Open the file in read and write mode     \n\topen (FILEIN, \"<$file\");\n\n\tmy @lines = ();\n\t# walk through the read file, creating a updated copy of the file...\n\tforeach my $line (<FILEIN>)\n\t{\n\t\tif ($line =~ /\\Q${search_string}\\E/)\n\t\t{    \n\t\t   ($line) =~ s/\\Q${search_string}\\E/${replace_string}/g;\n\t\t   $cnt++;\n\t\t}\n\t\tpush (@lines, $line);\n\t}\n\n\tclose FILEIN;\n\n\tstf::stfUtility->writeToFile(file => $file, content => \\@lines, replace => $TRUE);\n\treturn $cnt;\n}\n\n#------------------------------------------------------------#\n# err\n#\n# Prints messages at the error logging level.\n#\n# Usage:\n#  err(\"Unexpected dump found: \" . $dump);\n#------------------------------------------------------------#\nsub err {\n    my $messageText = shift;\n\n    if (defined $ENV{loggingLevel}) {\n    \tif ($ENV{loggingLevel} eq \"ERR\" || $ENV{loggingLevel} eq \"WARN\" || $ENV{loggingLevel} eq \"INFO\" || $ENV{loggingLevel} eq \"DEBUG\" || $ENV{loggingLevel} eq \"TRACE\") {\n\t\t\tstf::stfUtility->logMsg(message => $messageText);\n    \t}\n    } \n}\n\n#------------------------------------------------------------#\n# warn\n#\n# Prints messages at the warning logging level.\n#\n# Usage:\n#  warn(\"Killing processes: \" . join(\" \", sort keys %process_list));\n#------------------------------------------------------------#\nsub warn {\n    my $messageText = shift;\n\n    if (defined $ENV{loggingLevel}) {\n    \tif ($ENV{loggingLevel} eq \"WARN\" || $ENV{loggingLevel} eq \"INFO\" || $ENV{loggingLevel} eq \"DEBUG\" || $ENV{loggingLevel} eq \"TRACE\") {\n\t\t\tstf::stfUtility->logMsg(message => $messageText);\n    \t}\n    } \n}\n\n#------------------------------------------------------------#\n# info\n#\n# Prints messages at the info logging level.\n#\n# Usage:\n#  info(\"  o Process $process->{uid} is still running as expected\");\n#------------------------------------------------------------#\nsub info {\n    my $messageText = shift;\n\n    if (defined $ENV{loggingLevel}) {\n    \tif ($ENV{loggingLevel} eq \"INFO\" || $ENV{loggingLevel} eq \"DEBUG\" || $ENV{loggingLevel} eq \"TRACE\") {\n\t\t\tstf::stfUtility->logMsg(message => $messageText);\n    \t}\n    } \n}\n\n#------------------------------------------------------------#\n# debug\n#\n# Prints messages at the debug logging level.\n#\n# Usage:\n#  debug(\"The pskill tool ran without error\");\n#------------------------------------------------------------#\nsub debug {\n    my $messageText = shift;\n\n"
    },
    "99": {
      "metadata": {
        "chunk_id": "d6707707c68e9b144ba3a59c43ce235bbb095a6b5d1c006d222b13551f0fb8f2",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "    if (defined $ENV{loggingLevel}) {\n    \tif ($ENV{loggingLevel} eq \"DEBUG\" || $ENV{loggingLevel} eq \"TRACE\") {\n\t\t\tstf::stfUtility->logMsg(message => $messageText);\n    \t}\n    } \n}\n\n#------------------------------------------------------------#\n# trace\n#\n# Prints messages at the trace logging level.\n#\n# Usage:\n#  trace(\"Process $process->{uid} is still running\");\n#------------------------------------------------------------#\nsub trace {\n    my $messageText = shift;\n\n    if (defined $ENV{loggingLevel} && $ENV{loggingLevel} eq \"TRACE\") {\n    \t    stf::stfUtility->logMsg(message => $messageText);\n    } \n}\n\n#------------------------------------------------------------#\n# logMsg\n#\n# Prints messages and writes the messages to a file if one \n# is specified.\n#\n# Usage:\n#  stf::stfUtility->logMsg(file => $file, message => $msg);\n#  stf::stfUtility->logMsg(message => $messageText);\n#------------------------------------------------------------#\nsub logMsg {\n\tmy ($self, %args) = @_;\n\n    my $file      = \"\";         # the file to log the message to\n    my $message   = \"\";         # the string to add to the log\n\n\tif (exists $args{file}) {\n\t   $file = $args{file};\n\t}\n\tif (exists $args{message}) {\n\t   $message = $args{message};\n\t}\n\n\tmy $entry = \"$message\\n\";\n\n\tmy $timestamp;\n\t# Get a timestamp with millisecond accuracy if the HiRes perl module \n\t# is available, otherwise downgrade to second accuracy.\n\tif ($useHiRes) {\n\t\tmy $log_timestamp = Time::HiRes::gettimeofday();\n\n\t\t# Work out how many milliseconds the timestamp contains\n\t\tmy $timeWithNoMillis = int($log_timestamp);\n        my $for_millisecond = int(($log_timestamp-$timeWithNoMillis)*1000);\n\n\t\t# Format the time to HH:MM:SS.mmm format so that it in includes the milliseconds\n\t\tmy ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($timeWithNoMillis);\n        $timestamp = sprintf(\"%02d:%02d:%02d.%03d\", $hour, $min, $sec, $for_millisecond);\n\t}\n\telse {\n\t\tmy ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);\n\n        $timestamp = sprintf(\"%02d:%02d:%02d    \", $hour, $min, $sec);\n\t}\n\n\t# Prefix the message with the timestamp\n\t$entry = \"${timestamp} - $entry\";\n\n\t# Prefix all logging with 'STF'\n\t$entry = \"STF $entry\";\n\n\tif ( $file ne \"\" ) {\n\t\tstf::stfUtility->writeToFile(file => $file, content =>[$entry]);\n\t}\n\n\tprint $entry;\n}\n\n#------------------------------------------------------------#\n# strip\n#\n# Strips the leading and trailing whitespace from a string.\n#\n# Usage:\n#  $string = stf::stfUtility->strip($str);\n#\n# Arguments:\n#  The string to remove the leading and trailing whitespace from.\n#\n# Returns:\n#  The trimmed string\n#------------------------------------------------------------#\nsub strip {\n  my ($self, $str) = @_;\n\n  $str =~ s/^\\s+//g;\n  $str =~ s/\\s+$//g;\n\n  return $str;\n}\n\n#------------------------------------------------------------#\n# copyTree\n#\n# Copies a directory tree.\n#\n# Usage:\n#  $rc = stf::stfUtility->copyTree(    \n#    from    =>  fromdir,\n#    to        =>  todir,\n#    includeList    => /@includeList);\n#    excludeList    => /@excludeList);\n#\n# Arguments:\n#    from    = the directory to copy from\n#    to    = the directory to copy to\n#    @includeList    = (.ext1, .ext2, ...);\n#    @excludeList    = (a.ext1, b.ext2, ...);\n#\n# Returns\n#  0 if successful and 1 if unsuccessful\n#------------------------------------------------------------#\nsub copyTree { \n   my ($self, %args) = @_;              # The args\n   my $fromdir = \"\";                    # The directory to copy from\n   my $todir = \"\";                      # The directory to copy to\n   my $includeList = \"\";                # The optional array of file extensions to include in the jar\n   my $excludeList = \"\";                # The optional array of file names to exclude from the jar \n\n",
        "start_line": 718,
        "end_line": 850,
        "chunk_index": 5,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 1000,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772804"
      },
      "text": "    if (defined $ENV{loggingLevel}) {\n    \tif ($ENV{loggingLevel} eq \"DEBUG\" || $ENV{loggingLevel} eq \"TRACE\") {\n\t\t\tstf::stfUtility->logMsg(message => $messageText);\n    \t}\n    } \n}\n\n#------------------------------------------------------------#\n# trace\n#\n# Prints messages at the trace logging level.\n#\n# Usage:\n#  trace(\"Process $process->{uid} is still running\");\n#------------------------------------------------------------#\nsub trace {\n    my $messageText = shift;\n\n    if (defined $ENV{loggingLevel} && $ENV{loggingLevel} eq \"TRACE\") {\n    \t    stf::stfUtility->logMsg(message => $messageText);\n    } \n}\n\n#------------------------------------------------------------#\n# logMsg\n#\n# Prints messages and writes the messages to a file if one \n# is specified.\n#\n# Usage:\n#  stf::stfUtility->logMsg(file => $file, message => $msg);\n#  stf::stfUtility->logMsg(message => $messageText);\n#------------------------------------------------------------#\nsub logMsg {\n\tmy ($self, %args) = @_;\n\n    my $file      = \"\";         # the file to log the message to\n    my $message   = \"\";         # the string to add to the log\n\n\tif (exists $args{file}) {\n\t   $file = $args{file};\n\t}\n\tif (exists $args{message}) {\n\t   $message = $args{message};\n\t}\n\n\tmy $entry = \"$message\\n\";\n\n\tmy $timestamp;\n\t# Get a timestamp with millisecond accuracy if the HiRes perl module \n\t# is available, otherwise downgrade to second accuracy.\n\tif ($useHiRes) {\n\t\tmy $log_timestamp = Time::HiRes::gettimeofday();\n\n\t\t# Work out how many milliseconds the timestamp contains\n\t\tmy $timeWithNoMillis = int($log_timestamp);\n        my $for_millisecond = int(($log_timestamp-$timeWithNoMillis)*1000);\n\n\t\t# Format the time to HH:MM:SS.mmm format so that it in includes the milliseconds\n\t\tmy ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($timeWithNoMillis);\n        $timestamp = sprintf(\"%02d:%02d:%02d.%03d\", $hour, $min, $sec, $for_millisecond);\n\t}\n\telse {\n\t\tmy ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);\n\n        $timestamp = sprintf(\"%02d:%02d:%02d    \", $hour, $min, $sec);\n\t}\n\n\t# Prefix the message with the timestamp\n\t$entry = \"${timestamp} - $entry\";\n\n\t# Prefix all logging with 'STF'\n\t$entry = \"STF $entry\";\n\n\tif ( $file ne \"\" ) {\n\t\tstf::stfUtility->writeToFile(file => $file, content =>[$entry]);\n\t}\n\n\tprint $entry;\n}\n\n#------------------------------------------------------------#\n# strip\n#\n# Strips the leading and trailing whitespace from a string.\n#\n# Usage:\n#  $string = stf::stfUtility->strip($str);\n#\n# Arguments:\n#  The string to remove the leading and trailing whitespace from.\n#\n# Returns:\n#  The trimmed string\n#------------------------------------------------------------#\nsub strip {\n  my ($self, $str) = @_;\n\n  $str =~ s/^\\s+//g;\n  $str =~ s/\\s+$//g;\n\n  return $str;\n}\n\n#------------------------------------------------------------#\n# copyTree\n#\n# Copies a directory tree.\n#\n# Usage:\n#  $rc = stf::stfUtility->copyTree(    \n#    from    =>  fromdir,\n#    to        =>  todir,\n#    includeList    => /@includeList);\n#    excludeList    => /@excludeList);\n#\n# Arguments:\n#    from    = the directory to copy from\n#    to    = the directory to copy to\n#    @includeList    = (.ext1, .ext2, ...);\n#    @excludeList    = (a.ext1, b.ext2, ...);\n#\n# Returns\n#  0 if successful and 1 if unsuccessful\n#------------------------------------------------------------#\nsub copyTree { \n   my ($self, %args) = @_;              # The args\n   my $fromdir = \"\";                    # The directory to copy from\n   my $todir = \"\";                      # The directory to copy to\n   my $includeList = \"\";                # The optional array of file extensions to include in the jar\n   my $excludeList = \"\";                # The optional array of file names to exclude from the jar \n\n"
    },
    "100": {
      "metadata": {
        "chunk_id": "10f39b6507a0b09ce93d4906021775ae3fbd88e6584b32d829fb1516641baf26",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "   if (exists $args{from}) {\n      $fromdir = $args{from};\n\n      # strip out any quotes...\n      ($fromdir) =~ s/\\\"//g;\n   }\n\n   if (exists $args{to}) {\n      $todir = $args{to};\n\n      # strip out any quotes...\n      ($todir) =~ s/\\\"//g;\n   }\n\n   if (exists $args{includeList}) {\n      $includeList = $args{includeList};         \n   }\n\n   if (exists $args{excludelist}) {\n      $excludeList = $args{excludelist};         \n   }\n\n   if (!-d $fromdir) {\n      return 1;\n   }\n\n   if (!-d $todir) {\n      mkpath $todir or return 1;\n\n      chmod(0775, $todir) or return 1;\n   }\n\n   # get current dir\n   my $currdir = getcwd();\n   chdir $fromdir;\n\n   # Support relative paths for $todir\n   unless (File::Spec->file_name_is_absolute($todir)) {\n     $todir = catfile($currdir, $todir);\n   }\n\n   my @files = glob '.* *';\n   foreach my $file (@files ) {\n      my $from = catfile($fromdir, $file);\n      my $to = catfile($todir,$file);\n      if (-d $file) {\n\t      if (!-l $file and ($file ne \".\" and $file ne \"..\")) {\n\t         if ($includeList eq \"\" and $excludeList eq \"\") {\n\t            $self->copyTree(from    => $from, \n\t                            to      => $to);\n\t         }\n\t         elsif ($includeList ne \"\" and $excludeList eq \"\") {\n\t            $self->copyTree(from    => $from, \n\t                            to      => $to,\n\t                            includeList => $includeList);\n\t         } \n\t         elsif ($includeList eq \"\" and $excludeList ne \"\")  {\n\t          \t$self->copyTree(from    => $from, \n\t                            to      => $to,\n\t                            excludeList => $excludeList);\n\t         } \n\t         else {\n\t          \t$self->copyTree(from    => $from, \n\t                            to      => $to,\n\t                            includeList => $includeList,\n\t                            excludeList => $excludeList);\n\t         }\n\t         chdir $fromdir or return 1;\n\t      }\n      }\n      else {\n         my $match = 0; \n         if ($includeList eq \"\") {\n            $match = 1;\n         }\n         else {\n            my ($base, $path, $type) = fileparse($file,'\\.[\\w\\-\\+]*');\n            foreach my $extension (@{$includeList}) {\n               if ($extension eq $type) {\n                  $match = 1;\n               }\n            }\n         }\n\n         if ($excludeList ne \"\") {\n             my ($base, $path, $type) = fileparse($file,'\\.[\\w\\-\\+]*');\n             my $fileName = $base . $type;  \n             foreach my $exclude (@{$excludeList}) {\n                if ($fileName eq $exclude) {\n                   $match = 0;\n                }\n             }\n         }\n\n         if ($match == $TRUE) {\n            copy($from, $to) or return 1;\n         }\n      }\n   }\n\n   # change to the directory we were in\n   chdir $currdir or return 1;\n\n   return 0;\n}\n\n#----------------------------------------------------------------------------------#\n# getWorkspaceRoot\n#\n# Returns the full path of the workspace root.\n#\n# Usage:\n#  stf::stfUtility->getWorkspaceRoot();\n#\n# Returns:\n#  The workspace root\n#----------------------------------------------------------------------------------#\nsub getWorkspaceRoot {\n\tmy $self = @_;\n\n\tmy $stfUtilityPath = $INC{\"stf/stfUtility.pm\"};\n\ts/stfUtility.pm$// for $stfUtilityPath;\n\n\treturn abs_path(catfile($stfUtilityPath, \"..\", \"..\", \"..\"));\n}\n\n#----------------------------------------------------------------------------------#\n# getJavaVersionInfo\n#\n# Usage:\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(JAVA_HOME => 1);\n#  %java_details = stf::stfUtility->getJavaVersionInfo();\n# - Gets details for the Java at JAVA_HOME\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(PATH => 1);\n# - Gets details for the Java on the PATH\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(PATH => <path>);\n# - Gets details for the Java at <path>\n#----------------------------------------------------------------------------------#\nsub getJavaVersionInfo {\n\n\tmy ($self, %options) = @_;\n\n",
        "start_line": 851,
        "end_line": 996,
        "chunk_index": 6,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 1000,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772807"
      },
      "text": "   if (exists $args{from}) {\n      $fromdir = $args{from};\n\n      # strip out any quotes...\n      ($fromdir) =~ s/\\\"//g;\n   }\n\n   if (exists $args{to}) {\n      $todir = $args{to};\n\n      # strip out any quotes...\n      ($todir) =~ s/\\\"//g;\n   }\n\n   if (exists $args{includeList}) {\n      $includeList = $args{includeList};         \n   }\n\n   if (exists $args{excludelist}) {\n      $excludeList = $args{excludelist};         \n   }\n\n   if (!-d $fromdir) {\n      return 1;\n   }\n\n   if (!-d $todir) {\n      mkpath $todir or return 1;\n\n      chmod(0775, $todir) or return 1;\n   }\n\n   # get current dir\n   my $currdir = getcwd();\n   chdir $fromdir;\n\n   # Support relative paths for $todir\n   unless (File::Spec->file_name_is_absolute($todir)) {\n     $todir = catfile($currdir, $todir);\n   }\n\n   my @files = glob '.* *';\n   foreach my $file (@files ) {\n      my $from = catfile($fromdir, $file);\n      my $to = catfile($todir,$file);\n      if (-d $file) {\n\t      if (!-l $file and ($file ne \".\" and $file ne \"..\")) {\n\t         if ($includeList eq \"\" and $excludeList eq \"\") {\n\t            $self->copyTree(from    => $from, \n\t                            to      => $to);\n\t         }\n\t         elsif ($includeList ne \"\" and $excludeList eq \"\") {\n\t            $self->copyTree(from    => $from, \n\t                            to      => $to,\n\t                            includeList => $includeList);\n\t         } \n\t         elsif ($includeList eq \"\" and $excludeList ne \"\")  {\n\t          \t$self->copyTree(from    => $from, \n\t                            to      => $to,\n\t                            excludeList => $excludeList);\n\t         } \n\t         else {\n\t          \t$self->copyTree(from    => $from, \n\t                            to      => $to,\n\t                            includeList => $includeList,\n\t                            excludeList => $excludeList);\n\t         }\n\t         chdir $fromdir or return 1;\n\t      }\n      }\n      else {\n         my $match = 0; \n         if ($includeList eq \"\") {\n            $match = 1;\n         }\n         else {\n            my ($base, $path, $type) = fileparse($file,'\\.[\\w\\-\\+]*');\n            foreach my $extension (@{$includeList}) {\n               if ($extension eq $type) {\n                  $match = 1;\n               }\n            }\n         }\n\n         if ($excludeList ne \"\") {\n             my ($base, $path, $type) = fileparse($file,'\\.[\\w\\-\\+]*');\n             my $fileName = $base . $type;  \n             foreach my $exclude (@{$excludeList}) {\n                if ($fileName eq $exclude) {\n                   $match = 0;\n                }\n             }\n         }\n\n         if ($match == $TRUE) {\n            copy($from, $to) or return 1;\n         }\n      }\n   }\n\n   # change to the directory we were in\n   chdir $currdir or return 1;\n\n   return 0;\n}\n\n#----------------------------------------------------------------------------------#\n# getWorkspaceRoot\n#\n# Returns the full path of the workspace root.\n#\n# Usage:\n#  stf::stfUtility->getWorkspaceRoot();\n#\n# Returns:\n#  The workspace root\n#----------------------------------------------------------------------------------#\nsub getWorkspaceRoot {\n\tmy $self = @_;\n\n\tmy $stfUtilityPath = $INC{\"stf/stfUtility.pm\"};\n\ts/stfUtility.pm$// for $stfUtilityPath;\n\n\treturn abs_path(catfile($stfUtilityPath, \"..\", \"..\", \"..\"));\n}\n\n#----------------------------------------------------------------------------------#\n# getJavaVersionInfo\n#\n# Usage:\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(JAVA_HOME => 1);\n#  %java_details = stf::stfUtility->getJavaVersionInfo();\n# - Gets details for the Java at JAVA_HOME\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(PATH => 1);\n# - Gets details for the Java on the PATH\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(PATH => <path>);\n# - Gets details for the Java at <path>\n#----------------------------------------------------------------------------------#\nsub getJavaVersionInfo {\n\n\tmy ($self, %options) = @_;\n\n"
    },
    "101": {
      "metadata": {
        "chunk_id": "3a5298d868f636565336ea8a19f7d0d38cfcdd2e930ce1bc3dcf606833fa9327",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "\tmy $valid_input = 1;\n\tforeach my $key (sort keys %options) {\n\t\tif ( $key ne 'PATH' &&\n\t\t     $key ne 'JAVA_HOME' ) {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->getJavaVersionInfo: Received unrecognised option $key\\n\" );\n\t\t\t$valid_input = 0;\n\t\t}\n\t}\n\n\tmy %java_details;\n\n    my $tempInst;\n    if ($^O eq \"MSWin32\" ) {\n\t\t$tempInst = File::Temp::tempdir(CLEANUP => 1);\n\t} else { \n\t\t$tempInst=\"/tmp\";\n\t}\n\n    my $fullversion=\"JRE 0.0.0 IBM OS build unknown_build (SR0 FP0)\";\n\tmy $verlog = catfile($tempInst,\"version_info\");\n\tdebug(\"stf::stfUtility->getJavaVersionInfo: verlog is $verlog\");\n\n\tmy $path_to_java = \"\";\n\n\tif ( $valid_input == 1 ) {\n\t\tif ( defined $options{'PATH'} ) {\n\t\t\tif ( $options{'PATH'} eq '1' ) {\n\t\t\t\t$path_to_java = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$path_to_java = \"$options{'PATH'}/bin/\";\n\t\t\t}\n\t\t}\n\t\telsif ( !defined $ENV{'JAVA_HOME'} || $ENV{'JAVA_HOME'} eq \"\" ) {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->getJavaVersionInfo: Environment variable JAVA_HOME is not set, unable to retrieve Java version information\");\n\t\t\t$valid_input = 0;\n\t\t}\n\t\telse {\n\t\t\t$path_to_java = \"$ENV{'JAVA_HOME'}/bin/\";\n\t\t}\n\t}\n\n\tif ( $valid_input == 1 ) {\n\t\tmy $command = $path_to_java . \"java\";\n\t\t# stdout goes to $verlog.stdout\n\t\t# stderr goes to $verlog.stderr\n\t\tmy ($rc, $process) = stf::Commands->run_process(mnemonic => \"stf::stfUtility->getJavaVersionInfo\", command => \"$command\", args => \"-version\", logName => $verlog, echo => 1);\n\n\t    if ($rc != 0) {\n\t\t\tstf::stfUtility->logMsg( message => \"stf::stfUtility->getJavaVersionInfo: $command did not complete with rc = 0\");\n\t    }\n\t    my $lines = $self->readFileIntoArray(\"$verlog.stderr\");\n\n\t    # Strip out messages relating to zOS file permissions, because we may be on an NFS mount on zOS\n\t    $lines = $self->strip_zos_unable_to_switch_to_IFA_processor_message($lines);\n\t\tforeach my $line (@{$lines}) {\n\t\t\tdebug (\"stf::stfUtility->getJavaVersionInfo: Content from $verlog is $line\");\n\t\t}\n\n\t    %java_details = $self->parseJavaVersionInfo($lines);\n\n\t}\n\n    return %java_details;\n}\n\nsub parseJavaVersionInfo {\n\n\tmy ($self, $lines) = @_;\n\n\t# Is this an IBM or Oracle Java?\n\n",
        "start_line": 997,
        "end_line": 1069,
        "chunk_index": 7,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 675,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772811"
      },
      "text": "\tmy $valid_input = 1;\n\tforeach my $key (sort keys %options) {\n\t\tif ( $key ne 'PATH' &&\n\t\t     $key ne 'JAVA_HOME' ) {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->getJavaVersionInfo: Received unrecognised option $key\\n\" );\n\t\t\t$valid_input = 0;\n\t\t}\n\t}\n\n\tmy %java_details;\n\n    my $tempInst;\n    if ($^O eq \"MSWin32\" ) {\n\t\t$tempInst = File::Temp::tempdir(CLEANUP => 1);\n\t} else { \n\t\t$tempInst=\"/tmp\";\n\t}\n\n    my $fullversion=\"JRE 0.0.0 IBM OS build unknown_build (SR0 FP0)\";\n\tmy $verlog = catfile($tempInst,\"version_info\");\n\tdebug(\"stf::stfUtility->getJavaVersionInfo: verlog is $verlog\");\n\n\tmy $path_to_java = \"\";\n\n\tif ( $valid_input == 1 ) {\n\t\tif ( defined $options{'PATH'} ) {\n\t\t\tif ( $options{'PATH'} eq '1' ) {\n\t\t\t\t$path_to_java = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$path_to_java = \"$options{'PATH'}/bin/\";\n\t\t\t}\n\t\t}\n\t\telsif ( !defined $ENV{'JAVA_HOME'} || $ENV{'JAVA_HOME'} eq \"\" ) {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->getJavaVersionInfo: Environment variable JAVA_HOME is not set, unable to retrieve Java version information\");\n\t\t\t$valid_input = 0;\n\t\t}\n\t\telse {\n\t\t\t$path_to_java = \"$ENV{'JAVA_HOME'}/bin/\";\n\t\t}\n\t}\n\n\tif ( $valid_input == 1 ) {\n\t\tmy $command = $path_to_java . \"java\";\n\t\t# stdout goes to $verlog.stdout\n\t\t# stderr goes to $verlog.stderr\n\t\tmy ($rc, $process) = stf::Commands->run_process(mnemonic => \"stf::stfUtility->getJavaVersionInfo\", command => \"$command\", args => \"-version\", logName => $verlog, echo => 1);\n\n\t    if ($rc != 0) {\n\t\t\tstf::stfUtility->logMsg( message => \"stf::stfUtility->getJavaVersionInfo: $command did not complete with rc = 0\");\n\t    }\n\t    my $lines = $self->readFileIntoArray(\"$verlog.stderr\");\n\n\t    # Strip out messages relating to zOS file permissions, because we may be on an NFS mount on zOS\n\t    $lines = $self->strip_zos_unable_to_switch_to_IFA_processor_message($lines);\n\t\tforeach my $line (@{$lines}) {\n\t\t\tdebug (\"stf::stfUtility->getJavaVersionInfo: Content from $verlog is $line\");\n\t\t}\n\n\t    %java_details = $self->parseJavaVersionInfo($lines);\n\n\t}\n\n    return %java_details;\n}\n\nsub parseJavaVersionInfo {\n\n\tmy ($self, $lines) = @_;\n\n\t# Is this an IBM or Oracle Java?\n\n"
    },
    "102": {
      "metadata": {
        "chunk_id": "559614c52e2470a4f1a9022172522145cace41c6f870d75ba1e2f81bf972e867",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "\tmy $java_vendor           = 'Unknown'; # IBM or Oracle\n\tmy $java_version_string   = 'Unknown'; # 1.6.0, 1.7.0 etc.  from java -version output\n\tmy $build_string          = 'Unknown'; # e.g. pwa6490ea-20160104_02 or 1.8.0_92-b14\n\tmy $build_prefix          = 'Unknown'; # e.g. pwa6490ea IBM only\n\tmy $build_date            = 'Unknown'; # e.g. 20160104 IBM only\n\tmy $build_suffix          = 'Unknown'; # e.g. 02 IBM only\n\tmy $os                    = 'Unknown'; # w, a, x, m IBM only\n\tmy $arch                  = 'Unknown'; # p, z, i, l, r IBM only\n\tmy $bits                  = 'Unknown'; # 31, 32, 64\n\tmy $release               = 'Unknown'; # 60, 60_26, 70 etc. or 1.7.0, 1.8.0, 9 etc.\n\tmy $short_release         = 'Unknown'; # 6, 7, 8 etc.\n\tmy $release_suffix        = 'Unknown'; # e.g. 'ea'  IBM only\n\tmy $sr                    = '';        # Just the number\n\tmy $fp                    = '';        # Just the number or b14 etc. for Oracle\n\tmy $java_platform         = 'Unknown'; # e.g. linux_x86-32\n\tmy $java_platform_long    = 'Unknown'; # e.g. linux_x86-32_ibm or linux_x86-32_oracle\n\n    foreach my $line ( @{$lines} ) {\n    \t# Find the line containing the java version string\n   \t    if ( $line =~ /^java version/ ) {\n\t    \t#print \"Parsing line: $line\\n\";\n\t    \t# Match \"java version\" followed by one or spaces followed by zero or more double quotes\n\t    \t# Extract one or more characters which are not a quote\n\t    \t# Match on zero or more remaining characters \n\t    \t( $java_version_string )= $line =~ /^java version\\s+[\\\"]*([^\\\"]+).*/;\n\t    }\n\t    if ( $line =~ /^openjdk version/ ) {\n\t    \t( $java_version_string )= $line =~ /^openjdk version\\s+[\\\"]*([^\\\"]+).*/;\n\t    }\n\n",
        "start_line": 1070,
        "end_line": 1100,
        "chunk_index": 8,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 524,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772814"
      },
      "text": "\tmy $java_vendor           = 'Unknown'; # IBM or Oracle\n\tmy $java_version_string   = 'Unknown'; # 1.6.0, 1.7.0 etc.  from java -version output\n\tmy $build_string          = 'Unknown'; # e.g. pwa6490ea-20160104_02 or 1.8.0_92-b14\n\tmy $build_prefix          = 'Unknown'; # e.g. pwa6490ea IBM only\n\tmy $build_date            = 'Unknown'; # e.g. 20160104 IBM only\n\tmy $build_suffix          = 'Unknown'; # e.g. 02 IBM only\n\tmy $os                    = 'Unknown'; # w, a, x, m IBM only\n\tmy $arch                  = 'Unknown'; # p, z, i, l, r IBM only\n\tmy $bits                  = 'Unknown'; # 31, 32, 64\n\tmy $release               = 'Unknown'; # 60, 60_26, 70 etc. or 1.7.0, 1.8.0, 9 etc.\n\tmy $short_release         = 'Unknown'; # 6, 7, 8 etc.\n\tmy $release_suffix        = 'Unknown'; # e.g. 'ea'  IBM only\n\tmy $sr                    = '';        # Just the number\n\tmy $fp                    = '';        # Just the number or b14 etc. for Oracle\n\tmy $java_platform         = 'Unknown'; # e.g. linux_x86-32\n\tmy $java_platform_long    = 'Unknown'; # e.g. linux_x86-32_ibm or linux_x86-32_oracle\n\n    foreach my $line ( @{$lines} ) {\n    \t# Find the line containing the java version string\n   \t    if ( $line =~ /^java version/ ) {\n\t    \t#print \"Parsing line: $line\\n\";\n\t    \t# Match \"java version\" followed by one or spaces followed by zero or more double quotes\n\t    \t# Extract one or more characters which are not a quote\n\t    \t# Match on zero or more remaining characters \n\t    \t( $java_version_string )= $line =~ /^java version\\s+[\\\"]*([^\\\"]+).*/;\n\t    }\n\t    if ( $line =~ /^openjdk version/ ) {\n\t    \t( $java_version_string )= $line =~ /^openjdk version\\s+[\\\"]*([^\\\"]+).*/;\n\t    }\n\n"
    },
    "103": {
      "metadata": {
        "chunk_id": "b603aa08b5fdb8566dcf1cd2e724b190a02d112fdf99138f9b114b01871c81eb",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "    \tif ( $line =~ m/IBM/ ) {\n    \t\t$java_vendor = 'IBM';\n    \t}\n    \tif ( $line =~ m/HotSpot/ ) {\n    \t\t$java_vendor = 'Oracle';\n    \t}\n    \tif ( $line =~ m/OpenJDK/ ) {\n    \t\t$java_vendor = 'OpenJDK';\n    \t}\n    }\n\tif ( $java_vendor eq 'IBM' ) {\n\t    foreach my $line ( @{$lines} ) {\n\t    \t# Find the line containing the build identifier string\n    \t\tif ( $line =~ /Java\\(TM\\) SE Runtime Environment \\(build / ) {\n\t\t    \t#print \"Parsing line: $line\\n\";\n\t\t    \t# Example:\n\t\t    \t# Java(TM) SE Runtime Environment (build pmz6460sr16fp25-20160422_01(SR16 FP25))\n\t\t\t\t# Java(TM) SE Runtime Environment (build JRE 1.9.0 IBM Windows build 2016-09-02-182741)\n    \t\t\t( $build_string ) = $line =~ /^Java\\(TM\\) SE Runtime Environment \\(build ([^\\-]+\\-[^\\_]+\\_\\d\\d).*/;\n\t\t    \tif ( ! defined ($build_string) || $build_string eq \"\" ) {\n\t\t\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: Unable to parse java -version output line\\n$line\");\n\t\t    \t\tnext;\n\t\t    \t}\n    \t\t\t( $build_prefix, $build_date, $build_suffix ) = $build_string =~ /([^\\-]+)\\-([^\\_]+)\\_(\\d\\d)/;\n\t\t\t\t( $os, $arch, $bits, $release, $release_suffix ) = $build_prefix =~ /^[^x|w|a|m]+([x|w|a|m])([a|i|l|p|r|z])(\\d\\d)([\\d]+\\_[\\d]+|[\\d]+)(.*)/;\n\t\t\t\t# release_suffix is now empty, or something like 'ea', or 'sr3' or 'sr3fp30'\n\t\t\t\tif ( $release_suffix =~ m/fp/ ) {\n\t\t\t\t\t( $release_suffix, $fp ) = $release_suffix =~ /(.*)fp(\\d+).*$/;\n\t\t\t\t}\n\t\t\t\tif ( $release_suffix =~ m/sr/ ) {\n\t\t\t\t\t( $release_suffix, $sr ) = $release_suffix =~ /(.*)sr(\\d+).*$/;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$sr = $release_suffix;\n\t\t\t\t}\n\t\t\t    my $lang_level = $release;\n\t\t\t    my $vm_level = \"\";\n\t\t\t\tif ( $release =~ m/_/ ) {\n\t\t\t\t\t( $lang_level, $vm_level ) = $release =~ /(.*)_(.*)/;\n\t\t\t\t}\n\t\t\t\t$lang_level = $lang_level / 10;  # Change 60 to 6 etc.\n\t\t\t\t$short_release = $lang_level . $vm_level;\n\t\t\t}\n\t\t}\n\t}\n\n",
        "start_line": 1101,
        "end_line": 1147,
        "chunk_index": 9,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 634,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772817"
      },
      "text": "    \tif ( $line =~ m/IBM/ ) {\n    \t\t$java_vendor = 'IBM';\n    \t}\n    \tif ( $line =~ m/HotSpot/ ) {\n    \t\t$java_vendor = 'Oracle';\n    \t}\n    \tif ( $line =~ m/OpenJDK/ ) {\n    \t\t$java_vendor = 'OpenJDK';\n    \t}\n    }\n\tif ( $java_vendor eq 'IBM' ) {\n\t    foreach my $line ( @{$lines} ) {\n\t    \t# Find the line containing the build identifier string\n    \t\tif ( $line =~ /Java\\(TM\\) SE Runtime Environment \\(build / ) {\n\t\t    \t#print \"Parsing line: $line\\n\";\n\t\t    \t# Example:\n\t\t    \t# Java(TM) SE Runtime Environment (build pmz6460sr16fp25-20160422_01(SR16 FP25))\n\t\t\t\t# Java(TM) SE Runtime Environment (build JRE 1.9.0 IBM Windows build 2016-09-02-182741)\n    \t\t\t( $build_string ) = $line =~ /^Java\\(TM\\) SE Runtime Environment \\(build ([^\\-]+\\-[^\\_]+\\_\\d\\d).*/;\n\t\t    \tif ( ! defined ($build_string) || $build_string eq \"\" ) {\n\t\t\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: Unable to parse java -version output line\\n$line\");\n\t\t    \t\tnext;\n\t\t    \t}\n    \t\t\t( $build_prefix, $build_date, $build_suffix ) = $build_string =~ /([^\\-]+)\\-([^\\_]+)\\_(\\d\\d)/;\n\t\t\t\t( $os, $arch, $bits, $release, $release_suffix ) = $build_prefix =~ /^[^x|w|a|m]+([x|w|a|m])([a|i|l|p|r|z])(\\d\\d)([\\d]+\\_[\\d]+|[\\d]+)(.*)/;\n\t\t\t\t# release_suffix is now empty, or something like 'ea', or 'sr3' or 'sr3fp30'\n\t\t\t\tif ( $release_suffix =~ m/fp/ ) {\n\t\t\t\t\t( $release_suffix, $fp ) = $release_suffix =~ /(.*)fp(\\d+).*$/;\n\t\t\t\t}\n\t\t\t\tif ( $release_suffix =~ m/sr/ ) {\n\t\t\t\t\t( $release_suffix, $sr ) = $release_suffix =~ /(.*)sr(\\d+).*$/;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$sr = $release_suffix;\n\t\t\t\t}\n\t\t\t    my $lang_level = $release;\n\t\t\t    my $vm_level = \"\";\n\t\t\t\tif ( $release =~ m/_/ ) {\n\t\t\t\t\t( $lang_level, $vm_level ) = $release =~ /(.*)_(.*)/;\n\t\t\t\t}\n\t\t\t\t$lang_level = $lang_level / 10;  # Change 60 to 6 etc.\n\t\t\t\t$short_release = $lang_level . $vm_level;\n\t\t\t}\n\t\t}\n\t}\n\n"
    },
    "104": {
      "metadata": {
        "chunk_id": "575fa0b0e10d8a5a2a0ee56c96c44224f1e3b5369d3393a459c95a75e3a16827",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "\tif ( $java_vendor eq 'Oracle' ) {\n\t    foreach my $line ( @{$lines} ) {\n\t    \t# Find the line containing the build identifier string\n\t\t\tif ( $line =~ /Java\\(TM\\) SE Runtime Environment \\(build / ) {\n\t\t    \t#print \"Parsing line: $line\\n\";\n\t\t    \t# Examples:\n\t\t    \t# Java(TM) SE Runtime Environment (build 1.8.0_92-b14)\n\t\t\t# Java(TM) SE Runtime Environment (build 9-ea+124)\n    \t\t\t( $build_string ) = $line =~ /^Java\\(TM\\) SE Runtime Environment \\(build ([^\\)]+).*/;\n\t\t\t\t# Use the '+' to distinguish between the formats\n\t\t\t\tif ( $line =~ /\\+/ ) {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\-]+)\\-([^\\+]+)\\+(.*)/;\n\t\t\t\t}\n\t\t\t\telse {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\_]+)\\_([^\\-]+)\\-(.*)/;\n\t    \t\t}\n    \t\t}\n\t    \t# Is the Java 64 bit?\n\t    \t$bits = 32;\n    \t\tif ( $line =~ /64-Bit/ ) {\n    \t\t\t$bits = 64;\n    \t\t}\n\t\t}\n\t\t# We can't deduce operating system or architecture from Oracle build identifier, so let's try to work it out ourselves\n\t\tif ( $Config{osname} =~ /linux/ ) {\n\t\t\t$os = 'x';\n\t\t}\n\t\telsif ( $Config{osname} =~ /Win/ ) {\n\t\t\t$os = 'w';\n\t\t}\n\t\telse {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: add code for Oracle Java running on osname \" . $Config{osname} );\n\t\t}\n\n\t\tif ( $Config{archname} =~ /x86/ && $bits == 32 ) {\n\t\t\t$arch = 'i';\n\t\t}\n\t\telsif ( $Config{archname} =~ /x86/ && $bits == 64 ) {\n\t\t\t$arch = 'a';\n\t\t}\n\t\telsif ( $Config{archname} =~ /arm/  ) {\n\t\t\t$arch = 'r';\n\t\t}\n\t\telsif ( $Config{archname} =~ /riscv/  ) {\n\t\t\t$arch = 'v';\n\t\t}\n\t\telsif ( $Config{archname} =~ /loongarch/  ) {\n\t\t\t$arch = 'la';\n\t\t}\n\t\telse {\n\t\t    print \"Logging\\n\";\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: add code for Oracle java running on archname \" . $Config{archname} );\n\t\t}\n\t\t# Assign 'short release' based on the java version string\n\t\tif ( $java_version_string =~ /1.6.0/ ) { $short_release = '6'; }\n\t\tif ( $java_version_string =~ /1.7.0/ ) { $short_release = '7'; }\n\t\tif ( $java_version_string =~ /1.8.0/ ) { $short_release = '8'; }\n\t\tif ( $java_version_string =~ /^9.*/ ) { $short_release = '9'; }\n\t}\n\n\tif ( $java_vendor eq \"OpenJDK\" ) {\n\t    foreach my $line ( @{$lines} ) {\n\t    \t# Find the line containing the build identifier string\n\t\t\tif ( $line =~ /OpenJDK Runtime Environment \\(build / ) {\n\t\t    \t#print \"Parsing line: $line\\n\";\n\t\t    \t# Examples:\n\t\t\t# OpenJDK Runtime Environment (build 1.8.0-internal-jenkins_2017_05_17_18_01-b00)\n                        # OpenJDK Runtime Environment (build 1.8.0_91-b14)\n                        # OpenJDK Runtime Environment (build 9-internal+0-adhoc.sxa.openjdk-jdk9)\n\n",
        "start_line": 1148,
        "end_line": 1218,
        "chunk_index": 10,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 878,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772821"
      },
      "text": "\tif ( $java_vendor eq 'Oracle' ) {\n\t    foreach my $line ( @{$lines} ) {\n\t    \t# Find the line containing the build identifier string\n\t\t\tif ( $line =~ /Java\\(TM\\) SE Runtime Environment \\(build / ) {\n\t\t    \t#print \"Parsing line: $line\\n\";\n\t\t    \t# Examples:\n\t\t    \t# Java(TM) SE Runtime Environment (build 1.8.0_92-b14)\n\t\t\t# Java(TM) SE Runtime Environment (build 9-ea+124)\n    \t\t\t( $build_string ) = $line =~ /^Java\\(TM\\) SE Runtime Environment \\(build ([^\\)]+).*/;\n\t\t\t\t# Use the '+' to distinguish between the formats\n\t\t\t\tif ( $line =~ /\\+/ ) {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\-]+)\\-([^\\+]+)\\+(.*)/;\n\t\t\t\t}\n\t\t\t\telse {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\_]+)\\_([^\\-]+)\\-(.*)/;\n\t    \t\t}\n    \t\t}\n\t    \t# Is the Java 64 bit?\n\t    \t$bits = 32;\n    \t\tif ( $line =~ /64-Bit/ ) {\n    \t\t\t$bits = 64;\n    \t\t}\n\t\t}\n\t\t# We can't deduce operating system or architecture from Oracle build identifier, so let's try to work it out ourselves\n\t\tif ( $Config{osname} =~ /linux/ ) {\n\t\t\t$os = 'x';\n\t\t}\n\t\telsif ( $Config{osname} =~ /Win/ ) {\n\t\t\t$os = 'w';\n\t\t}\n\t\telse {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: add code for Oracle Java running on osname \" . $Config{osname} );\n\t\t}\n\n\t\tif ( $Config{archname} =~ /x86/ && $bits == 32 ) {\n\t\t\t$arch = 'i';\n\t\t}\n\t\telsif ( $Config{archname} =~ /x86/ && $bits == 64 ) {\n\t\t\t$arch = 'a';\n\t\t}\n\t\telsif ( $Config{archname} =~ /arm/  ) {\n\t\t\t$arch = 'r';\n\t\t}\n\t\telsif ( $Config{archname} =~ /riscv/  ) {\n\t\t\t$arch = 'v';\n\t\t}\n\t\telsif ( $Config{archname} =~ /loongarch/  ) {\n\t\t\t$arch = 'la';\n\t\t}\n\t\telse {\n\t\t    print \"Logging\\n\";\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: add code for Oracle java running on archname \" . $Config{archname} );\n\t\t}\n\t\t# Assign 'short release' based on the java version string\n\t\tif ( $java_version_string =~ /1.6.0/ ) { $short_release = '6'; }\n\t\tif ( $java_version_string =~ /1.7.0/ ) { $short_release = '7'; }\n\t\tif ( $java_version_string =~ /1.8.0/ ) { $short_release = '8'; }\n\t\tif ( $java_version_string =~ /^9.*/ ) { $short_release = '9'; }\n\t}\n\n\tif ( $java_vendor eq \"OpenJDK\" ) {\n\t    foreach my $line ( @{$lines} ) {\n\t    \t# Find the line containing the build identifier string\n\t\t\tif ( $line =~ /OpenJDK Runtime Environment \\(build / ) {\n\t\t    \t#print \"Parsing line: $line\\n\";\n\t\t    \t# Examples:\n\t\t\t# OpenJDK Runtime Environment (build 1.8.0-internal-jenkins_2017_05_17_18_01-b00)\n                        # OpenJDK Runtime Environment (build 1.8.0_91-b14)\n                        # OpenJDK Runtime Environment (build 9-internal+0-adhoc.sxa.openjdk-jdk9)\n\n"
    },
    "105": {
      "metadata": {
        "chunk_id": "d00226ea3ee483495de69db1231f36d87e0139f819e1a2cd0df7d8452c555623",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "    \t\t\t( $build_string ) = $line =~ /^OpenJDK Runtime Environment \\(build ([^\\)]+).*/;\n\t\t\t# Use the '-internal' or '+' to distinguish between the formats\n\t\t\tif ( $line =~ /\\+/ ) {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\-]+)\\-([^\\+]+)\\+(.*)/;\n\t\t\t} elsif ( $line =~ /\\-internal/ )  {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\-]+)\\-[^\\_]+\\_([^\\-]+)\\-(.*)/;\n\t\t\t} else {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\_]+)\\_([^\\-]+)\\-(.*)/;\n\t    \t\t}\n    \t\t}\n\t    \t# Is the Java 64 bit?\n\t    \t$bits = 32;\n    \t\tif ( $line =~ /64-Bit/ ) {\n    \t\t\t$bits = 64;\n    \t\t}\n\t\t}\n\t\t# We can't deduce operating system or architecture from Oracle build identifier, so let's try to work it out ourselves\n\t\tif ( $Config{osname} =~ /linux/ ) {\n\t\t\t$os = 'x';\n\t\t}\n\t\telsif ( $Config{osname} =~ /Win/ ) {\n\t\t\t$os = 'w';\n\t\t}\n\t\telsif ( $Config{osname} =~ /BSD/ ) {\n\t\t\t$os = 'b';\n\t\t}\n\t\telse {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: add code for Oracle Java running on osname \" . $Config{osname} );\n\t\t}\n\n\t\tif ( $Config{archname} =~ /x86/ && $bits == 32 ) {\n\t\t\t$arch = 'i';\n\t\t}\n\t\telsif ( $Config{archname} =~ /x86/ && $bits == 64 ) {\n\t\t\t$arch = 'a';\n\t\t}\n\t\telsif ( $Config{archname} =~ /arm/  ) {\n\t\t\t$arch = 'r';\n\t\t}\n\t\telsif ( $Config{archname} =~ /sparc/  ) {\n\t\t\t$arch = 'q';\n\t\t}\n\t\telse {\n\t\t    print \"Logging\\n\";\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: add code for Oracle java running on archname \" . $Config{archname} );\n\t\t}\n\t\t# Assign 'short release' based on the java version string\n\t\tif ( $java_version_string =~ /1.6.0/ ) { $short_release = '6'; }\n\t\tif ( $java_version_string =~ /1.7.0/ ) { $short_release = '7'; }\n\t\tif ( $java_version_string =~ /1.8.0/ ) { $short_release = '8'; }\n\t\tif ( $java_version_string =~ /^9.*/  ) { $short_release = '9'; }\n\t}\n\n\tif ( $os eq 'x' ) { $java_platform = 'linux_'; }\n\tif ( $os eq 'w' ) { $java_platform = 'win_'; }\n\tif ( $os eq 'a' ) { $java_platform = 'aix_'; }\n\tif ( $os eq 'm' ) { $java_platform = 'zos_'; }\n\tif ( $os eq 'b' ) { $java_platform = 'bsd_'; }\n\tif ( $arch eq 'a' ) { $java_platform .= 'x86-'; }\n\tif ( $arch eq 'i' ) { $java_platform .= 'x86-'; }\n\tif ( $arch eq 'l' ) { $java_platform .= 'ppcle-'; }\n\tif ( $arch eq 'p' ) { $java_platform .= 'ppc-'; }\n\tif ( $arch eq 'r' ) { $java_platform .= 'arm-'; }\n\tif ( $arch eq 'v' ) { $java_platform .= 'riscv-'; }\n\tif ( $arch eq 'la' ) { $java_platform .= 'loongarch-'; }\n\tif ( $arch eq 'q' ) { $java_platform .= 'sparc-'; }\n\tif ( $arch eq 'z' ) { $java_platform .= '390-'; }\n\tif ( $java_platform ne 'Unknown' ) {\n\t\t$java_platform .= $bits;\n\t\t$java_platform_long = lc($java_platform . \"_\" . $java_vendor);\n\t}\n\n",
        "start_line": 1219,
        "end_line": 1291,
        "chunk_index": 11,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 986,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772824"
      },
      "text": "    \t\t\t( $build_string ) = $line =~ /^OpenJDK Runtime Environment \\(build ([^\\)]+).*/;\n\t\t\t# Use the '-internal' or '+' to distinguish between the formats\n\t\t\tif ( $line =~ /\\+/ ) {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\-]+)\\-([^\\+]+)\\+(.*)/;\n\t\t\t} elsif ( $line =~ /\\-internal/ )  {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\-]+)\\-[^\\_]+\\_([^\\-]+)\\-(.*)/;\n\t\t\t} else {\n\t    \t\t\t( $release, $sr, $fp ) = $build_string =~ /([^\\_]+)\\_([^\\-]+)\\-(.*)/;\n\t    \t\t}\n    \t\t}\n\t    \t# Is the Java 64 bit?\n\t    \t$bits = 32;\n    \t\tif ( $line =~ /64-Bit/ ) {\n    \t\t\t$bits = 64;\n    \t\t}\n\t\t}\n\t\t# We can't deduce operating system or architecture from Oracle build identifier, so let's try to work it out ourselves\n\t\tif ( $Config{osname} =~ /linux/ ) {\n\t\t\t$os = 'x';\n\t\t}\n\t\telsif ( $Config{osname} =~ /Win/ ) {\n\t\t\t$os = 'w';\n\t\t}\n\t\telsif ( $Config{osname} =~ /BSD/ ) {\n\t\t\t$os = 'b';\n\t\t}\n\t\telse {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: add code for Oracle Java running on osname \" . $Config{osname} );\n\t\t}\n\n\t\tif ( $Config{archname} =~ /x86/ && $bits == 32 ) {\n\t\t\t$arch = 'i';\n\t\t}\n\t\telsif ( $Config{archname} =~ /x86/ && $bits == 64 ) {\n\t\t\t$arch = 'a';\n\t\t}\n\t\telsif ( $Config{archname} =~ /arm/  ) {\n\t\t\t$arch = 'r';\n\t\t}\n\t\telsif ( $Config{archname} =~ /sparc/  ) {\n\t\t\t$arch = 'q';\n\t\t}\n\t\telse {\n\t\t    print \"Logging\\n\";\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->parseJavaVersionInfo: add code for Oracle java running on archname \" . $Config{archname} );\n\t\t}\n\t\t# Assign 'short release' based on the java version string\n\t\tif ( $java_version_string =~ /1.6.0/ ) { $short_release = '6'; }\n\t\tif ( $java_version_string =~ /1.7.0/ ) { $short_release = '7'; }\n\t\tif ( $java_version_string =~ /1.8.0/ ) { $short_release = '8'; }\n\t\tif ( $java_version_string =~ /^9.*/  ) { $short_release = '9'; }\n\t}\n\n\tif ( $os eq 'x' ) { $java_platform = 'linux_'; }\n\tif ( $os eq 'w' ) { $java_platform = 'win_'; }\n\tif ( $os eq 'a' ) { $java_platform = 'aix_'; }\n\tif ( $os eq 'm' ) { $java_platform = 'zos_'; }\n\tif ( $os eq 'b' ) { $java_platform = 'bsd_'; }\n\tif ( $arch eq 'a' ) { $java_platform .= 'x86-'; }\n\tif ( $arch eq 'i' ) { $java_platform .= 'x86-'; }\n\tif ( $arch eq 'l' ) { $java_platform .= 'ppcle-'; }\n\tif ( $arch eq 'p' ) { $java_platform .= 'ppc-'; }\n\tif ( $arch eq 'r' ) { $java_platform .= 'arm-'; }\n\tif ( $arch eq 'v' ) { $java_platform .= 'riscv-'; }\n\tif ( $arch eq 'la' ) { $java_platform .= 'loongarch-'; }\n\tif ( $arch eq 'q' ) { $java_platform .= 'sparc-'; }\n\tif ( $arch eq 'z' ) { $java_platform .= '390-'; }\n\tif ( $java_platform ne 'Unknown' ) {\n\t\t$java_platform .= $bits;\n\t\t$java_platform_long = lc($java_platform . \"_\" . $java_vendor);\n\t}\n\n"
    },
    "106": {
      "metadata": {
        "chunk_id": "363e00f2dd765ae0e7c27b767f63fb546a7316056124842153f87026bef4d1d7",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "   \t#print \"java_version_string: $java_version_string\\n\";\n   \t#print \"java_vendor: $java_vendor\\n\";\n   \t#print \"build_prefix: $build_prefix\\n\";\n   \t#print \"build_string: $build_string\\n\";\n   \t#print \"build_date: $build_date\\n\";\n   \t#print \"build_suffix: $build_suffix\\n\";\n   \t#print \"os: $os\\n\";\n   \t#print \"arch: $arch\\n\";\n   \t#print \"bits: $bits\\n\";\n   \t#print \"release: $release\\n\";\n   \t#print \"short_release: $short_release\\n\";\n   \t#print \"sr: $sr\\n\";\n   \t#print \"fp: $fp\\n\";\n   \t#print \"java_platform: $java_platform\\n\";\n   \t#print \"java_platform_long: $java_platform_long\\n\";\n\n\tmy %java_details;\n\t$java_details{'JAVA_VERSION_STRING'} = $java_version_string;\n\t$java_details{'JAVA_VENDOR'} = $java_vendor;\n\t$java_details{'JAVA_BUILD_STRING'} = $build_string;\n\t$java_details{'JAVA_BUILD_PREFIX'} = $build_prefix;\n\t$java_details{'JAVA_BUILD_DATE'} = $build_date;\n\t$java_details{'JAVA_BUILD_SUFFIX'} = $build_suffix;\n\t$java_details{'JAVA_OS'} = $os;\n\t$java_details{'JAVA_ARCH'} = $arch;\n\t$java_details{'JAVA_BITS'} = $bits;\n\t$java_details{'JAVA_RELEASE'} = $release;\n\t$java_details{'JAVA_SHORT_RELEASE'} = $short_release;\n\t$java_details{'JAVA_SERVICE_REFRESH'} = $sr;\n\t$java_details{'JAVA_FIXPACK'} = $fp;\n\t$java_details{'JAVA_PLATFORM'} = $java_platform;\n\t$java_details{'JAVA_PLATFORM_LONG'} = $java_platform_long;\n\n\treturn %java_details;\n}\n\nsub strip_zos_unable_to_switch_to_IFA_processor_message {\n\n\tmy ($self, $lines) = @_;\n\n\t# If not on zOS, return\n\tif ($^O !~ /os390/) {\n\t\treturn $lines;\t\n\t}\n\n\tmy $stripped_array = [];\n\n\t# If there are no messages, return;\n\tif (!defined $lines or scalar @$lines == 0) {\n\t\treturn $lines;\n\t}\n\n\tfor (my $index; $index < scalar @$lines; $index++) {\n\n\t\tif (@$lines[$index] !~ /Unable to switch to IFA processor/) {\n\t\t\tpush (@$stripped_array, @$lines[$index]);\n\t\t} else {\n\t\t\tstf::stfUtility->logMsg ( message => \"Stripping \\\"Unable to switch to IFA processor\\\" message from file contents (This is normal if the SDK is on an NFS mount)\");\n\t\t}\n\n\t}\n\n\t#$errors = $stripped_array;\n\treturn $stripped_array;\n\n}\n\n#----------------------------------------------------------------------------------#\n# getJavaProperties\n#\n# Usage:\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(JAVA_HOME => 1);\n#  %java_details = stf::stfUtility->getJavaVersionInfo();\n# - Gets details for the Java at JAVA_HOME\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(PATH => 1);\n# - Gets details for the Java on the PATH\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(PATH => <path>);\n# - Gets details for the Java at <path>\n#----------------------------------------------------------------------------------#\nsub getJavaProperties {\n\n\tmy ($self, %options) = @_;\n\n\tmy $valid_input = 1;\n\tforeach my $key (sort keys %options) {\n\t\tif ( $key ne 'PATH' &&\n\t\t     $key ne 'JAVA_HOME' ) {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->getJavaProperties: Received unrecognised option $key\\n\" );\n\t\t\t$valid_input = 0;\n\t\t}\n\t}\n\n\tmy %java_properties;\n\n    my $tempInst;\n    if ($^O eq \"MSWin32\" ) {\n\t\t$tempInst = File::Temp::tempdir(CLEANUP => 1);\n\t} else { \n\t\t$tempInst=\"/tmp\";\n\t}\n\n\tmy $propertieslog = catfile($tempInst,\"java_properties\");\n\tdebug(\"stf::stfUtility->getJavaProperties: propertieslog is $propertieslog\");\n\n\tmy $path_to_java = \"\";\n\n",
        "start_line": 1292,
        "end_line": 1401,
        "chunk_index": 12,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 931,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772826"
      },
      "text": "   \t#print \"java_version_string: $java_version_string\\n\";\n   \t#print \"java_vendor: $java_vendor\\n\";\n   \t#print \"build_prefix: $build_prefix\\n\";\n   \t#print \"build_string: $build_string\\n\";\n   \t#print \"build_date: $build_date\\n\";\n   \t#print \"build_suffix: $build_suffix\\n\";\n   \t#print \"os: $os\\n\";\n   \t#print \"arch: $arch\\n\";\n   \t#print \"bits: $bits\\n\";\n   \t#print \"release: $release\\n\";\n   \t#print \"short_release: $short_release\\n\";\n   \t#print \"sr: $sr\\n\";\n   \t#print \"fp: $fp\\n\";\n   \t#print \"java_platform: $java_platform\\n\";\n   \t#print \"java_platform_long: $java_platform_long\\n\";\n\n\tmy %java_details;\n\t$java_details{'JAVA_VERSION_STRING'} = $java_version_string;\n\t$java_details{'JAVA_VENDOR'} = $java_vendor;\n\t$java_details{'JAVA_BUILD_STRING'} = $build_string;\n\t$java_details{'JAVA_BUILD_PREFIX'} = $build_prefix;\n\t$java_details{'JAVA_BUILD_DATE'} = $build_date;\n\t$java_details{'JAVA_BUILD_SUFFIX'} = $build_suffix;\n\t$java_details{'JAVA_OS'} = $os;\n\t$java_details{'JAVA_ARCH'} = $arch;\n\t$java_details{'JAVA_BITS'} = $bits;\n\t$java_details{'JAVA_RELEASE'} = $release;\n\t$java_details{'JAVA_SHORT_RELEASE'} = $short_release;\n\t$java_details{'JAVA_SERVICE_REFRESH'} = $sr;\n\t$java_details{'JAVA_FIXPACK'} = $fp;\n\t$java_details{'JAVA_PLATFORM'} = $java_platform;\n\t$java_details{'JAVA_PLATFORM_LONG'} = $java_platform_long;\n\n\treturn %java_details;\n}\n\nsub strip_zos_unable_to_switch_to_IFA_processor_message {\n\n\tmy ($self, $lines) = @_;\n\n\t# If not on zOS, return\n\tif ($^O !~ /os390/) {\n\t\treturn $lines;\t\n\t}\n\n\tmy $stripped_array = [];\n\n\t# If there are no messages, return;\n\tif (!defined $lines or scalar @$lines == 0) {\n\t\treturn $lines;\n\t}\n\n\tfor (my $index; $index < scalar @$lines; $index++) {\n\n\t\tif (@$lines[$index] !~ /Unable to switch to IFA processor/) {\n\t\t\tpush (@$stripped_array, @$lines[$index]);\n\t\t} else {\n\t\t\tstf::stfUtility->logMsg ( message => \"Stripping \\\"Unable to switch to IFA processor\\\" message from file contents (This is normal if the SDK is on an NFS mount)\");\n\t\t}\n\n\t}\n\n\t#$errors = $stripped_array;\n\treturn $stripped_array;\n\n}\n\n#----------------------------------------------------------------------------------#\n# getJavaProperties\n#\n# Usage:\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(JAVA_HOME => 1);\n#  %java_details = stf::stfUtility->getJavaVersionInfo();\n# - Gets details for the Java at JAVA_HOME\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(PATH => 1);\n# - Gets details for the Java on the PATH\n#\n#  %java_details = stf::stfUtility->getJavaVersionInfo(PATH => <path>);\n# - Gets details for the Java at <path>\n#----------------------------------------------------------------------------------#\nsub getJavaProperties {\n\n\tmy ($self, %options) = @_;\n\n\tmy $valid_input = 1;\n\tforeach my $key (sort keys %options) {\n\t\tif ( $key ne 'PATH' &&\n\t\t     $key ne 'JAVA_HOME' ) {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->getJavaProperties: Received unrecognised option $key\\n\" );\n\t\t\t$valid_input = 0;\n\t\t}\n\t}\n\n\tmy %java_properties;\n\n    my $tempInst;\n    if ($^O eq \"MSWin32\" ) {\n\t\t$tempInst = File::Temp::tempdir(CLEANUP => 1);\n\t} else { \n\t\t$tempInst=\"/tmp\";\n\t}\n\n\tmy $propertieslog = catfile($tempInst,\"java_properties\");\n\tdebug(\"stf::stfUtility->getJavaProperties: propertieslog is $propertieslog\");\n\n\tmy $path_to_java = \"\";\n\n"
    },
    "107": {
      "metadata": {
        "chunk_id": "16a40f9b46766104bbe18d80e4ed734dce749975a2c6965d9a9a835f7f570737",
        "file_path": "stf.core/scripts/stf/stfUtility.pm",
        "content": "\tif ( $valid_input == 1 ) {\n\t\tif ( defined $options{'PATH'} ) {\n\t\t\tif ( $options{'PATH'} eq '1' ) {\n\t\t\t\t$path_to_java = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$path_to_java = \"$options{'PATH'}/bin/\";\n\t\t\t}\n\t\t}\n\t\telsif ( !defined $ENV{'JAVA_HOME'} || $ENV{'JAVA_HOME'} eq \"\" ) {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->getJavaProperties: Environment variable JAVA_HOME is not set, unable to retrieve Java properties\");\n\t\t\t$valid_input = 0;\n\t\t}\n\t\telse {\n\t\t\t$path_to_java = \"$ENV{'JAVA_HOME'}/bin/\";\n\t\t}\n\t}\n\n\tif ( $valid_input == 1 ) {\n\t\tmy $command = $path_to_java . \"java\";\n\t\t# stdout goes to $propertieslog.stdout\n\t\t# stderr goes to $propertieslog.stderr\n\t\tmy ($rc, $process) = stf::Commands->run_process(mnemonic => \"stf::stfUtility->getJavaProperties\", command => \"$command\", args => \"-XshowSettings:properties -version\", logName => $propertieslog, echo => 0);\n\n\t    if ($rc != 0) {\n\t\t\tstf::stfUtility->logMsg( message => \"stf::stfUtility->getJavaProperties: $command did not complete with rc = 0\");\n\t    }\n\t    my $lines = $self->readFileIntoArray(\"$propertieslog.stderr\");\n\n\t    # Strip out messages relating to zOS file permissions, because we may be on an NFS mount on zOS\n\t    $lines = $self->strip_zos_unable_to_switch_to_IFA_processor_message($lines);\n\n\t    my $property = \"\";\n\t    my $value = \"\";\n\t\tforeach my $line (@{$lines}) {\n\t\t\tif ( $line =~ /=/ ) {\n\t\t\t\tif ( $property ne \"\" ) {\n\t\t\t\t\t$property =~ s/\\s+$//;\n\t\t\t\t\t$property =~ s/^\\s+//;\n\t\t\t\t\t$value =~ s/^\\s+//;\n\t\t\t\t\t$value =~ s/\\s+$//;\n\t\t\t\t\t$java_properties{$property} = $value;\n\t\t\t\t}\n\t\t\t\t($property, $value) = $line =~ /(.*)\\=(.*)/;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$line =~ s/^\\s+//;\n\t\t\t\t$line =~ s/\\s+$//;\n\t\t\t\t$value = \"$value $line\";\n\t\t\t}\n\t\t}\n\n\t\tif ( $property ne \"\" ) {\n\t\t\t$property =~ s/\\s+$//;\n\t\t\t$property =~ s/^\\s+//;\n\t\t\t$value =~ s/^\\s+//;\n\t\t\t$value =~ s/\\s+$//;\n\t\t\t$java_properties{$property} = $value;\n\t\t}\n\n\t}\n\n    return %java_properties;\n}\n\n1;\n\n\n",
        "start_line": 1402,
        "end_line": 1470,
        "chunk_index": 13,
        "total_chunks": 14,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 620,
        "node_type": null,
        "file_sha": "cd20b6d12b9d3179561de6d3ee4fcb039300a533",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.772828"
      },
      "text": "\tif ( $valid_input == 1 ) {\n\t\tif ( defined $options{'PATH'} ) {\n\t\t\tif ( $options{'PATH'} eq '1' ) {\n\t\t\t\t$path_to_java = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$path_to_java = \"$options{'PATH'}/bin/\";\n\t\t\t}\n\t\t}\n\t\telsif ( !defined $ENV{'JAVA_HOME'} || $ENV{'JAVA_HOME'} eq \"\" ) {\n\t\t\tstf::stfUtility->logMsg ( message => \"stf::stfUtility->getJavaProperties: Environment variable JAVA_HOME is not set, unable to retrieve Java properties\");\n\t\t\t$valid_input = 0;\n\t\t}\n\t\telse {\n\t\t\t$path_to_java = \"$ENV{'JAVA_HOME'}/bin/\";\n\t\t}\n\t}\n\n\tif ( $valid_input == 1 ) {\n\t\tmy $command = $path_to_java . \"java\";\n\t\t# stdout goes to $propertieslog.stdout\n\t\t# stderr goes to $propertieslog.stderr\n\t\tmy ($rc, $process) = stf::Commands->run_process(mnemonic => \"stf::stfUtility->getJavaProperties\", command => \"$command\", args => \"-XshowSettings:properties -version\", logName => $propertieslog, echo => 0);\n\n\t    if ($rc != 0) {\n\t\t\tstf::stfUtility->logMsg( message => \"stf::stfUtility->getJavaProperties: $command did not complete with rc = 0\");\n\t    }\n\t    my $lines = $self->readFileIntoArray(\"$propertieslog.stderr\");\n\n\t    # Strip out messages relating to zOS file permissions, because we may be on an NFS mount on zOS\n\t    $lines = $self->strip_zos_unable_to_switch_to_IFA_processor_message($lines);\n\n\t    my $property = \"\";\n\t    my $value = \"\";\n\t\tforeach my $line (@{$lines}) {\n\t\t\tif ( $line =~ /=/ ) {\n\t\t\t\tif ( $property ne \"\" ) {\n\t\t\t\t\t$property =~ s/\\s+$//;\n\t\t\t\t\t$property =~ s/^\\s+//;\n\t\t\t\t\t$value =~ s/^\\s+//;\n\t\t\t\t\t$value =~ s/\\s+$//;\n\t\t\t\t\t$java_properties{$property} = $value;\n\t\t\t\t}\n\t\t\t\t($property, $value) = $line =~ /(.*)\\=(.*)/;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$line =~ s/^\\s+//;\n\t\t\t\t$line =~ s/\\s+$//;\n\t\t\t\t$value = \"$value $line\";\n\t\t\t}\n\t\t}\n\n\t\tif ( $property ne \"\" ) {\n\t\t\t$property =~ s/\\s+$//;\n\t\t\t$property =~ s/^\\s+//;\n\t\t\t$value =~ s/^\\s+//;\n\t\t\t$value =~ s/\\s+$//;\n\t\t\t$java_properties{$property} = $value;\n\t\t}\n\n\t}\n\n    return %java_properties;\n}\n\n1;\n\n\n"
    },
    "108": {
      "metadata": {
        "chunk_id": "d7e26edb40b05f36e7f3314656808e2e7a9b71e6d1cb4c4c552d3a66fee26d68",
        "file_path": "stf.core/scripts/stfArguments.pm",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stfArguments;\n\nuse strict;\nuse warnings;\nuse FindBin qw($Bin);\nuse lib \"$Bin\";\nuse stfArguments;\n\nmy @stf_personal_properties = \"\";\nmy @stf_default_properties = \"\";\n\n# Registers property files for subsequent argument processing. \n# This subroutine must be called before 'get_argument'\nsub set_argument_data {\n\tmy $stf_personal = shift;\n\tmy $stf_default = shift;\n\n\t#print \"\\n\";\n \t#print \"stf_personal_properties: $stf_personal\\n\";\n \t#print \"stf_default_properties: $stf_default\\n\";\n\n\t# Read in the contents of the configuration files\n\t@stf_personal_properties           = read_file_contents($stf_personal);\n    @stf_default_properties            = read_file_contents($stf_default); \n}\n\n# Reads the contents of a file into an array\nsub read_file_contents\n{\n\tmy $version_file = shift;\n\topen(my $fh,'<',$version_file) or return \"\";\n\tmy @contents = <$fh>;\n\tclose($fh) or warn \"Could not close handle on version file: $version_file: $!\";\n\n\treturn @contents;\n}\n\n# Returns the value of an argument.\n# Search order is:\n#   1) command line arguments.\n#   2) User specific property for this STF test variant.\n#   3) STF default properties for this STF test variant.\n#   4) User specific STF properties\n#   5) Default STF properties\n#\nsub get_argument { \n\tmy $name = shift;\n\n\t# Find value for the named property    \n\tmy $value = do_get_argument($name);\n\n\t# Remove leading and trailing whitespace\n\t# This is needed for running from a workspace created on a Windows machine \n\t# when on a linux machine. \n\t# STF was failing because of a CR/LF problem. Without trimming the property\n\t# value unexpectedly ends with a CR.\n\t$value = stf::stfUtility->strip($value);\n\n\t# If the value contains a reference to variable ${HOME} \n\t# replace it with the resolved HOME environment variable (either $HOME or %USERPROFILE%)\n\t$value =~ s/\\$\\{HOME\\}/${ENV{'HOME'}}/;\n\n\t# If the resolved value matches '${.*}' then pull actual value from an environment variable.\n\tif ($value =~ /^\\$\\{.*\\}$/) {\n\t\tmy $env_variable_name = substr($value, 2, -1);\n\t\t$value = $ENV{$env_variable_name};\n\t}\n\n\treturn $value;\n}\n\n# Gets an argument and fails if the arguments value is null\n#\nsub get_and_check_argument {\n\tmy $argument_name = shift;\n\n\tmy $argument_value = get_argument($argument_name);\n\n\tif ( ! defined ($argument_value) || $argument_value eq 'null') {\n\t\tmy $arg_contents = do_get_argument($argument_name);\n\t\tif ($arg_contents =~ /^\\$\\{(.*)\\}$/) {\n\t\t\t# We failed attempting to find value for environment variable\n\t\t\tprint \"**FAILED** Can't resolve value for '$argument_name', as environment variable '$1' is not set\\n\";\n\t\t} else {\n\t\t\t# Generic failure message\n\t\t\tprint \"**FAILED** No value set for '$argument_name'\\n\";\n\t\t}\n\t\texit 1;\n\t}\n\n\t# Don't allow an empty value for the argument.\n\t# Especially important for 'results-root', to prevent deletion of 'old results' in '/*' \n\tif ($argument_value eq '') {\n\t\tprint \"**FAILED** Argument value cannot be empty for '$argument_name'\\n\";\n\t\texit 1;\n\t}\n\n\treturn $argument_value;\n}\n\nsub arg_info {\n\tmy $argument_name = shift;\n\n\tmy $argument_value = get_argument($argument_name);\n\tif ( defined ($argument_value)) {\n\t\tprint \"Arg '$argument_name' is defined\\n\";\n\t}\n\tif ( !defined ($argument_value)) {\n\t\tprint \"Arg '$argument_name' not defined\\n\";\n\t}\n\n\tif ($argument_value eq 'null') {\n\t\tprint \"Arg '$argument_name' NULL\\n\";\n\t}\n\tif ($argument_value ne 'null') {\n\t\tprint \"Arg '$argument_name' = '$argument_value'\\n\";\n\t}\n}\n\n",
        "start_line": 0,
        "end_line": 131,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 997,
        "node_type": null,
        "file_sha": "fc8cc03370222a9d75b4c6324f614d82bdbdb878",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.782212"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\npackage stfArguments;\n\nuse strict;\nuse warnings;\nuse FindBin qw($Bin);\nuse lib \"$Bin\";\nuse stfArguments;\n\nmy @stf_personal_properties = \"\";\nmy @stf_default_properties = \"\";\n\n# Registers property files for subsequent argument processing. \n# This subroutine must be called before 'get_argument'\nsub set_argument_data {\n\tmy $stf_personal = shift;\n\tmy $stf_default = shift;\n\n\t#print \"\\n\";\n \t#print \"stf_personal_properties: $stf_personal\\n\";\n \t#print \"stf_default_properties: $stf_default\\n\";\n\n\t# Read in the contents of the configuration files\n\t@stf_personal_properties           = read_file_contents($stf_personal);\n    @stf_default_properties            = read_file_contents($stf_default); \n}\n\n# Reads the contents of a file into an array\nsub read_file_contents\n{\n\tmy $version_file = shift;\n\topen(my $fh,'<',$version_file) or return \"\";\n\tmy @contents = <$fh>;\n\tclose($fh) or warn \"Could not close handle on version file: $version_file: $!\";\n\n\treturn @contents;\n}\n\n# Returns the value of an argument.\n# Search order is:\n#   1) command line arguments.\n#   2) User specific property for this STF test variant.\n#   3) STF default properties for this STF test variant.\n#   4) User specific STF properties\n#   5) Default STF properties\n#\nsub get_argument { \n\tmy $name = shift;\n\n\t# Find value for the named property    \n\tmy $value = do_get_argument($name);\n\n\t# Remove leading and trailing whitespace\n\t# This is needed for running from a workspace created on a Windows machine \n\t# when on a linux machine. \n\t# STF was failing because of a CR/LF problem. Without trimming the property\n\t# value unexpectedly ends with a CR.\n\t$value = stf::stfUtility->strip($value);\n\n\t# If the value contains a reference to variable ${HOME} \n\t# replace it with the resolved HOME environment variable (either $HOME or %USERPROFILE%)\n\t$value =~ s/\\$\\{HOME\\}/${ENV{'HOME'}}/;\n\n\t# If the resolved value matches '${.*}' then pull actual value from an environment variable.\n\tif ($value =~ /^\\$\\{.*\\}$/) {\n\t\tmy $env_variable_name = substr($value, 2, -1);\n\t\t$value = $ENV{$env_variable_name};\n\t}\n\n\treturn $value;\n}\n\n# Gets an argument and fails if the arguments value is null\n#\nsub get_and_check_argument {\n\tmy $argument_name = shift;\n\n\tmy $argument_value = get_argument($argument_name);\n\n\tif ( ! defined ($argument_value) || $argument_value eq 'null') {\n\t\tmy $arg_contents = do_get_argument($argument_name);\n\t\tif ($arg_contents =~ /^\\$\\{(.*)\\}$/) {\n\t\t\t# We failed attempting to find value for environment variable\n\t\t\tprint \"**FAILED** Can't resolve value for '$argument_name', as environment variable '$1' is not set\\n\";\n\t\t} else {\n\t\t\t# Generic failure message\n\t\t\tprint \"**FAILED** No value set for '$argument_name'\\n\";\n\t\t}\n\t\texit 1;\n\t}\n\n\t# Don't allow an empty value for the argument.\n\t# Especially important for 'results-root', to prevent deletion of 'old results' in '/*' \n\tif ($argument_value eq '') {\n\t\tprint \"**FAILED** Argument value cannot be empty for '$argument_name'\\n\";\n\t\texit 1;\n\t}\n\n\treturn $argument_value;\n}\n\nsub arg_info {\n\tmy $argument_name = shift;\n\n\tmy $argument_value = get_argument($argument_name);\n\tif ( defined ($argument_value)) {\n\t\tprint \"Arg '$argument_name' is defined\\n\";\n\t}\n\tif ( !defined ($argument_value)) {\n\t\tprint \"Arg '$argument_name' not defined\\n\";\n\t}\n\n\tif ($argument_value eq 'null') {\n\t\tprint \"Arg '$argument_name' NULL\\n\";\n\t}\n\tif ($argument_value ne 'null') {\n\t\tprint \"Arg '$argument_name' = '$argument_value'\\n\";\n\t}\n}\n\n"
    },
    "109": {
      "metadata": {
        "chunk_id": "e313b4cfdfac2fec35e6c562fb009a57bc68cca7d2cc85997b7492651d9fe18b",
        "file_path": "stf.core/scripts/stfArguments.pm",
        "content": "sub do_get_argument {\n\tmy $name = shift;\n\n\t# Try to find the value of the argument in the command line arguments\n\tforeach my $a(@ARGV) {\n\t\tmy $value = extract_if_match($name, $a);\n\t\tif (defined $value) {\n\t\t\treturn $value;\n\t\t}\n\t}\n\n\t# Look in the users STF configuration\n\tforeach my $a(@stf_personal_properties) {\n\t\tmy $value = extract_if_match($name, $a);\n\t\tif (defined $value) {\n\t\t\treturn $value;\n\t\t}\n\t}\n\n\t# Finally look in the default STF configuration\n\tforeach my $a(@stf_default_properties) {\n\t\tmy $value = extract_if_match($name, $a);\n\t\tif (defined $value) {\n\t\t\treturn $value;\n\t\t}\n\t}\n\n\tdie \"Failed to find value for property: '$name'\";\n}\n\nsub get_boolean_argument {\n\tmy $parameter_name = shift;\n\n\tmy $value = get_argument($parameter_name);\n\n\tif (lc $value eq 'true') {\n\t\treturn 1;\n\t} elsif (lc $value eq '') {\n\t\treturn 1;\n\t} elsif (lc $value eq 'false') {\n\t\treturn 0;\n\t}\n\n\tdie \"Failed to read boolean parameter '$parameter_name' with value '$value'\\n\" .\n\t\t\"The value must have a value of either 'true' or 'false'\";\t\n}\n\nsub extract_if_match {\n\tmy $target_name = shift;\n\tmy $arg = shift;\n\tmy $platform = stf::stfUtility->getPlatform();\n\n\t# Search for a value in the form '-name.<platform> = value'\n\tif ($arg =~ /^ *-?$target_name.$platform *=/) {\n\t\tmy ($value) = $arg =~ /= *(.*) */g;\n\t\treturn $value;\n\t}\n\n\t# Search for a value in the form '-name = value'\n\tif ($arg =~ /^ *-?$target_name *=/) {\n\t\tmy ($value) = $arg =~ /= *(.*) */g;\n\t\treturn $value;\n\t}\n\n\t# Search for a boolean flag, in the form '-name'\n\tif ($arg =~ /^ *-?$target_name *$/) {\n\t\treturn \"\";\n\t}\n\n\treturn undef;\n}\n\nsub get_home_dir {\n\t# 1. Expect $HOME to be set on Unix\n\t# 2. Use %HOME% if set on Windows, otherwise expect %USERPROFILE% to be set\n\t# 3. Otherwise set %HOME% to %USERPROFILE% on Windows (means code elsewhere in STF\n\t#    can rely on a HOME environment variable being set).\n\tif ( ! $ENV{HOME} ) {\n\t\tif ( $ENV{USERPROFILE} ) {\n\t\t\t$ENV{HOME} = $ENV{USERPROFILE};\n\t\t}\n\t}\n\treturn $ENV{HOME} if $ENV{HOME};\n\tprint \"Failed to get home directory for current user.\";\n\texit 1;\n}\n\nsub write_arguments_to_file { \n\tmy $output_file_name = shift;\n\tmy $stf_bin_dir = shift;\n\tmy $updated_test_root = shift;\n\tmy $updated_systemtest_prereqs = shift;\n\n\topen(my $fh, '>', $output_file_name) or die \"Not able to write arguments to file '$output_file_name'\";\n\n\tforeach my $a(@ARGV) {\n\t\tprint $fh \"$a\\n\\n\";\n\t}\n\n\tprint $fh \"-stf-bin-dir=$stf_bin_dir\\n\\n\";\n\n\tif (defined($updated_test_root)) {\n\t\tprint $fh \"-test-root=$updated_test_root\\n\\n\";\n\t}\n\n\tif (defined($updated_systemtest_prereqs)) {\n\tprint $fh \"-systemtest-prereqs=$updated_systemtest_prereqs\\n\\n\";\n\t}\n\n\tclose $fh;\n}\n\n1;\n\n\n",
        "start_line": 132,
        "end_line": 247,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 788,
        "node_type": null,
        "file_sha": "fc8cc03370222a9d75b4c6324f614d82bdbdb878",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.782235"
      },
      "text": "sub do_get_argument {\n\tmy $name = shift;\n\n\t# Try to find the value of the argument in the command line arguments\n\tforeach my $a(@ARGV) {\n\t\tmy $value = extract_if_match($name, $a);\n\t\tif (defined $value) {\n\t\t\treturn $value;\n\t\t}\n\t}\n\n\t# Look in the users STF configuration\n\tforeach my $a(@stf_personal_properties) {\n\t\tmy $value = extract_if_match($name, $a);\n\t\tif (defined $value) {\n\t\t\treturn $value;\n\t\t}\n\t}\n\n\t# Finally look in the default STF configuration\n\tforeach my $a(@stf_default_properties) {\n\t\tmy $value = extract_if_match($name, $a);\n\t\tif (defined $value) {\n\t\t\treturn $value;\n\t\t}\n\t}\n\n\tdie \"Failed to find value for property: '$name'\";\n}\n\nsub get_boolean_argument {\n\tmy $parameter_name = shift;\n\n\tmy $value = get_argument($parameter_name);\n\n\tif (lc $value eq 'true') {\n\t\treturn 1;\n\t} elsif (lc $value eq '') {\n\t\treturn 1;\n\t} elsif (lc $value eq 'false') {\n\t\treturn 0;\n\t}\n\n\tdie \"Failed to read boolean parameter '$parameter_name' with value '$value'\\n\" .\n\t\t\"The value must have a value of either 'true' or 'false'\";\t\n}\n\nsub extract_if_match {\n\tmy $target_name = shift;\n\tmy $arg = shift;\n\tmy $platform = stf::stfUtility->getPlatform();\n\n\t# Search for a value in the form '-name.<platform> = value'\n\tif ($arg =~ /^ *-?$target_name.$platform *=/) {\n\t\tmy ($value) = $arg =~ /= *(.*) */g;\n\t\treturn $value;\n\t}\n\n\t# Search for a value in the form '-name = value'\n\tif ($arg =~ /^ *-?$target_name *=/) {\n\t\tmy ($value) = $arg =~ /= *(.*) */g;\n\t\treturn $value;\n\t}\n\n\t# Search for a boolean flag, in the form '-name'\n\tif ($arg =~ /^ *-?$target_name *$/) {\n\t\treturn \"\";\n\t}\n\n\treturn undef;\n}\n\nsub get_home_dir {\n\t# 1. Expect $HOME to be set on Unix\n\t# 2. Use %HOME% if set on Windows, otherwise expect %USERPROFILE% to be set\n\t# 3. Otherwise set %HOME% to %USERPROFILE% on Windows (means code elsewhere in STF\n\t#    can rely on a HOME environment variable being set).\n\tif ( ! $ENV{HOME} ) {\n\t\tif ( $ENV{USERPROFILE} ) {\n\t\t\t$ENV{HOME} = $ENV{USERPROFILE};\n\t\t}\n\t}\n\treturn $ENV{HOME} if $ENV{HOME};\n\tprint \"Failed to get home directory for current user.\";\n\texit 1;\n}\n\nsub write_arguments_to_file { \n\tmy $output_file_name = shift;\n\tmy $stf_bin_dir = shift;\n\tmy $updated_test_root = shift;\n\tmy $updated_systemtest_prereqs = shift;\n\n\topen(my $fh, '>', $output_file_name) or die \"Not able to write arguments to file '$output_file_name'\";\n\n\tforeach my $a(@ARGV) {\n\t\tprint $fh \"$a\\n\\n\";\n\t}\n\n\tprint $fh \"-stf-bin-dir=$stf_bin_dir\\n\\n\";\n\n\tif (defined($updated_test_root)) {\n\t\tprint $fh \"-test-root=$updated_test_root\\n\\n\";\n\t}\n\n\tif (defined($updated_systemtest_prereqs)) {\n\tprint $fh \"-systemtest-prereqs=$updated_systemtest_prereqs\\n\\n\";\n\t}\n\n\tclose $fh;\n}\n\n1;\n\n\n"
    },
    "110": {
      "metadata": {
        "chunk_id": "1b1e32ff300ac1cb80a98afc8072e7ed47200bbce884fcea663c4cfbdc654892",
        "file_path": "stf.core/src/stf.core/log4j2.xml",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<Configuration status=\"WARN\">\n  <Appenders>\n    <Console name=\"Console\" target=\"SYSTEM_OUT\" ignoreExceptions=\"false\">\n      <PatternLayout pattern=\"%d{HH:mm:ss.SSS} - %msg%n\"/>\n    </Console>\n  </Appenders>\n  <Loggers>\n    <Root level=\"info\">\n      <AppenderRef ref=\"Console\"/>\n    </Root>\n  </Loggers>\n</Configuration>",
        "start_line": 0,
        "end_line": 27,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 214,
        "node_type": null,
        "file_sha": "a31e580dae27d536bbe4bf83d16e933f3a51af56",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.792122"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<Configuration status=\"WARN\">\n  <Appenders>\n    <Console name=\"Console\" target=\"SYSTEM_OUT\" ignoreExceptions=\"false\">\n      <PatternLayout pattern=\"%d{HH:mm:ss.SSS} - %msg%n\"/>\n    </Console>\n  </Appenders>\n  <Loggers>\n    <Root level=\"info\">\n      <AppenderRef ref=\"Console\"/>\n    </Root>\n  </Loggers>\n</Configuration>"
    },
    "111": {
      "metadata": {
        "chunk_id": "608cbf9b2ad113946b5f50668434021ab4b35953547d4ac3b7c6341cdbaf1540",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/StfConstants.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\npackage net.adoptopenjdk.stf;\n\nimport java.util.HashMap;\n\n/**\n * This class holds key STF constants.\n * \n * The aim of the file is to pull together information to prevent duplication \n * inside STF.\n */\npublic class StfConstants {\n\t// This is the name of the Eclipse project holding STF source code.\n\tpublic static String STF_PROJECT_NAME = \"stf.core\";\n\n\t// STF jar files must start with this prefix. \n\tpublic static String STF_JAR_PREFIX = \"stf\";\n\t\n\t// The name of the directory STF creates to contain test results \n\tpublic static String RESULTS_DIR = \"results\";\n\t\n\t// Project configuration can also be done through a stf classpath file. \n\t// This is used by projects which require a newer version of Java than \n\t// that supported by Eclipse.\n\tpublic static String STF_CLASSPATH_XML_FILE = \"stfclasspath.xml\";\n\t\n\t// String to be used as a prefix on all failure messages. \n\t// Using a consistent text string makes it easier to search log files for failures\n\tpublic static String FAILURE_PREFIX = \"**FAILED** \";\n\n\t// Inventory files are copied to a directory in results with this suffix\n\tpublic static String INVENTORY_DIR_SUFFIX = \"inventory\";\n\t\n\t// The following strings can be used command arguments, with the actual \n\t// value being substituted in at the time of code generation.\n\tpublic static String PLACEHOLDER_STF_COMMAND_NUMBER   = \"${{STF-COMMAND-NUMBER}}\";    // Eg, 1, 2, 3, etc\n\tpublic static String PLACEHOLDER_STF_COMMAND_MNEMONIC = \"${{STF-COMMAND-MNEMONIC}}\";  // Eg, SCL or XYZ, etc\n\tpublic static String PLACEHOLDER_STF_PROCESS_INSTANCE = \"${{STF-PROCESS-INSTANCE}}\";  // Eg, 1, 2, etc, or ''. Multiple process instance: 1,2,3,etc, or empty string for single instance. Replacement done in perl code\n\n\t//When the Stf Java creates the perl that runs a test, sometimes we want to tell it to take data related to one process and e.g. pass it to another process.\n\t//This HashMap contains a list of data you can get from the perl object representing a process at run time. Like the process id of a test you just started.\n\tpublic static Integer PERL_PROCESS_PID = 1;\n\tpublic static HashMap<Integer,String> PERL_PROCESS_DATA = new HashMap<Integer,String>();\n\tstatic {\n\t\tPERL_PROCESS_DATA.put(PERL_PROCESS_PID,\"->{pid}\");\n\t}\n}",
        "start_line": 0,
        "end_line": 58,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 664,
        "node_type": null,
        "file_sha": "2296b10074db8ece68c57ec9e8d3b2af6266ffa4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.799224"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\npackage net.adoptopenjdk.stf;\n\nimport java.util.HashMap;\n\n/**\n * This class holds key STF constants.\n * \n * The aim of the file is to pull together information to prevent duplication \n * inside STF.\n */\npublic class StfConstants {\n\t// This is the name of the Eclipse project holding STF source code.\n\tpublic static String STF_PROJECT_NAME = \"stf.core\";\n\n\t// STF jar files must start with this prefix. \n\tpublic static String STF_JAR_PREFIX = \"stf\";\n\t\n\t// The name of the directory STF creates to contain test results \n\tpublic static String RESULTS_DIR = \"results\";\n\t\n\t// Project configuration can also be done through a stf classpath file. \n\t// This is used by projects which require a newer version of Java than \n\t// that supported by Eclipse.\n\tpublic static String STF_CLASSPATH_XML_FILE = \"stfclasspath.xml\";\n\t\n\t// String to be used as a prefix on all failure messages. \n\t// Using a consistent text string makes it easier to search log files for failures\n\tpublic static String FAILURE_PREFIX = \"**FAILED** \";\n\n\t// Inventory files are copied to a directory in results with this suffix\n\tpublic static String INVENTORY_DIR_SUFFIX = \"inventory\";\n\t\n\t// The following strings can be used command arguments, with the actual \n\t// value being substituted in at the time of code generation.\n\tpublic static String PLACEHOLDER_STF_COMMAND_NUMBER   = \"${{STF-COMMAND-NUMBER}}\";    // Eg, 1, 2, 3, etc\n\tpublic static String PLACEHOLDER_STF_COMMAND_MNEMONIC = \"${{STF-COMMAND-MNEMONIC}}\";  // Eg, SCL or XYZ, etc\n\tpublic static String PLACEHOLDER_STF_PROCESS_INSTANCE = \"${{STF-PROCESS-INSTANCE}}\";  // Eg, 1, 2, etc, or ''. Multiple process instance: 1,2,3,etc, or empty string for single instance. Replacement done in perl code\n\n\t//When the Stf Java creates the perl that runs a test, sometimes we want to tell it to take data related to one process and e.g. pass it to another process.\n\t//This HashMap contains a list of data you can get from the perl object representing a process at run time. Like the process id of a test you just started.\n\tpublic static Integer PERL_PROCESS_PID = 1;\n\tpublic static HashMap<Integer,String> PERL_PROCESS_DATA = new HashMap<Integer,String>();\n\tstatic {\n\t\tPERL_PROCESS_DATA.put(PERL_PROCESS_PID,\"->{pid}\");\n\t}\n}"
    },
    "112": {
      "metadata": {
        "chunk_id": "6a8958a56699a08e2d3bbcca5633fd67187ad27da2617bdec5fe36837ef3a1e6",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/StfError.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\n/**\n * This is a subclass of StfException used to represent user level errors.\n * \n * Throwing an exception of this type results in a test run failing with an \n * error message and no stack trace.\n * So it should only be used in cases in which the user can work out what they \n * have done wrong by reading the error message.\n */\npublic class StfError extends StfException {\n\tprivate static final long serialVersionUID = -2155065137958897611L;\n\n\tpublic StfError(String message) {\n\t\tsuper(message);\n\t}\n}",
        "start_line": 0,
        "end_line": 30,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 246,
        "node_type": null,
        "file_sha": "a1baa41173034bdd045d6467dde44cecd6ee45ad",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.808077"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\n/**\n * This is a subclass of StfException used to represent user level errors.\n * \n * Throwing an exception of this type results in a test run failing with an \n * error message and no stack trace.\n * So it should only be used in cases in which the user can work out what they \n * have done wrong by reading the error message.\n */\npublic class StfError extends StfException {\n\tprivate static final long serialVersionUID = -2155065137958897611L;\n\n\tpublic StfError(String message) {\n\t\tsuper(message);\n\t}\n}"
    },
    "113": {
      "metadata": {
        "chunk_id": "3e56bf5e45f144734e3e70259fb7825ed4da7c41bcd218ad5f19b045bf519c4e",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/StfException.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\npublic class StfException extends Exception {\n\tprivate static final long serialVersionUID = 7859381674388734570L;\n\n\tpublic StfException(Exception cause) {\n\t\tsuper(cause);\n\t}\n\n\tpublic StfException(String message, Exception cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic StfException(String message) {\n\t\tsuper(message);\n\t}\n}",
        "start_line": 0,
        "end_line": 30,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 204,
        "node_type": null,
        "file_sha": "d3b1753948b8294434cf09351c569642ba171778",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.815624"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\npublic class StfException extends Exception {\n\tprivate static final long serialVersionUID = 7859381674388734570L;\n\n\tpublic StfException(Exception cause) {\n\t\tsuper(cause);\n\t}\n\n\tpublic StfException(String message, Exception cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic StfException(String message) {\n\t\tsuper(message);\n\t}\n}"
    },
    "114": {
      "metadata": {
        "chunk_id": "57b47fae65dc81447334c3ba91e0c49d5b3e07744f49ded8d3721c4e2b1e9a98",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/StfExitCodes.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n\n/**\n * This class holds a set of allowable exit codes.\n * \n * It is used by test plugins to handle special cases in which a passing process \n * may return with more than usual '0' exit code.\n */\npublic class StfExitCodes {\n\t// This holds the allowable exit codes\n\tprivate List<Integer> exitCodes;\n\n\t\n\tprivate StfExitCodes() {\n\t}\n\t\n\t\n\t/**\n\t * Create a StfExitCodes object from a var-args list of allowable exit codes.\n\t * \n\t * @param exitCodes contains 1 or more expected exit codes.\n\t * @return a StfExitCodes object containing the supplied exit codes.\n\t */\n\tpublic static StfExitCodes expected(Integer... exitCodes) {\n\t\tStfExitCodes exitCodesObj = new StfExitCodes();\n\t\texitCodesObj.exitCodes = Arrays.asList(exitCodes);\n\t\t\n\t\treturn exitCodesObj;\n\t}\n\t\n\t\n\t/**\n\t * @return an ArrayList containing the allowable exit codes.\n\t */\n\tpublic List<Integer> getAllowableExitCodes() { \n\t\treturn exitCodes;\n\t}\n\t\n\t\n\tpublic String toString() { \n\t\treturn exitCodes.toString();\n\t}\n}",
        "start_line": 0,
        "end_line": 60,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 380,
        "node_type": null,
        "file_sha": "6a6a7964416a9648ceaf6e3a4c5f3a24e793c3d1",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.824816"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n\n/**\n * This class holds a set of allowable exit codes.\n * \n * It is used by test plugins to handle special cases in which a passing process \n * may return with more than usual '0' exit code.\n */\npublic class StfExitCodes {\n\t// This holds the allowable exit codes\n\tprivate List<Integer> exitCodes;\n\n\t\n\tprivate StfExitCodes() {\n\t}\n\t\n\t\n\t/**\n\t * Create a StfExitCodes object from a var-args list of allowable exit codes.\n\t * \n\t * @param exitCodes contains 1 or more expected exit codes.\n\t * @return a StfExitCodes object containing the supplied exit codes.\n\t */\n\tpublic static StfExitCodes expected(Integer... exitCodes) {\n\t\tStfExitCodes exitCodesObj = new StfExitCodes();\n\t\texitCodesObj.exitCodes = Arrays.asList(exitCodes);\n\t\t\n\t\treturn exitCodesObj;\n\t}\n\t\n\t\n\t/**\n\t * @return an ArrayList containing the allowable exit codes.\n\t */\n\tpublic List<Integer> getAllowableExitCodes() { \n\t\treturn exitCodes;\n\t}\n\t\n\t\n\tpublic String toString() { \n\t\treturn exitCodes.toString();\n\t}\n}"
    },
    "115": {
      "metadata": {
        "chunk_id": "11b3a4908247bdbfec9b1d4a344d194d441b06609ce3eb0dc6df3e78cd24c1c2",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.codeGeneration;\n\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_COMMAND_MNEMONIC;\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_COMMAND_NUMBER;\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_PROCESS_INSTANCE;\nimport static net.adoptopenjdk.stf.StfConstants.PERL_PROCESS_DATA;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.regex.Matcher;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.extensions.Stf;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.ProcessDefinition;\nimport net.adoptopenjdk.stf.util.StringSplitter;\n\n\n/**\n * This class controls the process of adding generated perl code into the setup,\n * execute and teardown test scripts.\n * \n * It is assumed that only extension classes will be using this class, as they \n * are providing the fixtures which can be used by the test cases.\n */",
        "start_line": 0,
        "end_line": 60,
        "chunk_index": 0,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 556,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832348"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.codeGeneration;\n\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_COMMAND_MNEMONIC;\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_COMMAND_NUMBER;\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_PROCESS_INSTANCE;\nimport static net.adoptopenjdk.stf.StfConstants.PERL_PROCESS_DATA;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.regex.Matcher;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.extensions.Stf;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.ProcessDefinition;\nimport net.adoptopenjdk.stf.util.StringSplitter;\n\n\n/**\n * This class controls the process of adding generated perl code into the setup,\n * execute and teardown test scripts.\n * \n * It is assumed that only extension classes will be using this class, as they \n * are providing the fixtures which can be used by the test cases.\n */"
    },
    "116": {
      "metadata": {
        "chunk_id": "c00a631e0dee40f3e91c17447ed2ba9a10048d71775f38d84dfd937bc9bf0f5f",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "public class PerlCodeGenerator {\n    private static final Logger logger = LogManager.getLogger(PerlCodeGenerator.class.getName());\n\n    private StfEnvironmentCore environmentCore;\n\t\n\tprivate Stage stage;\n\tprivate String methodName;\n\tprivate FileRef outputFile;\n\tprivate BufferedWriter perlFile;\n\tprivate int indentationDepth;\n\n\t// Command serial number is static, so that it is not reset for each stage. \n\tprivate static int commandSerialNum = 0;\n\n\tprivate static int longestStageName;\n\n\t// Tracks the perl variables used in the current script\n\tprivate LinkedHashSet<String> declaredVariables;\n\t\n\t// Keep a 1 line summary on each generated command. To be logged at the end of code generation.\n\tprivate ArrayList<String> commandSummaryLog = new ArrayList<String>();\n\t\n\t\n\t// Results class to hold details on a command\n\tpublic static class CommandDetails {\n\t\tprivate int commandSerialNum;\n\t\tString executableName;\n\t\tString[] args;\n\t\tString argumentComment;\n\t\tHashMap<String, StfProcess> relatedProcesses = new HashMap<String, StfProcess>();\n\t\tHashMap<String, Integer> relatedProcessesData = new HashMap<String, Integer>();\n\t\t\n\t\tpublic void setRelatedProcesses(HashMap<String, StfProcess> rp, HashMap<String, Integer> rpd) {\n\t\t\trelatedProcesses = rp;\n\t\t\trelatedProcessesData = rpd;\n\t\t}\n\t\t\n\t\tpublic String getExecutableName() { return executableName; }\n\t\tpublic String[] getArgs() { return args; }\n\t\tpublic String getArgumentComment() { return argumentComment; }\n\t\tpublic HashMap<String, StfProcess> getRelatedProcesses() { return relatedProcesses; }\n\t\tpublic HashMap<String, Integer> getRelatedProcessesData() { return relatedProcessesData; }\n\t\t\n\t\tpublic String getAsSingleLineCommand() {\n\t\t\tStringBuilder singleLineCommand = new StringBuilder(executableName);\n\t\t\tfor (String arg : args) {\n\t\t\t\tsingleLineCommand.append(\" \" + arg);\n\t\t\t}\n\t\t\treturn singleLineCommand.toString(); \n\t\t}\n\t\t\n\t\tpublic int getCommandSerialNum() {\n\t\t\treturn commandSerialNum;\n\t\t}\n\t}\n\n\n\tpublic static void setStageNameLength(int longestStageName) {\n\t\tPerlCodeGenerator.longestStageName = longestStageName;\n\t}\n\n\t\n\tpublic PerlCodeGenerator(StfEnvironmentCore environmentCore, String methodName, Stage stage, FileRef outputFile) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\n\t\tthis.methodName = methodName; \n\t\tthis.stage = stage;\n\t\tthis.outputFile = outputFile;\n\t\t\n\t\tthis.declaredVariables = new LinkedHashSet<String>();\n\n\t\t// Create perl output file\n\t\tif (stage != Stage.INITIALISATION) {\n\t\t\tboolean isExistingPerlFile = outputFile.asJavaFile().exists();\n\t\t\ttry {\n\t\t\t\tFileWriter fw = new FileWriter(outputFile.asJavaFile(), true);\n\t\t\t\tperlFile = new BufferedWriter(fw);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Failed to create perl file: \" + outputFile, e);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isExistingPerlFile) {\n\t\t\t\t// Outputting a new file\n\t\t\t\toutputPerlHeaders();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tprivate void outputPerlHeaders() throws StfException {\n\t\tDirectoryRef scriptDir = environmentCore.findTestDirectory(\"stf.core/scripts\");",
        "start_line": 61,
        "end_line": 151,
        "chunk_index": 1,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 676,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832382"
      },
      "text": "public class PerlCodeGenerator {\n    private static final Logger logger = LogManager.getLogger(PerlCodeGenerator.class.getName());\n\n    private StfEnvironmentCore environmentCore;\n\t\n\tprivate Stage stage;\n\tprivate String methodName;\n\tprivate FileRef outputFile;\n\tprivate BufferedWriter perlFile;\n\tprivate int indentationDepth;\n\n\t// Command serial number is static, so that it is not reset for each stage. \n\tprivate static int commandSerialNum = 0;\n\n\tprivate static int longestStageName;\n\n\t// Tracks the perl variables used in the current script\n\tprivate LinkedHashSet<String> declaredVariables;\n\t\n\t// Keep a 1 line summary on each generated command. To be logged at the end of code generation.\n\tprivate ArrayList<String> commandSummaryLog = new ArrayList<String>();\n\t\n\t\n\t// Results class to hold details on a command\n\tpublic static class CommandDetails {\n\t\tprivate int commandSerialNum;\n\t\tString executableName;\n\t\tString[] args;\n\t\tString argumentComment;\n\t\tHashMap<String, StfProcess> relatedProcesses = new HashMap<String, StfProcess>();\n\t\tHashMap<String, Integer> relatedProcessesData = new HashMap<String, Integer>();\n\t\t\n\t\tpublic void setRelatedProcesses(HashMap<String, StfProcess> rp, HashMap<String, Integer> rpd) {\n\t\t\trelatedProcesses = rp;\n\t\t\trelatedProcessesData = rpd;\n\t\t}\n\t\t\n\t\tpublic String getExecutableName() { return executableName; }\n\t\tpublic String[] getArgs() { return args; }\n\t\tpublic String getArgumentComment() { return argumentComment; }\n\t\tpublic HashMap<String, StfProcess> getRelatedProcesses() { return relatedProcesses; }\n\t\tpublic HashMap<String, Integer> getRelatedProcessesData() { return relatedProcessesData; }\n\t\t\n\t\tpublic String getAsSingleLineCommand() {\n\t\t\tStringBuilder singleLineCommand = new StringBuilder(executableName);\n\t\t\tfor (String arg : args) {\n\t\t\t\tsingleLineCommand.append(\" \" + arg);\n\t\t\t}\n\t\t\treturn singleLineCommand.toString(); \n\t\t}\n\t\t\n\t\tpublic int getCommandSerialNum() {\n\t\t\treturn commandSerialNum;\n\t\t}\n\t}\n\n\n\tpublic static void setStageNameLength(int longestStageName) {\n\t\tPerlCodeGenerator.longestStageName = longestStageName;\n\t}\n\n\t\n\tpublic PerlCodeGenerator(StfEnvironmentCore environmentCore, String methodName, Stage stage, FileRef outputFile) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\n\t\tthis.methodName = methodName; \n\t\tthis.stage = stage;\n\t\tthis.outputFile = outputFile;\n\t\t\n\t\tthis.declaredVariables = new LinkedHashSet<String>();\n\n\t\t// Create perl output file\n\t\tif (stage != Stage.INITIALISATION) {\n\t\t\tboolean isExistingPerlFile = outputFile.asJavaFile().exists();\n\t\t\ttry {\n\t\t\t\tFileWriter fw = new FileWriter(outputFile.asJavaFile(), true);\n\t\t\t\tperlFile = new BufferedWriter(fw);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Failed to create perl file: \" + outputFile, e);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isExistingPerlFile) {\n\t\t\t\t// Outputting a new file\n\t\t\t\toutputPerlHeaders();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tprivate void outputPerlHeaders() throws StfException {\n\t\tDirectoryRef scriptDir = environmentCore.findTestDirectory(\"stf.core/scripts\");"
    },
    "117": {
      "metadata": {
        "chunk_id": "7e06dad8d6766bcf861f38d2448f56ebad1e471192a202f479e83d3a8194e2f3",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "this.methodName = methodName; \n\t\tthis.stage = stage;\n\t\tthis.outputFile = outputFile;\n\t\t\n\t\tthis.declaredVariables = new LinkedHashSet<String>();\n\n\t\t// Create perl output file\n\t\tif (stage != Stage.INITIALISATION) {\n\t\t\tboolean isExistingPerlFile = outputFile.asJavaFile().exists();\n\t\t\ttry {\n\t\t\t\tFileWriter fw = new FileWriter(outputFile.asJavaFile(), true);\n\t\t\t\tperlFile = new BufferedWriter(fw);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Failed to create perl file: \" + outputFile, e);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isExistingPerlFile) {\n\t\t\t\t// Outputting a new file\n\t\t\t\toutputPerlHeaders();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tprivate void outputPerlHeaders() throws StfException {\n\t\tDirectoryRef scriptDir = environmentCore.findTestDirectory(\"stf.core/scripts\");\n\n\t\t// Write perl header lines\n\t\toutputLine(\"#!/usr/bin/perl\");\n\t\toutputLine(\"# \");\n\t\toutputLine(\"# This script has been automatically generated by STF.\");\n\t\toutputLine(\"# Do not check-in or attempt to make permanent changes.\");\n\t\toutputLine(\"#\");\n\t\toutputLine(\"# Test:         \" + environmentCore.getProperty(Stf.ARG_TEST));\n\t\toutputLine(\"# Test-args:    \" + environmentCore.getProperty(Stf.ARG_TEST_ARGS));\n\t\toutputLine(\"# Platform:     \" + PlatformFinder.getPlatformAsString());\n\t\toutputLine(\"# Generated at: \" + new SimpleDateFormat(\"dd-MMM-yyyy HH:mm:ss.SSS\").format(new Date()));\n\t\toutputLine(\"#\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"# Turn on autoflush\");\n\t\toutputLine(\"$| = 1;\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"use warnings;\");\n\t\toutputLine(\"use strict;\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"use lib '\" + scriptDir.getSpec() + \"';\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"use FindBin qw($Bin);\");\n\t\toutputLine(\"use File::Path qw(mkpath rmtree);\");\n\t\toutputLine(\"use File::Copy qw(copy);\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"use stf::stfUtility;\");\n\t\toutputLine(\"use stf::Commands;\");",
        "start_line": 152,
        "end_line": 204,
        "chunk_index": 2,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 468,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832392"
      },
      "text": "this.methodName = methodName; \n\t\tthis.stage = stage;\n\t\tthis.outputFile = outputFile;\n\t\t\n\t\tthis.declaredVariables = new LinkedHashSet<String>();\n\n\t\t// Create perl output file\n\t\tif (stage != Stage.INITIALISATION) {\n\t\t\tboolean isExistingPerlFile = outputFile.asJavaFile().exists();\n\t\t\ttry {\n\t\t\t\tFileWriter fw = new FileWriter(outputFile.asJavaFile(), true);\n\t\t\t\tperlFile = new BufferedWriter(fw);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Failed to create perl file: \" + outputFile, e);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isExistingPerlFile) {\n\t\t\t\t// Outputting a new file\n\t\t\t\toutputPerlHeaders();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tprivate void outputPerlHeaders() throws StfException {\n\t\tDirectoryRef scriptDir = environmentCore.findTestDirectory(\"stf.core/scripts\");\n\n\t\t// Write perl header lines\n\t\toutputLine(\"#!/usr/bin/perl\");\n\t\toutputLine(\"# \");\n\t\toutputLine(\"# This script has been automatically generated by STF.\");\n\t\toutputLine(\"# Do not check-in or attempt to make permanent changes.\");\n\t\toutputLine(\"#\");\n\t\toutputLine(\"# Test:         \" + environmentCore.getProperty(Stf.ARG_TEST));\n\t\toutputLine(\"# Test-args:    \" + environmentCore.getProperty(Stf.ARG_TEST_ARGS));\n\t\toutputLine(\"# Platform:     \" + PlatformFinder.getPlatformAsString());\n\t\toutputLine(\"# Generated at: \" + new SimpleDateFormat(\"dd-MMM-yyyy HH:mm:ss.SSS\").format(new Date()));\n\t\toutputLine(\"#\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"# Turn on autoflush\");\n\t\toutputLine(\"$| = 1;\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"use warnings;\");\n\t\toutputLine(\"use strict;\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"use lib '\" + scriptDir.getSpec() + \"';\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"use FindBin qw($Bin);\");\n\t\toutputLine(\"use File::Path qw(mkpath rmtree);\");\n\t\toutputLine(\"use File::Copy qw(copy);\");\n\t\toutputEmptyLine();\n\t\toutputLine(\"use stf::stfUtility;\");\n\t\toutputLine(\"use stf::Commands;\");"
    },
    "118": {
      "metadata": {
        "chunk_id": "a3e4d98206adba7bff43741b595811a198ab823ad5e45f6fa282fb06248351ce",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "// Set the windows_sysinternals directory as an environment variable.\n\t\t// This is used in stfCommands.pm to locate windows_sysinternals.\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\tDirectoryRef sysInternalsDir = environmentCore.findPrereqDirectory(\"windows_sysinternals\");\n\t\t\toutputLine(\"$ENV{'WINDOWS_SYSINTERNALS_ROOT'} = \\\"\" + sysInternalsDir.getSpec() + \"\\\";\");\n\t\t}\n\t\toutputEmptyLine();\n\t\toutputLine(\"my $rc;\");\n\t\toutputLine(\"my $err;\");\n\t\t\n\t\t// Tell perl modules how much logging is needed\n\t\toutputEmptyLine();\n\t\tString loggingLevel = \"INFO\";\n\t\tif (environmentCore.isVerboseSet()) {\n\t\t\tloggingLevel = \"DEBUG\";  // run with '-v'\n\t\t}\n\t\tif (environmentCore.isSuperVerboseSet()) {\n\t\t\tloggingLevel = \"TRACE\";  // run with '-vv'\n\t\t}\n\t\toutputLine(\"$ENV{'loggingLevel'} = \\\"\" + loggingLevel + \"\\\";\");\n\t\t\n\t\t// If running on OMVS (the ZOS unix environment) then SYSLOG messages\n\t\t// from child processes need to be echo'ed to stderr.\n\t\t// An example would be 'dump taken for Java job xxx' messages.\n\t\tif (PlatformFinder.isZOS()) {\n\t\t\toutputEmptyLine();\n\t\t\toutputLine(\"# Make sure zos SYSLOG messages are echo'ed to standard error\");\n\t\t\toutputLine(\"$ENV{'_BPXK_JOBLOG'} = 2;\");\n\t\t}\n\t\t\n\t\t// Execution stage needs to run 'java -version'\n\t\tif (stage == Stage.EXECUTE) {\n\t\t\tString javaCommand = environmentCore.getJavaHome().childFile(\"bin/java\").getSpec();\n\t\t\tString javaVersionCommand = javaCommand + \" -version\";\n\t\t\toutputEmptyLine();\n\t\t\toutputEmptyLine();\n\t\t\toutputLine(\"# \");\n\t\t\toutputLine(\"# To help with debugging show the version of Java being used\");\n\t\t\toutputLine(\"# \");\n\t\t\toutputLine(\"info('');\");\n\t\t\toutputLine(\"info('Java version');\");\n\t\t\toutputLine(\"info('Running: \" + javaVersionCommand + \"');\");\n\t\t\toutputLine(\"system('\" + javaVersionCommand + \"');\");\n\t\t}\n\t\t\n\t\t// Make sure that any core dumps are created in the results directory\n\t\toutputEmptyLine();\n\t\toutputLine(\"# Move to the results directory, so that any created core files go there\");\n\t\toutputLine(\"chdir '\" + environmentCore.getResultsDir() + \"';\");\n\t}\n\t\n\t\n\t// Outputs perl to initialise a variable.\n\t// If the variable has not been used before then it is created. eg \n\t//   my $x = 0;\n\t//   $x = 5;\n\tprivate void outputVariableInitialisation(String variableName, String initalValue) throws StfException {\n\t\tString prefix = \"\";\n\t\tif (!declaredVariables.contains(variableName)) {\n\t\t\t// New variable, so create and add to list of known variables.\n\t\t\tprefix = \"my \";\n\t\t\tdeclaredVariables.add(variableName);\n\t\t}\n\t\t\n\t\toutputLine(prefix + variableName + \" = \" + initalValue + \";\");\n\t}\n\n\n\t// Outputs perl code to declare a variable.\n\t// If the variable has not been used before then it is created. eg \n\t//   my outfile;\n\tpublic void outputCreateVariable(String variableName) throws StfException {\n\t\tif (!declaredVariables.contains(variableName)) {\n\t\t\t// New variable, so create and add to list of known variables.\n\t\t\tdeclaredVariables.add(variableName);\n\n\t\t\toutputLine(\"my \" + variableName + \";\");\n\t\t}\n\t}\n\n\n\t/** \n\t * Generate code for the monitor_processes perl method.\n\t */\n\tpublic void monitorProcesses(ArrayList<StfProcess> processesToMonitor) throws StfException {\n\t\tStringBuilder processList = createProcessReferenceString(processesToMonitor);\n\t\t\n\t\toutputLine(\"$rc = stf::Commands->monitor_processes(\" + processList.toString() + \");\");\n\t}\n\n\n\t/**\n\t * Generate code to kill one or more processes.\n\t * @param resultAssignment is the code to generate to capture the result of the kill call.\n\t * Set to empty string if you don't want to know the result code, otherwise something like \"$rc = \".\n\t */\n\tpublic void outputKillProcesses(ArrayList<StfProcess> processesToKill, String resultAssignment) throws StfException {\n\t\tif (!processesToKill.isEmpty()) {\n\t\t\tStringBuilder processList = createProcessReferenceString(processesToKill);\n\t\t\toutputLine(resultAssignment + \"stf::Commands->kill_processes(\" + processList.toString() + \");\");\n\t\t}\n\t}",
        "start_line": 205,
        "end_line": 306,
        "chunk_index": 3,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 966,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832395"
      },
      "text": "// Set the windows_sysinternals directory as an environment variable.\n\t\t// This is used in stfCommands.pm to locate windows_sysinternals.\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\tDirectoryRef sysInternalsDir = environmentCore.findPrereqDirectory(\"windows_sysinternals\");\n\t\t\toutputLine(\"$ENV{'WINDOWS_SYSINTERNALS_ROOT'} = \\\"\" + sysInternalsDir.getSpec() + \"\\\";\");\n\t\t}\n\t\toutputEmptyLine();\n\t\toutputLine(\"my $rc;\");\n\t\toutputLine(\"my $err;\");\n\t\t\n\t\t// Tell perl modules how much logging is needed\n\t\toutputEmptyLine();\n\t\tString loggingLevel = \"INFO\";\n\t\tif (environmentCore.isVerboseSet()) {\n\t\t\tloggingLevel = \"DEBUG\";  // run with '-v'\n\t\t}\n\t\tif (environmentCore.isSuperVerboseSet()) {\n\t\t\tloggingLevel = \"TRACE\";  // run with '-vv'\n\t\t}\n\t\toutputLine(\"$ENV{'loggingLevel'} = \\\"\" + loggingLevel + \"\\\";\");\n\t\t\n\t\t// If running on OMVS (the ZOS unix environment) then SYSLOG messages\n\t\t// from child processes need to be echo'ed to stderr.\n\t\t// An example would be 'dump taken for Java job xxx' messages.\n\t\tif (PlatformFinder.isZOS()) {\n\t\t\toutputEmptyLine();\n\t\t\toutputLine(\"# Make sure zos SYSLOG messages are echo'ed to standard error\");\n\t\t\toutputLine(\"$ENV{'_BPXK_JOBLOG'} = 2;\");\n\t\t}\n\t\t\n\t\t// Execution stage needs to run 'java -version'\n\t\tif (stage == Stage.EXECUTE) {\n\t\t\tString javaCommand = environmentCore.getJavaHome().childFile(\"bin/java\").getSpec();\n\t\t\tString javaVersionCommand = javaCommand + \" -version\";\n\t\t\toutputEmptyLine();\n\t\t\toutputEmptyLine();\n\t\t\toutputLine(\"# \");\n\t\t\toutputLine(\"# To help with debugging show the version of Java being used\");\n\t\t\toutputLine(\"# \");\n\t\t\toutputLine(\"info('');\");\n\t\t\toutputLine(\"info('Java version');\");\n\t\t\toutputLine(\"info('Running: \" + javaVersionCommand + \"');\");\n\t\t\toutputLine(\"system('\" + javaVersionCommand + \"');\");\n\t\t}\n\t\t\n\t\t// Make sure that any core dumps are created in the results directory\n\t\toutputEmptyLine();\n\t\toutputLine(\"# Move to the results directory, so that any created core files go there\");\n\t\toutputLine(\"chdir '\" + environmentCore.getResultsDir() + \"';\");\n\t}\n\t\n\t\n\t// Outputs perl to initialise a variable.\n\t// If the variable has not been used before then it is created. eg \n\t//   my $x = 0;\n\t//   $x = 5;\n\tprivate void outputVariableInitialisation(String variableName, String initalValue) throws StfException {\n\t\tString prefix = \"\";\n\t\tif (!declaredVariables.contains(variableName)) {\n\t\t\t// New variable, so create and add to list of known variables.\n\t\t\tprefix = \"my \";\n\t\t\tdeclaredVariables.add(variableName);\n\t\t}\n\t\t\n\t\toutputLine(prefix + variableName + \" = \" + initalValue + \";\");\n\t}\n\n\n\t// Outputs perl code to declare a variable.\n\t// If the variable has not been used before then it is created. eg \n\t//   my outfile;\n\tpublic void outputCreateVariable(String variableName) throws StfException {\n\t\tif (!declaredVariables.contains(variableName)) {\n\t\t\t// New variable, so create and add to list of known variables.\n\t\t\tdeclaredVariables.add(variableName);\n\n\t\t\toutputLine(\"my \" + variableName + \";\");\n\t\t}\n\t}\n\n\n\t/** \n\t * Generate code for the monitor_processes perl method.\n\t */\n\tpublic void monitorProcesses(ArrayList<StfProcess> processesToMonitor) throws StfException {\n\t\tStringBuilder processList = createProcessReferenceString(processesToMonitor);\n\t\t\n\t\toutputLine(\"$rc = stf::Commands->monitor_processes(\" + processList.toString() + \");\");\n\t}\n\n\n\t/**\n\t * Generate code to kill one or more processes.\n\t * @param resultAssignment is the code to generate to capture the result of the kill call.\n\t * Set to empty string if you don't want to know the result code, otherwise something like \"$rc = \".\n\t */\n\tpublic void outputKillProcesses(ArrayList<StfProcess> processesToKill, String resultAssignment) throws StfException {\n\t\tif (!processesToKill.isEmpty()) {\n\t\t\tStringBuilder processList = createProcessReferenceString(processesToKill);\n\t\t\toutputLine(resultAssignment + \"stf::Commands->kill_processes(\" + processList.toString() + \");\");\n\t\t}\n\t}"
    },
    "119": {
      "metadata": {
        "chunk_id": "332816b6161358be3409fbfd7591e4017021b56faa95f30eb1d2b1eb5305d0ec",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "/**\n\t * Generate code to kill one or more processes.\n\t * @param resultAssignment is the code to generate to capture the result of the kill call.\n\t * Set to empty string if you don't want to know the result code, otherwise something like \"$rc = \".\n\t */\n\tpublic void outputKillProcesses(ArrayList<StfProcess> processesToKill, String resultAssignment) throws StfException {\n\t\tif (!processesToKill.isEmpty()) {\n\t\t\tStringBuilder processList = createProcessReferenceString(processesToKill);\n\t\t\toutputLine(resultAssignment + \"stf::Commands->kill_processes(\" + processList.toString() + \");\");\n\t\t}\n\t}\n\n\t\n\t// Create a comma separated list of perl variable names for the supplied process details\n\t// Eg, returns a string such as '$process_3SRV, %process_4CLS'\n\tprivate StringBuilder createProcessReferenceString(ArrayList<StfProcess> processes) {\n\t\tHashSet<String> processedVariables = new HashSet<String>();\n\t\tStringBuilder processList = new StringBuilder();",
        "start_line": 307,
        "end_line": 324,
        "chunk_index": 4,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 209,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832397"
      },
      "text": "/**\n\t * Generate code to kill one or more processes.\n\t * @param resultAssignment is the code to generate to capture the result of the kill call.\n\t * Set to empty string if you don't want to know the result code, otherwise something like \"$rc = \".\n\t */\n\tpublic void outputKillProcesses(ArrayList<StfProcess> processesToKill, String resultAssignment) throws StfException {\n\t\tif (!processesToKill.isEmpty()) {\n\t\t\tStringBuilder processList = createProcessReferenceString(processesToKill);\n\t\t\toutputLine(resultAssignment + \"stf::Commands->kill_processes(\" + processList.toString() + \");\");\n\t\t}\n\t}\n\n\t\n\t// Create a comma separated list of perl variable names for the supplied process details\n\t// Eg, returns a string such as '$process_3SRV, %process_4CLS'\n\tprivate StringBuilder createProcessReferenceString(ArrayList<StfProcess> processes) {\n\t\tHashSet<String> processedVariables = new HashSet<String>();\n\t\tStringBuilder processList = new StringBuilder();"
    },
    "120": {
      "metadata": {
        "chunk_id": "4b343e8231516d8e0802c8c652a09189f309b3d5421ead52fbeb0ebebf9f50b0",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "for (StfProcess process : processes) { \n\t\t\t// Don't allow the variable onto the list more than once\n\t\t\tString perlProcessVariable = process.getPerlProcessVariable();\n\t\t\tif (processedVariables.contains(perlProcessVariable)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprocessedVariables.add(perlProcessVariable);\n\t\t\t\n\t\t\tif (processList.length() > 0) {\n\t\t\t\tprocessList.append(\", \");\n\t\t\t}\n\t\t\tprocessList.append(perlProcessVariable);\n\t\t}\n\t\treturn processList;\n\t}\n\t\t\n\t\n\t/**\n\t * This method generates the perl code needed to run a process.\n\t * It is used for both synchronous and asynchronous methods, as the arguments used \n\t * are virtually the same.\n\t * @param comment is a high level summary of why this process is being run\n\t * @param argumentComment is a further comment about the arguments. Mostly used to expose the seed for -mode=random\n\t * @param mnemonic is a 3 letter abbreviation of the process. The mnemonic is prefixed \n\t * to every line of output when echoed by STF. \n\t * @param numInstances is the number of process instances to start with the same configuration.\n\t * @param echoSetting turns on/off child process echoing.\n\t * @param perlMethod is the name of the perl method to invoke.\n\t * @param expectedOutcome describes the automations expectation of process completion.\n\t * @param command represents the command contains the arguments.\n\t * @return an array list of StfProcess objects to represent the running processes.\n\t * @throws StfException\n\t */\n\tpublic StfProcess[] generateRunProcess2(String comment, String argumentComment, String mnemonic, int numInstances, Echo echoSetting, String perlMethod, ExpectedOutcome expectedOutcome, CommandDetails command) throws StfException {\n\t\t// Make sure that the automation has set a maximum run time (it's easy to miss)\n\t\tif (expectedOutcome.getDurationLimit() == null) {\n\t\t\tthrow new StfException(\"Maximum run time not set for process \" + mnemonic + \" ('\" + comment + \"').\"\n\t\t\t\t\t+ \" The ExpectedOutcome object needs a call to the within() method\");\n\t\t}\n\t\t\n\t\t// Output the command and its arguments.\n\t\t// Depending on the length and content of the command 1 of 3 different formatting options is used.\n\t\tString asSingleLineCommand = command.getAsSingleLineCommand();\n\t\tString commandString;\n\t\tString argsVariableName = null;\n\t\tif (needArrayBasedArgs(command)) {\n\t\t\t// Arguments contain special characters. Output command in array based format.\n\t\t\t// Write out a comment with the single line version of this command. \n\t\t\t// This allows somebody to cut+paste the whole line to manually run the same command.\n\t\t\tString pastableCommand = asSingleLineCommand.replace(PLACEHOLDER_STF_PROCESS_INSTANCE, \"\");\n\t\t\toutputLine(\"# Cut+paste version of the command: \" + replaceKeysWithValues(pastableCommand,\"\",command));\n\t\t\toutputEmptyLine();\n\t\n\t\t\t// Build up an array to hold all arguments for the command\n\t\t\targsVariableName = \"args\" + commandSerialNum;\n\t\t\toutputLine(\"my @\" + argsVariableName + \" = [\");\n\t\t\tfor (String arg : command.args) { \n\t\t\t\toutputLine(\"    '\" + replaceKeysWithValues(arg,\"'\",command) + \"',\");\n\t\t\t}\n\t\t\toutputLine(\"];\");\t\t\n\t\t\tcommandString = \"'\" + replaceKeysWithValues(command.executableName,\"'\",command) + \"'\";\n\t\t} else if (command.getAsSingleLineCommand().length() < 120) {\n\t\t\t// Short commands can fit onto a single line\n\t\t\tcommandString = \"'\" + replaceKeysWithValues(asSingleLineCommand,\"'\",command) + \"'\";\t\t\t\n\t\t} else {\n\t\t\t// Longer multiline command.\n\t\t\t// Write out a comment with the single line version of this command. \n\t\t\t// This allows somebody to cut+paste the whole line to manually run the same command.\n\t\t\tString pastableCommand = asSingleLineCommand.replace(PLACEHOLDER_STF_PROCESS_INSTANCE, \"\");\n\t\t\toutputLine(\"# Cut+paste version of the command: \" + replaceKeysWithValues(pastableCommand,\"\",command));\n\t\t\toutputEmptyLine();\n\t\n\t\t\t// Build a neatly formatted command string from all of the arguments\n\t\t\tStringBuilder commandStr = new StringBuilder();\n\t\t\tcommandStr.append(\"'\" + command.executableName);",
        "start_line": 325,
        "end_line": 399,
        "chunk_index": 5,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 919,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832400"
      },
      "text": "for (StfProcess process : processes) { \n\t\t\t// Don't allow the variable onto the list more than once\n\t\t\tString perlProcessVariable = process.getPerlProcessVariable();\n\t\t\tif (processedVariables.contains(perlProcessVariable)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprocessedVariables.add(perlProcessVariable);\n\t\t\t\n\t\t\tif (processList.length() > 0) {\n\t\t\t\tprocessList.append(\", \");\n\t\t\t}\n\t\t\tprocessList.append(perlProcessVariable);\n\t\t}\n\t\treturn processList;\n\t}\n\t\t\n\t\n\t/**\n\t * This method generates the perl code needed to run a process.\n\t * It is used for both synchronous and asynchronous methods, as the arguments used \n\t * are virtually the same.\n\t * @param comment is a high level summary of why this process is being run\n\t * @param argumentComment is a further comment about the arguments. Mostly used to expose the seed for -mode=random\n\t * @param mnemonic is a 3 letter abbreviation of the process. The mnemonic is prefixed \n\t * to every line of output when echoed by STF. \n\t * @param numInstances is the number of process instances to start with the same configuration.\n\t * @param echoSetting turns on/off child process echoing.\n\t * @param perlMethod is the name of the perl method to invoke.\n\t * @param expectedOutcome describes the automations expectation of process completion.\n\t * @param command represents the command contains the arguments.\n\t * @return an array list of StfProcess objects to represent the running processes.\n\t * @throws StfException\n\t */\n\tpublic StfProcess[] generateRunProcess2(String comment, String argumentComment, String mnemonic, int numInstances, Echo echoSetting, String perlMethod, ExpectedOutcome expectedOutcome, CommandDetails command) throws StfException {\n\t\t// Make sure that the automation has set a maximum run time (it's easy to miss)\n\t\tif (expectedOutcome.getDurationLimit() == null) {\n\t\t\tthrow new StfException(\"Maximum run time not set for process \" + mnemonic + \" ('\" + comment + \"').\"\n\t\t\t\t\t+ \" The ExpectedOutcome object needs a call to the within() method\");\n\t\t}\n\t\t\n\t\t// Output the command and its arguments.\n\t\t// Depending on the length and content of the command 1 of 3 different formatting options is used.\n\t\tString asSingleLineCommand = command.getAsSingleLineCommand();\n\t\tString commandString;\n\t\tString argsVariableName = null;\n\t\tif (needArrayBasedArgs(command)) {\n\t\t\t// Arguments contain special characters. Output command in array based format.\n\t\t\t// Write out a comment with the single line version of this command. \n\t\t\t// This allows somebody to cut+paste the whole line to manually run the same command.\n\t\t\tString pastableCommand = asSingleLineCommand.replace(PLACEHOLDER_STF_PROCESS_INSTANCE, \"\");\n\t\t\toutputLine(\"# Cut+paste version of the command: \" + replaceKeysWithValues(pastableCommand,\"\",command));\n\t\t\toutputEmptyLine();\n\t\n\t\t\t// Build up an array to hold all arguments for the command\n\t\t\targsVariableName = \"args\" + commandSerialNum;\n\t\t\toutputLine(\"my @\" + argsVariableName + \" = [\");\n\t\t\tfor (String arg : command.args) { \n\t\t\t\toutputLine(\"    '\" + replaceKeysWithValues(arg,\"'\",command) + \"',\");\n\t\t\t}\n\t\t\toutputLine(\"];\");\t\t\n\t\t\tcommandString = \"'\" + replaceKeysWithValues(command.executableName,\"'\",command) + \"'\";\n\t\t} else if (command.getAsSingleLineCommand().length() < 120) {\n\t\t\t// Short commands can fit onto a single line\n\t\t\tcommandString = \"'\" + replaceKeysWithValues(asSingleLineCommand,\"'\",command) + \"'\";\t\t\t\n\t\t} else {\n\t\t\t// Longer multiline command.\n\t\t\t// Write out a comment with the single line version of this command. \n\t\t\t// This allows somebody to cut+paste the whole line to manually run the same command.\n\t\t\tString pastableCommand = asSingleLineCommand.replace(PLACEHOLDER_STF_PROCESS_INSTANCE, \"\");\n\t\t\toutputLine(\"# Cut+paste version of the command: \" + replaceKeysWithValues(pastableCommand,\"\",command));\n\t\t\toutputEmptyLine();\n\t\n\t\t\t// Build a neatly formatted command string from all of the arguments\n\t\t\tStringBuilder commandStr = new StringBuilder();\n\t\t\tcommandStr.append(\"'\" + command.executableName);"
    },
    "121": {
      "metadata": {
        "chunk_id": "1ad96f4914c2594d0706d9abdb9d35f7fbb585a2ccd5dd854e8cf8244341eda5",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "// Short commands can fit onto a single line\n\t\t\tcommandString = \"'\" + replaceKeysWithValues(asSingleLineCommand,\"'\",command) + \"'\";\t\t\t\n\t\t} else {\n\t\t\t// Longer multiline command.\n\t\t\t// Write out a comment with the single line version of this command. \n\t\t\t// This allows somebody to cut+paste the whole line to manually run the same command.\n\t\t\tString pastableCommand = asSingleLineCommand.replace(PLACEHOLDER_STF_PROCESS_INSTANCE, \"\");\n\t\t\toutputLine(\"# Cut+paste version of the command: \" + replaceKeysWithValues(pastableCommand,\"\",command));\n\t\t\toutputEmptyLine();\n\t\n\t\t\t// Build a neatly formatted command string from all of the arguments\n\t\t\tStringBuilder commandStr = new StringBuilder();\n\t\t\tcommandStr.append(\"'\" + command.executableName);\n\t\t\t\n\t\t\t// Write out the command and its arguments. \n\t\t\t// Combine an argument and value onto the same line if possible. \n\t\t\t// eg, generate '-timeLimit 8m20s ' on 1 line instead of taking 2 lines. \n\t\t\tboolean lastArgStartsHypen = false;\n\t\t\tfor (int i=0; i<command.args.length; i++) {\n\t\t\t\tString arg = command.args[i].trim();\n\t\t\t\t\n\t\t\t\t// Output white space, and possible open quote, in preparation for the argument value  \n\t\t\t\tboolean thisArgStartsHypen = arg.startsWith(\"-\") && !arg.startsWith(\"-1\");  // Don't put the common numeric '-1' on its own line\n\t\t\t\tif (lastArgStartsHypen && !thisArgStartsHypen) {\n\t\t\t\t\t// The current argument is going on the same line\n\t\t\t\t\tcommandStr.append(\" \");\n\t\t\t\t} else {\n\t\t\t\t\t// Force a newline\n\t\t\t\t\tcommandStr.append(\" ' .\\n    '\");\n\t\t\t\t}\n\t\t\t\tlastArgStartsHypen = thisArgStartsHypen;\n\t\t\t\t\n\t\t\t\t// Finally write out the argument value\n\t\t\t\tcommandStr.append(arg);\n\t\t\t}\n\t\t\tcommandStr.append(\" '\"); // close the final argument\n\t\t\tcommandString = replaceKeysWithValues(commandStr.toString(),\"'\",command);\n\t\t}\n\t\t\n\t\t// Declare the command to be executed\n\t\tString commandVariable = \"$command\" + PerlCodeGenerator.commandSerialNum;\n\t\tString commandComment = \"# The command to run\";\n\t\tif (argumentComment != null && !argumentComment.isEmpty()) {\n\t\t\tcommandComment = commandComment + argumentComment;\n\t\t}\n\t\toutputLine(commandComment);\n\t\toutputLine(\"my \" + commandVariable + \" = \" + commandString + \";\");\n\t\toutputEmptyLine();",
        "start_line": 400,
        "end_line": 447,
        "chunk_index": 6,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 549,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832402"
      },
      "text": "// Short commands can fit onto a single line\n\t\t\tcommandString = \"'\" + replaceKeysWithValues(asSingleLineCommand,\"'\",command) + \"'\";\t\t\t\n\t\t} else {\n\t\t\t// Longer multiline command.\n\t\t\t// Write out a comment with the single line version of this command. \n\t\t\t// This allows somebody to cut+paste the whole line to manually run the same command.\n\t\t\tString pastableCommand = asSingleLineCommand.replace(PLACEHOLDER_STF_PROCESS_INSTANCE, \"\");\n\t\t\toutputLine(\"# Cut+paste version of the command: \" + replaceKeysWithValues(pastableCommand,\"\",command));\n\t\t\toutputEmptyLine();\n\t\n\t\t\t// Build a neatly formatted command string from all of the arguments\n\t\t\tStringBuilder commandStr = new StringBuilder();\n\t\t\tcommandStr.append(\"'\" + command.executableName);\n\t\t\t\n\t\t\t// Write out the command and its arguments. \n\t\t\t// Combine an argument and value onto the same line if possible. \n\t\t\t// eg, generate '-timeLimit 8m20s ' on 1 line instead of taking 2 lines. \n\t\t\tboolean lastArgStartsHypen = false;\n\t\t\tfor (int i=0; i<command.args.length; i++) {\n\t\t\t\tString arg = command.args[i].trim();\n\t\t\t\t\n\t\t\t\t// Output white space, and possible open quote, in preparation for the argument value  \n\t\t\t\tboolean thisArgStartsHypen = arg.startsWith(\"-\") && !arg.startsWith(\"-1\");  // Don't put the common numeric '-1' on its own line\n\t\t\t\tif (lastArgStartsHypen && !thisArgStartsHypen) {\n\t\t\t\t\t// The current argument is going on the same line\n\t\t\t\t\tcommandStr.append(\" \");\n\t\t\t\t} else {\n\t\t\t\t\t// Force a newline\n\t\t\t\t\tcommandStr.append(\" ' .\\n    '\");\n\t\t\t\t}\n\t\t\t\tlastArgStartsHypen = thisArgStartsHypen;\n\t\t\t\t\n\t\t\t\t// Finally write out the argument value\n\t\t\t\tcommandStr.append(arg);\n\t\t\t}\n\t\t\tcommandStr.append(\" '\"); // close the final argument\n\t\t\tcommandString = replaceKeysWithValues(commandStr.toString(),\"'\",command);\n\t\t}\n\t\t\n\t\t// Declare the command to be executed\n\t\tString commandVariable = \"$command\" + PerlCodeGenerator.commandSerialNum;\n\t\tString commandComment = \"# The command to run\";\n\t\tif (argumentComment != null && !argumentComment.isEmpty()) {\n\t\t\tcommandComment = commandComment + argumentComment;\n\t\t}\n\t\toutputLine(commandComment);\n\t\toutputLine(\"my \" + commandVariable + \" = \" + commandString + \";\");\n\t\toutputEmptyLine();"
    },
    "122": {
      "metadata": {
        "chunk_id": "5e55ced7793572e9c2b9058675f6315f5af4ec324ba782f0ea5880fa3749b7b9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "// Create stdout/sdterr File references, for later access through the StfProcess object\n\t\tDirectoryRef resultsDir = environmentCore.getResultsDir();\n\t\tString commandName = commandSerialNum + \".\" + mnemonic;\n\t\tFileRef stdout = resultsDir.childFile(commandName + \".stdout\");\n\t\tFileRef stderr = resultsDir.childFile(commandName + \".stderr\");\n\t\t\n\t\tString processVariable = null;  // holds the name of the perl process reference\n\t\tString resultsValue = null;\n\t\tString argStart = \"{\";\n\t\tString argEnd   = \"}\";\n\t\tif (perlMethod.equals(\"start_process\") || perlMethod.equals(\"run_process\")) {\n\t\t\t// Command will look like: ($rc, $process_2SER) = stf::Commands->start_process({ ...\n\t\t\targStart = \"\";\n\t\t\targEnd   = \"\";\n\t\t\tprocessVariable = \"$\" + \"process_\" + commandSerialNum + mnemonic;\n\t\t\tresultsValue = \"($rc, \" + processVariable + \")\";\n\t\t\toutputLine(\"my \" + processVariable + \";\");\n\t\t} else if (perlMethod.equals(\"start_processes\") || perlMethod.equals(\"run_processes\")) {\n\t\t\t// Command will look like: ($rc, %process_3CLI) = stf::Commands->start_processes({ ...\n\t\t\tprocessVariable = \"%\" + \"process_\" + commandSerialNum + mnemonic;\n\t\t\tresultsValue = \"($rc, \" + processVariable + \")\";\n\t\t\toutputLine(\"my \" + processVariable + \";\");\n\t\t} else {\n\t\t\tthrow new StfException(\"Internal Error: method unknown: \" + perlMethod);\n\t\t}\n\t\t\n\t\t// Run the command\n\t\toutputLine(\"# Execute the \" + mnemonic + \" command, and wait for it to finish\");\n\t\toutputLine(resultsValue + \" = stf::Commands->\" + perlMethod + \"(\" + argStart);\n\t    outputLine(\"    mnemonic  => '\" + mnemonic + \"',\");\n\t    outputLine(\"    command   => \" + commandVariable + \",\");\n\t    if (argsVariableName != null) {\n\t    \toutputLine(\"    args      => @\" + argsVariableName + \",\");\n\t    }\n\t    if (numInstances > 1) {\n\t    \toutputLine(\"    instances => '\" + numInstances + \"',\");\n\t    }\n\t    outputLine(\"    logName   => '\" + resultsDir.childFile(commandName) + \"',\");\n\t    outputLine(\"    echo      => '\" + (echoSetting == ECHO_ON ? \"1\" : \"0\") + \"',\");\n\t    outputLine(\"    runtime   => '\" + expectedOutcome.getDurationLimit().getSeconds() + \"',\");\n\t    outputLine(\"    expectedOutcome => '\" + generateExpectedOutcomeValue(expectedOutcome) + \"'\" + argEnd + \");\");\n\t    \n\t    // Create StfProcess objects to represent each process that will be started\n\t    StfProcess processes[] = new StfProcess[numInstances];\n\t    for (int i=0; i<numInstances; i++) {\n\t    \t// Work out the mnemonic perl will use for the current instance, eg CL1, CL2, CL3, etc\n\t    \tString currentMnemonic;\n\t    \tif (numInstances == 1) {\n\t    \t\tcurrentMnemonic = mnemonic;\n\t    \t} else {\n\t    \t\tcurrentMnemonic = mnemonic + (i+1); \n\t    \t}\n\t    \tprocesses[i] = new StfProcess(currentMnemonic, processVariable, expectedOutcome, stderr, stdout);\n\t    }\n\t    \n\t    return processes;\n\t}\n\t/**\n\t * This method takes a String, finds any references to Perl processes inside that string, and \n\t * substitutes those references with the relevant Perl code.\n\t * \n\t * E.g. The CommandDetails.relatedProcesses object could tell us that \"substitute_this_string\" \n\t * is linked to process1, and CommandDetails.relatedProcessesData could tell us that \n\t * \"substitute_this_string\" is linked to PERL_PROCESS_DATA's index for the perl code \"->{pid}\".\n\t * \n\t * So \"'java TestClass substitute_this_string debug'\" becomes \"'java RunThis ' + $process1->{pid} + ' debug'\"\n\t * \n\t * This allows us to get data about another process at runtime, and use it (e.g.) as an argument to a second process.\n\t * \n\t * @param inputString         The string which may contain perl variable references.\n\t * @param delimiter           If the inputString is surrounded by (e.g.) single quotes, we need to know what symbol \n\t *                            we're escaping and resuming after replacing the substitute string with perl code.\n\t *                            Leave blank to escape nothing.\n\t * @param CommandDetails      The object that tells us what substitution strings to replace with what perl code.",
        "start_line": 448,
        "end_line": 521,
        "chunk_index": 7,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 972,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832404"
      },
      "text": "// Create stdout/sdterr File references, for later access through the StfProcess object\n\t\tDirectoryRef resultsDir = environmentCore.getResultsDir();\n\t\tString commandName = commandSerialNum + \".\" + mnemonic;\n\t\tFileRef stdout = resultsDir.childFile(commandName + \".stdout\");\n\t\tFileRef stderr = resultsDir.childFile(commandName + \".stderr\");\n\t\t\n\t\tString processVariable = null;  // holds the name of the perl process reference\n\t\tString resultsValue = null;\n\t\tString argStart = \"{\";\n\t\tString argEnd   = \"}\";\n\t\tif (perlMethod.equals(\"start_process\") || perlMethod.equals(\"run_process\")) {\n\t\t\t// Command will look like: ($rc, $process_2SER) = stf::Commands->start_process({ ...\n\t\t\targStart = \"\";\n\t\t\targEnd   = \"\";\n\t\t\tprocessVariable = \"$\" + \"process_\" + commandSerialNum + mnemonic;\n\t\t\tresultsValue = \"($rc, \" + processVariable + \")\";\n\t\t\toutputLine(\"my \" + processVariable + \";\");\n\t\t} else if (perlMethod.equals(\"start_processes\") || perlMethod.equals(\"run_processes\")) {\n\t\t\t// Command will look like: ($rc, %process_3CLI) = stf::Commands->start_processes({ ...\n\t\t\tprocessVariable = \"%\" + \"process_\" + commandSerialNum + mnemonic;\n\t\t\tresultsValue = \"($rc, \" + processVariable + \")\";\n\t\t\toutputLine(\"my \" + processVariable + \";\");\n\t\t} else {\n\t\t\tthrow new StfException(\"Internal Error: method unknown: \" + perlMethod);\n\t\t}\n\t\t\n\t\t// Run the command\n\t\toutputLine(\"# Execute the \" + mnemonic + \" command, and wait for it to finish\");\n\t\toutputLine(resultsValue + \" = stf::Commands->\" + perlMethod + \"(\" + argStart);\n\t    outputLine(\"    mnemonic  => '\" + mnemonic + \"',\");\n\t    outputLine(\"    command   => \" + commandVariable + \",\");\n\t    if (argsVariableName != null) {\n\t    \toutputLine(\"    args      => @\" + argsVariableName + \",\");\n\t    }\n\t    if (numInstances > 1) {\n\t    \toutputLine(\"    instances => '\" + numInstances + \"',\");\n\t    }\n\t    outputLine(\"    logName   => '\" + resultsDir.childFile(commandName) + \"',\");\n\t    outputLine(\"    echo      => '\" + (echoSetting == ECHO_ON ? \"1\" : \"0\") + \"',\");\n\t    outputLine(\"    runtime   => '\" + expectedOutcome.getDurationLimit().getSeconds() + \"',\");\n\t    outputLine(\"    expectedOutcome => '\" + generateExpectedOutcomeValue(expectedOutcome) + \"'\" + argEnd + \");\");\n\t    \n\t    // Create StfProcess objects to represent each process that will be started\n\t    StfProcess processes[] = new StfProcess[numInstances];\n\t    for (int i=0; i<numInstances; i++) {\n\t    \t// Work out the mnemonic perl will use for the current instance, eg CL1, CL2, CL3, etc\n\t    \tString currentMnemonic;\n\t    \tif (numInstances == 1) {\n\t    \t\tcurrentMnemonic = mnemonic;\n\t    \t} else {\n\t    \t\tcurrentMnemonic = mnemonic + (i+1); \n\t    \t}\n\t    \tprocesses[i] = new StfProcess(currentMnemonic, processVariable, expectedOutcome, stderr, stdout);\n\t    }\n\t    \n\t    return processes;\n\t}\n\t/**\n\t * This method takes a String, finds any references to Perl processes inside that string, and \n\t * substitutes those references with the relevant Perl code.\n\t * \n\t * E.g. The CommandDetails.relatedProcesses object could tell us that \"substitute_this_string\" \n\t * is linked to process1, and CommandDetails.relatedProcessesData could tell us that \n\t * \"substitute_this_string\" is linked to PERL_PROCESS_DATA's index for the perl code \"->{pid}\".\n\t * \n\t * So \"'java TestClass substitute_this_string debug'\" becomes \"'java RunThis ' + $process1->{pid} + ' debug'\"\n\t * \n\t * This allows us to get data about another process at runtime, and use it (e.g.) as an argument to a second process.\n\t * \n\t * @param inputString         The string which may contain perl variable references.\n\t * @param delimiter           If the inputString is surrounded by (e.g.) single quotes, we need to know what symbol \n\t *                            we're escaping and resuming after replacing the substitute string with perl code.\n\t *                            Leave blank to escape nothing.\n\t * @param CommandDetails      The object that tells us what substitution strings to replace with what perl code."
    },
    "123": {
      "metadata": {
        "chunk_id": "2f2aa5607ce1d9510b193d12987adc451073b39c1241dd4c5e9f5c618e89b2b4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "* \n\t * So \"'java TestClass substitute_this_string debug'\" becomes \"'java RunThis ' + $process1->{pid} + ' debug'\"\n\t * \n\t * This allows us to get data about another process at runtime, and use it (e.g.) as an argument to a second process.\n\t * \n\t * @param inputString         The string which may contain perl variable references.\n\t * @param delimiter           If the inputString is surrounded by (e.g.) single quotes, we need to know what symbol \n\t *                            we're escaping and resuming after replacing the substitute string with perl code.\n\t *                            Leave blank to escape nothing.\n\t * @param CommandDetails      The object that tells us what substitution strings to replace with what perl code.\n\t * @return String             The processed String, where each process reference is replaced with Perl code\n\t */\n\tprivate String replaceKeysWithValues(String inputString, String delimiter, CommandDetails data) {\n\t\tString outputString = inputString;\n\t\t//Now we replace instances of any substitution string with a data request from the associated process.\n\t\tfor(Map.Entry<String, StfProcess> processPair : data.getRelatedProcesses().entrySet()) {\n\t\t\tif(outputString.contains(processPair.getKey())) {\n\t\t\t\t//The next three lines turn our StfProcess object into the Perl variable name.\n\t\t\t\tArrayList<StfProcess> tempArray = new ArrayList<StfProcess>();\n\t\t\t\ttempArray.add(processPair.getValue());\n\t\t\t\tStringBuilder processVariable = createProcessReferenceString(tempArray);\n\t\t\t\t//This next line should result in a variable name in perl, followed by the suffix in the PERL_PROCESS_DATA HashMap \n\t\t\t\t//that corresponds to the value associated with the key linked to this data request.\n\t\t\t\tString dataRetrievalPerl = processVariable.toString().substring(1) + PERL_PROCESS_DATA.get(data.getRelatedProcessesData().get(processPair.getKey()));\n\t\t\t\tif(delimiter.isEmpty()) {\n\t\t\t\t\toutputString = outputString.replaceAll(processPair.getKey(), Matcher.quoteReplacement(\"$\") + dataRetrievalPerl);\n\t\t\t\t} else {\n\t\t\t\t\toutputString = outputString.replaceAll(processPair.getKey(), delimiter + \" . \" + Matcher.quoteReplacement(\"$\") + dataRetrievalPerl + \" . \" + delimiter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn outputString;\n\t}\n\t\n\t\n\t/*\n\t * Generates the perl value for an expected outcome argument.\n\t * Essential translates between the contents of the ExpectedOutcome object and \n\t * its equivalent representation in perl code.\n\t */\n\tprivate String generateExpectedOutcomeValue(ExpectedOutcome expectedOutcome) {\n\t\tswitch (expectedOutcome.getExpectedOutcome()) {\n\t\t\tcase CLEAN_RUN:     return \"exitValue:0\";\n\t\t\tcase NON_ZERO_EXIT: return \"exitValue:\" + expectedOutcome.getExpectedExitValue();\n\t\t\tcase NEVER:         return \"never\";\n\t\t\tcase CRASHES:       return \"crashes\";\n\t\t}\n\t\t\n\t\tthrow new IllegalStateException(\"Internal Error. Missing outcome state\");\n\t}",
        "start_line": 522,
        "end_line": 571,
        "chunk_index": 8,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 611,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832407"
      },
      "text": "* \n\t * So \"'java TestClass substitute_this_string debug'\" becomes \"'java RunThis ' + $process1->{pid} + ' debug'\"\n\t * \n\t * This allows us to get data about another process at runtime, and use it (e.g.) as an argument to a second process.\n\t * \n\t * @param inputString         The string which may contain perl variable references.\n\t * @param delimiter           If the inputString is surrounded by (e.g.) single quotes, we need to know what symbol \n\t *                            we're escaping and resuming after replacing the substitute string with perl code.\n\t *                            Leave blank to escape nothing.\n\t * @param CommandDetails      The object that tells us what substitution strings to replace with what perl code.\n\t * @return String             The processed String, where each process reference is replaced with Perl code\n\t */\n\tprivate String replaceKeysWithValues(String inputString, String delimiter, CommandDetails data) {\n\t\tString outputString = inputString;\n\t\t//Now we replace instances of any substitution string with a data request from the associated process.\n\t\tfor(Map.Entry<String, StfProcess> processPair : data.getRelatedProcesses().entrySet()) {\n\t\t\tif(outputString.contains(processPair.getKey())) {\n\t\t\t\t//The next three lines turn our StfProcess object into the Perl variable name.\n\t\t\t\tArrayList<StfProcess> tempArray = new ArrayList<StfProcess>();\n\t\t\t\ttempArray.add(processPair.getValue());\n\t\t\t\tStringBuilder processVariable = createProcessReferenceString(tempArray);\n\t\t\t\t//This next line should result in a variable name in perl, followed by the suffix in the PERL_PROCESS_DATA HashMap \n\t\t\t\t//that corresponds to the value associated with the key linked to this data request.\n\t\t\t\tString dataRetrievalPerl = processVariable.toString().substring(1) + PERL_PROCESS_DATA.get(data.getRelatedProcessesData().get(processPair.getKey()));\n\t\t\t\tif(delimiter.isEmpty()) {\n\t\t\t\t\toutputString = outputString.replaceAll(processPair.getKey(), Matcher.quoteReplacement(\"$\") + dataRetrievalPerl);\n\t\t\t\t} else {\n\t\t\t\t\toutputString = outputString.replaceAll(processPair.getKey(), delimiter + \" . \" + Matcher.quoteReplacement(\"$\") + dataRetrievalPerl + \" . \" + delimiter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn outputString;\n\t}\n\t\n\t\n\t/*\n\t * Generates the perl value for an expected outcome argument.\n\t * Essential translates between the contents of the ExpectedOutcome object and \n\t * its equivalent representation in perl code.\n\t */\n\tprivate String generateExpectedOutcomeValue(ExpectedOutcome expectedOutcome) {\n\t\tswitch (expectedOutcome.getExpectedOutcome()) {\n\t\t\tcase CLEAN_RUN:     return \"exitValue:0\";\n\t\t\tcase NON_ZERO_EXIT: return \"exitValue:\" + expectedOutcome.getExpectedExitValue();\n\t\t\tcase NEVER:         return \"never\";\n\t\t\tcase CRASHES:       return \"crashes\";\n\t\t}\n\t\t\n\t\tthrow new IllegalStateException(\"Internal Error. Missing outcome state\");\n\t}"
    },
    "124": {
      "metadata": {
        "chunk_id": "2e6ec687c9511c8e393a75bcdf7522c336e15ae3877f886ff28f4d42470abdc4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "/* Examines the arguments for a command to determine if the contents of the arguments\n\t * mean that the command needs to be invoked with arguments that are passed in as \n\t * an array. \n\t * @return true if an array (instead of a single argument string) is required.\n\t */\n\tprivate boolean needArrayBasedArgs(CommandDetails command) {\n\t\t// Look at the contents of all args to decide which variant of command generation \n\t\t// will be used. \n\t\t// We prefer to generate the command as a big string, as this is more readable.\n\t\t// However if any of the args contain a double-quote or a space we need to fall back to \n\t\t// passing in the args as elements in an array. This is foolproof but not so readable.\n\t\tboolean foundFunnyChar = false;\n\t\tfor (String arg : command.args) {\n\t\t\tfoundFunnyChar |= arg.contains(\" \") || arg.contains(\"\\\"\");\n\t\t}\n\n\t\treturn foundFunnyChar;\n\t}\n\t\n\t\n\t/**\n\t * Builds an object representing a command formatted in different ways.\n\t * 1. A string formatted for readability\n\t * 2. An unformatted string\n\t * 3. TODO.  The command as a string and its arguments as an array\n\t * \n\t * Formatting the command makes a huge difference to its readability in the \n\t * generated perl script.\n\t *\n\t * @param mnemonic is the mnemonic for this command.\n\t * @param numInstances is the number of process instances to start with the same configuration.\n\t * @param argumentComment is an optional value for describing something about the command \n\t * arguments. Mostly used to say what the random mode seed is set to.\n\t * @param executable is the name of the program to run.\n\t * @param args is a list of strings for the arguments to the command.\n\t * @return a result object containing the command.\n\t * @throws StfException\n\t */\n\tpublic CommandDetails buildCommand(String mnemonic, int numInstances, String argumentComment, String executable, String... argsValues) throws StfException {\n\t\t// Now that we are about to generate the perl code we can replace any values\n\t\t// with the known command number or mnemonic.\n\t\t// Values for ${{STF-PROCESS-INSTANCE}} need to be done in perl land.\n\t\tString[] updatedArgs = new String[argsValues.length];\n\t\tfor (int i=0; i<argsValues.length; i++) {\n\t\t\tString arg = argsValues[i];\n\t\t\targ = arg.replace(PLACEHOLDER_STF_COMMAND_NUMBER, Integer.toString(commandSerialNum));\n\t\t\targ = arg.replace(PLACEHOLDER_STF_COMMAND_MNEMONIC, mnemonic);\n\t\t\tif (numInstances == 1) {\n\t\t\t\t// For single instances there is no point in letting perl replace the process\n\t\t\t\t// instance placeholder. May as well remove it now to keep the generated code clean.\n\t\t\t\targ = arg.replace(StfConstants.PLACEHOLDER_STF_PROCESS_INSTANCE, \"\");\n\t\t\t}\n\t\t\tupdatedArgs[i] = arg;\n\t\t}\n\t\t\n\t\t// Build object to return results in\n\t\tCommandDetails commandDetails = new CommandDetails();\n\t\tcommandDetails.commandSerialNum = commandSerialNum;\n\t\tcommandDetails.executableName = executable;\n\t\tcommandDetails.args = updatedArgs;\n\t\tcommandDetails.argumentComment = argumentComment;\n\t\t\n\t\treturn commandDetails;\n\t}\n\t\n\t\n\t/**\n\t * Builds a formatted JVM command.\n\t * This method can generate perl code to run any of the programs in the JVM bin directory.\n\t * \n\t * @param mnemonic is the mnemonic for this command.\n\t * @param numInstances is the number of process instances to start with the same configuration.\n\t * @param processDetails holds information about the process that is to be run.\n\t * @return a result object containing the java command.\n\t * @throws StfException\n\t */\n\tpublic CommandDetails buildJvmCommand(String mnemonic, int numInstances, ProcessDefinition processDetails) throws StfException {\n\t\tJavaVersion jvm = processDetails.getJavaVersion();",
        "start_line": 572,
        "end_line": 649,
        "chunk_index": 9,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 847,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832411"
      },
      "text": "/* Examines the arguments for a command to determine if the contents of the arguments\n\t * mean that the command needs to be invoked with arguments that are passed in as \n\t * an array. \n\t * @return true if an array (instead of a single argument string) is required.\n\t */\n\tprivate boolean needArrayBasedArgs(CommandDetails command) {\n\t\t// Look at the contents of all args to decide which variant of command generation \n\t\t// will be used. \n\t\t// We prefer to generate the command as a big string, as this is more readable.\n\t\t// However if any of the args contain a double-quote or a space we need to fall back to \n\t\t// passing in the args as elements in an array. This is foolproof but not so readable.\n\t\tboolean foundFunnyChar = false;\n\t\tfor (String arg : command.args) {\n\t\t\tfoundFunnyChar |= arg.contains(\" \") || arg.contains(\"\\\"\");\n\t\t}\n\n\t\treturn foundFunnyChar;\n\t}\n\t\n\t\n\t/**\n\t * Builds an object representing a command formatted in different ways.\n\t * 1. A string formatted for readability\n\t * 2. An unformatted string\n\t * 3. TODO.  The command as a string and its arguments as an array\n\t * \n\t * Formatting the command makes a huge difference to its readability in the \n\t * generated perl script.\n\t *\n\t * @param mnemonic is the mnemonic for this command.\n\t * @param numInstances is the number of process instances to start with the same configuration.\n\t * @param argumentComment is an optional value for describing something about the command \n\t * arguments. Mostly used to say what the random mode seed is set to.\n\t * @param executable is the name of the program to run.\n\t * @param args is a list of strings for the arguments to the command.\n\t * @return a result object containing the command.\n\t * @throws StfException\n\t */\n\tpublic CommandDetails buildCommand(String mnemonic, int numInstances, String argumentComment, String executable, String... argsValues) throws StfException {\n\t\t// Now that we are about to generate the perl code we can replace any values\n\t\t// with the known command number or mnemonic.\n\t\t// Values for ${{STF-PROCESS-INSTANCE}} need to be done in perl land.\n\t\tString[] updatedArgs = new String[argsValues.length];\n\t\tfor (int i=0; i<argsValues.length; i++) {\n\t\t\tString arg = argsValues[i];\n\t\t\targ = arg.replace(PLACEHOLDER_STF_COMMAND_NUMBER, Integer.toString(commandSerialNum));\n\t\t\targ = arg.replace(PLACEHOLDER_STF_COMMAND_MNEMONIC, mnemonic);\n\t\t\tif (numInstances == 1) {\n\t\t\t\t// For single instances there is no point in letting perl replace the process\n\t\t\t\t// instance placeholder. May as well remove it now to keep the generated code clean.\n\t\t\t\targ = arg.replace(StfConstants.PLACEHOLDER_STF_PROCESS_INSTANCE, \"\");\n\t\t\t}\n\t\t\tupdatedArgs[i] = arg;\n\t\t}\n\t\t\n\t\t// Build object to return results in\n\t\tCommandDetails commandDetails = new CommandDetails();\n\t\tcommandDetails.commandSerialNum = commandSerialNum;\n\t\tcommandDetails.executableName = executable;\n\t\tcommandDetails.args = updatedArgs;\n\t\tcommandDetails.argumentComment = argumentComment;\n\t\t\n\t\treturn commandDetails;\n\t}\n\t\n\t\n\t/**\n\t * Builds a formatted JVM command.\n\t * This method can generate perl code to run any of the programs in the JVM bin directory.\n\t * \n\t * @param mnemonic is the mnemonic for this command.\n\t * @param numInstances is the number of process instances to start with the same configuration.\n\t * @param processDetails holds information about the process that is to be run.\n\t * @return a result object containing the java command.\n\t * @throws StfException\n\t */\n\tpublic CommandDetails buildJvmCommand(String mnemonic, int numInstances, ProcessDefinition processDetails) throws StfException {\n\t\tJavaVersion jvm = processDetails.getJavaVersion();"
    },
    "125": {
      "metadata": {
        "chunk_id": "64321b1816ac8bc4651961a529698954ad233bf352426b47a13e60a71a23c200",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "ArrayList<String> commandArgs = new ArrayList<String>();\n\t\tString argumentComment = null;\n\t\t\n\t\t// Sometimes the test needs JVM args which are the very first arguments. eg modes for shared classes test\n\t\tString command = processDetails.getCommand();\n\t\tif (command.endsWith(\"java\") && environmentCore.getStage() == Stage.EXECUTE) {\n\t\t\t// Add any such values as the first arguments, so that they can be overriden\n\t\t\tArgument java_args_initial = getExecuteInitialArgument(jvm);\n\t\t\tString initialJvmOptions = environmentCore.getProperty(java_args_initial);\n\t\t\tArrayList<String> jvmOptionArgs = StringSplitter.splitArguments(initialJvmOptions);\n\t\t\tcommandArgs.addAll(jvmOptionArgs);\n\t\t\t\n\t\t\tif (initialJvmOptions != null && !initialJvmOptions.isEmpty()) {\n\t\t\t\t// If there are some initial java args then we need to pull in a comment about the arguments.\n\t\t\t\t// The comment probably says what random mode seed is being used, but need to grab \n\t\t\t\t// at this point so that it can be output in execute.pl\n\t\t\t\tArgument java_args_comment = getExecuteCommentArgument(jvm);\n\t\t\t\targumentComment = environmentCore.getProperty(java_args_comment);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Add in the arguments that the test plugin wants\n\t\tString[] argStrings = processDetails.asArgsArray().toArray(new String[0]);\n\t\tcommandArgs.addAll(Arrays.asList(argStrings));\n\t\t\n\t\t// If we are about to run java then add in the current set of jvm options\n\t\tif (command.endsWith(\"java\")) {\n\t\t\t// JVM options need to go in just before the classpath (so that they take precedence)\n\t\t\t// Firstly work out the index at which they need to be inserted.\n\t\t\tint insertPosition = -1;\n\t\t\tfor (int i=0; i<commandArgs.size(); i++) {\n\t\t\t\tif (commandArgs.get(i).startsWith(\"-classpath\") || commandArgs.get(i).startsWith(\"-jar\")) {\n\t\t\t\t\tinsertPosition = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Insert jvm options at the correct point\n\t\t\tString jvmOptions = getBaseJvmOptions(jvm);\n\t\t\tif (jvmOptions != null) {\n\t\t\t\tArrayList<String> jvmOptionArgs = StringSplitter.splitArguments(jvmOptions);\n\t\t\t\tif (insertPosition == -1) {\n\t\t\t\t\tcommandArgs.addAll(jvmOptionArgs);  // No classpath! Add at the end of the command\n\t\t\t\t} else {\n\t\t\t\t\tcommandArgs.addAll(insertPosition, jvmOptionArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buildCommand(mnemonic, numInstances, argumentComment, command, commandArgs.toArray(new String[0]));\n\t}\n\n\tprivate Argument getExecuteInitialArgument(JavaVersion jvm) { \n\t\tif (jvm.isPrimaryJvm()) {\n\t\t\treturn Stf.ARG_JAVA_ARGS_EXECUTE_INITIAL;\n\t\t} else {\n\t\t\treturn Stf.ARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL;\n\t\t}\n\t}\n\t\n\tprivate Argument getExecuteCommentArgument(JavaVersion jvm) { \n\t\tif (jvm.isPrimaryJvm()) {\n\t\t\treturn Stf.ARG_JAVA_ARGS_EXECUTE_COMMENT;\n\t\t} else {\n\t\t\treturn Stf.ARG_JAVA_ARGS_EXECUTE_SECONDARY_COMMENT;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the lowest level of JVM options needed when running a java process.\n\t * The actual value return depends on the stage which is currently executing.\n\t * \n\t * @return String containing the java options to be used.\n\t */\n\tpublic String getBaseJvmOptions(JavaVersion jvm) throws StfException {\n\t\tif (environmentCore.getStage() == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Can't run java process in the initialisation stage\");\n\t\t}\n\t\t\n\t\tArgument baseJvmOptionsArgument = environmentCore.getStage().getJavaArg(jvm);\n\t\tString baseJvmOptions = environmentCore.getProperty(baseJvmOptionsArgument);\n\t\treturn baseJvmOptions;\n\t}",
        "start_line": 650,
        "end_line": 731,
        "chunk_index": 10,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 832,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832414"
      },
      "text": "ArrayList<String> commandArgs = new ArrayList<String>();\n\t\tString argumentComment = null;\n\t\t\n\t\t// Sometimes the test needs JVM args which are the very first arguments. eg modes for shared classes test\n\t\tString command = processDetails.getCommand();\n\t\tif (command.endsWith(\"java\") && environmentCore.getStage() == Stage.EXECUTE) {\n\t\t\t// Add any such values as the first arguments, so that they can be overriden\n\t\t\tArgument java_args_initial = getExecuteInitialArgument(jvm);\n\t\t\tString initialJvmOptions = environmentCore.getProperty(java_args_initial);\n\t\t\tArrayList<String> jvmOptionArgs = StringSplitter.splitArguments(initialJvmOptions);\n\t\t\tcommandArgs.addAll(jvmOptionArgs);\n\t\t\t\n\t\t\tif (initialJvmOptions != null && !initialJvmOptions.isEmpty()) {\n\t\t\t\t// If there are some initial java args then we need to pull in a comment about the arguments.\n\t\t\t\t// The comment probably says what random mode seed is being used, but need to grab \n\t\t\t\t// at this point so that it can be output in execute.pl\n\t\t\t\tArgument java_args_comment = getExecuteCommentArgument(jvm);\n\t\t\t\targumentComment = environmentCore.getProperty(java_args_comment);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Add in the arguments that the test plugin wants\n\t\tString[] argStrings = processDetails.asArgsArray().toArray(new String[0]);\n\t\tcommandArgs.addAll(Arrays.asList(argStrings));\n\t\t\n\t\t// If we are about to run java then add in the current set of jvm options\n\t\tif (command.endsWith(\"java\")) {\n\t\t\t// JVM options need to go in just before the classpath (so that they take precedence)\n\t\t\t// Firstly work out the index at which they need to be inserted.\n\t\t\tint insertPosition = -1;\n\t\t\tfor (int i=0; i<commandArgs.size(); i++) {\n\t\t\t\tif (commandArgs.get(i).startsWith(\"-classpath\") || commandArgs.get(i).startsWith(\"-jar\")) {\n\t\t\t\t\tinsertPosition = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Insert jvm options at the correct point\n\t\t\tString jvmOptions = getBaseJvmOptions(jvm);\n\t\t\tif (jvmOptions != null) {\n\t\t\t\tArrayList<String> jvmOptionArgs = StringSplitter.splitArguments(jvmOptions);\n\t\t\t\tif (insertPosition == -1) {\n\t\t\t\t\tcommandArgs.addAll(jvmOptionArgs);  // No classpath! Add at the end of the command\n\t\t\t\t} else {\n\t\t\t\t\tcommandArgs.addAll(insertPosition, jvmOptionArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buildCommand(mnemonic, numInstances, argumentComment, command, commandArgs.toArray(new String[0]));\n\t}\n\n\tprivate Argument getExecuteInitialArgument(JavaVersion jvm) { \n\t\tif (jvm.isPrimaryJvm()) {\n\t\t\treturn Stf.ARG_JAVA_ARGS_EXECUTE_INITIAL;\n\t\t} else {\n\t\t\treturn Stf.ARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL;\n\t\t}\n\t}\n\t\n\tprivate Argument getExecuteCommentArgument(JavaVersion jvm) { \n\t\tif (jvm.isPrimaryJvm()) {\n\t\t\treturn Stf.ARG_JAVA_ARGS_EXECUTE_COMMENT;\n\t\t} else {\n\t\t\treturn Stf.ARG_JAVA_ARGS_EXECUTE_SECONDARY_COMMENT;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the lowest level of JVM options needed when running a java process.\n\t * The actual value return depends on the stage which is currently executing.\n\t * \n\t * @return String containing the java options to be used.\n\t */\n\tpublic String getBaseJvmOptions(JavaVersion jvm) throws StfException {\n\t\tif (environmentCore.getStage() == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Can't run java process in the initialisation stage\");\n\t\t}\n\t\t\n\t\tArgument baseJvmOptionsArgument = environmentCore.getStage().getJavaArg(jvm);\n\t\tString baseJvmOptions = environmentCore.getProperty(baseJvmOptionsArgument);\n\t\treturn baseJvmOptions;\n\t}"
    },
    "126": {
      "metadata": {
        "chunk_id": "e5d65458588a80be60eb3a2146d834eec0f282843d09dfef487623cd40cdec39",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "/**\n\t * Returns the lowest level of JVM options needed when running a java process.\n\t * The actual value return depends on the stage which is currently executing.\n\t * \n\t * @return String containing the java options to be used.\n\t */\n\tpublic String getBaseJvmOptions(JavaVersion jvm) throws StfException {\n\t\tif (environmentCore.getStage() == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Can't run java process in the initialisation stage\");\n\t\t}\n\t\t\n\t\tArgument baseJvmOptionsArgument = environmentCore.getStage().getJavaArg(jvm);\n\t\tString baseJvmOptions = environmentCore.getProperty(baseJvmOptionsArgument);\n\t\treturn baseJvmOptions;\n\t}\n\n\n\t/**\n\t * This method should be called before the generation of a new command.\n\t * It outputs a comment block and increments the command number.\n\t * \n\t * @param comment is a comment from the test case describing why the the command is being run.\n\t * @param commandName is a short name describing the command that is going to be executed.\n\t * @param commandSummary is a brief description about what the command does.\n\t * @param commentary holds pair of name value strings describing the main arg/value pairs.\n\t * @returns the serial number of the new command.\n\t * @throws StfException\n\t */\n\tpublic int startNewCommand(String comment, String commandName, String commandSummary, String... commentary) throws StfException {\n\t\tcommandSerialNum++;\n\t\t\n\t\t// Add a summary of this command into the generated script\n\t\toutputEmptyLine();\n\t\toutputEmptyLine();\n\t\toutputLine(\"#\");\n\t\toutputLine(\"# Step   : \" + commandSerialNum);\n\t\toutputLine(\"# Command: \" + commandName);\n\t\toutputLine(\"# Comment: \" + comment);\n\t\toutputLine(\"#\");\n\t\t\n\t\t// Find longest commentary name\n\t\tif (commentary.length % 2 != 0) {\n\t\t\tthrow new IllegalStateException(\"Number commentary strings not even\");\n\t\t}\n\t\tint longestName = 0;\n\t\tfor (int i=0; i<commentary.length/2; i++) {\n\t\t\tString name = commentary[i*2];\n\t\t\tlongestName = Math.max(longestName, name.length());\n\t\t}\n\n\t\t// Output some lines describing the command and its arguments.\n\t\toutputLine(\"info('');\");\n\t\toutputLine(\"info('+------ Step \" + commandSerialNum + \" - \" + comment + \"');\");\n\t\toutputLine(\"info('| \" + commandSummary + \"');\");\n\t\t// Output all commentary name/value pairs\n\t\tfor (int i=0; i<commentary.length/2; i++) {  // step through each pair\n\t\t\tString name = commentary[i*2];\n\t\t\tString value = commentary[(i*2)+1];\n\t\t\tString paddedName = String.format(\"%1$-\" + longestName + \"s\", name);\n\t\t\toutputLine(\"info('|   \" + paddedName + \" \" + value + \"');\");\n\t\t}\n\t\toutputLine(\"info('|');\");\n\t\toutputLine(\"\");\n\n\t\t// Remember details of this command for the command summary table.\n\t\t// This is written near the start of the STF output once generation has completed.\n\t\tString summary = String.format(\"   %2d  %-\" + longestStageName + \"s %-17s %s\", commandSerialNum, methodName, commandName, comment);\n\t\tcommandSummaryLog.add(summary);\n\t\t\n\t\treturn commandSerialNum;\n\t}\n\n\t\n\t/**\n\t * Verifies that a boolean condition is true.\n\t * \n\t * @param condition is the value being checked.\n\t * @param comment is used as the exception test if 'condition' is not true.\n\t * @throws StfException if 'condition' is not equal to true.\n\t */\n\tpublic void verify(boolean condition, String comment) throws StfException {\n\t\tif (condition != true) { \n\t\t\tthrow new StfException(comment);\n\t\t}\n\t}",
        "start_line": 732,
        "end_line": 816,
        "chunk_index": 11,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 820,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832417"
      },
      "text": "/**\n\t * Returns the lowest level of JVM options needed when running a java process.\n\t * The actual value return depends on the stage which is currently executing.\n\t * \n\t * @return String containing the java options to be used.\n\t */\n\tpublic String getBaseJvmOptions(JavaVersion jvm) throws StfException {\n\t\tif (environmentCore.getStage() == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Can't run java process in the initialisation stage\");\n\t\t}\n\t\t\n\t\tArgument baseJvmOptionsArgument = environmentCore.getStage().getJavaArg(jvm);\n\t\tString baseJvmOptions = environmentCore.getProperty(baseJvmOptionsArgument);\n\t\treturn baseJvmOptions;\n\t}\n\n\n\t/**\n\t * This method should be called before the generation of a new command.\n\t * It outputs a comment block and increments the command number.\n\t * \n\t * @param comment is a comment from the test case describing why the the command is being run.\n\t * @param commandName is a short name describing the command that is going to be executed.\n\t * @param commandSummary is a brief description about what the command does.\n\t * @param commentary holds pair of name value strings describing the main arg/value pairs.\n\t * @returns the serial number of the new command.\n\t * @throws StfException\n\t */\n\tpublic int startNewCommand(String comment, String commandName, String commandSummary, String... commentary) throws StfException {\n\t\tcommandSerialNum++;\n\t\t\n\t\t// Add a summary of this command into the generated script\n\t\toutputEmptyLine();\n\t\toutputEmptyLine();\n\t\toutputLine(\"#\");\n\t\toutputLine(\"# Step   : \" + commandSerialNum);\n\t\toutputLine(\"# Command: \" + commandName);\n\t\toutputLine(\"# Comment: \" + comment);\n\t\toutputLine(\"#\");\n\t\t\n\t\t// Find longest commentary name\n\t\tif (commentary.length % 2 != 0) {\n\t\t\tthrow new IllegalStateException(\"Number commentary strings not even\");\n\t\t}\n\t\tint longestName = 0;\n\t\tfor (int i=0; i<commentary.length/2; i++) {\n\t\t\tString name = commentary[i*2];\n\t\t\tlongestName = Math.max(longestName, name.length());\n\t\t}\n\n\t\t// Output some lines describing the command and its arguments.\n\t\toutputLine(\"info('');\");\n\t\toutputLine(\"info('+------ Step \" + commandSerialNum + \" - \" + comment + \"');\");\n\t\toutputLine(\"info('| \" + commandSummary + \"');\");\n\t\t// Output all commentary name/value pairs\n\t\tfor (int i=0; i<commentary.length/2; i++) {  // step through each pair\n\t\t\tString name = commentary[i*2];\n\t\t\tString value = commentary[(i*2)+1];\n\t\t\tString paddedName = String.format(\"%1$-\" + longestName + \"s\", name);\n\t\t\toutputLine(\"info('|   \" + paddedName + \" \" + value + \"');\");\n\t\t}\n\t\toutputLine(\"info('|');\");\n\t\toutputLine(\"\");\n\n\t\t// Remember details of this command for the command summary table.\n\t\t// This is written near the start of the STF output once generation has completed.\n\t\tString summary = String.format(\"   %2d  %-\" + longestStageName + \"s %-17s %s\", commandSerialNum, methodName, commandName, comment);\n\t\tcommandSummaryLog.add(summary);\n\t\t\n\t\treturn commandSerialNum;\n\t}\n\n\t\n\t/**\n\t * Verifies that a boolean condition is true.\n\t * \n\t * @param condition is the value being checked.\n\t * @param comment is used as the exception test if 'condition' is not true.\n\t * @throws StfException if 'condition' is not equal to true.\n\t */\n\tpublic void verify(boolean condition, String comment) throws StfException {\n\t\tif (condition != true) { \n\t\t\tthrow new StfException(comment);\n\t\t}\n\t}"
    },
    "127": {
      "metadata": {
        "chunk_id": "aa3a19b4973b92821dc31ebfc9603559ee9c97d5ce1e02814ee1a2071e637a66",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "// Remember details of this command for the command summary table.\n\t\t// This is written near the start of the STF output once generation has completed.\n\t\tString summary = String.format(\"   %2d  %-\" + longestStageName + \"s %-17s %s\", commandSerialNum, methodName, commandName, comment);\n\t\tcommandSummaryLog.add(summary);\n\t\t\n\t\treturn commandSerialNum;\n\t}\n\n\t\n\t/**\n\t * Verifies that a boolean condition is true.\n\t * \n\t * @param condition is the value being checked.\n\t * @param comment is used as the exception test if 'condition' is not true.\n\t * @throws StfException if 'condition' is not equal to true.\n\t */\n\tpublic void verify(boolean condition, String comment) throws StfException {\n\t\tif (condition != true) { \n\t\t\tthrow new StfException(comment);\n\t\t}\n\t}\n\n\n\t/**\n\t * Adds a block of perl which fails the test if a perl condition is true.\n\t * \n\t * @param command is a short description of the command for which code is being generated.\n\t * @param comment is a description from the test plugin describing why the current command is being run.\n\t * @param resultVariable is the perl variable whose result is being checked.\n\t * @param operator is the comparison operator used to compare the resultVariable with the successValue. \n\t * @param resultValue contains the value to compare resultVariable to.\n\t * @param runningProcesses is a list of processes which could still be running, and need to be killed before the script dies.\n\t * @throws StfException if we fail to write to the output file.\n\t */\n\tpublic void outputFailIfTrue(String command, String comment, String resultVariable, String operator, String resultValue, ArrayList<String> extraErrorLines, ArrayList<StfProcess> runningProcesses) throws StfException {\n\t\t// Build the if statement and error message, eg 'if ($rc != 0) { ...'\n\t\toutputLine(\"if (\" + resultVariable + \" \" + operator + \" \" + resultValue +  \") {\");\n\t\tincreaseIndentation();\n\n\t\t// Output some optional failure lines from the caller \n\t\tif (extraErrorLines != null) {\n\t\t\tfor (String line : extraErrorLines) { \n\t\t\t\toutputLine(line);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Generate perl to kill any running processes and exit the test \n\t\tString errorMessage = StfConstants.FAILURE_PREFIX \n\t\t\t\t+ \"at \" + describeCommand(command, comment) + \". \"\n\t\t\t\t+ \"Expected return value=\" + resultValue + \" \"\n\t\t\t\t+ \"Actual=\" + resultVariable;\n\t\toutputDieCommand(runningProcesses, errorMessage);\n\t\t\n\t\tdecreaseIndentation();\n\t\toutputLine(\"}\");\n\t}\n\n\n\t/**\n\t * Generates the code needed to terminate the running perl script.\n\t * Generally only needed to handle error paths. \n\t * @param runningProcesses is an array list containing all processes which could \n\t * still be running, and will therefore be killed.\n\t * @param dieMessage is the message to be used for the die call.\n\t */\n\tpublic void outputDieCommand(ArrayList<StfProcess> runningProcesses, String dieMessage) throws StfException {\n\t\t// Terminate all child processes\n\t\toutputKillProcesses(runningProcesses, \"\");",
        "start_line": 817,
        "end_line": 884,
        "chunk_index": 12,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 696,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832420"
      },
      "text": "// Remember details of this command for the command summary table.\n\t\t// This is written near the start of the STF output once generation has completed.\n\t\tString summary = String.format(\"   %2d  %-\" + longestStageName + \"s %-17s %s\", commandSerialNum, methodName, commandName, comment);\n\t\tcommandSummaryLog.add(summary);\n\t\t\n\t\treturn commandSerialNum;\n\t}\n\n\t\n\t/**\n\t * Verifies that a boolean condition is true.\n\t * \n\t * @param condition is the value being checked.\n\t * @param comment is used as the exception test if 'condition' is not true.\n\t * @throws StfException if 'condition' is not equal to true.\n\t */\n\tpublic void verify(boolean condition, String comment) throws StfException {\n\t\tif (condition != true) { \n\t\t\tthrow new StfException(comment);\n\t\t}\n\t}\n\n\n\t/**\n\t * Adds a block of perl which fails the test if a perl condition is true.\n\t * \n\t * @param command is a short description of the command for which code is being generated.\n\t * @param comment is a description from the test plugin describing why the current command is being run.\n\t * @param resultVariable is the perl variable whose result is being checked.\n\t * @param operator is the comparison operator used to compare the resultVariable with the successValue. \n\t * @param resultValue contains the value to compare resultVariable to.\n\t * @param runningProcesses is a list of processes which could still be running, and need to be killed before the script dies.\n\t * @throws StfException if we fail to write to the output file.\n\t */\n\tpublic void outputFailIfTrue(String command, String comment, String resultVariable, String operator, String resultValue, ArrayList<String> extraErrorLines, ArrayList<StfProcess> runningProcesses) throws StfException {\n\t\t// Build the if statement and error message, eg 'if ($rc != 0) { ...'\n\t\toutputLine(\"if (\" + resultVariable + \" \" + operator + \" \" + resultValue +  \") {\");\n\t\tincreaseIndentation();\n\n\t\t// Output some optional failure lines from the caller \n\t\tif (extraErrorLines != null) {\n\t\t\tfor (String line : extraErrorLines) { \n\t\t\t\toutputLine(line);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Generate perl to kill any running processes and exit the test \n\t\tString errorMessage = StfConstants.FAILURE_PREFIX \n\t\t\t\t+ \"at \" + describeCommand(command, comment) + \". \"\n\t\t\t\t+ \"Expected return value=\" + resultValue + \" \"\n\t\t\t\t+ \"Actual=\" + resultVariable;\n\t\toutputDieCommand(runningProcesses, errorMessage);\n\t\t\n\t\tdecreaseIndentation();\n\t\toutputLine(\"}\");\n\t}\n\n\n\t/**\n\t * Generates the code needed to terminate the running perl script.\n\t * Generally only needed to handle error paths. \n\t * @param runningProcesses is an array list containing all processes which could \n\t * still be running, and will therefore be killed.\n\t * @param dieMessage is the message to be used for the die call.\n\t */\n\tpublic void outputDieCommand(ArrayList<StfProcess> runningProcesses, String dieMessage) throws StfException {\n\t\t// Terminate all child processes\n\t\toutputKillProcesses(runningProcesses, \"\");"
    },
    "128": {
      "metadata": {
        "chunk_id": "58132fb931947986c510e317ab1a0037894fc0da562394bb3bbe8e07ac10cd7c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "/**\n\t * Generates the code needed to terminate the running perl script.\n\t * Generally only needed to handle error paths. \n\t * @param runningProcesses is an array list containing all processes which could \n\t * still be running, and will therefore be killed.\n\t * @param dieMessage is the message to be used for the die call.\n\t */\n\tpublic void outputDieCommand(ArrayList<StfProcess> runningProcesses, String dieMessage) throws StfException {\n\t\t// Terminate all child processes\n\t\toutputKillProcesses(runningProcesses, \"\");\n\n\t\t// Now the real reason for this method. Terminate the perl process.\n\t\toutputLine(\"die \\\"\" + dieMessage + \"\\\";\");\n\t}\n\t\n\t\n\t/**\n\t * Adds a block of perl code which scans a log file counting the number of times that a \n\t * specified string matches.\n\t * It passes no judgement about whether or not the resulting count is good or bad, that is the\n\t * job of subsequent call to outputFailIfTrue().\n\t * \n\t * It does this by creating a while loop which opens a log and does a regex match on each line.\n\t * Every match causes the resultVariable to be incremented.\n\t * \n\t * @param resultVariable is the perl variable where the result of the scan is set. eg '$error_count'\n\t * @param log is the log file whose output is scanned.\n\t * @param runningProcesses is a list of processes which could still be running, and need to be killed before the script dies.\n\t * @param expectedResultMessages contains the message/s that the log file is expected to contain.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void outputCountFileMatches(String countVariable, FileRef log, ArrayList<StfProcess> runningProcesses, String... expectedResultMessages) throws StfException {\n\t\t// Build the if statement arguments\n\t\tStringBuilder ifArgs = new StringBuilder();\n\t\t\n\t\t// Ensure that supports the checking of multiple messages\n\t\tboolean multipleResultMessageValues = false;\n\t\tfor (String expectedResultMessage : expectedResultMessages) {\n\t\t\tif (multipleResultMessageValues) {\n\t\t\t\tifArgs.append(\" || \");\n\t\t\t}\n\t\t\tifArgs.append(\"$line =~ '\" + expectedResultMessage + \"'\");\n\t\t\tmultipleResultMessageValues = true;\n\t\t}\n\t\t\n\t\t// Build the perl code that loops through the log and does the regex matching\n\t\toutputLine(\"unless (open(LOG, \" + \"'\" + log + \"' )) {\");\n\t\tincreaseIndentation();\n\t\toutputDieCommand(runningProcesses, \"Could not open log\");\n\t\tdecreaseIndentation();\n\t\toutputLine(\"}\");\t\n\t\toutputEmptyLine();\n\t\t\n\t\toutputVariableInitialisation(countVariable, \"0\");\n\t\toutputLine(\"while (my $line = <LOG>) {\"); \n\t\toutputLine(\"    if (\" + ifArgs + \") {\");\n\t\toutputLine(\"        \" + countVariable + \"++;\");\n\t\toutputLine(\"    }\");\n\t\toutputLine(\"}\");\n\t\toutputLine(\"close(LOG);\");\n\t}\n\t\n\t\n\t/**\n\t * Generates perl code to echo the contents of a file to standard output.\n\t * @param targetFile points to the file to be read\n\t * @param runningProcesses are the processes that need to be killed if the file cannot be opened.\n\t */\n\tpublic void outputEchoFile(FileRef targetFile, ArrayList<StfProcess> runningProcesses) throws StfException {\n\t\t// Open the target file\n\t\toutputLine(\"unless (open(LOG, \" + \"'\" + targetFile + \"' )) {\");\n\t\tincreaseIndentation();\n\t\toutputDieCommand(runningProcesses, \"Failed to open file for contents echoing at: \" + targetFile);\n\t\tdecreaseIndentation();\n\t\toutputLine(\"}\");\t\n\t\toutputEmptyLine();\n\n\t\t// Read and echo every line of target file\n\t\toutputLine(\"info('Echoing contents of file \" + targetFile + \"');\");\n\t\toutputLine(\"info('>>>>>>');\");\n\t\t\n\t\toutputLine(\"while (my $line = <LOG>) {\"); \n\t\toutputLine(\"    print($line);\");\n\t\toutputLine(\"}\");\n\t\toutputLine(\"close(LOG);\");\n\t\t\n\t\toutputLine(\"info('<<<<<<');\");\n\t\toutputLine(\"info('Ending echo for file \" + targetFile + \"');\");\n\t}\n\t\n\t\n\t\n\t/**\n\t * This method increases the indentation depth \n\t */\n\tpublic void increaseIndentation() {\n\t\tindentationDepth++;\n\t}\n\t\n\t\n\t/**\n\t * This method decreases the indentation depth\n\t */\n\tpublic void decreaseIndentation() {\n\t\tindentationDepth--;\n\t}",
        "start_line": 885,
        "end_line": 990,
        "chunk_index": 13,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 948,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832423"
      },
      "text": "/**\n\t * Generates the code needed to terminate the running perl script.\n\t * Generally only needed to handle error paths. \n\t * @param runningProcesses is an array list containing all processes which could \n\t * still be running, and will therefore be killed.\n\t * @param dieMessage is the message to be used for the die call.\n\t */\n\tpublic void outputDieCommand(ArrayList<StfProcess> runningProcesses, String dieMessage) throws StfException {\n\t\t// Terminate all child processes\n\t\toutputKillProcesses(runningProcesses, \"\");\n\n\t\t// Now the real reason for this method. Terminate the perl process.\n\t\toutputLine(\"die \\\"\" + dieMessage + \"\\\";\");\n\t}\n\t\n\t\n\t/**\n\t * Adds a block of perl code which scans a log file counting the number of times that a \n\t * specified string matches.\n\t * It passes no judgement about whether or not the resulting count is good or bad, that is the\n\t * job of subsequent call to outputFailIfTrue().\n\t * \n\t * It does this by creating a while loop which opens a log and does a regex match on each line.\n\t * Every match causes the resultVariable to be incremented.\n\t * \n\t * @param resultVariable is the perl variable where the result of the scan is set. eg '$error_count'\n\t * @param log is the log file whose output is scanned.\n\t * @param runningProcesses is a list of processes which could still be running, and need to be killed before the script dies.\n\t * @param expectedResultMessages contains the message/s that the log file is expected to contain.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void outputCountFileMatches(String countVariable, FileRef log, ArrayList<StfProcess> runningProcesses, String... expectedResultMessages) throws StfException {\n\t\t// Build the if statement arguments\n\t\tStringBuilder ifArgs = new StringBuilder();\n\t\t\n\t\t// Ensure that supports the checking of multiple messages\n\t\tboolean multipleResultMessageValues = false;\n\t\tfor (String expectedResultMessage : expectedResultMessages) {\n\t\t\tif (multipleResultMessageValues) {\n\t\t\t\tifArgs.append(\" || \");\n\t\t\t}\n\t\t\tifArgs.append(\"$line =~ '\" + expectedResultMessage + \"'\");\n\t\t\tmultipleResultMessageValues = true;\n\t\t}\n\t\t\n\t\t// Build the perl code that loops through the log and does the regex matching\n\t\toutputLine(\"unless (open(LOG, \" + \"'\" + log + \"' )) {\");\n\t\tincreaseIndentation();\n\t\toutputDieCommand(runningProcesses, \"Could not open log\");\n\t\tdecreaseIndentation();\n\t\toutputLine(\"}\");\t\n\t\toutputEmptyLine();\n\t\t\n\t\toutputVariableInitialisation(countVariable, \"0\");\n\t\toutputLine(\"while (my $line = <LOG>) {\"); \n\t\toutputLine(\"    if (\" + ifArgs + \") {\");\n\t\toutputLine(\"        \" + countVariable + \"++;\");\n\t\toutputLine(\"    }\");\n\t\toutputLine(\"}\");\n\t\toutputLine(\"close(LOG);\");\n\t}\n\t\n\t\n\t/**\n\t * Generates perl code to echo the contents of a file to standard output.\n\t * @param targetFile points to the file to be read\n\t * @param runningProcesses are the processes that need to be killed if the file cannot be opened.\n\t */\n\tpublic void outputEchoFile(FileRef targetFile, ArrayList<StfProcess> runningProcesses) throws StfException {\n\t\t// Open the target file\n\t\toutputLine(\"unless (open(LOG, \" + \"'\" + targetFile + \"' )) {\");\n\t\tincreaseIndentation();\n\t\toutputDieCommand(runningProcesses, \"Failed to open file for contents echoing at: \" + targetFile);\n\t\tdecreaseIndentation();\n\t\toutputLine(\"}\");\t\n\t\toutputEmptyLine();\n\n\t\t// Read and echo every line of target file\n\t\toutputLine(\"info('Echoing contents of file \" + targetFile + \"');\");\n\t\toutputLine(\"info('>>>>>>');\");\n\t\t\n\t\toutputLine(\"while (my $line = <LOG>) {\"); \n\t\toutputLine(\"    print($line);\");\n\t\toutputLine(\"}\");\n\t\toutputLine(\"close(LOG);\");\n\t\t\n\t\toutputLine(\"info('<<<<<<');\");\n\t\toutputLine(\"info('Ending echo for file \" + targetFile + \"');\");\n\t}\n\t\n\t\n\t\n\t/**\n\t * This method increases the indentation depth \n\t */\n\tpublic void increaseIndentation() {\n\t\tindentationDepth++;\n\t}\n\t\n\t\n\t/**\n\t * This method decreases the indentation depth\n\t */\n\tpublic void decreaseIndentation() {\n\t\tindentationDepth--;\n\t}"
    },
    "129": {
      "metadata": {
        "chunk_id": "b3bf6bb99c8ba5dcca3c1fa78b26133b0a58c579a04a15112d5b3245d46f245a",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "// Read and echo every line of target file\n\t\toutputLine(\"info('Echoing contents of file \" + targetFile + \"');\");\n\t\toutputLine(\"info('>>>>>>');\");\n\t\t\n\t\toutputLine(\"while (my $line = <LOG>) {\"); \n\t\toutputLine(\"    print($line);\");\n\t\toutputLine(\"}\");\n\t\toutputLine(\"close(LOG);\");\n\t\t\n\t\toutputLine(\"info('<<<<<<');\");\n\t\toutputLine(\"info('Ending echo for file \" + targetFile + \"');\");\n\t}\n\t\n\t\n\t\n\t/**\n\t * This method increases the indentation depth \n\t */\n\tpublic void increaseIndentation() {\n\t\tindentationDepth++;\n\t}\n\t\n\t\n\t/**\n\t * This method decreases the indentation depth\n\t */\n\tpublic void decreaseIndentation() {\n\t\tindentationDepth--;\n\t}\n\t\n\n\t/**\n\t * This method gets the indentation depth and returns the indentation string\n\t * \n\t * @return the indentation string \n\t */\n\tprivate String getIndentation() {\n\t\tStringBuilder indentationArgs = new StringBuilder();\n\t\t\n\t\tfor (int indentationLevel=0; indentationLevel<indentationDepth; indentationLevel++) {\n\t\t\tindentationArgs.append(\"    \");\n\t\t}\n\t\t\n\t\treturn indentationArgs.toString();\n\t}\n\t\n\t\n\t/**\n\t * Adds a block of perl which makes sure that a perl variable is set to '0'.\n\t * If the perl variable has a different value then an error message is produced and the \n\t * process aborts.\n\t * \n\t * @param command is a short description of the command for which code is being generated.\n\t * @param comment is a description from the test plugin describing why the current command is being run.\n\t * @param resultVariable is the perl variable whose result is being checked.\n\t * @param runningProcesses is a list of processes which could still be running, and need to be killed before the script dies.\n\t * @throws StfException if 'resultVariable' is not a valid perl variable name or if we fail to write to the output file.\n\t */\n\tpublic void outputErrorCheck(String command, String comment, String resultVariable, ArrayList<StfProcess> runningProcesses) throws StfException {\n\t\tif (!resultVariable.startsWith(\"@\")) {\n\t\t\tthrow new StfException(\"Variable must be an array\");\n\t\t}\n\t\t\n\t\toutputLine(\"if ( defined (\" + resultVariable + \"[0] ) ) {\");\n\t\tincreaseIndentation();\n\t\toutputLine(\"stf::stfUtility->listErrors( \" + resultVariable + \");\");\n\t\toutputDieCommand(runningProcesses, StfConstants.FAILURE_PREFIX + \"at \" + describeCommand(command, comment));\n\t\tdecreaseIndentation();\n\t\toutputLine(\"}\");\n    }\n\t\n\n\tpublic String describeCommand(String command, String comment) { \n\t\treturn \"step \" + PerlCodeGenerator.commandSerialNum + \" (\" + comment + \")\";\n\t}\n\n\t\n\t/**\n\t * Adds a line of perl code to the output file. \n\t * The code is prefixed with indentation, which can be set by the caller \n\t * using the increaseIndentation() and decreaseIndentation() public methods.\n\t * The caller is responsible for making sure it is valid perl code and the indentation level is correct.\n\t * \n\t * @param perlCode is a String containing the perl code to write.\n\t * @throws StfException if there is an IO exception when writing to the file.\n\t */\n\tpublic void outputLine(String perlCode) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"perl code generation 'do' methods cannot be used during the initialisation stage\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tperlFile.write(getIndentation() + perlCode + \"\\n\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to write to perl output: \" + outputFile, e);\n\t\t}\n\t}\n\n\t\n\tpublic void outputEmptyLine() throws StfException {\n\t\toutputLine(\"\");\n\t}\n\n\n\t/**\n\t * When the generation of the perl script is complete then the STF framework will call this \n\t * method to close off the output file.\n\t * \n\t * @doExitCommand set to true if a perl exit command needs to be generated.\n\t * @throws StfException if there is an IO exception.\n\t */\n\tpublic void closeOutput(boolean doExitCommand) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\treturn;\n\t\t}",
        "start_line": 991,
        "end_line": 1105,
        "chunk_index": 14,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 928,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832425"
      },
      "text": "// Read and echo every line of target file\n\t\toutputLine(\"info('Echoing contents of file \" + targetFile + \"');\");\n\t\toutputLine(\"info('>>>>>>');\");\n\t\t\n\t\toutputLine(\"while (my $line = <LOG>) {\"); \n\t\toutputLine(\"    print($line);\");\n\t\toutputLine(\"}\");\n\t\toutputLine(\"close(LOG);\");\n\t\t\n\t\toutputLine(\"info('<<<<<<');\");\n\t\toutputLine(\"info('Ending echo for file \" + targetFile + \"');\");\n\t}\n\t\n\t\n\t\n\t/**\n\t * This method increases the indentation depth \n\t */\n\tpublic void increaseIndentation() {\n\t\tindentationDepth++;\n\t}\n\t\n\t\n\t/**\n\t * This method decreases the indentation depth\n\t */\n\tpublic void decreaseIndentation() {\n\t\tindentationDepth--;\n\t}\n\t\n\n\t/**\n\t * This method gets the indentation depth and returns the indentation string\n\t * \n\t * @return the indentation string \n\t */\n\tprivate String getIndentation() {\n\t\tStringBuilder indentationArgs = new StringBuilder();\n\t\t\n\t\tfor (int indentationLevel=0; indentationLevel<indentationDepth; indentationLevel++) {\n\t\t\tindentationArgs.append(\"    \");\n\t\t}\n\t\t\n\t\treturn indentationArgs.toString();\n\t}\n\t\n\t\n\t/**\n\t * Adds a block of perl which makes sure that a perl variable is set to '0'.\n\t * If the perl variable has a different value then an error message is produced and the \n\t * process aborts.\n\t * \n\t * @param command is a short description of the command for which code is being generated.\n\t * @param comment is a description from the test plugin describing why the current command is being run.\n\t * @param resultVariable is the perl variable whose result is being checked.\n\t * @param runningProcesses is a list of processes which could still be running, and need to be killed before the script dies.\n\t * @throws StfException if 'resultVariable' is not a valid perl variable name or if we fail to write to the output file.\n\t */\n\tpublic void outputErrorCheck(String command, String comment, String resultVariable, ArrayList<StfProcess> runningProcesses) throws StfException {\n\t\tif (!resultVariable.startsWith(\"@\")) {\n\t\t\tthrow new StfException(\"Variable must be an array\");\n\t\t}\n\t\t\n\t\toutputLine(\"if ( defined (\" + resultVariable + \"[0] ) ) {\");\n\t\tincreaseIndentation();\n\t\toutputLine(\"stf::stfUtility->listErrors( \" + resultVariable + \");\");\n\t\toutputDieCommand(runningProcesses, StfConstants.FAILURE_PREFIX + \"at \" + describeCommand(command, comment));\n\t\tdecreaseIndentation();\n\t\toutputLine(\"}\");\n    }\n\t\n\n\tpublic String describeCommand(String command, String comment) { \n\t\treturn \"step \" + PerlCodeGenerator.commandSerialNum + \" (\" + comment + \")\";\n\t}\n\n\t\n\t/**\n\t * Adds a line of perl code to the output file. \n\t * The code is prefixed with indentation, which can be set by the caller \n\t * using the increaseIndentation() and decreaseIndentation() public methods.\n\t * The caller is responsible for making sure it is valid perl code and the indentation level is correct.\n\t * \n\t * @param perlCode is a String containing the perl code to write.\n\t * @throws StfException if there is an IO exception when writing to the file.\n\t */\n\tpublic void outputLine(String perlCode) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"perl code generation 'do' methods cannot be used during the initialisation stage\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tperlFile.write(getIndentation() + perlCode + \"\\n\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to write to perl output: \" + outputFile, e);\n\t\t}\n\t}\n\n\t\n\tpublic void outputEmptyLine() throws StfException {\n\t\toutputLine(\"\");\n\t}\n\n\n\t/**\n\t * When the generation of the perl script is complete then the STF framework will call this \n\t * method to close off the output file.\n\t * \n\t * @doExitCommand set to true if a perl exit command needs to be generated.\n\t * @throws StfException if there is an IO exception.\n\t */\n\tpublic void closeOutput(boolean doExitCommand) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\treturn;\n\t\t}"
    },
    "130": {
      "metadata": {
        "chunk_id": "49c871768526b164979bbb8525362ad37bab2f7be7349742c717f1301f5e2c4e",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/PerlCodeGenerator.java",
        "content": "public void outputEmptyLine() throws StfException {\n\t\toutputLine(\"\");\n\t}\n\n\n\t/**\n\t * When the generation of the perl script is complete then the STF framework will call this \n\t * method to close off the output file.\n\t * \n\t * @doExitCommand set to true if a perl exit command needs to be generated.\n\t * @throws StfException if there is an IO exception.\n\t */\n\tpublic void closeOutput(boolean doExitCommand) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (doExitCommand) {\n\t\t\toutputEmptyLine();\n\t\t\toutputEmptyLine();\n\t\t\toutputLine(\"info('\" + environmentCore.getStage() + \" stage completed');\");\n\t\t\toutputLine(\"exit 0;\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tperlFile.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to close perl output: \" + outputFile, e);\n\t\t}\n\t}\n\t\n\t\n\tpublic void summariseGeneratedCommands() {\n\t\tfor (String commandSummary : commandSummaryLog) {\n\t\t\tlogger.info(commandSummary);\n\t\t}\n\t}\n}",
        "start_line": 1106,
        "end_line": 1143,
        "chunk_index": 15,
        "total_chunks": 16,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 242,
        "node_type": null,
        "file_sha": "f9a6274e6acf8aea2ec8a48dafd01119f922c485",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.832428"
      },
      "text": "public void outputEmptyLine() throws StfException {\n\t\toutputLine(\"\");\n\t}\n\n\n\t/**\n\t * When the generation of the perl script is complete then the STF framework will call this \n\t * method to close off the output file.\n\t * \n\t * @doExitCommand set to true if a perl exit command needs to be generated.\n\t * @throws StfException if there is an IO exception.\n\t */\n\tpublic void closeOutput(boolean doExitCommand) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (doExitCommand) {\n\t\t\toutputEmptyLine();\n\t\t\toutputEmptyLine();\n\t\t\toutputLine(\"info('\" + environmentCore.getStage() + \" stage completed');\");\n\t\t\toutputLine(\"exit 0;\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tperlFile.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to close perl output: \" + outputFile, e);\n\t\t}\n\t}\n\t\n\t\n\tpublic void summariseGeneratedCommands() {\n\t\tfor (String commandSummary : commandSummaryLog) {\n\t\t\tlogger.info(commandSummary);\n\t\t}\n\t}\n}"
    },
    "131": {
      "metadata": {
        "chunk_id": "b7cbcabd206227d3d87c3ffaf2074dde47cd52113057b37245ab238d673d7148",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/codeGeneration/Stage.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.codeGeneration;\n\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.extensions.Stf;\n\n/** \n * This class represents the different stages of code generation.\n * \n * Extensions and test plugins sometimes need to know which stage they are \n * working on so that the can vary the code being produced. \n * For example, only the execution stage should be running with full JVM arguments.\n */\npublic enum Stage { \n\tINITIALISATION(\"pluginInit\", null),\n\tSETUP         (\"setUp\",      Stf.ARG_JAVA_ARGS_SETUP),\n\tEXECUTE       (\"execute\",    Stf.ARG_JAVA_ARGS_EXECUTE, Stf.ARG_JAVA_ARGS_EXECUTE_SECONDARY),\n\tTEARDOWN      (\"tearDown\",   Stf.ARG_JAVA_ARGS_TEARDOWN);\n\t\n\tprivate String methodName;\n\tprivate Argument primaryJavaArg; \n\tprivate Argument secondaryJavaArg; \n\t\n\tprivate Stage(String methodName, Argument javaArg) {\n\t\tthis.methodName = methodName;\n\t\tthis.primaryJavaArg   = javaArg;\n\t\tthis.secondaryJavaArg = javaArg;\n\t}\n\n\tprivate Stage(String methodName, Argument primaryJavaArg, Argument secondaryJavaArg) {\n\t\tthis.methodName = methodName;\n\t\tthis.primaryJavaArg   = primaryJavaArg;\n\t\tthis.secondaryJavaArg = secondaryJavaArg;\n\t}\n\t\t\n\tpublic String getMethodName() {\n\t\treturn methodName;\n\t}\n\t\n\t/**\n\t * @return The argument which will contain Java arguments for the stage.\n\t */\n\tpublic Argument getJavaArg(JavaVersion javaVersion) {\n\t\tif (javaVersion.isPrimaryJvm()) {\n\t\t\treturn primaryJavaArg;\n\t\t} else {\n\t\t\treturn secondaryJavaArg;\n\t\t}\n\t}\n};",
        "start_line": 0,
        "end_line": 63,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 490,
        "node_type": null,
        "file_sha": "8abe3618024c54b47884f9a055f61adf9ccb3cc7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.845251"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.codeGeneration;\n\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.extensions.Stf;\n\n/** \n * This class represents the different stages of code generation.\n * \n * Extensions and test plugins sometimes need to know which stage they are \n * working on so that the can vary the code being produced. \n * For example, only the execution stage should be running with full JVM arguments.\n */\npublic enum Stage { \n\tINITIALISATION(\"pluginInit\", null),\n\tSETUP         (\"setUp\",      Stf.ARG_JAVA_ARGS_SETUP),\n\tEXECUTE       (\"execute\",    Stf.ARG_JAVA_ARGS_EXECUTE, Stf.ARG_JAVA_ARGS_EXECUTE_SECONDARY),\n\tTEARDOWN      (\"tearDown\",   Stf.ARG_JAVA_ARGS_TEARDOWN);\n\t\n\tprivate String methodName;\n\tprivate Argument primaryJavaArg; \n\tprivate Argument secondaryJavaArg; \n\t\n\tprivate Stage(String methodName, Argument javaArg) {\n\t\tthis.methodName = methodName;\n\t\tthis.primaryJavaArg   = javaArg;\n\t\tthis.secondaryJavaArg = javaArg;\n\t}\n\n\tprivate Stage(String methodName, Argument primaryJavaArg, Argument secondaryJavaArg) {\n\t\tthis.methodName = methodName;\n\t\tthis.primaryJavaArg   = primaryJavaArg;\n\t\tthis.secondaryJavaArg = secondaryJavaArg;\n\t}\n\t\t\n\tpublic String getMethodName() {\n\t\treturn methodName;\n\t}\n\t\n\t/**\n\t * @return The argument which will contain Java arguments for the stage.\n\t */\n\tpublic Argument getJavaArg(JavaVersion javaVersion) {\n\t\tif (javaVersion.isPrimaryJvm()) {\n\t\t\treturn primaryJavaArg;\n\t\t} else {\n\t\t\treturn secondaryJavaArg;\n\t\t}\n\t}\n};"
    },
    "132": {
      "metadata": {
        "chunk_id": "2985decaddd83b07872075116d7b7aae05269a510b1525ebbe4d0a5f936cc482",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/DirectoryRef.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * This class represents a directory, as known to a specific test case.\n * \n * The test plugin does not know the absolute directory represented by an instance \n * of this class.\n * This is a deliberate choice, and is done to simplify the test cases and also \n * ensure that they remain platform independent.\n */",
        "start_line": 0,
        "end_line": 32,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 243,
        "node_type": null,
        "file_sha": "88c3004ee3aaabe3f629fd6ac773054123d83c35",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.854337"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * This class represents a directory, as known to a specific test case.\n * \n * The test plugin does not know the absolute directory represented by an instance \n * of this class.\n * This is a deliberate choice, and is done to simplify the test cases and also \n * ensure that they remain platform independent.\n */"
    },
    "133": {
      "metadata": {
        "chunk_id": "530954b771f252789b408cec11130e4c705920a157e25b7d0a1c57ab00a11c13",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/DirectoryRef.java",
        "content": "public class DirectoryRef {\n\tprivate String fileName;\n\t\n\tDirectoryRef(String fileName) throws StfException {\n\t\tString trimmedFileName = fileName.trim();\n\t\t\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\t// Replace all of the windows file separators with the linux equivalent.\n\t\t\ttrimmedFileName = trimmedFileName.replaceAll(\"\\\\\\\\\", \"/\");  // Check that the file spec is windows compliant.\n\t\t\t// And then we remove duplicates, as Windows paths can cause recursive backslashing.\n\t\t\twhile (trimmedFileName.contains(\"//\")) {\n\t\t\t\ttrimmedFileName = trimmedFileName.replaceAll(\"//\", \"/\");  // Check that the file spec is windows compliant.\n\t\t\t}\n\t\t\tthis.fileName = trimmedFileName;\n\t\t} else {\n\t\t\tif (trimmedFileName.startsWith(\"~\")) {\n\t\t\t\tString homeDir = System.getProperties().getProperty(\"user.home\");\n\t\t\t\tthis.fileName = trimmedFileName.replace(\"~\", homeDir);\n\t\t\t} else if (trimmedFileName.startsWith(\"/\")) {\n\t\t\t\tthis.fileName = trimmedFileName;\n\t\t\t} else if (trimmedFileName.startsWith(\".\")) {\n\t\t\t\tthis.fileName = trimmedFileName;\n\t\t\t} else {\n\t\t\t\tthrow new StfException(\"Invalid directory specification: '\" + fileName + \"'. \"\n\t\t\t\t\t\t+ \"Must start with either '~', '/' or '.'\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Normailze paths that contain \"..\" where possible \n\t\tif (this.fileName.contains(\"..\")) { \n\t\t\tif (this.fileName.endsWith(\"/..\")) {\n\t\t\t\t// Throw an exception if we're attempting to go \"up\" the path from root.\n\t\t\t\tif( this.fileName.equals(\"/..\") || this.fileName.substring(1).equals(\":/..\") ) {\n\t\t\t\t\tthis.fileName = this.fileName.substring(0, this.fileName.length() - 3);\n\t\t\t\t\tthrow new StfException(\"Directory \" + this.fileName\t+ \" does not have a parent directory,\"\n\t\t\t\t\t\t\t\t\t+ \" so \" + this.fileName + \"/.. will not work. Setting to \" + this.fileName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If it's a relative directory, we can't be sure if it does/does not exist \n\t\t\t// until we're ready to check if it exists, so ignore the ..'s.\n\t\t\telse if(this.fileName.startsWith(\"./..\")) {\n\t\t\t\treturn;\n\t\t\t// Make file names more readable by converting '/a/b/../../c/d/e/f/../..' to '/c/d', etc, where possible.\n\t\t\t} else {\n\t\t\t\tPath p1 = Paths.get(this.fileName);\n\t\t\t\tString normalizedPath = p1.normalize().toString();\n\t\t\t\tif (normalizedPath.length() > 0) {\n\t\t\t\t\tthis.fileName = normalizedPath; \n\t\t\t\t\tif (PlatformFinder.isWindows()) {\n\t\t\t\t\t\t// Replace all of the windows file separators with the linux equivalent.\n\t\t\t\t\t\tthis.fileName = this.fileName.replaceAll(\"\\\\\\\\\", \"/\");   \n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\t\n\t/**\n\t * Create a reference to a file which lives below this directory reference.\n\t * @param subdirs is a string describing the file. eg 'bin/java.properties'\n\t */\n\tpublic FileRef childFile(String subdirs) throws StfException {\n\t\tif (subdirs.startsWith(\"/\")) {\n\t\t\tsubdirs = subdirs.substring(1);\n\t\t}\n\t\t\n\t\tif (subdirs.startsWith(\"~\")) {\n\t\t\tthrow new StfException(\"Invalid sub directory specification. Must not start with '~'. \"\n\t\t\t\t\t+ \"Parent directory: '\" + fileName + \"'. \"\n\t\t\t\t\t+ \"Invalid child directory: '\" + subdirs + \"'\");\n\t\t}\n\t\n\t\tif (subdirs.contains(\"\\\\\")) {\n\t\t\tthrow new StfException(\"Invalid file specification. The relative file name cannot contain windows style file separators: \" + subdirs);\n\t\t}\n\t\t\n\t\tString join = fileName.endsWith(\"/\") ? \"\" : \"/\";\t\n\t\treturn new FileRef(fileName + join + subdirs.trim());\n\t}\n\n\t\n\t/**\n\t * Create a reference to a directory which lives below this directory reference.\n\t * @param subdirs is a string describing the sub directory. eg 'bin' or 'bin/java'\n\t */\n\tpublic DirectoryRef childDirectory(String subdirs) throws StfException {\n\t\tif (subdirs.startsWith(\"~\") || subdirs.startsWith(\"/\")) {\n\t\t\tthrow new StfException(\"Invalid sub directory specification. Must not start with either '~' or '/'. \"\n\t\t\t\t\t+ \"Parent directory: '\" + fileName + \"'. \"\n\t\t\t\t\t+ \"Invalid child directory: '\" + subdirs + \"'\");\n\t\t}",
        "start_line": 33,
        "end_line": 124,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 919,
        "node_type": null,
        "file_sha": "88c3004ee3aaabe3f629fd6ac773054123d83c35",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.854346"
      },
      "text": "public class DirectoryRef {\n\tprivate String fileName;\n\t\n\tDirectoryRef(String fileName) throws StfException {\n\t\tString trimmedFileName = fileName.trim();\n\t\t\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\t// Replace all of the windows file separators with the linux equivalent.\n\t\t\ttrimmedFileName = trimmedFileName.replaceAll(\"\\\\\\\\\", \"/\");  // Check that the file spec is windows compliant.\n\t\t\t// And then we remove duplicates, as Windows paths can cause recursive backslashing.\n\t\t\twhile (trimmedFileName.contains(\"//\")) {\n\t\t\t\ttrimmedFileName = trimmedFileName.replaceAll(\"//\", \"/\");  // Check that the file spec is windows compliant.\n\t\t\t}\n\t\t\tthis.fileName = trimmedFileName;\n\t\t} else {\n\t\t\tif (trimmedFileName.startsWith(\"~\")) {\n\t\t\t\tString homeDir = System.getProperties().getProperty(\"user.home\");\n\t\t\t\tthis.fileName = trimmedFileName.replace(\"~\", homeDir);\n\t\t\t} else if (trimmedFileName.startsWith(\"/\")) {\n\t\t\t\tthis.fileName = trimmedFileName;\n\t\t\t} else if (trimmedFileName.startsWith(\".\")) {\n\t\t\t\tthis.fileName = trimmedFileName;\n\t\t\t} else {\n\t\t\t\tthrow new StfException(\"Invalid directory specification: '\" + fileName + \"'. \"\n\t\t\t\t\t\t+ \"Must start with either '~', '/' or '.'\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Normailze paths that contain \"..\" where possible \n\t\tif (this.fileName.contains(\"..\")) { \n\t\t\tif (this.fileName.endsWith(\"/..\")) {\n\t\t\t\t// Throw an exception if we're attempting to go \"up\" the path from root.\n\t\t\t\tif( this.fileName.equals(\"/..\") || this.fileName.substring(1).equals(\":/..\") ) {\n\t\t\t\t\tthis.fileName = this.fileName.substring(0, this.fileName.length() - 3);\n\t\t\t\t\tthrow new StfException(\"Directory \" + this.fileName\t+ \" does not have a parent directory,\"\n\t\t\t\t\t\t\t\t\t+ \" so \" + this.fileName + \"/.. will not work. Setting to \" + this.fileName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If it's a relative directory, we can't be sure if it does/does not exist \n\t\t\t// until we're ready to check if it exists, so ignore the ..'s.\n\t\t\telse if(this.fileName.startsWith(\"./..\")) {\n\t\t\t\treturn;\n\t\t\t// Make file names more readable by converting '/a/b/../../c/d/e/f/../..' to '/c/d', etc, where possible.\n\t\t\t} else {\n\t\t\t\tPath p1 = Paths.get(this.fileName);\n\t\t\t\tString normalizedPath = p1.normalize().toString();\n\t\t\t\tif (normalizedPath.length() > 0) {\n\t\t\t\t\tthis.fileName = normalizedPath; \n\t\t\t\t\tif (PlatformFinder.isWindows()) {\n\t\t\t\t\t\t// Replace all of the windows file separators with the linux equivalent.\n\t\t\t\t\t\tthis.fileName = this.fileName.replaceAll(\"\\\\\\\\\", \"/\");   \n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\t\n\t/**\n\t * Create a reference to a file which lives below this directory reference.\n\t * @param subdirs is a string describing the file. eg 'bin/java.properties'\n\t */\n\tpublic FileRef childFile(String subdirs) throws StfException {\n\t\tif (subdirs.startsWith(\"/\")) {\n\t\t\tsubdirs = subdirs.substring(1);\n\t\t}\n\t\t\n\t\tif (subdirs.startsWith(\"~\")) {\n\t\t\tthrow new StfException(\"Invalid sub directory specification. Must not start with '~'. \"\n\t\t\t\t\t+ \"Parent directory: '\" + fileName + \"'. \"\n\t\t\t\t\t+ \"Invalid child directory: '\" + subdirs + \"'\");\n\t\t}\n\t\n\t\tif (subdirs.contains(\"\\\\\")) {\n\t\t\tthrow new StfException(\"Invalid file specification. The relative file name cannot contain windows style file separators: \" + subdirs);\n\t\t}\n\t\t\n\t\tString join = fileName.endsWith(\"/\") ? \"\" : \"/\";\t\n\t\treturn new FileRef(fileName + join + subdirs.trim());\n\t}\n\n\t\n\t/**\n\t * Create a reference to a directory which lives below this directory reference.\n\t * @param subdirs is a string describing the sub directory. eg 'bin' or 'bin/java'\n\t */\n\tpublic DirectoryRef childDirectory(String subdirs) throws StfException {\n\t\tif (subdirs.startsWith(\"~\") || subdirs.startsWith(\"/\")) {\n\t\t\tthrow new StfException(\"Invalid sub directory specification. Must not start with either '~' or '/'. \"\n\t\t\t\t\t+ \"Parent directory: '\" + fileName + \"'. \"\n\t\t\t\t\t+ \"Invalid child directory: '\" + subdirs + \"'\");\n\t\t}"
    },
    "134": {
      "metadata": {
        "chunk_id": "42eb85220a4044b6eb6ef9dc0ac01fbcc69d8d2fa01ff6a8c68488d708712cf7",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/DirectoryRef.java",
        "content": "/**\n\t * Create a reference to a directory which lives below this directory reference.\n\t * @param subdirs is a string describing the sub directory. eg 'bin' or 'bin/java'\n\t */\n\tpublic DirectoryRef childDirectory(String subdirs) throws StfException {\n\t\tif (subdirs.startsWith(\"~\") || subdirs.startsWith(\"/\")) {\n\t\t\tthrow new StfException(\"Invalid sub directory specification. Must not start with either '~' or '/'. \"\n\t\t\t\t\t+ \"Parent directory: '\" + fileName + \"'. \"\n\t\t\t\t\t+ \"Invalid child directory: '\" + subdirs + \"'\");\n\t\t}\n\n\t\tif (subdirs.contains(\"\\\\\")) {\n\t\t\tthrow new StfException(\"Invalid file specification. The relative file name cannot contain windows style file separators: \" + subdirs);\n\t\t}\n\t\n\t\tString join = fileName.endsWith(\"/\") ? \"\" : \"/\";\t\n\t\treturn new DirectoryRef(fileName + join + subdirs.trim());\n\t}\n\t\n\n\t/**\n\t * This is a utility function takes in the full path of a file and returns the part of the \n\t * string which is below the current directory reference.\n\t * For example,\n\t *   dir ref   = /stf/results\n\t *   file spec = /stf/results/12.inventory/load/mauvetests.xml\n\t *   returns   = 12.inventory/load/mauvetests.xml\n\t * @return the part of the file spec which is a child of the current directory.\n\t * @throws StfException if the supplied file specification is a file not below the current directory reference.\n\t */\n\tpublic String getSubpathOf(String fileSpec) throws StfException {\n\t\t// Get platform independent versions of the supplied file spec and the current directoryRef\n\t\tfileSpec = fileSpec.replace(\"\\\\\", \"/\").replace(\"//\", \"/\");\n\t\tString thisDirSpec = fileName;\n\t\t\n\t\tif (!fileSpec.startsWith(thisDirSpec)) {\n\t\t\tthrow new StfException(\"Referenced file is not a child of the current directory reference. \" \n\t\t\t\t\t\t+ \" File: \" + fileSpec + \" in not below: \" + thisDirSpec);\n\t\t}\n\n\t\tString uniquePart = fileSpec.substring(thisDirSpec.length()+1);\n\t\t\n\t\treturn uniquePart;\n\t}\n\n\t\n\t/**\n\t * Convert the current file reference to a Java File object.\n\t * Note: the Java File object is platform specific.\n\t * @throws StfException \n\t */\n\tpublic File asJavaFile() throws StfException {\n\t\treturn new File(getSpec());\n\t}\n\t\n\n\t/**\n\t * Return the platform specific absolute location of the current directory reference.\n\t * @throws StfException \n\t */\n\tpublic String getSpec() throws StfException {\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\treturn fileName.replace(\"/\", \"\\\\\\\\\");\n\t\t}\n\t\t \n\t\treturn fileName;\n\t}\n\n\t\n\t/**\n\t * Return the platform independent location of the current directory reference.\n\t */\n\tpublic String getPath() {\n\t\treturn fileName;\n\t}\n\t\n\n\tpublic String toString() {\n\t\ttry {\n\t\t\treturn getSpec();\n\t\t} catch (StfException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\n\tpublic boolean exists() throws StfException {\n\t\treturn asJavaFile().exists();\n\t}\n\n\n\tpublic DirectoryRef getParent() throws StfException {\n\t\treturn new DirectoryRef(fileName + \"/..\");\n\t}",
        "start_line": 125,
        "end_line": 219,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 695,
        "node_type": null,
        "file_sha": "88c3004ee3aaabe3f629fd6ac773054123d83c35",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.854349"
      },
      "text": "/**\n\t * Create a reference to a directory which lives below this directory reference.\n\t * @param subdirs is a string describing the sub directory. eg 'bin' or 'bin/java'\n\t */\n\tpublic DirectoryRef childDirectory(String subdirs) throws StfException {\n\t\tif (subdirs.startsWith(\"~\") || subdirs.startsWith(\"/\")) {\n\t\t\tthrow new StfException(\"Invalid sub directory specification. Must not start with either '~' or '/'. \"\n\t\t\t\t\t+ \"Parent directory: '\" + fileName + \"'. \"\n\t\t\t\t\t+ \"Invalid child directory: '\" + subdirs + \"'\");\n\t\t}\n\n\t\tif (subdirs.contains(\"\\\\\")) {\n\t\t\tthrow new StfException(\"Invalid file specification. The relative file name cannot contain windows style file separators: \" + subdirs);\n\t\t}\n\t\n\t\tString join = fileName.endsWith(\"/\") ? \"\" : \"/\";\t\n\t\treturn new DirectoryRef(fileName + join + subdirs.trim());\n\t}\n\t\n\n\t/**\n\t * This is a utility function takes in the full path of a file and returns the part of the \n\t * string which is below the current directory reference.\n\t * For example,\n\t *   dir ref   = /stf/results\n\t *   file spec = /stf/results/12.inventory/load/mauvetests.xml\n\t *   returns   = 12.inventory/load/mauvetests.xml\n\t * @return the part of the file spec which is a child of the current directory.\n\t * @throws StfException if the supplied file specification is a file not below the current directory reference.\n\t */\n\tpublic String getSubpathOf(String fileSpec) throws StfException {\n\t\t// Get platform independent versions of the supplied file spec and the current directoryRef\n\t\tfileSpec = fileSpec.replace(\"\\\\\", \"/\").replace(\"//\", \"/\");\n\t\tString thisDirSpec = fileName;\n\t\t\n\t\tif (!fileSpec.startsWith(thisDirSpec)) {\n\t\t\tthrow new StfException(\"Referenced file is not a child of the current directory reference. \" \n\t\t\t\t\t\t+ \" File: \" + fileSpec + \" in not below: \" + thisDirSpec);\n\t\t}\n\n\t\tString uniquePart = fileSpec.substring(thisDirSpec.length()+1);\n\t\t\n\t\treturn uniquePart;\n\t}\n\n\t\n\t/**\n\t * Convert the current file reference to a Java File object.\n\t * Note: the Java File object is platform specific.\n\t * @throws StfException \n\t */\n\tpublic File asJavaFile() throws StfException {\n\t\treturn new File(getSpec());\n\t}\n\t\n\n\t/**\n\t * Return the platform specific absolute location of the current directory reference.\n\t * @throws StfException \n\t */\n\tpublic String getSpec() throws StfException {\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\treturn fileName.replace(\"/\", \"\\\\\\\\\");\n\t\t}\n\t\t \n\t\treturn fileName;\n\t}\n\n\t\n\t/**\n\t * Return the platform independent location of the current directory reference.\n\t */\n\tpublic String getPath() {\n\t\treturn fileName;\n\t}\n\t\n\n\tpublic String toString() {\n\t\ttry {\n\t\t\treturn getSpec();\n\t\t} catch (StfException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\n\tpublic boolean exists() throws StfException {\n\t\treturn asJavaFile().exists();\n\t}\n\n\n\tpublic DirectoryRef getParent() throws StfException {\n\t\treturn new DirectoryRef(fileName + \"/..\");\n\t}"
    },
    "135": {
      "metadata": {
        "chunk_id": "04248a588583c5edbe92bfdd2669df56ba07e53fca36a5a508a2ee5cf4afb7d6",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/DirectoryRef.java",
        "content": "/**\n\t * Return the platform specific absolute location of the current directory reference.\n\t * @throws StfException \n\t */\n\tpublic String getSpec() throws StfException {\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\treturn fileName.replace(\"/\", \"\\\\\\\\\");\n\t\t}\n\t\t \n\t\treturn fileName;\n\t}\n\n\t\n\t/**\n\t * Return the platform independent location of the current directory reference.\n\t */\n\tpublic String getPath() {\n\t\treturn fileName;\n\t}\n\t\n\n\tpublic String toString() {\n\t\ttry {\n\t\t\treturn getSpec();\n\t\t} catch (StfException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\n\tpublic boolean exists() throws StfException {\n\t\treturn asJavaFile().exists();\n\t}\n\n\n\tpublic DirectoryRef getParent() throws StfException {\n\t\treturn new DirectoryRef(fileName + \"/..\");\n\t}\n\n\n\t// Convert a File reference of the results directory into a DirectoryRef object\n\tpublic static DirectoryRef createResultsDirectoryRef(File resultsDir) throws StfException {\n\t\tif (!resultsDir.getAbsolutePath().endsWith(StfConstants.RESULTS_DIR)) {\n\t\t\tthrow new StfException(\"Invalid results directory: \" + resultsDir.getAbsolutePath());\n\t\t}\n\t\treturn new DirectoryRef(resultsDir.getAbsolutePath());\n\t}\n\t\n\t/**\n\t * Takes a directory path (without a root) and a list of test roots, and tries to find out which \n\t * root contains that directory. If it cannot be found, or is found multiple times, an exception \n\t * is thrown.\n\t * @param directoryRef  The path of the directory we are trying to find, minus the root.\n\t * @param testRootRefs  The potential roots of the path for the directory we're trying to find.\n\t * @return              A DirectoryRef for the root of the directory we were trying to find.\n\t * @throws StfException In case we cannot find the directory, or if we found it in more than one test root.\n\t */\n\tpublic static DirectoryRef findDirectoryRoot(String directoryRef, ArrayList<DirectoryRef> testRootRefs) throws StfException {\n\t\tint count = 0;\n\t\tDirectoryRef directoryRoot = new DirectoryRef(\"./ignore\");\n\t\tfor (int i = 0 ; i < testRootRefs.size() ; ++i ) {\n\t\t\ttry {\n\t\t\t\tfindDirectory(directoryRef, new ArrayList<DirectoryRef>(testRootRefs.subList(i, i+1)));\n\t\t\t\tdirectoryRoot = testRootRefs.get(i);\n\t\t\t\tcount++;\n\t\t\t} catch (StfException e) {\n\t\t\t\t//ignore;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (count != 1) {\n\t\t\t//This should produce the right error.\n\t\t\tfindDirectory(directoryRef, testRootRefs);\n\t\t}\n\t\t\n\t\treturn directoryRoot;\n\t}",
        "start_line": 220,
        "end_line": 297,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 570,
        "node_type": null,
        "file_sha": "88c3004ee3aaabe3f629fd6ac773054123d83c35",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.854352"
      },
      "text": "/**\n\t * Return the platform specific absolute location of the current directory reference.\n\t * @throws StfException \n\t */\n\tpublic String getSpec() throws StfException {\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\treturn fileName.replace(\"/\", \"\\\\\\\\\");\n\t\t}\n\t\t \n\t\treturn fileName;\n\t}\n\n\t\n\t/**\n\t * Return the platform independent location of the current directory reference.\n\t */\n\tpublic String getPath() {\n\t\treturn fileName;\n\t}\n\t\n\n\tpublic String toString() {\n\t\ttry {\n\t\t\treturn getSpec();\n\t\t} catch (StfException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\n\tpublic boolean exists() throws StfException {\n\t\treturn asJavaFile().exists();\n\t}\n\n\n\tpublic DirectoryRef getParent() throws StfException {\n\t\treturn new DirectoryRef(fileName + \"/..\");\n\t}\n\n\n\t// Convert a File reference of the results directory into a DirectoryRef object\n\tpublic static DirectoryRef createResultsDirectoryRef(File resultsDir) throws StfException {\n\t\tif (!resultsDir.getAbsolutePath().endsWith(StfConstants.RESULTS_DIR)) {\n\t\t\tthrow new StfException(\"Invalid results directory: \" + resultsDir.getAbsolutePath());\n\t\t}\n\t\treturn new DirectoryRef(resultsDir.getAbsolutePath());\n\t}\n\t\n\t/**\n\t * Takes a directory path (without a root) and a list of test roots, and tries to find out which \n\t * root contains that directory. If it cannot be found, or is found multiple times, an exception \n\t * is thrown.\n\t * @param directoryRef  The path of the directory we are trying to find, minus the root.\n\t * @param testRootRefs  The potential roots of the path for the directory we're trying to find.\n\t * @return              A DirectoryRef for the root of the directory we were trying to find.\n\t * @throws StfException In case we cannot find the directory, or if we found it in more than one test root.\n\t */\n\tpublic static DirectoryRef findDirectoryRoot(String directoryRef, ArrayList<DirectoryRef> testRootRefs) throws StfException {\n\t\tint count = 0;\n\t\tDirectoryRef directoryRoot = new DirectoryRef(\"./ignore\");\n\t\tfor (int i = 0 ; i < testRootRefs.size() ; ++i ) {\n\t\t\ttry {\n\t\t\t\tfindDirectory(directoryRef, new ArrayList<DirectoryRef>(testRootRefs.subList(i, i+1)));\n\t\t\t\tdirectoryRoot = testRootRefs.get(i);\n\t\t\t\tcount++;\n\t\t\t} catch (StfException e) {\n\t\t\t\t//ignore;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (count != 1) {\n\t\t\t//This should produce the right error.\n\t\t\tfindDirectory(directoryRef, testRootRefs);\n\t\t}\n\t\t\n\t\treturn directoryRoot;\n\t}"
    },
    "136": {
      "metadata": {
        "chunk_id": "1132032b8cc969c0bcd29e7e5fb8380cc8826f5bec06106cfecf61362abef139",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/DirectoryRef.java",
        "content": "/**\n\t * Takes a directory path (without a root) and a list of test roots, and tries to find that \n\t * directory inside each of those roots. If it cannot be found, or is found multiple times, \n\t * an exception is thrown.\n\t * @param directoryRef              The path of the directory we are trying to find, minus the root.\n\t * @param testRootRefs              The potential roots of the path for the directory we're trying to find.\n\t * @param errorPrefixes These are optional.\n\t *                      The first String will be prefixed onto the StfException message if the directory cannot be found.\n\t *                      The second String will be prefixed onto the StfException message if the directory is found more then once.\n\t *                      The third+ Strings will be ignored.\n\t * @return                          A DirectoryRef for the directory we were trying to find.\n\t * @throws StfException             In case we cannot find the directory, or if we found it in more than one test root.\n\t */\n\tpublic static DirectoryRef findDirectory(String directoryRef, ArrayList<DirectoryRef> testRootRefs, String... errorPrefixes) throws StfException {\n\t\tArrayList<DirectoryRef> matchingTestRoots = new ArrayList<DirectoryRef>();\n\t\tfor (DirectoryRef oneTestRoot : testRootRefs) {\n\t\t\tif (oneTestRoot.childDirectory(directoryRef).exists()) {\n\t\t\t\tmatchingTestRoots.add(oneTestRoot);\n\t\t\t}\n\t\t}\n\t\t//Check to see if we only found it.\n\t\tif (matchingTestRoots.size() == 0) {\n\t\t\t//First we assemble a list of test roots we searched in.\n\t\t\tString workspaces = \"\";\n\t\t\tfor (DirectoryRef oneTestRootRef : testRootRefs) {\n\t\t\t\tworkspaces = workspaces + \",'\" + oneTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error. \n\t\t\tString prefix = \"\";\n\t\t\tif (errorPrefixes.length > 0) {\n\t\t\t\tprefix = errorPrefixes[0] + \" \";\n\t\t\t}\n\t\t\tthrow new StfException(prefix + \"Note: directory '\" + directoryRef + \"' could not be found in any of the supplied roots: \" + workspaces.substring(1));\n\t\t}\n\t\t//Check to see if we only found it once.\n\t\tif (matchingTestRoots.size() > 1) {\n\t\t\t//First we assemble a list of test roots we found the directory in.\n\t\t\tString matchedWorkspaces = \"\";\n\t\t\tfor (DirectoryRef oneMatchingTestRootRef : matchingTestRoots) {\n\t\t\t\tmatchedWorkspaces = matchedWorkspaces + \",'\" + oneMatchingTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error. \n\t\t\tString prefix = \"\";\n\t\t\tif (errorPrefixes.length > 1) {\n\t\t\t\tprefix = errorPrefixes[1] + \" \";\n\t\t\t}\n\t\t\tthrow new StfException(prefix + \"Note: directory '\" + directoryRef + \"' was found multiple times, in this subset of the supplied test roots: \" + matchedWorkspaces.substring(1));\n\t\t}\n\t\t\n\t\t//Return the match.\n\t\treturn matchingTestRoots.get(0).childDirectory(directoryRef);\n\t}\n}",
        "start_line": 298,
        "end_line": 350,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 680,
        "node_type": null,
        "file_sha": "88c3004ee3aaabe3f629fd6ac773054123d83c35",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.854355"
      },
      "text": "/**\n\t * Takes a directory path (without a root) and a list of test roots, and tries to find that \n\t * directory inside each of those roots. If it cannot be found, or is found multiple times, \n\t * an exception is thrown.\n\t * @param directoryRef              The path of the directory we are trying to find, minus the root.\n\t * @param testRootRefs              The potential roots of the path for the directory we're trying to find.\n\t * @param errorPrefixes These are optional.\n\t *                      The first String will be prefixed onto the StfException message if the directory cannot be found.\n\t *                      The second String will be prefixed onto the StfException message if the directory is found more then once.\n\t *                      The third+ Strings will be ignored.\n\t * @return                          A DirectoryRef for the directory we were trying to find.\n\t * @throws StfException             In case we cannot find the directory, or if we found it in more than one test root.\n\t */\n\tpublic static DirectoryRef findDirectory(String directoryRef, ArrayList<DirectoryRef> testRootRefs, String... errorPrefixes) throws StfException {\n\t\tArrayList<DirectoryRef> matchingTestRoots = new ArrayList<DirectoryRef>();\n\t\tfor (DirectoryRef oneTestRoot : testRootRefs) {\n\t\t\tif (oneTestRoot.childDirectory(directoryRef).exists()) {\n\t\t\t\tmatchingTestRoots.add(oneTestRoot);\n\t\t\t}\n\t\t}\n\t\t//Check to see if we only found it.\n\t\tif (matchingTestRoots.size() == 0) {\n\t\t\t//First we assemble a list of test roots we searched in.\n\t\t\tString workspaces = \"\";\n\t\t\tfor (DirectoryRef oneTestRootRef : testRootRefs) {\n\t\t\t\tworkspaces = workspaces + \",'\" + oneTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error. \n\t\t\tString prefix = \"\";\n\t\t\tif (errorPrefixes.length > 0) {\n\t\t\t\tprefix = errorPrefixes[0] + \" \";\n\t\t\t}\n\t\t\tthrow new StfException(prefix + \"Note: directory '\" + directoryRef + \"' could not be found in any of the supplied roots: \" + workspaces.substring(1));\n\t\t}\n\t\t//Check to see if we only found it once.\n\t\tif (matchingTestRoots.size() > 1) {\n\t\t\t//First we assemble a list of test roots we found the directory in.\n\t\t\tString matchedWorkspaces = \"\";\n\t\t\tfor (DirectoryRef oneMatchingTestRootRef : matchingTestRoots) {\n\t\t\t\tmatchedWorkspaces = matchedWorkspaces + \",'\" + oneMatchingTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error. \n\t\t\tString prefix = \"\";\n\t\t\tif (errorPrefixes.length > 1) {\n\t\t\t\tprefix = errorPrefixes[1] + \" \";\n\t\t\t}\n\t\t\tthrow new StfException(prefix + \"Note: directory '\" + directoryRef + \"' was found multiple times, in this subset of the supplied test roots: \" + matchedWorkspaces.substring(1));\n\t\t}\n\t\t\n\t\t//Return the match.\n\t\treturn matchingTestRoots.get(0).childDirectory(directoryRef);\n\t}\n}"
    },
    "137": {
      "metadata": {
        "chunk_id": "1a35c3195f150d1792d83b5775bcb6dd30c4155815c67797784c33e51a2efd24",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/DynamicVariableReplacer.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class takes incoming string and updates references to\n *   1) A child directory of the results or tmp directory. eg ${resultsDir.childDir(cacheData)}\n *   2) A reference to an environment variable, eg ${JAVA_HOME}\n *   3) A reference to another property, eg ${apps-root}\n *   \n * For example the incoming string may be '-XcacheName:${resultsDir.childDir(cache)}' which\n * would evaluate to perhaps '/tmp/stf/TestName/results/cache' on linux \n * and 'C:\\temp\\stf\\TestName\\results\\cache' on Windows\n */",
        "start_line": 0,
        "end_line": 31,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 286,
        "node_type": null,
        "file_sha": "d4626fead388ad0eaee9eff69a45b8d9447ef107",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.864916"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class takes incoming string and updates references to\n *   1) A child directory of the results or tmp directory. eg ${resultsDir.childDir(cacheData)}\n *   2) A reference to an environment variable, eg ${JAVA_HOME}\n *   3) A reference to another property, eg ${apps-root}\n *   \n * For example the incoming string may be '-XcacheName:${resultsDir.childDir(cache)}' which\n * would evaluate to perhaps '/tmp/stf/TestName/results/cache' on linux \n * and 'C:\\temp\\stf\\TestName\\results\\cache' on Windows\n */"
    },
    "138": {
      "metadata": {
        "chunk_id": "09b48479ed8665a2e3f9c3ca479914609559b576e7789024b2980c5d279d965e",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/DynamicVariableReplacer.java",
        "content": "public class DynamicVariableReplacer {\n\tprivate StfEnvironmentCore environmentCore;\n\t\n\t\n\tpublic DynamicVariableReplacer(StfEnvironmentCore environmentCore) {\n\t\tthis.environmentCore = environmentCore;\n\t}\n\t\n\n\t/**\n\t * Updates references in the incoming string and returns a string with such values\n\t * replaced with their resolved values.\n\t */\n\tpublic String process(String original) throws StfException { \n\t\tif (!original.contains(\"${\")) {\n\t\t\treturn original;\n\t\t}\n\t\t\n\t\t// The value looks like it references at least one other variable.\n\t\t// Update the property value by replacing the reference with the actual value(s). \n        Pattern pattern = Pattern.compile(\"\\\\$\\\\{.*?\\\\}\");  // ie: look for ${.*?}\n        Matcher matcher = pattern.matcher(original);\n\n        StringBuffer buff = new StringBuffer();\n        while (matcher.find()) {\n            String referenceSpec = matcher.group(0);\n            String referenceName = referenceSpec.substring(2, referenceSpec.length()-1);\n            \n            // Stage 1. A child of the results or tmp directory\n            String replacementValue = processRelativeDir(referenceName);\n            \n            // Stage 2. Try replacement using an environment variable\n            if (replacementValue == null) {\n            \treplacementValue = System.getenv(referenceName);\n            }\n            \n            // Stage 3. Try replacement using system property\n            if (replacementValue == null) {\n            \treplacementValue = System.getProperty(referenceName);\n            }\n            \n            // Stage 4. It's not a reference to an env.variable, so attempt to substitute another property value.\n            if (replacementValue == null) {\n\t            replacementValue = environmentCore.getProperty(referenceName);\n            }\n\n            matcher.appendReplacement(buff, replacementValue);\n        }\n        matcher.appendTail(buff);\n        \n        return buff.toString();\n\t}\n\n\n\t/*\n\t * Attempts to evaluate a string which references a directory which is a child of the results or tmp dir.\n\t * For example the reference may be 'resultsDir.childDir(cache)' which would return '/tmp/stf/TestName/result/cache'\n\t */\n\tprivate String processRelativeDir(String reference) throws StfException {\n        Pattern pattern = Pattern.compile(\"^(.*?)\\\\.(.*?)\\\\((.*?)\\\\)$\");  // ie: look for \"<name> . <method> ( <string> )\"\n        Matcher matcher = pattern.matcher(reference);\n        \n        if (!matcher.find()) {\n        \treturn null;  // doesn't match the reference format\n        }\n\n        // Use regex to grab the different parts of the reference\n        String objectName = matcher.group(1);\n        String methodName = matcher.group(2);\n        String childName  = matcher.group(3);\n\n        // Work out which directory is being referenced\n        DirectoryRef dirRef = null;\n        if (objectName.equals(\"resultsDir\")) {\n        \tdirRef = environmentCore.getResultsDir();\n        } else if (objectName.equals(\"tmpDir\")) {\n        \tdirRef = environmentCore.getTmpDir();\n        } else {\n        \tthrow new StfException(\"Unknown object name in reference: \" + reference);\n        }\n        \n        // Valid the method name being used\n        if (!methodName.equals(\"childDir\")) {\n        \tthrow new StfException(\"Unknown method in reference: \" + reference);\n        }\n        \n        String resolvedReference = dirRef.childDirectory(childName).getSpec();\n        return resolvedReference;\n\t}\n}",
        "start_line": 32,
        "end_line": 121,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 695,
        "node_type": null,
        "file_sha": "d4626fead388ad0eaee9eff69a45b8d9447ef107",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.864924"
      },
      "text": "public class DynamicVariableReplacer {\n\tprivate StfEnvironmentCore environmentCore;\n\t\n\t\n\tpublic DynamicVariableReplacer(StfEnvironmentCore environmentCore) {\n\t\tthis.environmentCore = environmentCore;\n\t}\n\t\n\n\t/**\n\t * Updates references in the incoming string and returns a string with such values\n\t * replaced with their resolved values.\n\t */\n\tpublic String process(String original) throws StfException { \n\t\tif (!original.contains(\"${\")) {\n\t\t\treturn original;\n\t\t}\n\t\t\n\t\t// The value looks like it references at least one other variable.\n\t\t// Update the property value by replacing the reference with the actual value(s). \n        Pattern pattern = Pattern.compile(\"\\\\$\\\\{.*?\\\\}\");  // ie: look for ${.*?}\n        Matcher matcher = pattern.matcher(original);\n\n        StringBuffer buff = new StringBuffer();\n        while (matcher.find()) {\n            String referenceSpec = matcher.group(0);\n            String referenceName = referenceSpec.substring(2, referenceSpec.length()-1);\n            \n            // Stage 1. A child of the results or tmp directory\n            String replacementValue = processRelativeDir(referenceName);\n            \n            // Stage 2. Try replacement using an environment variable\n            if (replacementValue == null) {\n            \treplacementValue = System.getenv(referenceName);\n            }\n            \n            // Stage 3. Try replacement using system property\n            if (replacementValue == null) {\n            \treplacementValue = System.getProperty(referenceName);\n            }\n            \n            // Stage 4. It's not a reference to an env.variable, so attempt to substitute another property value.\n            if (replacementValue == null) {\n\t            replacementValue = environmentCore.getProperty(referenceName);\n            }\n\n            matcher.appendReplacement(buff, replacementValue);\n        }\n        matcher.appendTail(buff);\n        \n        return buff.toString();\n\t}\n\n\n\t/*\n\t * Attempts to evaluate a string which references a directory which is a child of the results or tmp dir.\n\t * For example the reference may be 'resultsDir.childDir(cache)' which would return '/tmp/stf/TestName/result/cache'\n\t */\n\tprivate String processRelativeDir(String reference) throws StfException {\n        Pattern pattern = Pattern.compile(\"^(.*?)\\\\.(.*?)\\\\((.*?)\\\\)$\");  // ie: look for \"<name> . <method> ( <string> )\"\n        Matcher matcher = pattern.matcher(reference);\n        \n        if (!matcher.find()) {\n        \treturn null;  // doesn't match the reference format\n        }\n\n        // Use regex to grab the different parts of the reference\n        String objectName = matcher.group(1);\n        String methodName = matcher.group(2);\n        String childName  = matcher.group(3);\n\n        // Work out which directory is being referenced\n        DirectoryRef dirRef = null;\n        if (objectName.equals(\"resultsDir\")) {\n        \tdirRef = environmentCore.getResultsDir();\n        } else if (objectName.equals(\"tmpDir\")) {\n        \tdirRef = environmentCore.getTmpDir();\n        } else {\n        \tthrow new StfException(\"Unknown object name in reference: \" + reference);\n        }\n        \n        // Valid the method name being used\n        if (!methodName.equals(\"childDir\")) {\n        \tthrow new StfException(\"Unknown method in reference: \" + reference);\n        }\n        \n        String resolvedReference = dirRef.childDirectory(childName).getSpec();\n        return resolvedReference;\n\t}\n}"
    },
    "139": {
      "metadata": {
        "chunk_id": "6413256d8dd9b90a88b7de356fa5e97bb608a0ea85cbd9af7a886a122baf9557",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/FileRef.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class represents a file, which is known to a specific test case.\n * \n * The test plugin does not know the absolute path to the file, only it's relative \n * location to some root directory reference.\n * This is a deliberate choice, and is done to simplify the test cases and also\n * ensure that they remain platform independent.\n */",
        "start_line": 0,
        "end_line": 30,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 233,
        "node_type": null,
        "file_sha": "c15bb17ce4a8098ae9f9cca2bd1efe182605c9f8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.877034"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class represents a file, which is known to a specific test case.\n * \n * The test plugin does not know the absolute path to the file, only it's relative \n * location to some root directory reference.\n * This is a deliberate choice, and is done to simplify the test cases and also\n * ensure that they remain platform independent.\n */"
    },
    "140": {
      "metadata": {
        "chunk_id": "1659f6d837b8a750c78b470e061d4914c4e9b2fcda2ad1081cf2e4a7b7f23148",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/FileRef.java",
        "content": "public class FileRef {\n\tprivate String fileName;\n\t\n\tFileRef(String fileName) throws StfException {\n\t\tString trimmedFileName = fileName.trim();\n\t\t\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\t// Make sure it's a windows style path\n\t\t    Pattern pattern = Pattern.compile(\"(^[a-zA-Z]:[\\\\\\\\/])|(^\\\\.[\\\\\\\\/])\");\n\t\t    if(pattern.matcher(trimmedFileName).find()) {\n\t\t    \tthis.fileName = trimmedFileName;\n\t\t    } else {\n\t\t\t\tthrow new StfException(\"Invalid file name \\\"\" + trimmedFileName + \"\\\". Must start with either a drive name (e.g. C:), or a full stop.\");\n\t\t    }\n\t\t} else {\n\t\t\tif (trimmedFileName.startsWith(\"~\")) {\n\t\t\t\tString homeDir = System.getProperties().getProperty(\"user.home\");\n\t\t\t\tthis.fileName = trimmedFileName.replace(\"~\", homeDir);\n\t\t\t} else if (trimmedFileName.startsWith(\"/\")) {\n\t\t\t\tthis.fileName = trimmedFileName;\n\t\t\t} else if (trimmedFileName.startsWith(\".\")) {\n\t\t\t\tthis.fileName = trimmedFileName;\n\t\t\t} else {\n\t\t\t\tthrow new StfException(\"Invalid file specification. Must start with either '~', '/' or '.'\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Get a reference to the parent directory of the current file.\n\t */\n\tpublic DirectoryRef parent() throws StfException {\n\t\tint lastDivider = fileName.lastIndexOf(\"/\");\n\t\tif (lastDivider < 0) {\n\t\t\tthrow new StfException(\"Can't get parent directory for file: \" + fileName);\n\t\t}\n\t\t\n\t\treturn new DirectoryRef(fileName.substring(0, lastDivider));\n\t}\n\n\n\t/**\n\t * Return the file name that this file reference is pointing at.\n\t * eg, for file reference of '/tmp/results/x.log', the file name returned would be 'x.log'\n\t */\n\tpublic String getName() {\n\t\tString[] fileNameParts = fileName.split(\"/\"); \n\t\treturn fileNameParts[fileNameParts.length-1]; \n\t}\n\t\n\n\t/** \n\t * Convert this file reference into a Java File object.\n\t */\n\tpublic File asJavaFile() {\n\t\treturn new File(fileName);\n\t}\n\n\tpublic boolean exists() throws StfException {\n\t\treturn asJavaFile().exists();\n\t}\n\n\t\n\t/**\n\t * Return the platform specific absolute location of the current file reference.\n\t */\n\tpublic String getSpec() {\n\t\treturn fileName;\n\t}",
        "start_line": 31,
        "end_line": 100,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 484,
        "node_type": null,
        "file_sha": "c15bb17ce4a8098ae9f9cca2bd1efe182605c9f8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.877043"
      },
      "text": "public class FileRef {\n\tprivate String fileName;\n\t\n\tFileRef(String fileName) throws StfException {\n\t\tString trimmedFileName = fileName.trim();\n\t\t\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\t// Make sure it's a windows style path\n\t\t    Pattern pattern = Pattern.compile(\"(^[a-zA-Z]:[\\\\\\\\/])|(^\\\\.[\\\\\\\\/])\");\n\t\t    if(pattern.matcher(trimmedFileName).find()) {\n\t\t    \tthis.fileName = trimmedFileName;\n\t\t    } else {\n\t\t\t\tthrow new StfException(\"Invalid file name \\\"\" + trimmedFileName + \"\\\". Must start with either a drive name (e.g. C:), or a full stop.\");\n\t\t    }\n\t\t} else {\n\t\t\tif (trimmedFileName.startsWith(\"~\")) {\n\t\t\t\tString homeDir = System.getProperties().getProperty(\"user.home\");\n\t\t\t\tthis.fileName = trimmedFileName.replace(\"~\", homeDir);\n\t\t\t} else if (trimmedFileName.startsWith(\"/\")) {\n\t\t\t\tthis.fileName = trimmedFileName;\n\t\t\t} else if (trimmedFileName.startsWith(\".\")) {\n\t\t\t\tthis.fileName = trimmedFileName;\n\t\t\t} else {\n\t\t\t\tthrow new StfException(\"Invalid file specification. Must start with either '~', '/' or '.'\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Get a reference to the parent directory of the current file.\n\t */\n\tpublic DirectoryRef parent() throws StfException {\n\t\tint lastDivider = fileName.lastIndexOf(\"/\");\n\t\tif (lastDivider < 0) {\n\t\t\tthrow new StfException(\"Can't get parent directory for file: \" + fileName);\n\t\t}\n\t\t\n\t\treturn new DirectoryRef(fileName.substring(0, lastDivider));\n\t}\n\n\n\t/**\n\t * Return the file name that this file reference is pointing at.\n\t * eg, for file reference of '/tmp/results/x.log', the file name returned would be 'x.log'\n\t */\n\tpublic String getName() {\n\t\tString[] fileNameParts = fileName.split(\"/\"); \n\t\treturn fileNameParts[fileNameParts.length-1]; \n\t}\n\t\n\n\t/** \n\t * Convert this file reference into a Java File object.\n\t */\n\tpublic File asJavaFile() {\n\t\treturn new File(fileName);\n\t}\n\n\tpublic boolean exists() throws StfException {\n\t\treturn asJavaFile().exists();\n\t}\n\n\t\n\t/**\n\t * Return the platform specific absolute location of the current file reference.\n\t */\n\tpublic String getSpec() {\n\t\treturn fileName;\n\t}"
    },
    "141": {
      "metadata": {
        "chunk_id": "e24757f65f7c98ec3b39de82bcaae18f20c3e97c969db1ea0f28dfe0e27270be",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/FileRef.java",
        "content": "/**\n\t * Return the platform specific absolute location of the current file reference.\n\t */\n\tpublic String getSpec() {\n\t\treturn fileName;\n\t}\n\n\n\tpublic String toString() {\n\t\treturn getSpec();\n\t}\n\t\n\t\n\t/**\n\t * Takes a file path (without a root) and a list of test roots, and tries to find out which \n\t * root contains that file. If it cannot be found, or is found multiple times, an exception \n\t * is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param testRootRefs  The potential roots of the path for the file we're trying to find.\n\t * @return              A DirectoryRef for the root of the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one test root.\n\t */\n\tpublic static DirectoryRef findFileRoot(String fileRef, ArrayList<DirectoryRef> testRootRefs) throws StfException {\n\t\tint count = 0;\n\t\tDirectoryRef fileRoot = new DirectoryRef(\"./ignore\");\n\t\tfor (int i = 0 ; i < testRootRefs.size() ; ++i ) {\n\t\t\ttry {\n\t\t\t\tfindFile(fileRef, new ArrayList<DirectoryRef>(testRootRefs.subList(i, i+1)));\n\t\t\t\tfileRoot = testRootRefs.get(i);\n\t\t\t\tcount++;\n\t\t\t} catch (StfException e) {\n\t\t\t\t//ignore;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (count != 1) {\n\t\t\t//This should produce the right error.\n\t\t\tfindFile(fileRef, testRootRefs);\n\t\t}\n\t\t\n\t\treturn fileRoot;\n\t}\n\t\n\t/**\n\t * Takes a file path (without a root) and a list of test roots, and tries to find that file \n\t * inside each of our test roots. If it cannot be found, an exception is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param testRootRefs  The potential roots of the path for the file we're trying to find.\n\t * @param errorPrefixes These are optional.\n\t *                      The first String will be prefixed onto the StfException message if the file cannot be found.\n\t *                      The second String will be prefixed onto the StfException message if the file is found more then once.\n\t *                      The third+ Strings will be ignored.\n\t * @return               A FileRef for the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one test root.\n\t */\n\tpublic static FileRef findFile(String fileRef, ArrayList<DirectoryRef> testRootRefs, String... errorPrefixes) throws StfException {\n\t\tArrayList<DirectoryRef> matchingTestRoots = new ArrayList<DirectoryRef>();\n\t\tfor (DirectoryRef oneTestRoot : testRootRefs) {\n\t\t\tif (oneTestRoot.childFile(fileRef).exists()) {\n\t\t\t\tmatchingTestRoots.add(oneTestRoot);\n\t\t\t}\n\t\t}\n\t\t//Check to see if we only found it.\n\t\tif (matchingTestRoots.size() == 0) {\n\t\t\t//First we assemble a list of test roots we searched in.\n\t\t\tString workspaces = \"\";\n\t\t\tfor (DirectoryRef oneTestRootRef : testRootRefs) {\n\t\t\t\tworkspaces = workspaces + \",'\" + oneTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error.\n\t\t\tString prefix = \"\";\n\t\t\tif (errorPrefixes.length > 0) {\n\t\t\t\tprefix = errorPrefixes[0] + \" \";\n\t\t\t}\n\t\t\tthrow new StfException(prefix + \"Note: file '\" + fileRef + \"' could not be found in any of the supplied test roots: \" + workspaces.substring(1));\n\t\t} \n\t\t//Check to see if we only found it once.\n\t\tif (matchingTestRoots.size() > 1) {\n\t\t\t//First we assemble a list of test roots we found the directory in.\n\t\t\tString matchedWorkspaces = \"\";\n\t\t\tfor (DirectoryRef oneMatchingTestRootRef : matchingTestRoots) {\n\t\t\t\tmatchedWorkspaces = matchedWorkspaces + \",'\" + oneMatchingTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error. \n\t\t\tString prefix = \"\";\n\t\t\tif (errorPrefixes.length > 1) {\n\t\t\t\tprefix = errorPrefixes[1] + \" \";\n\t\t\t}\n\t\t\tthrow new StfException(prefix + \"Note: file '\" + fileRef + \"' was found multiple times, in this subset of the supplied test roots: \" + matchedWorkspaces.substring(1));\n\t\t}\n\t\t\n\t\t//Return the match.\n\t\treturn matchingTestRoots.get(0).childFile(fileRef);\n\t}\n}",
        "start_line": 101,
        "end_line": 195,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 1032,
        "node_type": null,
        "file_sha": "c15bb17ce4a8098ae9f9cca2bd1efe182605c9f8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.877046"
      },
      "text": "/**\n\t * Return the platform specific absolute location of the current file reference.\n\t */\n\tpublic String getSpec() {\n\t\treturn fileName;\n\t}\n\n\n\tpublic String toString() {\n\t\treturn getSpec();\n\t}\n\t\n\t\n\t/**\n\t * Takes a file path (without a root) and a list of test roots, and tries to find out which \n\t * root contains that file. If it cannot be found, or is found multiple times, an exception \n\t * is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param testRootRefs  The potential roots of the path for the file we're trying to find.\n\t * @return              A DirectoryRef for the root of the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one test root.\n\t */\n\tpublic static DirectoryRef findFileRoot(String fileRef, ArrayList<DirectoryRef> testRootRefs) throws StfException {\n\t\tint count = 0;\n\t\tDirectoryRef fileRoot = new DirectoryRef(\"./ignore\");\n\t\tfor (int i = 0 ; i < testRootRefs.size() ; ++i ) {\n\t\t\ttry {\n\t\t\t\tfindFile(fileRef, new ArrayList<DirectoryRef>(testRootRefs.subList(i, i+1)));\n\t\t\t\tfileRoot = testRootRefs.get(i);\n\t\t\t\tcount++;\n\t\t\t} catch (StfException e) {\n\t\t\t\t//ignore;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (count != 1) {\n\t\t\t//This should produce the right error.\n\t\t\tfindFile(fileRef, testRootRefs);\n\t\t}\n\t\t\n\t\treturn fileRoot;\n\t}\n\t\n\t/**\n\t * Takes a file path (without a root) and a list of test roots, and tries to find that file \n\t * inside each of our test roots. If it cannot be found, an exception is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param testRootRefs  The potential roots of the path for the file we're trying to find.\n\t * @param errorPrefixes These are optional.\n\t *                      The first String will be prefixed onto the StfException message if the file cannot be found.\n\t *                      The second String will be prefixed onto the StfException message if the file is found more then once.\n\t *                      The third+ Strings will be ignored.\n\t * @return               A FileRef for the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one test root.\n\t */\n\tpublic static FileRef findFile(String fileRef, ArrayList<DirectoryRef> testRootRefs, String... errorPrefixes) throws StfException {\n\t\tArrayList<DirectoryRef> matchingTestRoots = new ArrayList<DirectoryRef>();\n\t\tfor (DirectoryRef oneTestRoot : testRootRefs) {\n\t\t\tif (oneTestRoot.childFile(fileRef).exists()) {\n\t\t\t\tmatchingTestRoots.add(oneTestRoot);\n\t\t\t}\n\t\t}\n\t\t//Check to see if we only found it.\n\t\tif (matchingTestRoots.size() == 0) {\n\t\t\t//First we assemble a list of test roots we searched in.\n\t\t\tString workspaces = \"\";\n\t\t\tfor (DirectoryRef oneTestRootRef : testRootRefs) {\n\t\t\t\tworkspaces = workspaces + \",'\" + oneTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error.\n\t\t\tString prefix = \"\";\n\t\t\tif (errorPrefixes.length > 0) {\n\t\t\t\tprefix = errorPrefixes[0] + \" \";\n\t\t\t}\n\t\t\tthrow new StfException(prefix + \"Note: file '\" + fileRef + \"' could not be found in any of the supplied test roots: \" + workspaces.substring(1));\n\t\t} \n\t\t//Check to see if we only found it once.\n\t\tif (matchingTestRoots.size() > 1) {\n\t\t\t//First we assemble a list of test roots we found the directory in.\n\t\t\tString matchedWorkspaces = \"\";\n\t\t\tfor (DirectoryRef oneMatchingTestRootRef : matchingTestRoots) {\n\t\t\t\tmatchedWorkspaces = matchedWorkspaces + \",'\" + oneMatchingTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error. \n\t\t\tString prefix = \"\";\n\t\t\tif (errorPrefixes.length > 1) {\n\t\t\t\tprefix = errorPrefixes[1] + \" \";\n\t\t\t}\n\t\t\tthrow new StfException(prefix + \"Note: file '\" + fileRef + \"' was found multiple times, in this subset of the supplied test roots: \" + matchedWorkspaces.substring(1));\n\t\t}\n\t\t\n\t\t//Return the match.\n\t\treturn matchingTestRoots.get(0).childFile(fileRef);\n\t}\n}"
    },
    "142": {
      "metadata": {
        "chunk_id": "075dc0465aacb1d5a9dc8ff40d1a9319994356da1c504978153ae7c98d90c2f7",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/JavaVersion.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.extensions.Stf;\n\n\n/** \n * Provides information about the version of java which is used in the execution stage.\n * \n * It captures the output of 'java -version' and extracts the required information by \n * parsing this output.\n * To prevent repeated executions of an external process the 'java -version' \n * output is cached.\n */",
        "start_line": 0,
        "end_line": 36,
        "chunk_index": 0,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 272,
        "node_type": null,
        "file_sha": "0527d38d754361f2aca39ee6004fc2a7b2bdcdc4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.886142"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.extensions.Stf;\n\n\n/** \n * Provides information about the version of java which is used in the execution stage.\n * \n * It captures the output of 'java -version' and extracts the required information by \n * parsing this output.\n * To prevent repeated executions of an external process the 'java -version' \n * output is cached.\n */"
    },
    "143": {
      "metadata": {
        "chunk_id": "f2200106923913b0193c5c246ccc7d2d3f826cd76fef3369f4c6d659d1171443",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/JavaVersion.java",
        "content": "public class JavaVersion {\n    private static final Logger logger = LogManager.getLogger(JavaVersion.class.getName());\n\n    private static HashMap<String, JavaVersion> instances = new HashMap<String, JavaVersion>();\n\n    private String javaHome;\n    private boolean isPrimaryJvm;\n    \n\t// Cache output from running 'java -version'\n\tprivate String javaVersionOutput;\n\t\n\n\tprivate JavaVersion(boolean isPrimaryJvm, String javaHome) throws StfException {\n\t\tthis.javaHome = javaHome;\n\t\tthis.isPrimaryJvm = isPrimaryJvm;\n\t\t\n\t\t// Run 'java -version' to find out about the JVM used for the execution stage. \n\t\tString javaCmd = javaHome + File.separator + \"bin\" + File.separator + \"java\"; \n        ProcessBuilder pb = new ProcessBuilder(javaCmd, \"-version\");\n\n        // Run 'java -version'\n        Process process;\n\t\ttry {\n\t\t\tprocess = pb.start();\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(e);\n\t\t}\n\n\t\t// Wait for the process to finish\n\t\tInputStream err = process.getErrorStream();\n        while (true) {\n            try {\n                process.waitFor();\n                break;\n            } catch (InterruptedException e) {\n                // Ignored\n            }\n        }\n\n\t\t// Read the 'java -version' information from stderr\n        byte[] buf = new byte[10000];\n        try {\n\t\t\tint lengthOfErrorBuffer = err.read(buf);\n\t\t\tjavaVersionOutput = new String(buf, 0, lengthOfErrorBuffer);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to read result of command: \" + javaCmd);\n\t\t}\n\n \t\t// Eat superfluous first lines (e.g. JIT: env var TR_OPTIONS, or JVMJ9VM082E Unable to switch to IFA processor,\n        // or JVMJ9VM090I Slow response to network query, etc )\n        while (javaVersionOutput.startsWith(\"JVMJ9VM\") || javaVersionOutput.startsWith(\"JIT:\")) {\n \t\t\t// Line starts with error message. Remove up to and including the newline.\n \t\t\tint endOfFirstLine = javaVersionOutput.indexOf('\\n');\n \t\t\tjavaVersionOutput = javaVersionOutput.substring(endOfFirstLine+1);\n \t\t}\n        \n        // Allow parsing of output from some Oracle Java 9 versions.\n        // Converts 'openjdk version \"9-internal\"' to 'java version \"9-internal\"'\n        if (javaVersionOutput.startsWith(\"openjdk version\")) {\n        \tjavaVersionOutput = javaVersionOutput.replace(\"openjdk\", \"java\");\n        }\n\t}\n\n\tpublic static JavaVersion getInstance(StfEnvironmentCore environmentCore) throws StfException {\n\t\treturn getInstance(true, environmentCore.getProperty(Stf.ARG_JAVAHOME_EXECUTE));\n\t}\n\n\tpublic static JavaVersion getInstance(boolean isPrimaryJvm, String javaHome) throws StfException {\n\t\tif (javaHome.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!instances.containsKey(javaHome)) {\n\t\t\tJavaVersion newJavaVersion = new JavaVersion(isPrimaryJvm, javaHome);\n\t\t\tinstances.put(javaHome, newJavaVersion);\n\t\t}\n\t\t\n\t\treturn instances.get(javaHome);\n\t}\n\t\n\tpublic String getJavaHome() {\n\t\treturn javaHome;\n\t}\n\t\n\tpublic boolean isPrimaryJvm() {\n\t\treturn isPrimaryJvm;\n\t}\n\n\n\t/**\n\t * @return true if the JVM used for test execution is Java version 9. Otherwise false.\n\t */\n\tpublic boolean isJava9() {\n\t\t// Sample IBM output:\n\t\t//\n\t\t//java version \"1.9.0\"\n\t\t//Java(TM) SE Runtime Environment (build pwa6490ea-20160704_01)\n\t\t//IBM J9 VM build 2.9, JRE 1.9.0 Windows 7 amd64-64 Compressed References 20160701\n\t\t//_309978 (JIT enabled, AOT enabled)\n\t\t//J9VM - R29_20160701_0101_B309978\n\t\t//JIT  - tr.open_20160621_119843_74d1a142.green\n\t\t//OMR   - 62dba360\n\t\t//JCL - 20160628_01 based on Oracle jdk-9+95\n\t\t\n\t\t// Sample Oracle output:\n\t\t//\n\t\t//java version \"9-ea\"\n\t\t//Java(TM) SE Runtime Environment (build 9-ea+122)\n\t\t//Java HotSpot(TM) 64-Bit Server VM (build 9-ea+122, mixed mode)\n\t\t\n\t\tif ( javaVersionOutput.startsWith(\"java version \\\"9\" ) ) {\n\t\t\treturn true;\n\t\t};\n\t\tif ( javaVersionOutput.startsWith(\"java version \\\"1.9\" ) ) {\n\t\t\treturn true;\n\t\t};\n\t\treturn false;\n\t}",
        "start_line": 37,
        "end_line": 154,
        "chunk_index": 1,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 1018,
        "node_type": null,
        "file_sha": "0527d38d754361f2aca39ee6004fc2a7b2bdcdc4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.886149"
      },
      "text": "public class JavaVersion {\n    private static final Logger logger = LogManager.getLogger(JavaVersion.class.getName());\n\n    private static HashMap<String, JavaVersion> instances = new HashMap<String, JavaVersion>();\n\n    private String javaHome;\n    private boolean isPrimaryJvm;\n    \n\t// Cache output from running 'java -version'\n\tprivate String javaVersionOutput;\n\t\n\n\tprivate JavaVersion(boolean isPrimaryJvm, String javaHome) throws StfException {\n\t\tthis.javaHome = javaHome;\n\t\tthis.isPrimaryJvm = isPrimaryJvm;\n\t\t\n\t\t// Run 'java -version' to find out about the JVM used for the execution stage. \n\t\tString javaCmd = javaHome + File.separator + \"bin\" + File.separator + \"java\"; \n        ProcessBuilder pb = new ProcessBuilder(javaCmd, \"-version\");\n\n        // Run 'java -version'\n        Process process;\n\t\ttry {\n\t\t\tprocess = pb.start();\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(e);\n\t\t}\n\n\t\t// Wait for the process to finish\n\t\tInputStream err = process.getErrorStream();\n        while (true) {\n            try {\n                process.waitFor();\n                break;\n            } catch (InterruptedException e) {\n                // Ignored\n            }\n        }\n\n\t\t// Read the 'java -version' information from stderr\n        byte[] buf = new byte[10000];\n        try {\n\t\t\tint lengthOfErrorBuffer = err.read(buf);\n\t\t\tjavaVersionOutput = new String(buf, 0, lengthOfErrorBuffer);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to read result of command: \" + javaCmd);\n\t\t}\n\n \t\t// Eat superfluous first lines (e.g. JIT: env var TR_OPTIONS, or JVMJ9VM082E Unable to switch to IFA processor,\n        // or JVMJ9VM090I Slow response to network query, etc )\n        while (javaVersionOutput.startsWith(\"JVMJ9VM\") || javaVersionOutput.startsWith(\"JIT:\")) {\n \t\t\t// Line starts with error message. Remove up to and including the newline.\n \t\t\tint endOfFirstLine = javaVersionOutput.indexOf('\\n');\n \t\t\tjavaVersionOutput = javaVersionOutput.substring(endOfFirstLine+1);\n \t\t}\n        \n        // Allow parsing of output from some Oracle Java 9 versions.\n        // Converts 'openjdk version \"9-internal\"' to 'java version \"9-internal\"'\n        if (javaVersionOutput.startsWith(\"openjdk version\")) {\n        \tjavaVersionOutput = javaVersionOutput.replace(\"openjdk\", \"java\");\n        }\n\t}\n\n\tpublic static JavaVersion getInstance(StfEnvironmentCore environmentCore) throws StfException {\n\t\treturn getInstance(true, environmentCore.getProperty(Stf.ARG_JAVAHOME_EXECUTE));\n\t}\n\n\tpublic static JavaVersion getInstance(boolean isPrimaryJvm, String javaHome) throws StfException {\n\t\tif (javaHome.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!instances.containsKey(javaHome)) {\n\t\t\tJavaVersion newJavaVersion = new JavaVersion(isPrimaryJvm, javaHome);\n\t\t\tinstances.put(javaHome, newJavaVersion);\n\t\t}\n\t\t\n\t\treturn instances.get(javaHome);\n\t}\n\t\n\tpublic String getJavaHome() {\n\t\treturn javaHome;\n\t}\n\t\n\tpublic boolean isPrimaryJvm() {\n\t\treturn isPrimaryJvm;\n\t}\n\n\n\t/**\n\t * @return true if the JVM used for test execution is Java version 9. Otherwise false.\n\t */\n\tpublic boolean isJava9() {\n\t\t// Sample IBM output:\n\t\t//\n\t\t//java version \"1.9.0\"\n\t\t//Java(TM) SE Runtime Environment (build pwa6490ea-20160704_01)\n\t\t//IBM J9 VM build 2.9, JRE 1.9.0 Windows 7 amd64-64 Compressed References 20160701\n\t\t//_309978 (JIT enabled, AOT enabled)\n\t\t//J9VM - R29_20160701_0101_B309978\n\t\t//JIT  - tr.open_20160621_119843_74d1a142.green\n\t\t//OMR   - 62dba360\n\t\t//JCL - 20160628_01 based on Oracle jdk-9+95\n\t\t\n\t\t// Sample Oracle output:\n\t\t//\n\t\t//java version \"9-ea\"\n\t\t//Java(TM) SE Runtime Environment (build 9-ea+122)\n\t\t//Java HotSpot(TM) 64-Bit Server VM (build 9-ea+122, mixed mode)\n\t\t\n\t\tif ( javaVersionOutput.startsWith(\"java version \\\"9\" ) ) {\n\t\t\treturn true;\n\t\t};\n\t\tif ( javaVersionOutput.startsWith(\"java version \\\"1.9\" ) ) {\n\t\t\treturn true;\n\t\t};\n\t\treturn false;\n\t}"
    },
    "144": {
      "metadata": {
        "chunk_id": "21cd4aa4354ac553c31875d97ba9f54c6579183d762939d98632fe9149a872d9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/JavaVersion.java",
        "content": "/**\n\t * @return true if the JVM used for test execution is Java version 8. Otherwise false.\n\t */\n\tpublic boolean isJava8() {\n\t\t// Sample IBM output:\n\t\t//\n\t\t//java version \"1.8.0\"\n\t\t//Java(TM) SE Runtime Environment (build pwa6480sr3-20160428_01(SR3))\n\t\t//IBM J9 VM (build 2.8, JRE 1.8.0 Windows 7 amd64-64 Compressed References 2016042\n\t\t//7_301573 (JIT enabled, AOT enabled)\n\t\t//J9VM - R28_Java8_SR3_20160427_1620_B301573\n\t\t//JIT  - tr.r14.java.green_20160329_114288\n\t\t//GC   - R28_Java8_SR3_20160427_1620_B301573_CMPRSS\n\t\t//J9CL - 20160427_301573)\n\t\t//JCL - 20160421_01 based on Oracle jdk8u91-b14\n\n\t\t// Sample Oracle output:\n\t\t//\n\t\t//java version \"1.8.0_92\"\n\t\t//Java(TM) SE Runtime Environment (build 1.8.0_92-b14)\n\t\t//Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)\n\n\t\treturn javaVersionOutput.startsWith(\"java version \\\"1.8.\");\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 7. Otherwise false.\n\t */\n\tpublic boolean isJava7() {\n\t\treturn javaVersionOutput.startsWith(\"java version \\\"1.7.\");\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 6. Otherwise false.\n\t */\n\tpublic boolean isJava6() {\n\t\treturn javaVersionOutput.startsWith(\"java version \\\"1.6.\");\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 10. Otherwise false.\n\t */\n\tpublic boolean isJava10() {\n\t\treturn javaVersionOutput.startsWith(\"java version \\\"10\");\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 11. Otherwise false.\n\t */\n\tpublic boolean isJava11() {\n\t\treturn javaVersionOutput.trim().startsWith(\"java version \\\"11\");\n\t}\n\n\t/**\n\t * @param version int value of version to check if matches\n\t * @return true if the JVM used for test execution matches input param version. Otherwise false.\n\t */\n\tpublic boolean isJavaVersion(int version) {\n\t\tString brand = \"java\";\n\t\tString stringifiedVersion = Integer.toString(version);\n\t\tif (version < 9) {\n\t\t\tstringifiedVersion = \"1.\" + version;\n\t\t}\n\t\tif (version == 9) {\n\t\t\treturn isJava9();\n\t\t}\n\t\treturn javaVersionOutput.contains(\"version \\\"\" + stringifiedVersion);\n\t}\n\n\t/**\n\t * @return the java version with the format as a single int.\n\t * eg, 6, 7, 8 or 9, 10, 11+ etc\n\t * @return int containing the java version number.\n\t * @throws StfException if an unknown JVM release has been found.\n\t */\n\tpublic int getJavaVersion() throws StfException {\n\t\tint lowver = 6;\n\t\tint highver = 99;\n\t\tfor (int version=lowver; version < highver; version++) {\n\t\t\tif (isJavaVersion(version)) return version;\n\t\t}\t\n\t\tthrow new StfException(\"Unknown JVM release and version: \" + PlatformFinder.getPlatformAsString() + \"\\n\" + javaVersionOutput);\n\t}\n\t\n\t// Return jvm version as 60, 70, 80 or 90, 100 etc\n\tpublic String getJavaVersionCode() throws StfException {\n\t\treturn getJavaVersion() + \"0\";\n\t}\n\t\n\tpublic boolean isIBMJvm() throws StfException {\n\t\treturn (javaVersionOutput.contains(\"IBM\") | javaVersionOutput.contains(\"OpenJ9\"));\n\t}\n\n\tpublic boolean isOracleJvm() throws StfException {\n\t\treturn javaVersionOutput.contains(\"HotSpot\");\n\t}",
        "start_line": 155,
        "end_line": 250,
        "chunk_index": 2,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 911,
        "node_type": null,
        "file_sha": "0527d38d754361f2aca39ee6004fc2a7b2bdcdc4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.886152"
      },
      "text": "/**\n\t * @return true if the JVM used for test execution is Java version 8. Otherwise false.\n\t */\n\tpublic boolean isJava8() {\n\t\t// Sample IBM output:\n\t\t//\n\t\t//java version \"1.8.0\"\n\t\t//Java(TM) SE Runtime Environment (build pwa6480sr3-20160428_01(SR3))\n\t\t//IBM J9 VM (build 2.8, JRE 1.8.0 Windows 7 amd64-64 Compressed References 2016042\n\t\t//7_301573 (JIT enabled, AOT enabled)\n\t\t//J9VM - R28_Java8_SR3_20160427_1620_B301573\n\t\t//JIT  - tr.r14.java.green_20160329_114288\n\t\t//GC   - R28_Java8_SR3_20160427_1620_B301573_CMPRSS\n\t\t//J9CL - 20160427_301573)\n\t\t//JCL - 20160421_01 based on Oracle jdk8u91-b14\n\n\t\t// Sample Oracle output:\n\t\t//\n\t\t//java version \"1.8.0_92\"\n\t\t//Java(TM) SE Runtime Environment (build 1.8.0_92-b14)\n\t\t//Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)\n\n\t\treturn javaVersionOutput.startsWith(\"java version \\\"1.8.\");\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 7. Otherwise false.\n\t */\n\tpublic boolean isJava7() {\n\t\treturn javaVersionOutput.startsWith(\"java version \\\"1.7.\");\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 6. Otherwise false.\n\t */\n\tpublic boolean isJava6() {\n\t\treturn javaVersionOutput.startsWith(\"java version \\\"1.6.\");\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 10. Otherwise false.\n\t */\n\tpublic boolean isJava10() {\n\t\treturn javaVersionOutput.startsWith(\"java version \\\"10\");\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 11. Otherwise false.\n\t */\n\tpublic boolean isJava11() {\n\t\treturn javaVersionOutput.trim().startsWith(\"java version \\\"11\");\n\t}\n\n\t/**\n\t * @param version int value of version to check if matches\n\t * @return true if the JVM used for test execution matches input param version. Otherwise false.\n\t */\n\tpublic boolean isJavaVersion(int version) {\n\t\tString brand = \"java\";\n\t\tString stringifiedVersion = Integer.toString(version);\n\t\tif (version < 9) {\n\t\t\tstringifiedVersion = \"1.\" + version;\n\t\t}\n\t\tif (version == 9) {\n\t\t\treturn isJava9();\n\t\t}\n\t\treturn javaVersionOutput.contains(\"version \\\"\" + stringifiedVersion);\n\t}\n\n\t/**\n\t * @return the java version with the format as a single int.\n\t * eg, 6, 7, 8 or 9, 10, 11+ etc\n\t * @return int containing the java version number.\n\t * @throws StfException if an unknown JVM release has been found.\n\t */\n\tpublic int getJavaVersion() throws StfException {\n\t\tint lowver = 6;\n\t\tint highver = 99;\n\t\tfor (int version=lowver; version < highver; version++) {\n\t\t\tif (isJavaVersion(version)) return version;\n\t\t}\t\n\t\tthrow new StfException(\"Unknown JVM release and version: \" + PlatformFinder.getPlatformAsString() + \"\\n\" + javaVersionOutput);\n\t}\n\t\n\t// Return jvm version as 60, 70, 80 or 90, 100 etc\n\tpublic String getJavaVersionCode() throws StfException {\n\t\treturn getJavaVersion() + \"0\";\n\t}\n\t\n\tpublic boolean isIBMJvm() throws StfException {\n\t\treturn (javaVersionOutput.contains(\"IBM\") | javaVersionOutput.contains(\"OpenJ9\"));\n\t}\n\n\tpublic boolean isOracleJvm() throws StfException {\n\t\treturn javaVersionOutput.contains(\"HotSpot\");\n\t}"
    },
    "145": {
      "metadata": {
        "chunk_id": "db8e4fbe84f4ca1e2de5839e459587e0ab9a9bd2ccb575dc73da47ef561a59e4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/JavaVersion.java",
        "content": "public boolean isOracleJvm() throws StfException {\n\t\treturn javaVersionOutput.contains(\"HotSpot\");\n\t}\n\n\tpublic String getRawOutput() {\n\t\treturn javaVersionOutput;\n\t}\n\t\n\t/**\n\t * Allows a test to only run if the execution stage is using an IBM JVM.\n\t * If an IBM JVM is not used then the test run will fail with a StfError.\n\t * This method should not be used for tests which will run on an Oracle JVM, as\n\t * it's sometimes useful to retain the flexibility of be able to run on either.\n\t * @throws StfException for non-IBM JVM or if execution of 'java -version' failed. \n\t */\n\tpublic void verifyUsingIBMJava() throws StfException {\n\t\tif (!isIBMJvm()) {\n\t\t\tString narrative = isPrimaryJvm ? \"\" : \" for the secondary JVM\";\n\t\t\tlogger.info(\"'java -version' output:\\n\" + getRawOutput());\n\t\t\tthrow new StfError(\"Aborting run. This test requires an IBM JVM\" + narrative + \".\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Allows a test to only run if the execution stage is using an Oracle JVM.\n\t * If an IBM is not then the test run will fail with a StfError.\n\t * @throws StfException for non-Oracle JVM or if execution of 'java -version' failed. \n\t */\n\tpublic void verifyUsingOracleJava() throws StfException {\n\t\tif (!isOracleJvm()) {\n\t\t\tString narrative = isPrimaryJvm ? \"\" : \" for the secondary JVM\";\n\t\t\tlogger.info(\"'java -version' output:\\n\" + getRawOutput());\n\t\t\tthrow new StfError(\"Aborting run. This test requires an Oracle JVM\" + narrative + \".\");\n\t\t}\n\t}\n}",
        "start_line": 251,
        "end_line": 286,
        "chunk_index": 3,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 371,
        "node_type": null,
        "file_sha": "0527d38d754361f2aca39ee6004fc2a7b2bdcdc4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.886154"
      },
      "text": "public boolean isOracleJvm() throws StfException {\n\t\treturn javaVersionOutput.contains(\"HotSpot\");\n\t}\n\n\tpublic String getRawOutput() {\n\t\treturn javaVersionOutput;\n\t}\n\t\n\t/**\n\t * Allows a test to only run if the execution stage is using an IBM JVM.\n\t * If an IBM JVM is not used then the test run will fail with a StfError.\n\t * This method should not be used for tests which will run on an Oracle JVM, as\n\t * it's sometimes useful to retain the flexibility of be able to run on either.\n\t * @throws StfException for non-IBM JVM or if execution of 'java -version' failed. \n\t */\n\tpublic void verifyUsingIBMJava() throws StfException {\n\t\tif (!isIBMJvm()) {\n\t\t\tString narrative = isPrimaryJvm ? \"\" : \" for the secondary JVM\";\n\t\t\tlogger.info(\"'java -version' output:\\n\" + getRawOutput());\n\t\t\tthrow new StfError(\"Aborting run. This test requires an IBM JVM\" + narrative + \".\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Allows a test to only run if the execution stage is using an Oracle JVM.\n\t * If an IBM is not then the test run will fail with a StfError.\n\t * @throws StfException for non-Oracle JVM or if execution of 'java -version' failed. \n\t */\n\tpublic void verifyUsingOracleJava() throws StfException {\n\t\tif (!isOracleJvm()) {\n\t\t\tString narrative = isPrimaryJvm ? \"\" : \" for the secondary JVM\";\n\t\t\tlogger.info(\"'java -version' output:\\n\" + getRawOutput());\n\t\t\tthrow new StfError(\"Aborting run. This test requires an Oracle JVM\" + narrative + \".\");\n\t\t}\n\t}\n}"
    },
    "146": {
      "metadata": {
        "chunk_id": "c3431cdd97966fb0bce330c561b61cda638965cac970eeb4079be89d5d155a07",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/ModuleRef.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class represents a Module.\n */\npublic class ModuleRef {\n\tprivate String moduleName;\n\tprivate FileRef jarFileRef;\n\t\n\tpublic ModuleRef(String moduleName, FileRef jarFileRef) throws StfException {\n\t\tthis.moduleName = moduleName;\n\t\tthis.jarFileRef = jarFileRef;\n\t}\n\n\n\t/**\n\t * Return the name of this module.\n\t */\n\tpublic String getName() {\n\t\treturn moduleName; \n\t}\n\t\n\n\t/**\n\t * Return the base name of this module.\n\t * This is the module name but without any '.jmod' file extension\n\t * eg, if a 'com.hello.jmod' has been created this method would return 'com.hello'\n\t */\n\tpublic String getBaseName() {\n\t\tif (moduleName.endsWith(\".jmod\")) {\n\t\t\tint extensionStart = moduleName.lastIndexOf(\".jmod\");\n\t\t\treturn moduleName.substring(0, extensionStart);\n\t\t}\n\t\t\n\t\treturn moduleName; \n\t}\n\t\n\n\t/** \n\t * @return a FileRef for the jar file used by this module.\n\t */\n\tpublic FileRef getJarFileRef() {\n\t\treturn jarFileRef;\n\t}\n\t\n\t\n\tpublic String toString() { \n\t\treturn moduleName + \"->\" + jarFileRef.getName();\n\t}\n}",
        "start_line": 0,
        "end_line": 66,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 398,
        "node_type": null,
        "file_sha": "ee87d19c48d311e18c172fdc3767cd8b864eebc2",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.896090"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class represents a Module.\n */\npublic class ModuleRef {\n\tprivate String moduleName;\n\tprivate FileRef jarFileRef;\n\t\n\tpublic ModuleRef(String moduleName, FileRef jarFileRef) throws StfException {\n\t\tthis.moduleName = moduleName;\n\t\tthis.jarFileRef = jarFileRef;\n\t}\n\n\n\t/**\n\t * Return the name of this module.\n\t */\n\tpublic String getName() {\n\t\treturn moduleName; \n\t}\n\t\n\n\t/**\n\t * Return the base name of this module.\n\t * This is the module name but without any '.jmod' file extension\n\t * eg, if a 'com.hello.jmod' has been created this method would return 'com.hello'\n\t */\n\tpublic String getBaseName() {\n\t\tif (moduleName.endsWith(\".jmod\")) {\n\t\t\tint extensionStart = moduleName.lastIndexOf(\".jmod\");\n\t\t\treturn moduleName.substring(0, extensionStart);\n\t\t}\n\t\t\n\t\treturn moduleName; \n\t}\n\t\n\n\t/** \n\t * @return a FileRef for the jar file used by this module.\n\t */\n\tpublic FileRef getJarFileRef() {\n\t\treturn jarFileRef;\n\t}\n\t\n\t\n\tpublic String toString() { \n\t\treturn moduleName + \"->\" + jarFileRef.getName();\n\t}\n}"
    },
    "147": {
      "metadata": {
        "chunk_id": "8dbcbf4fa47b2931f029423b26ffc35ad5ff0c6ff948eb892dda6134ae2c3480",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/PlatformFinder.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.stf.StfException;\n\n/**\n * A utility which prints which platform of the current JVM\n * \n * TODO: This code should\n *   1) Operate a higher level than supplying magic strings. eg, add methods such as 'isWindows()'\n *   2) Avoid final else options which assume a certain platform. Things should be explicit, with the else throwing an exception.\n */",
        "start_line": 0,
        "end_line": 27,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 232,
        "node_type": null,
        "file_sha": "9eb9c2875976027853cb24048eb427ba71f910f7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.907902"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.stf.StfException;\n\n/**\n * A utility which prints which platform of the current JVM\n * \n * TODO: This code should\n *   1) Operate a higher level than supplying magic strings. eg, add methods such as 'isWindows()'\n *   2) Avoid final else options which assume a certain platform. Things should be explicit, with the else throwing an exception.\n */"
    },
    "148": {
      "metadata": {
        "chunk_id": "4d8012dc7d29738ecb0384e900c41b3e4b5b7182b788a6ef648335c4b6637101",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/PlatformFinder.java",
        "content": "public class PlatformFinder {\n\tpublic enum Platform {\n\t\tLINUX(\"linux\"),\n\t\tWINDOWS(\"win\"),\n\t\tAIX(\"aix\"),\n\t\tZOS(\"zos\"),\n\t\tBSD(\"bsd\"),\n\t\tOSX(\"osx\"),\n\t\tSOLARIS(\"sunos\");\n\t\t\n\t\tprivate String shortName;\n\t\tprivate Platform(String shortName) { this.shortName = shortName; }\n\t\tpublic String getShortName() { return this.shortName; }\n\t}; \n\n\t\n\tprivate static PlatformFinder instance = null;\n\n\tprivate Platform platform;\n    private String osShortName;\n    private String osArch;\n    private String osEndian;\n    private String osArchType;\n\n\t \n\tpublic static void main(String[] args) throws StfException {\n\t\tSystem.out.println(PlatformFinder.getPlatformAsString());\n\t\t\n\t\tPlatformFinder.forcePlatform(\"win_ppcle-32\");\n\t\tSystem.out.println(PlatformFinder.getPlatformAsString());\n\t\t\n\t\tPlatformFinder.forcePlatform(\"win_x86-64\");\n\t\tSystem.out.println(PlatformFinder.getPlatformAsString());\n\t}\n\n\tprivate static PlatformFinder getInstance() throws StfException {\n\t\tif (instance == null) {\n\t\t\tinstance = new PlatformFinder(\n\t\t\t\t\t\t\t PlatformFinder.calcOSShortName(), \n\t\t\t\t\t\t\t PlatformFinder.calcArchName(), \n\t\t\t\t\t\t\t PlatformFinder.calcEndian(),\n\t\t\t\t\t\t\t PlatformFinder.calcArchType());\n\t\t}\n\t\t\n\t\treturn instance;\n\t}\n\n\n\tpublic PlatformFinder(String osShortName, String osArch, String osEndian, String osArchType) throws StfException {\n\t\t// Decode the osShortName, and set the platform field\n\t\tfor (Platform p : Platform.values()) { \n\t\t\tif (p.getShortName().equals(osShortName)) {\n\t\t\t\tplatform = p;\n\t\t\t}\n\t\t}\n\t\tif (platform == null) { \n\t\t\tthrow new StfException(\"Failed to identify platform for OS short name: '\" + osShortName + \"'\");\n\t\t}\n\n\t\t// Validate the architecture value\n\t\tString osArchRegex = \"390|x86|ppc|x86|arm|riscv|sparc|loongarch\";\n\t\tif (!osArch.matches(osArchRegex)) {\n\t\t\tthrow new StfException(\"Unknown architecture value: '\" + osArch + \"'. Expected one of '\" + osArchRegex + \"'\");\n\t\t}\n\n\t\t// Validate the endian value\n\t\tString osEndianRegex = \"le|\";\n\t\tif (!osEndian.matches(osEndianRegex)) {\n\t\t\tthrow new StfException(\"Unknown endian value: '\" + osEndian + \"'. Expected one of '\" + osEndianRegex + \"'\");\n\t\t}\n\n\t\t// Validate the word size value\n\t\tString osWordSizeRegex = \"31|32|64\";\n\t\tif (!osArchType.matches(osWordSizeRegex)) {\n\t\t\tthrow new StfException(\"Unknown word size value: '\" + osArchType + \"'. Expected one of '\" + osWordSizeRegex + \"'\");\n\t\t}\n\n\t\tthis.osShortName = osShortName;\n\t\tthis.osArch      = osArch;\n\t\tthis.osEndian    = osEndian;\n\t\tthis.osArchType  = osArchType;\n\t}\n\t\n\t\n\tpublic static void forcePlatform(String platformDescription) throws StfException {\n        String patternString = \"(.*)_(.*?)([l][e])?-(.*)\";\n\n        Pattern pattern = Pattern.compile(patternString);\n        Matcher matcher = pattern.matcher(platformDescription);\n\n        if (!matcher.find() || matcher.groupCount() != 4) {\n        \tthrow new StfException(\"Failed to parse platform description. '\" + platformDescription + \"' \"\n        \t\t\t+ \"Should be in the form '<os-name>_<architecture>-<wordsize>', \"\n        \t\t\t+ \"eg, linux_x86-64\");\n        }\n        \n        String shortName    = matcher.group(1);\n        String architecture = matcher.group(2);\n        String endian       = matcher.group(3);\n        String wordsize     = matcher.group(4);\n        \n        if (endian == null) {\n        \tendian = \"\";\n        }\n\n\t\tinstance = new PlatformFinder(shortName, architecture, endian, wordsize);\n\t}\n\n    public static String getPlatformAsString() throws StfException {\n    \tPlatformFinder pf = getInstance();\n        return pf.osShortName + \"_\" + pf.osArch + pf.osEndian + \"-\" + pf.osArchType;     \t     \t \n    }\n    \n    public static String getPlatformSimple() throws StfException {\n    \treturn calcOSShortName();\n    }\n\n\tpublic static Platform getPlatform() throws StfException {\n\t\treturn PlatformFinder.getInstance().platform;\n\t}\n\n\tpublic static String getArchName() throws StfException {\n\t\treturn PlatformFinder.getInstance().osArch;\n\t}",
        "start_line": 28,
        "end_line": 151,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 959,
        "node_type": null,
        "file_sha": "9eb9c2875976027853cb24048eb427ba71f910f7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.907919"
      },
      "text": "public class PlatformFinder {\n\tpublic enum Platform {\n\t\tLINUX(\"linux\"),\n\t\tWINDOWS(\"win\"),\n\t\tAIX(\"aix\"),\n\t\tZOS(\"zos\"),\n\t\tBSD(\"bsd\"),\n\t\tOSX(\"osx\"),\n\t\tSOLARIS(\"sunos\");\n\t\t\n\t\tprivate String shortName;\n\t\tprivate Platform(String shortName) { this.shortName = shortName; }\n\t\tpublic String getShortName() { return this.shortName; }\n\t}; \n\n\t\n\tprivate static PlatformFinder instance = null;\n\n\tprivate Platform platform;\n    private String osShortName;\n    private String osArch;\n    private String osEndian;\n    private String osArchType;\n\n\t \n\tpublic static void main(String[] args) throws StfException {\n\t\tSystem.out.println(PlatformFinder.getPlatformAsString());\n\t\t\n\t\tPlatformFinder.forcePlatform(\"win_ppcle-32\");\n\t\tSystem.out.println(PlatformFinder.getPlatformAsString());\n\t\t\n\t\tPlatformFinder.forcePlatform(\"win_x86-64\");\n\t\tSystem.out.println(PlatformFinder.getPlatformAsString());\n\t}\n\n\tprivate static PlatformFinder getInstance() throws StfException {\n\t\tif (instance == null) {\n\t\t\tinstance = new PlatformFinder(\n\t\t\t\t\t\t\t PlatformFinder.calcOSShortName(), \n\t\t\t\t\t\t\t PlatformFinder.calcArchName(), \n\t\t\t\t\t\t\t PlatformFinder.calcEndian(),\n\t\t\t\t\t\t\t PlatformFinder.calcArchType());\n\t\t}\n\t\t\n\t\treturn instance;\n\t}\n\n\n\tpublic PlatformFinder(String osShortName, String osArch, String osEndian, String osArchType) throws StfException {\n\t\t// Decode the osShortName, and set the platform field\n\t\tfor (Platform p : Platform.values()) { \n\t\t\tif (p.getShortName().equals(osShortName)) {\n\t\t\t\tplatform = p;\n\t\t\t}\n\t\t}\n\t\tif (platform == null) { \n\t\t\tthrow new StfException(\"Failed to identify platform for OS short name: '\" + osShortName + \"'\");\n\t\t}\n\n\t\t// Validate the architecture value\n\t\tString osArchRegex = \"390|x86|ppc|x86|arm|riscv|sparc|loongarch\";\n\t\tif (!osArch.matches(osArchRegex)) {\n\t\t\tthrow new StfException(\"Unknown architecture value: '\" + osArch + \"'. Expected one of '\" + osArchRegex + \"'\");\n\t\t}\n\n\t\t// Validate the endian value\n\t\tString osEndianRegex = \"le|\";\n\t\tif (!osEndian.matches(osEndianRegex)) {\n\t\t\tthrow new StfException(\"Unknown endian value: '\" + osEndian + \"'. Expected one of '\" + osEndianRegex + \"'\");\n\t\t}\n\n\t\t// Validate the word size value\n\t\tString osWordSizeRegex = \"31|32|64\";\n\t\tif (!osArchType.matches(osWordSizeRegex)) {\n\t\t\tthrow new StfException(\"Unknown word size value: '\" + osArchType + \"'. Expected one of '\" + osWordSizeRegex + \"'\");\n\t\t}\n\n\t\tthis.osShortName = osShortName;\n\t\tthis.osArch      = osArch;\n\t\tthis.osEndian    = osEndian;\n\t\tthis.osArchType  = osArchType;\n\t}\n\t\n\t\n\tpublic static void forcePlatform(String platformDescription) throws StfException {\n        String patternString = \"(.*)_(.*?)([l][e])?-(.*)\";\n\n        Pattern pattern = Pattern.compile(patternString);\n        Matcher matcher = pattern.matcher(platformDescription);\n\n        if (!matcher.find() || matcher.groupCount() != 4) {\n        \tthrow new StfException(\"Failed to parse platform description. '\" + platformDescription + \"' \"\n        \t\t\t+ \"Should be in the form '<os-name>_<architecture>-<wordsize>', \"\n        \t\t\t+ \"eg, linux_x86-64\");\n        }\n        \n        String shortName    = matcher.group(1);\n        String architecture = matcher.group(2);\n        String endian       = matcher.group(3);\n        String wordsize     = matcher.group(4);\n        \n        if (endian == null) {\n        \tendian = \"\";\n        }\n\n\t\tinstance = new PlatformFinder(shortName, architecture, endian, wordsize);\n\t}\n\n    public static String getPlatformAsString() throws StfException {\n    \tPlatformFinder pf = getInstance();\n        return pf.osShortName + \"_\" + pf.osArch + pf.osEndian + \"-\" + pf.osArchType;     \t     \t \n    }\n    \n    public static String getPlatformSimple() throws StfException {\n    \treturn calcOSShortName();\n    }\n\n\tpublic static Platform getPlatform() throws StfException {\n\t\treturn PlatformFinder.getInstance().platform;\n\t}\n\n\tpublic static String getArchName() throws StfException {\n\t\treturn PlatformFinder.getInstance().osArch;\n\t}"
    },
    "149": {
      "metadata": {
        "chunk_id": "08b70348a0b984264a99622e070788e1673dcd08c04863695550c318e1dd2226",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/PlatformFinder.java",
        "content": "instance = new PlatformFinder(shortName, architecture, endian, wordsize);\n\t}\n\n    public static String getPlatformAsString() throws StfException {\n    \tPlatformFinder pf = getInstance();\n        return pf.osShortName + \"_\" + pf.osArch + pf.osEndian + \"-\" + pf.osArchType;     \t     \t \n    }\n    \n    public static String getPlatformSimple() throws StfException {\n    \treturn calcOSShortName();\n    }\n\n\tpublic static Platform getPlatform() throws StfException {\n\t\treturn PlatformFinder.getInstance().platform;\n\t}\n\n\tpublic static String getArchName() throws StfException {\n\t\treturn PlatformFinder.getInstance().osArch;\n\t}\n\n\tpublic static String getArchType() throws StfException {\n\t\treturn PlatformFinder.getInstance().osArchType;\n\t}\n\n\t/**\n\t * Removes a platform suffix from a string. eg, converts 'apps-root.win' to 'apps-root'\n\t * \n\t * @param str is the string with an optional platform suffix\n\t * @return a string containing the string without a platform suffix.\n\t */\n\tpublic static String removePlatformSuffix(String str) {\n\t\treturn str.replaceAll(\".linux$|.win$|.aix$|.zos$|.osx$|.bsd$\", \"\");\n\t}\n\n\n    private static String calcOSShortName()\n    {\n        // get the osName and make it lowercase\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        \n        // set the shortname to the osName if the current system is Linux\n        // or AIX this is all that is needed\n        String osShortName = osName;\n            \t \n        // if we are on z/OS remove the slash\n        if (osName.equals(\"z/os\")) {\n            osShortName = \"zos\";\n        }\n        \n        // if we are on a Windows machine use win as the shortname\n        if (osName.contains(\"win\")) {\n            osShortName = \"win\";\n        }\n        \n        // if we are on a Mac use osx as the shortname\n        if (osName.contains(\"mac\")) {\n            osShortName = \"osx\";\n        }",
        "start_line": 152,
        "end_line": 209,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 440,
        "node_type": null,
        "file_sha": "9eb9c2875976027853cb24048eb427ba71f910f7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.907921"
      },
      "text": "instance = new PlatformFinder(shortName, architecture, endian, wordsize);\n\t}\n\n    public static String getPlatformAsString() throws StfException {\n    \tPlatformFinder pf = getInstance();\n        return pf.osShortName + \"_\" + pf.osArch + pf.osEndian + \"-\" + pf.osArchType;     \t     \t \n    }\n    \n    public static String getPlatformSimple() throws StfException {\n    \treturn calcOSShortName();\n    }\n\n\tpublic static Platform getPlatform() throws StfException {\n\t\treturn PlatformFinder.getInstance().platform;\n\t}\n\n\tpublic static String getArchName() throws StfException {\n\t\treturn PlatformFinder.getInstance().osArch;\n\t}\n\n\tpublic static String getArchType() throws StfException {\n\t\treturn PlatformFinder.getInstance().osArchType;\n\t}\n\n\t/**\n\t * Removes a platform suffix from a string. eg, converts 'apps-root.win' to 'apps-root'\n\t * \n\t * @param str is the string with an optional platform suffix\n\t * @return a string containing the string without a platform suffix.\n\t */\n\tpublic static String removePlatformSuffix(String str) {\n\t\treturn str.replaceAll(\".linux$|.win$|.aix$|.zos$|.osx$|.bsd$\", \"\");\n\t}\n\n\n    private static String calcOSShortName()\n    {\n        // get the osName and make it lowercase\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        \n        // set the shortname to the osName if the current system is Linux\n        // or AIX this is all that is needed\n        String osShortName = osName;\n            \t \n        // if we are on z/OS remove the slash\n        if (osName.equals(\"z/os\")) {\n            osShortName = \"zos\";\n        }\n        \n        // if we are on a Windows machine use win as the shortname\n        if (osName.contains(\"win\")) {\n            osShortName = \"win\";\n        }\n        \n        // if we are on a Mac use osx as the shortname\n        if (osName.contains(\"mac\")) {\n            osShortName = \"osx\";\n        }"
    },
    "150": {
      "metadata": {
        "chunk_id": "c07fe0c1a9cce52cc5ceb93766d720d7761d0cbd09113652cf7dc0b582d21b91",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/PlatformFinder.java",
        "content": "private static String calcOSShortName()\n    {\n        // get the osName and make it lowercase\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        \n        // set the shortname to the osName if the current system is Linux\n        // or AIX this is all that is needed\n        String osShortName = osName;\n            \t \n        // if we are on z/OS remove the slash\n        if (osName.equals(\"z/os\")) {\n            osShortName = \"zos\";\n        }\n        \n        // if we are on a Windows machine use win as the shortname\n        if (osName.contains(\"win\")) {\n            osShortName = \"win\";\n        }\n        \n        // if we are on a Mac use osx as the shortname\n        if (osName.contains(\"mac\")) {\n            osShortName = \"osx\";\n        }   \n\n        // if we are on BSD use bsd as the shortname\n        if (osName.contains(\"bsd\")) {\n            osShortName = \"bsd\";\n        }\n        \n        // if we are on sunos use sunos as the shortname\n        if (osName.contains(\"sunos\")) {\n            osShortName = \"sunos\";\n        }\n                \n        return osShortName;\n    }\n    \n    \n    private static String calcArchName()\n    {\n        // get the architecture name (ppc, amd etc), os name (z/OS, \n        // linux, etc) and the architecture type (31, 32, 64) \n        String osArch = System.getProperty(\"os.arch\");\n        \n        if (osArch.length() >= 4 && osArch.substring(0, 4).equals(\"s390\")) {\n        \t// if the current system is a 390 machine use 390 as the osArch    \t \n            osArch = \"390\";    \t\t \n        } else if (osArch.equals(\"amd64\")) {\n        \t// if the current system is AMD64 use x86 as the osArch\n            osArch = \"x86\";    \t\t \n        } else if(osArch.contains(\"ppc64\")) {\n        \t// if the current system is PPC64 use ppc as the osArch\n            osArch = \"ppc\";    \t\t \n        } else if(osArch.contains(\"aarch64\")) {\n                // if the current system is aarch64 use arm as the osArch\n            osArch = \"arm\";\n        } else if(osArch.contains(\"loongarch64\")) {\n            // if the current system is loongarch64 use loongarch as the osArch\n           osArch = \"loongarch\";\n\t} else if(osArch.contains(\"riscv\")) {\n            // The openj9 jdk sets os.arch to riscv, the bisheng jdk sets it to riscv64\n            osArch = \"riscv\";\n        } else if(osArch.contains(\"sparcv9\")) {\n            // if the current system is sparcv9 use sparc as the osArch\n            osArch = \"sparc\";\n        } else if (osArch.length() == 4\n        \t && osArch.charAt(0) == 'i'\n        \t && Character.isDigit(osArch.charAt(1))\n        \t && osArch.substring(2).equals(\"86\")) {\n            // if the current system is i?86 where ? is a digit use x86\n            osArch = \"x86\";\n        } else if (osArch.equals(\"x86_64\")) {\n        \t// if the current system is x86_64 (which is true for Mac) use x86 as the osArch\n            osArch = \"x86\";    \t\t \n        }        \n        \n        return osArch;\n    }\n\n\n    private static String calcArchType() {\n        // get the architecture name and the architecture type (32, 64)\n        String osArchType = System.getProperty(\"sun.arch.data.model\");\n        String osArch = System.getProperty(\"os.arch\");\n           \n        // if no Sun classes, use IBM one instead\n        if (osArchType == null) {\n            osArchType = System.getProperty(\"com.ibm.vm.bitmode\");\n        }\n        \n        return osArchType;\n    }\n    \n\n    private static String calcEndian()\n    {\n        String osEndian = System.getProperty(\"sun.cpu.endian\");\n        String osArch = System.getProperty(\"os.arch\");\n        \n        if ((osEndian.equals(\"little\")) && (osArch.contains(\"ppc64\")))  {\n            osEndian = \"le\";\n        } else {\n            osEndian = \"\";\n        }\n        \n        return osEndian;\n    }\n    \n\n    public static boolean isWindows() throws StfException {\n        return getPlatform() == Platform.WINDOWS;\n    }",
        "start_line": 210,
        "end_line": 321,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 987,
        "node_type": null,
        "file_sha": "9eb9c2875976027853cb24048eb427ba71f910f7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.907924"
      },
      "text": "private static String calcOSShortName()\n    {\n        // get the osName and make it lowercase\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        \n        // set the shortname to the osName if the current system is Linux\n        // or AIX this is all that is needed\n        String osShortName = osName;\n            \t \n        // if we are on z/OS remove the slash\n        if (osName.equals(\"z/os\")) {\n            osShortName = \"zos\";\n        }\n        \n        // if we are on a Windows machine use win as the shortname\n        if (osName.contains(\"win\")) {\n            osShortName = \"win\";\n        }\n        \n        // if we are on a Mac use osx as the shortname\n        if (osName.contains(\"mac\")) {\n            osShortName = \"osx\";\n        }   \n\n        // if we are on BSD use bsd as the shortname\n        if (osName.contains(\"bsd\")) {\n            osShortName = \"bsd\";\n        }\n        \n        // if we are on sunos use sunos as the shortname\n        if (osName.contains(\"sunos\")) {\n            osShortName = \"sunos\";\n        }\n                \n        return osShortName;\n    }\n    \n    \n    private static String calcArchName()\n    {\n        // get the architecture name (ppc, amd etc), os name (z/OS, \n        // linux, etc) and the architecture type (31, 32, 64) \n        String osArch = System.getProperty(\"os.arch\");\n        \n        if (osArch.length() >= 4 && osArch.substring(0, 4).equals(\"s390\")) {\n        \t// if the current system is a 390 machine use 390 as the osArch    \t \n            osArch = \"390\";    \t\t \n        } else if (osArch.equals(\"amd64\")) {\n        \t// if the current system is AMD64 use x86 as the osArch\n            osArch = \"x86\";    \t\t \n        } else if(osArch.contains(\"ppc64\")) {\n        \t// if the current system is PPC64 use ppc as the osArch\n            osArch = \"ppc\";    \t\t \n        } else if(osArch.contains(\"aarch64\")) {\n                // if the current system is aarch64 use arm as the osArch\n            osArch = \"arm\";\n        } else if(osArch.contains(\"loongarch64\")) {\n            // if the current system is loongarch64 use loongarch as the osArch\n           osArch = \"loongarch\";\n\t} else if(osArch.contains(\"riscv\")) {\n            // The openj9 jdk sets os.arch to riscv, the bisheng jdk sets it to riscv64\n            osArch = \"riscv\";\n        } else if(osArch.contains(\"sparcv9\")) {\n            // if the current system is sparcv9 use sparc as the osArch\n            osArch = \"sparc\";\n        } else if (osArch.length() == 4\n        \t && osArch.charAt(0) == 'i'\n        \t && Character.isDigit(osArch.charAt(1))\n        \t && osArch.substring(2).equals(\"86\")) {\n            // if the current system is i?86 where ? is a digit use x86\n            osArch = \"x86\";\n        } else if (osArch.equals(\"x86_64\")) {\n        \t// if the current system is x86_64 (which is true for Mac) use x86 as the osArch\n            osArch = \"x86\";    \t\t \n        }        \n        \n        return osArch;\n    }\n\n\n    private static String calcArchType() {\n        // get the architecture name and the architecture type (32, 64)\n        String osArchType = System.getProperty(\"sun.arch.data.model\");\n        String osArch = System.getProperty(\"os.arch\");\n           \n        // if no Sun classes, use IBM one instead\n        if (osArchType == null) {\n            osArchType = System.getProperty(\"com.ibm.vm.bitmode\");\n        }\n        \n        return osArchType;\n    }\n    \n\n    private static String calcEndian()\n    {\n        String osEndian = System.getProperty(\"sun.cpu.endian\");\n        String osArch = System.getProperty(\"os.arch\");\n        \n        if ((osEndian.equals(\"little\")) && (osArch.contains(\"ppc64\")))  {\n            osEndian = \"le\";\n        } else {\n            osEndian = \"\";\n        }\n        \n        return osEndian;\n    }\n    \n\n    public static boolean isWindows() throws StfException {\n        return getPlatform() == Platform.WINDOWS;\n    }"
    },
    "151": {
      "metadata": {
        "chunk_id": "9f34849d2a90612ec603cc94619da3664303b726b64224598a8481a5a46c4d87",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/PlatformFinder.java",
        "content": "private static String calcEndian()\n    {\n        String osEndian = System.getProperty(\"sun.cpu.endian\");\n        String osArch = System.getProperty(\"os.arch\");\n        \n        if ((osEndian.equals(\"little\")) && (osArch.contains(\"ppc64\")))  {\n            osEndian = \"le\";\n        } else {\n            osEndian = \"\";\n        }\n        \n        return osEndian;\n    }\n    \n\n    public static boolean isWindows() throws StfException {\n        return getPlatform() == Platform.WINDOWS;\n    }\n\n    \n\tpublic static boolean isLinux() throws StfException {\n\t\treturn getPlatform() == Platform.LINUX;\n\t} \n\t\n\t\n\tpublic static boolean isAix() throws StfException {\n\t\treturn getPlatform() == Platform.AIX;\n\t}\n\t\n\tpublic static boolean isZOS() throws StfException {\n\t\treturn getPlatform() == Platform.ZOS;\n\t}\n\t\n\tpublic static boolean isOSX() throws StfException {\n\t\treturn getPlatform() == Platform.OSX;\n\t}\n\t\n\tpublic static boolean isSolaris() throws StfException {\n\t\treturn getPlatform() == Platform.SOLARIS;\n\t}\n}",
        "start_line": 322,
        "end_line": 362,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 234,
        "node_type": null,
        "file_sha": "9eb9c2875976027853cb24048eb427ba71f910f7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.907926"
      },
      "text": "private static String calcEndian()\n    {\n        String osEndian = System.getProperty(\"sun.cpu.endian\");\n        String osArch = System.getProperty(\"os.arch\");\n        \n        if ((osEndian.equals(\"little\")) && (osArch.contains(\"ppc64\")))  {\n            osEndian = \"le\";\n        } else {\n            osEndian = \"\";\n        }\n        \n        return osEndian;\n    }\n    \n\n    public static boolean isWindows() throws StfException {\n        return getPlatform() == Platform.WINDOWS;\n    }\n\n    \n\tpublic static boolean isLinux() throws StfException {\n\t\treturn getPlatform() == Platform.LINUX;\n\t} \n\t\n\t\n\tpublic static boolean isAix() throws StfException {\n\t\treturn getPlatform() == Platform.AIX;\n\t}\n\t\n\tpublic static boolean isZOS() throws StfException {\n\t\treturn getPlatform() == Platform.ZOS;\n\t}\n\t\n\tpublic static boolean isOSX() throws StfException {\n\t\treturn getPlatform() == Platform.OSX;\n\t}\n\t\n\tpublic static boolean isSolaris() throws StfException {\n\t\treturn getPlatform() == Platform.SOLARIS;\n\t}\n}"
    },
    "152": {
      "metadata": {
        "chunk_id": "ecb05b937208eb01a2e6bad5b1f7c1cf5c011cbfc092970e7bd7e912d2efb89b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfEnvironmentCore.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.Stage;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.LayeredProperties;\nimport net.adoptopenjdk.stf.environment.properties.OrderedProperties;\nimport net.adoptopenjdk.stf.environment.properties.OrderedProperties.PropertyFileDetails;\nimport net.adoptopenjdk.stf.extensions.Stf;\n\n\n/** \n * This class provides full access to environmental data.\n * \n * It is expected that this class is used by STF itself and also by STF \n * extensions, but not by test plugin code.\n * If this class can be accessed by plugins then there is the risk that \n * plugins will make use of the facilities with the risk that tests become \n * excessively complex and fragile.\n * \n * This is a superset of the information provided by the StfEnvironment class, which \n * provides restricted information to plugins.\n */",
        "start_line": 0,
        "end_line": 44,
        "chunk_index": 0,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 380,
        "node_type": null,
        "file_sha": "5935ba9c996d77aaf4a3f685f9aed91fc09fbd44",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.917529"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.Stage;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.LayeredProperties;\nimport net.adoptopenjdk.stf.environment.properties.OrderedProperties;\nimport net.adoptopenjdk.stf.environment.properties.OrderedProperties.PropertyFileDetails;\nimport net.adoptopenjdk.stf.extensions.Stf;\n\n\n/** \n * This class provides full access to environmental data.\n * \n * It is expected that this class is used by STF itself and also by STF \n * extensions, but not by test plugin code.\n * If this class can be accessed by plugins then there is the risk that \n * plugins will make use of the facilities with the risk that tests become \n * excessively complex and fragile.\n * \n * This is a superset of the information provided by the StfEnvironment class, which \n * provides restricted information to plugins.\n */"
    },
    "153": {
      "metadata": {
        "chunk_id": "8cc946fc70e6f0d37b472d42dc427cb1241e549068232ae046e5abd84989782f",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfEnvironmentCore.java",
        "content": "public class StfEnvironmentCore {\n\t// Reference to the workspaces containing tests which use STF, \n\t// plus the workspace containing STF itself (always the final element).\n\tprivate ArrayList<DirectoryRef> testRoots = new ArrayList<DirectoryRef>();\n\t// Reference to the directories containing the test prereqs\n\tprivate ArrayList<DirectoryRef> prereqRoots = new ArrayList<DirectoryRef>();\n\t\n\tprivate LayeredProperties properties;\n\t\n\tprivate DirectoryRef tmpDir;\n\tprivate DirectoryRef testDir;\n\tprivate DirectoryRef resultsDir;\n\tprivate DirectoryRef modulesDir;\n\tprivate DirectoryRef debugDir;\n\t\n\tprivate StfTestArguments testArgs = null;\n\n\tprivate Stage stage;\n\t\n    private static final Logger logger = LogManager.getLogger(StfEnvironmentCore.class.getName());\n\t\n\t\n\tpublic StfEnvironmentCore(ArrayList<PropertyFileDetails> propertyFileDetails, ArrayList<Argument> supportedArguments,\n\t\t\tString testDir) throws StfException {\n\n\t\tArrayList<OrderedProperties> allPropertyData = new ArrayList<OrderedProperties>();\n\t\tOrderedProperties invocationProperties = new OrderedProperties(\"<<invocation arguments>>\");\n//TODO tmpdir, etc, ??\t\tinvocationProperties.put(\"test\", testName);  // Are there really invocation arguments that need their own layer.\n\t\tallPropertyData.add(invocationProperties);\n\n\t\t// Read in contents of all property files\n\t\tfor (PropertyFileDetails propertyFile : propertyFileDetails) {\n\t\t\tOrderedProperties propertyData = OrderedProperties.loadFromFile(propertyFile);\n\t\t\tallPropertyData.add(propertyData);\n\t\t}\n\n\t\tthis.properties = new LayeredProperties(allPropertyData, supportedArguments);",
        "start_line": 45,
        "end_line": 81,
        "chunk_index": 1,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 325,
        "node_type": null,
        "file_sha": "5935ba9c996d77aaf4a3f685f9aed91fc09fbd44",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.917540"
      },
      "text": "public class StfEnvironmentCore {\n\t// Reference to the workspaces containing tests which use STF, \n\t// plus the workspace containing STF itself (always the final element).\n\tprivate ArrayList<DirectoryRef> testRoots = new ArrayList<DirectoryRef>();\n\t// Reference to the directories containing the test prereqs\n\tprivate ArrayList<DirectoryRef> prereqRoots = new ArrayList<DirectoryRef>();\n\t\n\tprivate LayeredProperties properties;\n\t\n\tprivate DirectoryRef tmpDir;\n\tprivate DirectoryRef testDir;\n\tprivate DirectoryRef resultsDir;\n\tprivate DirectoryRef modulesDir;\n\tprivate DirectoryRef debugDir;\n\t\n\tprivate StfTestArguments testArgs = null;\n\n\tprivate Stage stage;\n\t\n    private static final Logger logger = LogManager.getLogger(StfEnvironmentCore.class.getName());\n\t\n\t\n\tpublic StfEnvironmentCore(ArrayList<PropertyFileDetails> propertyFileDetails, ArrayList<Argument> supportedArguments,\n\t\t\tString testDir) throws StfException {\n\n\t\tArrayList<OrderedProperties> allPropertyData = new ArrayList<OrderedProperties>();\n\t\tOrderedProperties invocationProperties = new OrderedProperties(\"<<invocation arguments>>\");\n//TODO tmpdir, etc, ??\t\tinvocationProperties.put(\"test\", testName);  // Are there really invocation arguments that need their own layer.\n\t\tallPropertyData.add(invocationProperties);\n\n\t\t// Read in contents of all property files\n\t\tfor (PropertyFileDetails propertyFile : propertyFileDetails) {\n\t\t\tOrderedProperties propertyData = OrderedProperties.loadFromFile(propertyFile);\n\t\t\tallPropertyData.add(propertyData);\n\t\t}\n\n\t\tthis.properties = new LayeredProperties(allPropertyData, supportedArguments);"
    },
    "154": {
      "metadata": {
        "chunk_id": "d5109fec927ef3a8f715b5f8347e4298b91344e1015013f20b6453ae9ad782a4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfEnvironmentCore.java",
        "content": "// Make sure the stf workspace is always present in the list of roots, and is always element 0.\n\t\tDirectoryRef defaultTestRoot = createDirectoryRefFromProperty(Stf.ARG_STF_BIN_DIR).getParent().getParent();\n\t\t// Work out where the test cases workspace/s are.\n\t\tif (!getProperty(Stf.ARG_TEST_ROOT).isEmpty()) {\n\t\t\t// Get hold of test-root, ie, the directories containing test cases. \n\t\t\t// This should be a list of valid directories.\n\t\t\tthis.testRoots = explodeStringOfPaths(defaultTestRoot, getProperty(Stf.ARG_TEST_ROOT), \"test-root\");\n\t\t\t\n\t\t} else {\n\t\t\t// Use 2nd best option, and assume that everything is relative to the STF directory.\n\t\t\tthis.testRoots.add(defaultTestRoot);\n\t\t\tinvocationProperties.put(Stf.ARG_TEST_ROOT.getName(), defaultTestRoot.getSpec());\n\t\t}\n\t\t\n\t\t// Work out where the prereqs are\n\t\tif (!getProperty(Stf.ARG_SYSTEMTEST_PREREQS).isEmpty()) {\n\t\t\t// Get hold of test-root, ie, the directories containing test cases. \n\t\t\t// This should be a list of valid directories.\n\t\t\tthis.prereqRoots = explodeStringOfPaths(null,getProperty(Stf.ARG_SYSTEMTEST_PREREQS),\"systemtest-prereq\");\n\t\t} else {\n\t\t\tDirectoryRef prereqDir = findSystemtestPrereqs(invocationProperties, this.testRoots.get(0));\n\t\t\tthis.prereqRoots = new ArrayList<DirectoryRef>();\n\t\t\tthis.prereqRoots.add(prereqDir);\n\t\t\tinvocationProperties.put(Stf.ARG_SYSTEMTEST_PREREQS.getName(), prereqDir.getSpec());\n\t\t\tlogger.warn(\"systemtest_prereqs directory was not set on the command line, \"\n\t\t\t\t\t+ \"nor found in a properties file. STF will set it to: \" \n\t\t\t\t\t+ this.prereqRoots.get(0).getSpec());\n\t\t}\n\t\t\n\t\tthis.testDir    = createDirectoryRef(testDir);\n\t\tthis.tmpDir     = this.testDir.childDirectory(\"tmp\");\n\t\tthis.resultsDir = this.testDir.childDirectory(StfConstants.RESULTS_DIR);\n\t\tthis.modulesDir = this.testDir.childDirectory(\"modules\");\n\t\tthis.debugDir   = this.testDir.childDirectory(\"debug\");\n\t\t\n\t\tthis.tmpDir.asJavaFile().mkdirs();\n\t\tthis.resultsDir.asJavaFile().mkdirs();\n\t\tthis.modulesDir.asJavaFile().mkdirs();\n\t\tthis.debugDir.asJavaFile().mkdirs();\n\t}\n\t\n\t/**\n\t * This method takes a semi-colon-seperated String of valid paths, and returns an Arraylist containing \n\t * a DirectoryRef object for each unique path.\n\t * @param firstElement   The first element for the array, in situations where one element must be first.\n\t * @param  directoryList A list of valid directories, separated by semicolons.\n\t * @param  titleString  The title of this paths collection, for use in errors and debug messages. E.g. \"test-root\".\n\t * @throws StfException  To be thrown if any of the directories either does not exist, or is not a directory.\n\t */\n\tprivate ArrayList<DirectoryRef> explodeStringOfPaths(DirectoryRef firstElement, String directoryList, String titleString) throws StfException {\n\t\tArrayList<DirectoryRef> arrayOfPaths = new ArrayList<DirectoryRef>();\n\t\tArrayList<String> uniqueDirs = new ArrayList<String>(); // To ensure we only add unique directories to testRoots.\n\t\t\n\t\t// Add the default first element to the array.\n\t\tif (firstElement != null) {\n\t\t\tarrayOfPaths.add(firstElement);\n\t\t\ttry {\n\t\t\t\tuniqueDirs.add(firstElement.asJavaFile().getCanonicalPath());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Could not get the canonical path for the default \" + titleString + \": \" + firstElement.getSpec(),e);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Split the string at every semicolon, and iterate over the list;\n\t\t// removing duplicates and verifying that each is a valid directory.\n\t\tString[] pathStrings = directoryList.split(\";\");\n\t\tfor (int i = 0 ; i < pathStrings.length ; i++) {\n\t\t\tFile canonicalPath = new File(pathStrings[i]);\n\t\t\ttry {\n\t\t\t\tif (!uniqueDirs.contains(canonicalPath.getCanonicalPath())) { \n\t\t\t\t\tuniqueDirs.add(canonicalPath.getCanonicalPath());\n\t\t\t\t\tarrayOfPaths.add(createDirectoryRef(pathStrings[i]));\n\t\t\t\t\tlogger.debug(titleString.substring(0, 1).toUpperCase() + titleString.substring(1) + \" \" + (arrayOfPaths.size()-1) + \" = \" + arrayOfPaths.get(arrayOfPaths.size()-1).getSpec());\n\t\t\t\t} else {",
        "start_line": 82,
        "end_line": 155,
        "chunk_index": 2,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 1019,
        "node_type": null,
        "file_sha": "5935ba9c996d77aaf4a3f685f9aed91fc09fbd44",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.917544"
      },
      "text": "// Make sure the stf workspace is always present in the list of roots, and is always element 0.\n\t\tDirectoryRef defaultTestRoot = createDirectoryRefFromProperty(Stf.ARG_STF_BIN_DIR).getParent().getParent();\n\t\t// Work out where the test cases workspace/s are.\n\t\tif (!getProperty(Stf.ARG_TEST_ROOT).isEmpty()) {\n\t\t\t// Get hold of test-root, ie, the directories containing test cases. \n\t\t\t// This should be a list of valid directories.\n\t\t\tthis.testRoots = explodeStringOfPaths(defaultTestRoot, getProperty(Stf.ARG_TEST_ROOT), \"test-root\");\n\t\t\t\n\t\t} else {\n\t\t\t// Use 2nd best option, and assume that everything is relative to the STF directory.\n\t\t\tthis.testRoots.add(defaultTestRoot);\n\t\t\tinvocationProperties.put(Stf.ARG_TEST_ROOT.getName(), defaultTestRoot.getSpec());\n\t\t}\n\t\t\n\t\t// Work out where the prereqs are\n\t\tif (!getProperty(Stf.ARG_SYSTEMTEST_PREREQS).isEmpty()) {\n\t\t\t// Get hold of test-root, ie, the directories containing test cases. \n\t\t\t// This should be a list of valid directories.\n\t\t\tthis.prereqRoots = explodeStringOfPaths(null,getProperty(Stf.ARG_SYSTEMTEST_PREREQS),\"systemtest-prereq\");\n\t\t} else {\n\t\t\tDirectoryRef prereqDir = findSystemtestPrereqs(invocationProperties, this.testRoots.get(0));\n\t\t\tthis.prereqRoots = new ArrayList<DirectoryRef>();\n\t\t\tthis.prereqRoots.add(prereqDir);\n\t\t\tinvocationProperties.put(Stf.ARG_SYSTEMTEST_PREREQS.getName(), prereqDir.getSpec());\n\t\t\tlogger.warn(\"systemtest_prereqs directory was not set on the command line, \"\n\t\t\t\t\t+ \"nor found in a properties file. STF will set it to: \" \n\t\t\t\t\t+ this.prereqRoots.get(0).getSpec());\n\t\t}\n\t\t\n\t\tthis.testDir    = createDirectoryRef(testDir);\n\t\tthis.tmpDir     = this.testDir.childDirectory(\"tmp\");\n\t\tthis.resultsDir = this.testDir.childDirectory(StfConstants.RESULTS_DIR);\n\t\tthis.modulesDir = this.testDir.childDirectory(\"modules\");\n\t\tthis.debugDir   = this.testDir.childDirectory(\"debug\");\n\t\t\n\t\tthis.tmpDir.asJavaFile().mkdirs();\n\t\tthis.resultsDir.asJavaFile().mkdirs();\n\t\tthis.modulesDir.asJavaFile().mkdirs();\n\t\tthis.debugDir.asJavaFile().mkdirs();\n\t}\n\t\n\t/**\n\t * This method takes a semi-colon-seperated String of valid paths, and returns an Arraylist containing \n\t * a DirectoryRef object for each unique path.\n\t * @param firstElement   The first element for the array, in situations where one element must be first.\n\t * @param  directoryList A list of valid directories, separated by semicolons.\n\t * @param  titleString  The title of this paths collection, for use in errors and debug messages. E.g. \"test-root\".\n\t * @throws StfException  To be thrown if any of the directories either does not exist, or is not a directory.\n\t */\n\tprivate ArrayList<DirectoryRef> explodeStringOfPaths(DirectoryRef firstElement, String directoryList, String titleString) throws StfException {\n\t\tArrayList<DirectoryRef> arrayOfPaths = new ArrayList<DirectoryRef>();\n\t\tArrayList<String> uniqueDirs = new ArrayList<String>(); // To ensure we only add unique directories to testRoots.\n\t\t\n\t\t// Add the default first element to the array.\n\t\tif (firstElement != null) {\n\t\t\tarrayOfPaths.add(firstElement);\n\t\t\ttry {\n\t\t\t\tuniqueDirs.add(firstElement.asJavaFile().getCanonicalPath());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Could not get the canonical path for the default \" + titleString + \": \" + firstElement.getSpec(),e);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Split the string at every semicolon, and iterate over the list;\n\t\t// removing duplicates and verifying that each is a valid directory.\n\t\tString[] pathStrings = directoryList.split(\";\");\n\t\tfor (int i = 0 ; i < pathStrings.length ; i++) {\n\t\t\tFile canonicalPath = new File(pathStrings[i]);\n\t\t\ttry {\n\t\t\t\tif (!uniqueDirs.contains(canonicalPath.getCanonicalPath())) { \n\t\t\t\t\tuniqueDirs.add(canonicalPath.getCanonicalPath());\n\t\t\t\t\tarrayOfPaths.add(createDirectoryRef(pathStrings[i]));\n\t\t\t\t\tlogger.debug(titleString.substring(0, 1).toUpperCase() + titleString.substring(1) + \" \" + (arrayOfPaths.size()-1) + \" = \" + arrayOfPaths.get(arrayOfPaths.size()-1).getSpec());\n\t\t\t\t} else {"
    },
    "155": {
      "metadata": {
        "chunk_id": "b86a7146149818a1defafd17066f8d321eaf19fd3e7d5d9719b43ba2163232e9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfEnvironmentCore.java",
        "content": "}\n\t\t}\n\t\t\n\t\t// Split the string at every semicolon, and iterate over the list;\n\t\t// removing duplicates and verifying that each is a valid directory.\n\t\tString[] pathStrings = directoryList.split(\";\");\n\t\tfor (int i = 0 ; i < pathStrings.length ; i++) {\n\t\t\tFile canonicalPath = new File(pathStrings[i]);\n\t\t\ttry {\n\t\t\t\tif (!uniqueDirs.contains(canonicalPath.getCanonicalPath())) { \n\t\t\t\t\tuniqueDirs.add(canonicalPath.getCanonicalPath());\n\t\t\t\t\tarrayOfPaths.add(createDirectoryRef(pathStrings[i]));\n\t\t\t\t\tlogger.debug(titleString.substring(0, 1).toUpperCase() + titleString.substring(1) + \" \" + (arrayOfPaths.size()-1) + \" = \" + arrayOfPaths.get(arrayOfPaths.size()-1).getSpec());\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\"Ignoring \" + titleString + \" \" + pathStrings[i] + \" \"\n\t\t\t\t\t\t\t\t+ \"because its canonical path is identical to that of an earlier \" + titleString + \".\");\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Could not get the canonical path for the \" + titleString + \": \" + pathStrings[i],e);\n\t\t\t}\n\t\t}\n\t\t//Now we verify that all of the directories are valid\n\t\tfor (DirectoryRef onePath : arrayOfPaths) {\n\t\t\tif (!onePath.exists()) {\n\t\t\t\tthrow new StfException(titleString.substring(0, 1).toUpperCase() + titleString.substring(1) + \" does not exist: \" + onePath.getSpec());\n\t\t\t}\n\t\t\tif (!onePath.asJavaFile().isDirectory()) {\n\t\t\t\tthrow new StfException(titleString.substring(0, 1).toUpperCase() + titleString.substring(1) + \" exists, but is not a directory: \" + onePath.getSpec());\n\t\t\t}\n\t\t}\n\t\treturn arrayOfPaths;\n\t}\n\t\n\t/**\n\t * This method looks for the prereqs location if we were not given one.\n\t * @param  invocationProperties For setting ARG_SYSTEMTEST_PREREQS when we have the correct path.\n\t * @return DirectoryRef         The location we think there might be a copy of the prereqs.\n\t * @throws StfException         To be thrown if we can't find systemtest_prereqs on the workspace path.\n\t */\n\tprivate DirectoryRef findSystemtestPrereqs(OrderedProperties invocationProperties, DirectoryRef testRoot) throws StfException {\n\t\t// Figure out where it is by scanning the paths of each test root.\n\t\tboolean endPrereqsLoop = false;\n\t\tDirectoryRef potentialPrereqsRoot = (createDirectoryRef(testRoot.getSpec()));\n\t\tString asciiOrEbcdic = \"ascii\";\n\t\tif (getPlatform().startsWith(\"zos\")) {\n\t\t\tasciiOrEbcdic = \"ebcdic\";\n\t\t}\n\t\twhile (!endPrereqsLoop) {\n\t\t\t//Go up one step in the path. check to see if we haven't left the path.\n\t\t\ttry {\n\t\t\t\t//Does this directory contain systemtest_prereqs?\n\t\t\t\tif(potentialPrereqsRoot.childDirectory(\"systemtest_prereqs\").exists()) {\n\t\t\t\t\treturn potentialPrereqsRoot.childDirectory(\"systemtest_prereqs\");\n\t\t\t\t} else if(potentialPrereqsRoot.childDirectory(\"prereqs\").childDirectory(asciiOrEbcdic).childDirectory(\"systemtest_prereqs\").exists()) {\n\t\t\t\t\treturn potentialPrereqsRoot.childDirectory(\"prereqs\").childDirectory(asciiOrEbcdic).childDirectory(\"systemtest_prereqs\");\n\t\t\t\t} else {\n\t\t\t\t\t//If no, then go up a step and try again.\n\t\t\t\t\tpotentialPrereqsRoot = potentialPrereqsRoot.getParent();\n\t\t\t\t}\n\t\t\t} catch (StfException e) {\n\t\t\t\t//do nothing.\n\t\t\t}\n\t\t}\n\t\t\n\t\t//If systemtest_prereqs was not on the test root path, throw an exception.\n\t\tthrow new StfException(\"Prereqs root cannot be found. We were not provided a location, and were \"\n\t\t\t\t\t\t\t + \"unable to find the systemtest_prereqs directory inside any of the directories \"\n\t\t\t\t\t\t\t + \"along any of the test_root paths: \" + testRoot.getSpec());\n\t}",
        "start_line": 156,
        "end_line": 224,
        "chunk_index": 3,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 908,
        "node_type": null,
        "file_sha": "5935ba9c996d77aaf4a3f685f9aed91fc09fbd44",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.917547"
      },
      "text": "}\n\t\t}\n\t\t\n\t\t// Split the string at every semicolon, and iterate over the list;\n\t\t// removing duplicates and verifying that each is a valid directory.\n\t\tString[] pathStrings = directoryList.split(\";\");\n\t\tfor (int i = 0 ; i < pathStrings.length ; i++) {\n\t\t\tFile canonicalPath = new File(pathStrings[i]);\n\t\t\ttry {\n\t\t\t\tif (!uniqueDirs.contains(canonicalPath.getCanonicalPath())) { \n\t\t\t\t\tuniqueDirs.add(canonicalPath.getCanonicalPath());\n\t\t\t\t\tarrayOfPaths.add(createDirectoryRef(pathStrings[i]));\n\t\t\t\t\tlogger.debug(titleString.substring(0, 1).toUpperCase() + titleString.substring(1) + \" \" + (arrayOfPaths.size()-1) + \" = \" + arrayOfPaths.get(arrayOfPaths.size()-1).getSpec());\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\"Ignoring \" + titleString + \" \" + pathStrings[i] + \" \"\n\t\t\t\t\t\t\t\t+ \"because its canonical path is identical to that of an earlier \" + titleString + \".\");\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Could not get the canonical path for the \" + titleString + \": \" + pathStrings[i],e);\n\t\t\t}\n\t\t}\n\t\t//Now we verify that all of the directories are valid\n\t\tfor (DirectoryRef onePath : arrayOfPaths) {\n\t\t\tif (!onePath.exists()) {\n\t\t\t\tthrow new StfException(titleString.substring(0, 1).toUpperCase() + titleString.substring(1) + \" does not exist: \" + onePath.getSpec());\n\t\t\t}\n\t\t\tif (!onePath.asJavaFile().isDirectory()) {\n\t\t\t\tthrow new StfException(titleString.substring(0, 1).toUpperCase() + titleString.substring(1) + \" exists, but is not a directory: \" + onePath.getSpec());\n\t\t\t}\n\t\t}\n\t\treturn arrayOfPaths;\n\t}\n\t\n\t/**\n\t * This method looks for the prereqs location if we were not given one.\n\t * @param  invocationProperties For setting ARG_SYSTEMTEST_PREREQS when we have the correct path.\n\t * @return DirectoryRef         The location we think there might be a copy of the prereqs.\n\t * @throws StfException         To be thrown if we can't find systemtest_prereqs on the workspace path.\n\t */\n\tprivate DirectoryRef findSystemtestPrereqs(OrderedProperties invocationProperties, DirectoryRef testRoot) throws StfException {\n\t\t// Figure out where it is by scanning the paths of each test root.\n\t\tboolean endPrereqsLoop = false;\n\t\tDirectoryRef potentialPrereqsRoot = (createDirectoryRef(testRoot.getSpec()));\n\t\tString asciiOrEbcdic = \"ascii\";\n\t\tif (getPlatform().startsWith(\"zos\")) {\n\t\t\tasciiOrEbcdic = \"ebcdic\";\n\t\t}\n\t\twhile (!endPrereqsLoop) {\n\t\t\t//Go up one step in the path. check to see if we haven't left the path.\n\t\t\ttry {\n\t\t\t\t//Does this directory contain systemtest_prereqs?\n\t\t\t\tif(potentialPrereqsRoot.childDirectory(\"systemtest_prereqs\").exists()) {\n\t\t\t\t\treturn potentialPrereqsRoot.childDirectory(\"systemtest_prereqs\");\n\t\t\t\t} else if(potentialPrereqsRoot.childDirectory(\"prereqs\").childDirectory(asciiOrEbcdic).childDirectory(\"systemtest_prereqs\").exists()) {\n\t\t\t\t\treturn potentialPrereqsRoot.childDirectory(\"prereqs\").childDirectory(asciiOrEbcdic).childDirectory(\"systemtest_prereqs\");\n\t\t\t\t} else {\n\t\t\t\t\t//If no, then go up a step and try again.\n\t\t\t\t\tpotentialPrereqsRoot = potentialPrereqsRoot.getParent();\n\t\t\t\t}\n\t\t\t} catch (StfException e) {\n\t\t\t\t//do nothing.\n\t\t\t}\n\t\t}\n\t\t\n\t\t//If systemtest_prereqs was not on the test root path, throw an exception.\n\t\tthrow new StfException(\"Prereqs root cannot be found. We were not provided a location, and were \"\n\t\t\t\t\t\t\t + \"unable to find the systemtest_prereqs directory inside any of the directories \"\n\t\t\t\t\t\t\t + \"along any of the test_root paths: \" + testRoot.getSpec());\n\t}"
    },
    "156": {
      "metadata": {
        "chunk_id": "54ed90d0119617bcc27db2253c842699b514640d6a7150fc477b36a2e874435c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfEnvironmentCore.java",
        "content": "/**\n\t * This method allows STF to set the stage which code is currently being \n\t * generated for.\n\t */\n\tpublic void setStage(Stage stage) {\n\t\tthis.stage = stage;\n\t}\n\n\t\n\t/**\n\t * This method allows extensions to find out which stage they are generating code for.\n\t * This allows different behaviour for different stages.\n\t */\n\tpublic Stage getStage() {\n\t\treturn stage;\n\t}\n\n\t\n\t/**\n\t * This method writes out the current state of the all properties.\n\t * It also checks that no unknown property values have been set.\n\t * @throws StfException if a problem is detected.\n\t */\n\tpublic void dumpAndCheckAllProperties(ArrayList<Argument> allArguments) throws StfException {\n\t\t// Record contents of all properties layer by layer\n\t\tFileRef allPropertiesDebugFile = debugDir.childFile(\"properties.txt\");\n\t\tproperties.dumpAllProperties(allPropertiesDebugFile.asJavaFile());\n\t\t\n\t\t// Record the current value for all properties. \n\t\t// i.e. the actual values which would be returned if each property is retrieved. \n\t\tFileRef resolvedPropertiesFile = debugDir.childFile(\"resolvedProperties.txt\");\n\t\tproperties.dumpResolvedProperties(allArguments, resolvedPropertiesFile.asJavaFile());\n\t\t\n\t\t// Verify that no values have been supplied for unknown properties\n\t\tproperties.checkForUnknownProperties();\n\t}\n\t\n\n\tpublic FileRef createFileRef(String fileName) throws StfException {\n\t\treturn new FileRef(fileName);\n\t}\n\n\n\tpublic DirectoryRef createDirectoryRef(String fileName) throws StfException {\n\t\treturn new DirectoryRef(fileName);\n\t}\n\t\n\t\n\t//Calls findDirectory, but defaults to our list of prereq roots rather than the supplied list.\n\tpublic DirectoryRef findPrereqDirectory(String directoryRef, String... errorPrefixes) throws StfException {\n\t\treturn DirectoryRef.findDirectory(directoryRef, getPrereqRoots(), errorPrefixes);\n\t}\n\t\n\t\n\t//Calls findFile, but defaults to our list of prereq roots rather than the supplied list.\n\tpublic FileRef findPrereqFile(String fileRef, String... errorPrefixes) throws StfException {\n\t\treturn FileRef.findFile(fileRef, getPrereqRoots(), errorPrefixes);\n\t}\n\t\n\t\n\t//Calls findDirectory, but defaults to our list of test roots rather than the supplied list.\n\tpublic DirectoryRef findTestDirectory(String directoryRef, String... errorPrefixes) throws StfException {\n\t\treturn DirectoryRef.findDirectory(directoryRef, getTestRoots(), errorPrefixes);\n\t}\n\t\n\t\n\t//Calls findFile, but defaults to our list of test roots rather than the supplied list.\n\tpublic FileRef findTestFile(String fileRef, String... errorPrefixes) throws StfException {\n\t\treturn FileRef.findFile(fileRef, getTestRoots(), errorPrefixes);\n\t}\n\t\n\n\tpublic DirectoryRef createDirectoryRefFromProperty(Argument arg) throws StfException {\n\t\tString argValue = null;\n\t\ttry {\n\t\t\targValue = getProperty(arg);\n\t\t\treturn createDirectoryRef(argValue);\n\t\t} catch (StfException e) { \n\t\t\tthrow new StfException(\"Failed to create directory reference \"\n\t\t\t\t\t+ \"for property '\" + arg.getName() + \"' \"\n\t\t\t\t\t+ \"with a value of '\" + argValue +\"'\");\n\t\t}\n\t}\n\t\n\t\n\tpublic ArrayList<DirectoryRef> getTestRoots() {\n\t\treturn testRoots;\n\t}\n\t\n\tpublic ArrayList<DirectoryRef> getPrereqRoots() {\n\t\treturn prereqRoots;\n\t}\n\n\tpublic DirectoryRef getTmpDir() { \n\t\treturn tmpDir;\n\t}\n\n\tpublic DirectoryRef getResultsDir() { \n\t\treturn resultsDir;\n\t}\n\n\tpublic DirectoryRef getModulesDir() { \n\t\treturn modulesDir;\n\t}\n\n\tpublic DirectoryRef getDebugDir() { \n\t\treturn debugDir;\n\t}\n\n\t/**\n\t * @return a String containing the name of the running plugin.\n\t * @throws StfException \n\t */\n\tpublic String getSourceFileName() throws StfException {\n\t\treturn getProperty(Stf.ARG_TEST);\n\t}",
        "start_line": 225,
        "end_line": 340,
        "chunk_index": 4,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 844,
        "node_type": null,
        "file_sha": "5935ba9c996d77aaf4a3f685f9aed91fc09fbd44",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.917550"
      },
      "text": "/**\n\t * This method allows STF to set the stage which code is currently being \n\t * generated for.\n\t */\n\tpublic void setStage(Stage stage) {\n\t\tthis.stage = stage;\n\t}\n\n\t\n\t/**\n\t * This method allows extensions to find out which stage they are generating code for.\n\t * This allows different behaviour for different stages.\n\t */\n\tpublic Stage getStage() {\n\t\treturn stage;\n\t}\n\n\t\n\t/**\n\t * This method writes out the current state of the all properties.\n\t * It also checks that no unknown property values have been set.\n\t * @throws StfException if a problem is detected.\n\t */\n\tpublic void dumpAndCheckAllProperties(ArrayList<Argument> allArguments) throws StfException {\n\t\t// Record contents of all properties layer by layer\n\t\tFileRef allPropertiesDebugFile = debugDir.childFile(\"properties.txt\");\n\t\tproperties.dumpAllProperties(allPropertiesDebugFile.asJavaFile());\n\t\t\n\t\t// Record the current value for all properties. \n\t\t// i.e. the actual values which would be returned if each property is retrieved. \n\t\tFileRef resolvedPropertiesFile = debugDir.childFile(\"resolvedProperties.txt\");\n\t\tproperties.dumpResolvedProperties(allArguments, resolvedPropertiesFile.asJavaFile());\n\t\t\n\t\t// Verify that no values have been supplied for unknown properties\n\t\tproperties.checkForUnknownProperties();\n\t}\n\t\n\n\tpublic FileRef createFileRef(String fileName) throws StfException {\n\t\treturn new FileRef(fileName);\n\t}\n\n\n\tpublic DirectoryRef createDirectoryRef(String fileName) throws StfException {\n\t\treturn new DirectoryRef(fileName);\n\t}\n\t\n\t\n\t//Calls findDirectory, but defaults to our list of prereq roots rather than the supplied list.\n\tpublic DirectoryRef findPrereqDirectory(String directoryRef, String... errorPrefixes) throws StfException {\n\t\treturn DirectoryRef.findDirectory(directoryRef, getPrereqRoots(), errorPrefixes);\n\t}\n\t\n\t\n\t//Calls findFile, but defaults to our list of prereq roots rather than the supplied list.\n\tpublic FileRef findPrereqFile(String fileRef, String... errorPrefixes) throws StfException {\n\t\treturn FileRef.findFile(fileRef, getPrereqRoots(), errorPrefixes);\n\t}\n\t\n\t\n\t//Calls findDirectory, but defaults to our list of test roots rather than the supplied list.\n\tpublic DirectoryRef findTestDirectory(String directoryRef, String... errorPrefixes) throws StfException {\n\t\treturn DirectoryRef.findDirectory(directoryRef, getTestRoots(), errorPrefixes);\n\t}\n\t\n\t\n\t//Calls findFile, but defaults to our list of test roots rather than the supplied list.\n\tpublic FileRef findTestFile(String fileRef, String... errorPrefixes) throws StfException {\n\t\treturn FileRef.findFile(fileRef, getTestRoots(), errorPrefixes);\n\t}\n\t\n\n\tpublic DirectoryRef createDirectoryRefFromProperty(Argument arg) throws StfException {\n\t\tString argValue = null;\n\t\ttry {\n\t\t\targValue = getProperty(arg);\n\t\t\treturn createDirectoryRef(argValue);\n\t\t} catch (StfException e) { \n\t\t\tthrow new StfException(\"Failed to create directory reference \"\n\t\t\t\t\t+ \"for property '\" + arg.getName() + \"' \"\n\t\t\t\t\t+ \"with a value of '\" + argValue +\"'\");\n\t\t}\n\t}\n\t\n\t\n\tpublic ArrayList<DirectoryRef> getTestRoots() {\n\t\treturn testRoots;\n\t}\n\t\n\tpublic ArrayList<DirectoryRef> getPrereqRoots() {\n\t\treturn prereqRoots;\n\t}\n\n\tpublic DirectoryRef getTmpDir() { \n\t\treturn tmpDir;\n\t}\n\n\tpublic DirectoryRef getResultsDir() { \n\t\treturn resultsDir;\n\t}\n\n\tpublic DirectoryRef getModulesDir() { \n\t\treturn modulesDir;\n\t}\n\n\tpublic DirectoryRef getDebugDir() { \n\t\treturn debugDir;\n\t}\n\n\t/**\n\t * @return a String containing the name of the running plugin.\n\t * @throws StfException \n\t */\n\tpublic String getSourceFileName() throws StfException {\n\t\treturn getProperty(Stf.ARG_TEST);\n\t}"
    },
    "157": {
      "metadata": {
        "chunk_id": "42e45fce286aeeb9ddd3b63276b8666a3432d020344aadc8eef0e24f692dad38",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfEnvironmentCore.java",
        "content": "public DirectoryRef getTmpDir() { \n\t\treturn tmpDir;\n\t}\n\n\tpublic DirectoryRef getResultsDir() { \n\t\treturn resultsDir;\n\t}\n\n\tpublic DirectoryRef getModulesDir() { \n\t\treturn modulesDir;\n\t}\n\n\tpublic DirectoryRef getDebugDir() { \n\t\treturn debugDir;\n\t}\n\n\t/**\n\t * @return a String containing the name of the running plugin.\n\t * @throws StfException \n\t */\n\tpublic String getSourceFileName() throws StfException {\n\t\treturn getProperty(Stf.ARG_TEST);\n\t}\n\n\t\n\t// Test specific information is specified in the '-test-args' which holds a comma \n\t// separated list of name value pairs.\n\t// For example, expected could be: \"suite\", \"single-thread\", \"reporter=[LIVE]\"\n\t// and the actual args: '-testProperties=\"suite=bidi, single-thread=false\"\n\tpublic StfTestArguments getTestProperties(String... expectedTestArgs) throws StfException {\n\t\tif (testArgs == null) {\n\t\t\tString testArgsValue = getProperty(Stf.ARG_TEST_ARGS);\n\t\t\ttestArgs = new StfTestArguments(testArgsValue, expectedTestArgs);\n\t\t}\n\t\t\n\t\treturn testArgs;\n\t}\n\n\t\n\tpublic boolean getBooleanProperty(Argument property) throws StfException {\n\t\treturn properties.getProperty(property.getName()).equals(\"\");\n\t}\n\t\n\tpublic String getProperty(Argument property) throws StfException {\n\t\treturn properties.getProperty(property.getName());\n\t}\n\t\n\tpublic int getPropertyAsInt(Argument property) throws StfException {\n\t\treturn Integer.parseInt(properties.getProperty(property.getName()));\n\t}\n\t\n\tString getProperty(String propertyName) throws StfException {\n\t\treturn properties.getProperty(propertyName);\n\t}\n\t\n\n\t/**\n\t * Sets an existing property to a new value.\n\t * This should only been done when absolutely necessary.\n\t * @throws StfException \n\t */\n\tpublic String updateProperty(Argument argument, String newValue) throws StfException {\n\t\tString existingValue = properties.getProperty(argument.getName());\n\t\tproperties.updateProperty(argument, newValue);\n\t\treturn existingValue;\n\t}\n\n\t\n\t/**\n\t * Returns the directory for JAVA_HOME\n\t * The actual value return depends on the stage which is currently executing.\n\t * \n\t * @return Reference to the JAVA_HOME directory.\n\t * @throws StfException if JAVA_HOME has not been defined or if the plugin is attempting \n\t *         to start a java process during its initialisation.\n\t */\n\tpublic DirectoryRef getJavaHome() throws StfException {\n\t\tArgument javaHomeArgument = null;\n\t\tswitch (getStage()) {\n\t\tcase SETUP:    javaHomeArgument = Stf.ARG_JAVAHOME_SETUP; break;\n\t\tcase EXECUTE:  javaHomeArgument = Stf.ARG_JAVAHOME_EXECUTE; break;\n\t\tcase TEARDOWN: javaHomeArgument = Stf.ARG_JAVAHOME_TEARDOWN; break;\n\t\tdefault: \n\t\t\tthrow new StfException(\"Can't run java process in the initialisation stage\");\n\t\t}\n\t\t\n\t\treturn createDirectoryRefFromProperty(javaHomeArgument);\n\t}\n\n\t\n\tpublic String getPlatform() throws StfException {\n\t\treturn PlatformFinder.getPlatformAsString();  //TODO: convert to enumeration\n\t}\n\t\n\tpublic String getPlatformSimple() throws StfException {\n\t\treturn PlatformFinder.getPlatformSimple();\n\t}\n\n\t\n\t/** \n\t * Returns the osgi.os name.\n\t * Expected return values are win32, linux, aix, zos, macosx\n\t */\n\tpublic String getOsgiOperatingSystemName() throws StfException {\n\t\tswitch (PlatformFinder.getPlatform()) {\n\t\tcase WINDOWS: return \"win32\";\n\t\tcase AIX :    return \"aix\";\n\t\tcase LINUX:   return \"linux\";\n\t\tcase ZOS :    return \"zos\";\n\t\tcase OSX :    return \"macosx\";\n\t\tcase SOLARIS :    return \"solaris\";\n\t\tdefault:      throw new StfException(\"Unknown platform for osgi.os: \" + PlatformFinder.getPlatformAsString());\n\t\t}\n\t}\n\n\t/** \n\t * Returns the osgi.ws value.\n\t * Expected return values are win32, gtk\n\t */\n\tpublic String getOsgiWindowingSystemName() throws StfException {\n\t\tswitch (PlatformFinder.getPlatform()) {\n\t\tcase WINDOWS: return \"win32\";\n\t\tcase AIX :    return \"gtk\";\n\t\tcase LINUX:   return \"gtk\";\n\t\tdefault:      throw new StfException(\"Unknown platform for osgi.ws: \" + PlatformFinder.getPlatformAsString());\n\t\t}\n\t}",
        "start_line": 341,
        "end_line": 467,
        "chunk_index": 5,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 941,
        "node_type": null,
        "file_sha": "5935ba9c996d77aaf4a3f685f9aed91fc09fbd44",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.917553"
      },
      "text": "public DirectoryRef getTmpDir() { \n\t\treturn tmpDir;\n\t}\n\n\tpublic DirectoryRef getResultsDir() { \n\t\treturn resultsDir;\n\t}\n\n\tpublic DirectoryRef getModulesDir() { \n\t\treturn modulesDir;\n\t}\n\n\tpublic DirectoryRef getDebugDir() { \n\t\treturn debugDir;\n\t}\n\n\t/**\n\t * @return a String containing the name of the running plugin.\n\t * @throws StfException \n\t */\n\tpublic String getSourceFileName() throws StfException {\n\t\treturn getProperty(Stf.ARG_TEST);\n\t}\n\n\t\n\t// Test specific information is specified in the '-test-args' which holds a comma \n\t// separated list of name value pairs.\n\t// For example, expected could be: \"suite\", \"single-thread\", \"reporter=[LIVE]\"\n\t// and the actual args: '-testProperties=\"suite=bidi, single-thread=false\"\n\tpublic StfTestArguments getTestProperties(String... expectedTestArgs) throws StfException {\n\t\tif (testArgs == null) {\n\t\t\tString testArgsValue = getProperty(Stf.ARG_TEST_ARGS);\n\t\t\ttestArgs = new StfTestArguments(testArgsValue, expectedTestArgs);\n\t\t}\n\t\t\n\t\treturn testArgs;\n\t}\n\n\t\n\tpublic boolean getBooleanProperty(Argument property) throws StfException {\n\t\treturn properties.getProperty(property.getName()).equals(\"\");\n\t}\n\t\n\tpublic String getProperty(Argument property) throws StfException {\n\t\treturn properties.getProperty(property.getName());\n\t}\n\t\n\tpublic int getPropertyAsInt(Argument property) throws StfException {\n\t\treturn Integer.parseInt(properties.getProperty(property.getName()));\n\t}\n\t\n\tString getProperty(String propertyName) throws StfException {\n\t\treturn properties.getProperty(propertyName);\n\t}\n\t\n\n\t/**\n\t * Sets an existing property to a new value.\n\t * This should only been done when absolutely necessary.\n\t * @throws StfException \n\t */\n\tpublic String updateProperty(Argument argument, String newValue) throws StfException {\n\t\tString existingValue = properties.getProperty(argument.getName());\n\t\tproperties.updateProperty(argument, newValue);\n\t\treturn existingValue;\n\t}\n\n\t\n\t/**\n\t * Returns the directory for JAVA_HOME\n\t * The actual value return depends on the stage which is currently executing.\n\t * \n\t * @return Reference to the JAVA_HOME directory.\n\t * @throws StfException if JAVA_HOME has not been defined or if the plugin is attempting \n\t *         to start a java process during its initialisation.\n\t */\n\tpublic DirectoryRef getJavaHome() throws StfException {\n\t\tArgument javaHomeArgument = null;\n\t\tswitch (getStage()) {\n\t\tcase SETUP:    javaHomeArgument = Stf.ARG_JAVAHOME_SETUP; break;\n\t\tcase EXECUTE:  javaHomeArgument = Stf.ARG_JAVAHOME_EXECUTE; break;\n\t\tcase TEARDOWN: javaHomeArgument = Stf.ARG_JAVAHOME_TEARDOWN; break;\n\t\tdefault: \n\t\t\tthrow new StfException(\"Can't run java process in the initialisation stage\");\n\t\t}\n\t\t\n\t\treturn createDirectoryRefFromProperty(javaHomeArgument);\n\t}\n\n\t\n\tpublic String getPlatform() throws StfException {\n\t\treturn PlatformFinder.getPlatformAsString();  //TODO: convert to enumeration\n\t}\n\t\n\tpublic String getPlatformSimple() throws StfException {\n\t\treturn PlatformFinder.getPlatformSimple();\n\t}\n\n\t\n\t/** \n\t * Returns the osgi.os name.\n\t * Expected return values are win32, linux, aix, zos, macosx\n\t */\n\tpublic String getOsgiOperatingSystemName() throws StfException {\n\t\tswitch (PlatformFinder.getPlatform()) {\n\t\tcase WINDOWS: return \"win32\";\n\t\tcase AIX :    return \"aix\";\n\t\tcase LINUX:   return \"linux\";\n\t\tcase ZOS :    return \"zos\";\n\t\tcase OSX :    return \"macosx\";\n\t\tcase SOLARIS :    return \"solaris\";\n\t\tdefault:      throw new StfException(\"Unknown platform for osgi.os: \" + PlatformFinder.getPlatformAsString());\n\t\t}\n\t}\n\n\t/** \n\t * Returns the osgi.ws value.\n\t * Expected return values are win32, gtk\n\t */\n\tpublic String getOsgiWindowingSystemName() throws StfException {\n\t\tswitch (PlatformFinder.getPlatform()) {\n\t\tcase WINDOWS: return \"win32\";\n\t\tcase AIX :    return \"gtk\";\n\t\tcase LINUX:   return \"gtk\";\n\t\tdefault:      throw new StfException(\"Unknown platform for osgi.ws: \" + PlatformFinder.getPlatformAsString());\n\t\t}\n\t}"
    },
    "158": {
      "metadata": {
        "chunk_id": "dffb786d658a25a620ad146b821b107afdcdf0ffbb634c2e5450291e5b69e0cf",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfEnvironmentCore.java",
        "content": "/** \n\t * Returns the osgi.ws value.\n\t * Expected return values are win32, gtk\n\t */\n\tpublic String getOsgiWindowingSystemName() throws StfException {\n\t\tswitch (PlatformFinder.getPlatform()) {\n\t\tcase WINDOWS: return \"win32\";\n\t\tcase AIX :    return \"gtk\";\n\t\tcase LINUX:   return \"gtk\";\n\t\tdefault:      throw new StfException(\"Unknown platform for osgi.ws: \" + PlatformFinder.getPlatformAsString());\n\t\t}\n\t}\n\n\t/** \n\t * Returns the osgi.arch name.\n\t * Expected return values are x86, x86_64, ppc, ppc64, arm, riscv, loongarch\n\t */\n\tpublic String getOsgiProcessorArchitecture() throws StfException {\n\t\tString archName = PlatformFinder.getArchName();\n\t\tString wordSize = PlatformFinder.getArchType();\n\t\t\n\t\tif (archName.equals(\"x86\") && wordSize.equals(\"32\")) {\n\t\t\treturn \"x86\";\n\t\t} else if (archName.equals(\"x86\") && wordSize.equals(\"64\")) {\n\t\t\treturn \"x86_64\";\n\t\t} else if (archName.equals(\"ppc\") && wordSize.equals(\"32\")) {\n\t\t\treturn \"ppc\";\n\t\t} else if (archName.equals(\"ppc\") && wordSize.equals(\"64\")) {\n\t\t\treturn \"ppc64\";\n\t\t} else if (archName.equals(\"arm\")) {\n\t\t\treturn \"arm\";\n\t\t} else if (archName.equals(\"riscv\")) {\n\t\t\treturn \"riscv\";\n\t\t} else if (archName.equals(\"loongarch\")) {\n                        return \"loongarch\";\n\t\t} else if (archName.equals(\"sparc\")) {\n\t\t\treturn \"sparc\";\n\t\t}\n\t\t\n\t\tthrow new StfException(\"Unknown osgi.arch. archName:\" + archName + \" wordSize:\" + wordSize);\n\t}\n\n\t\n\t/**\n\t * Returns the word size of the machine. eg, 32 or 64\n\t */\n\tpublic int getWordSize() throws NumberFormatException, StfException { \n\t\treturn Integer.parseInt(PlatformFinder.getArchType());\n\t}\n\t\n\n\t/**\n\t * Check that any test specific arguments have actually been used.\n\t * This prevents the user from running a test and supplying test specific arguments \n\t * which they believe do something but actually have no effect.\n\t * \n\t * @throws StfException if the test has been invoked with unused test specific args.\n\t */\n\tpublic void verifyTestArgsUsed() throws StfException {\n\t\tif (testArgs == null) {\n\t\t\tString testArgs = getProperty(Stf.ARG_TEST_ARGS);\n\t\t\tif (!testArgs.isEmpty()) {\n\t\t\t\tthrow new StfException(\"Can't start test with '-\" + Stf.ARG_TEST_ARGS.getName() + \"' as this test does not use any.\");\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic boolean isVerboseSet() throws StfException {\n\t\treturn getBooleanProperty(Stf.ARG_VERBOSE);\n\t}\n\n\tpublic boolean isSuperVerboseSet() throws StfException {\n\t\treturn getBooleanProperty(Stf.ARG_VERBOSE_VERBOSE);\n\t}\n\t\n\tpublic JavaVersion primaryJvm() throws StfException {\n\t\tString javahome = getProperty(Stf.ARG_JAVAHOME_EXECUTE);\n\t\treturn JavaVersion.getInstance(true, javahome);\n\t}",
        "start_line": 468,
        "end_line": 547,
        "chunk_index": 6,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 709,
        "node_type": null,
        "file_sha": "5935ba9c996d77aaf4a3f685f9aed91fc09fbd44",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.917557"
      },
      "text": "/** \n\t * Returns the osgi.ws value.\n\t * Expected return values are win32, gtk\n\t */\n\tpublic String getOsgiWindowingSystemName() throws StfException {\n\t\tswitch (PlatformFinder.getPlatform()) {\n\t\tcase WINDOWS: return \"win32\";\n\t\tcase AIX :    return \"gtk\";\n\t\tcase LINUX:   return \"gtk\";\n\t\tdefault:      throw new StfException(\"Unknown platform for osgi.ws: \" + PlatformFinder.getPlatformAsString());\n\t\t}\n\t}\n\n\t/** \n\t * Returns the osgi.arch name.\n\t * Expected return values are x86, x86_64, ppc, ppc64, arm, riscv, loongarch\n\t */\n\tpublic String getOsgiProcessorArchitecture() throws StfException {\n\t\tString archName = PlatformFinder.getArchName();\n\t\tString wordSize = PlatformFinder.getArchType();\n\t\t\n\t\tif (archName.equals(\"x86\") && wordSize.equals(\"32\")) {\n\t\t\treturn \"x86\";\n\t\t} else if (archName.equals(\"x86\") && wordSize.equals(\"64\")) {\n\t\t\treturn \"x86_64\";\n\t\t} else if (archName.equals(\"ppc\") && wordSize.equals(\"32\")) {\n\t\t\treturn \"ppc\";\n\t\t} else if (archName.equals(\"ppc\") && wordSize.equals(\"64\")) {\n\t\t\treturn \"ppc64\";\n\t\t} else if (archName.equals(\"arm\")) {\n\t\t\treturn \"arm\";\n\t\t} else if (archName.equals(\"riscv\")) {\n\t\t\treturn \"riscv\";\n\t\t} else if (archName.equals(\"loongarch\")) {\n                        return \"loongarch\";\n\t\t} else if (archName.equals(\"sparc\")) {\n\t\t\treturn \"sparc\";\n\t\t}\n\t\t\n\t\tthrow new StfException(\"Unknown osgi.arch. archName:\" + archName + \" wordSize:\" + wordSize);\n\t}\n\n\t\n\t/**\n\t * Returns the word size of the machine. eg, 32 or 64\n\t */\n\tpublic int getWordSize() throws NumberFormatException, StfException { \n\t\treturn Integer.parseInt(PlatformFinder.getArchType());\n\t}\n\t\n\n\t/**\n\t * Check that any test specific arguments have actually been used.\n\t * This prevents the user from running a test and supplying test specific arguments \n\t * which they believe do something but actually have no effect.\n\t * \n\t * @throws StfException if the test has been invoked with unused test specific args.\n\t */\n\tpublic void verifyTestArgsUsed() throws StfException {\n\t\tif (testArgs == null) {\n\t\t\tString testArgs = getProperty(Stf.ARG_TEST_ARGS);\n\t\t\tif (!testArgs.isEmpty()) {\n\t\t\t\tthrow new StfException(\"Can't start test with '-\" + Stf.ARG_TEST_ARGS.getName() + \"' as this test does not use any.\");\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic boolean isVerboseSet() throws StfException {\n\t\treturn getBooleanProperty(Stf.ARG_VERBOSE);\n\t}\n\n\tpublic boolean isSuperVerboseSet() throws StfException {\n\t\treturn getBooleanProperty(Stf.ARG_VERBOSE_VERBOSE);\n\t}\n\t\n\tpublic JavaVersion primaryJvm() throws StfException {\n\t\tString javahome = getProperty(Stf.ARG_JAVAHOME_EXECUTE);\n\t\treturn JavaVersion.getInstance(true, javahome);\n\t}"
    },
    "159": {
      "metadata": {
        "chunk_id": "50329cdfad90f694c96c9c397b798eb00186f82686cd6628c4de96f10d3284be",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfEnvironmentCore.java",
        "content": "public boolean isVerboseSet() throws StfException {\n\t\treturn getBooleanProperty(Stf.ARG_VERBOSE);\n\t}\n\n\tpublic boolean isSuperVerboseSet() throws StfException {\n\t\treturn getBooleanProperty(Stf.ARG_VERBOSE_VERBOSE);\n\t}\n\t\n\tpublic JavaVersion primaryJvm() throws StfException {\n\t\tString javahome = getProperty(Stf.ARG_JAVAHOME_EXECUTE);\n\t\treturn JavaVersion.getInstance(true, javahome);\n\t}\n\n\tpublic JavaVersion secondaryJvm() throws StfException {\n\t\tString javahome = getProperty(Stf.ARG_JAVAHOME_EXECUTE_SECONDARY);\n\t\tif (javahome.isEmpty()) {\n\t\t\tthrow new StfException(\"Secondary JVM not usable, as none has been configured. \"\n\t\t\t\t\t+ \"See '\" + Stf.ARG_JAVA_ARGS_EXECUTE_SECONDARY.getName() + \"' argument or set JAVA_HOME_SECONDARY enviroment variable.\");\n\t\t}\n\t\treturn JavaVersion.getInstance(false, javahome);\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 6. Otherwise false.\n\t */\n\tpublic boolean isUsingJava6() throws StfException {\n\t\treturn JavaVersion.getInstance(this).isJava6();\n\t}\n\t\n\t/**\n\t * @return the java version with the format as a single digit.\n\t * eg, 6, 7, 8 or 9, etc\n\t * @return int containing the java version number.\n\t * @throws StfException if an unknown JVM release has been found.\n\t */\n\tpublic int getJavaVersion() throws StfException {\n\t\treturn JavaVersion.getInstance(this).getJavaVersion();\n\t}\n\t\n\t/**\n\t * @return the java version with the format as 90 for Java 9,\n\t * 80 for Java 8 and so forth.\n\t * @throws StfException if an unknown JVM release has been found.\n\t */\n\tpublic String getJavaVersionCode() throws StfException {\n\t\treturn JavaVersion.getInstance(this).getJavaVersionCode();\n\t}\n\t\n\t/**\n\t * @return true if version of Java used in the execution stage is an IBM JVM.\n\t * @throws StfException if the execution of 'java -version' failed.\n\t */\n\tpublic boolean isUsingIBMJava() throws StfException {\n\t\treturn JavaVersion.getInstance(this).isIBMJvm();\n\t}\n}",
        "start_line": 548,
        "end_line": 603,
        "chunk_index": 7,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 486,
        "node_type": null,
        "file_sha": "5935ba9c996d77aaf4a3f685f9aed91fc09fbd44",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.917560"
      },
      "text": "public boolean isVerboseSet() throws StfException {\n\t\treturn getBooleanProperty(Stf.ARG_VERBOSE);\n\t}\n\n\tpublic boolean isSuperVerboseSet() throws StfException {\n\t\treturn getBooleanProperty(Stf.ARG_VERBOSE_VERBOSE);\n\t}\n\t\n\tpublic JavaVersion primaryJvm() throws StfException {\n\t\tString javahome = getProperty(Stf.ARG_JAVAHOME_EXECUTE);\n\t\treturn JavaVersion.getInstance(true, javahome);\n\t}\n\n\tpublic JavaVersion secondaryJvm() throws StfException {\n\t\tString javahome = getProperty(Stf.ARG_JAVAHOME_EXECUTE_SECONDARY);\n\t\tif (javahome.isEmpty()) {\n\t\t\tthrow new StfException(\"Secondary JVM not usable, as none has been configured. \"\n\t\t\t\t\t+ \"See '\" + Stf.ARG_JAVA_ARGS_EXECUTE_SECONDARY.getName() + \"' argument or set JAVA_HOME_SECONDARY enviroment variable.\");\n\t\t}\n\t\treturn JavaVersion.getInstance(false, javahome);\n\t}\n\t\n\t/**\n\t * @return true if the JVM used for test execution is Java version 6. Otherwise false.\n\t */\n\tpublic boolean isUsingJava6() throws StfException {\n\t\treturn JavaVersion.getInstance(this).isJava6();\n\t}\n\t\n\t/**\n\t * @return the java version with the format as a single digit.\n\t * eg, 6, 7, 8 or 9, etc\n\t * @return int containing the java version number.\n\t * @throws StfException if an unknown JVM release has been found.\n\t */\n\tpublic int getJavaVersion() throws StfException {\n\t\treturn JavaVersion.getInstance(this).getJavaVersion();\n\t}\n\t\n\t/**\n\t * @return the java version with the format as 90 for Java 9,\n\t * 80 for Java 8 and so forth.\n\t * @throws StfException if an unknown JVM release has been found.\n\t */\n\tpublic String getJavaVersionCode() throws StfException {\n\t\treturn JavaVersion.getInstance(this).getJavaVersionCode();\n\t}\n\t\n\t/**\n\t * @return true if version of Java used in the execution stage is an IBM JVM.\n\t * @throws StfException if the execution of 'java -version' failed.\n\t */\n\tpublic boolean isUsingIBMJava() throws StfException {\n\t\treturn JavaVersion.getInstance(this).isIBMJvm();\n\t}\n}"
    },
    "160": {
      "metadata": {
        "chunk_id": "3a276c1d546ec8177bc824a642f77da99be3624de14013c04ab0457039424fe2",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfTestArguments.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class represents the contents of STFs '-test-args' argument.\n *\n * It enforces error checking to ensure that:\n *   - values are supplied for all non defaulting arguments.\n *   - no excess arguments are supplied.\n *\n * It also allows callers to convert from a test-arg to a corresponding enum constant.\n * This is not a complex operation but using this class provides automatic error \n * checking and generates sensible error messages for invalid values. \n */",
        "start_line": 0,
        "end_line": 34,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 268,
        "node_type": null,
        "file_sha": "54b9f3be03ec8ad57b6de9a0a221a5702f3e1c9c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.928295"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class represents the contents of STFs '-test-args' argument.\n *\n * It enforces error checking to ensure that:\n *   - values are supplied for all non defaulting arguments.\n *   - no excess arguments are supplied.\n *\n * It also allows callers to convert from a test-arg to a corresponding enum constant.\n * This is not a complex operation but using this class provides automatic error \n * checking and generates sensible error messages for invalid values. \n */"
    },
    "161": {
      "metadata": {
        "chunk_id": "4417975200f9fcdb905c1c3de149efbd414c7dda2ab86ed2ca69dd825fb3d30b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfTestArguments.java",
        "content": "public class StfTestArguments {\n\tprivate HashMap<String, String> testArgs;\n\t\n\tpublic StfTestArguments(String testArgsString, String... expectedTestArgs) throws StfException {\n\t\t// Build a set of expected property names.\n\t\t// Also set test property defaults, if described in the expected description\n\t\tHashSet<String> expectedPropertySet = new HashSet<String>();\n\t\ttestArgs = new HashMap<String, String>();\n\t\tfor (String expected : expectedTestArgs) {\n\t\t\t// Add to the set of property names\n\t\t\tString[] expectedParts = expected.trim().split(\"=\");\n\t\t\tString expectedName = expectedParts[0];\n\t\t\texpectedPropertySet.add(expectedName);\n\t\t\t\n\t\t\t// Optionally create a default name/value\n\t\t\tif (expectedParts.length > 1) {\n\t\t\t\tString defaultValue = expectedParts[1];\n\t\t\t\tif (!defaultValue.startsWith(\"[\") && !defaultValue.endsWith(\"]\")) {\n\t\t\t\t\tthrow new StfException(\"Default value not enclosed in within '[' and ']': '\" + expected + \"'\");\n\t\t\t\t}\n\t\t\t\tdefaultValue = defaultValue.substring(1, defaultValue.length()-1);\n\t\t\t\ttestArgs.put(expectedName, defaultValue);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Process the name value pairs in '-test-args'\n\t\tif (!testArgsString.isEmpty()) {\n\t\t\tfor (String nameValuePair : testArgsString.split(\",\")) {\n\t\t\t\tString[] singleValue = nameValuePair.trim().split(\"=\");\n\t\t\t\tif (singleValue.length != 2) {\n\t\t\t\t\tthrow new StfError(\"Failed to parse test specific arguments as name/value pairs. Value: '\" + nameValuePair + \"'\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// This is a special case for JCK where we may supply multiple sub-folders to run\n\t\t\t\tif( singleValue[1].contains(\";\")) {\n\t\t\t\t\tString [] tests = singleValue[1].split(\";\");\n\t\t\t\t\tString finalTarget = \"\";\n\t\t\t\t\tfor (int i = 0; i < tests.length; i++) {\n\t\t\t\t\t\tfinalTarget = finalTarget + tests[i]; \n\t\t\t\t\t\tif (i+1 < tests.length) {\n\t\t\t\t\t\t\t// JCK harness expects tests to be listed with a single space\n\t\t\t\t\t\t\tfinalTarget = finalTarget + \" \"; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttestArgs.put(singleValue[0], finalTarget);\n\t\t\t\t} else { \n\t\t\t\t\ttestArgs.put(singleValue[0], singleValue[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check for missing properties. \n\t\t// i.e. properties which were expected but have not been supplied for this test run.\n\t\tHashSet<String> missing = new HashSet<String>(expectedPropertySet);\n\t\tmissing.removeAll(testArgs.keySet());\n\t\tif (!missing.isEmpty()) {\n\t\t\tthrow new StfError(\"Test specific properties not supplied: '\" + missing + \"'. \"\n\t\t\t\t\t+ \"Allowed arguments are: \" + Arrays.toString(expectedTestArgs));\n\t\t}\n\n\t\t// Check for any extra properties.\n\t\t// i.e. The test has been started with test specific properties that the plugin is not expecting.\n\t\tHashSet<String> actuals = new HashSet<String>(testArgs.keySet());\n\t\tactuals.removeAll(expectedPropertySet);\n\t\tif (!actuals.isEmpty()) {\n\t\t\tthrow new StfError(\"Unknown test specific argument: '\" + actuals + \"'. \"\n\t\t\t\t\t+ \"Allowed arguments are: \" + Arrays.toString(expectedTestArgs));\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Converts an argument to it's corresponding enum equivalent.\n\t * \n\t * The main benefit of this method over a simple enum lookup is that it enforces\n\t * error checking and produces sensible error messages for invalid argument values.\n\t *  \n\t * @param argName is the name of the argument.\n\t * @param enumType is the class of enums to convert the value to\n\t * @return The enum constant for the value of argName.\n\t * @throws StfException if no enum constant can be found for the argument.\n\t */\n\tpublic <E extends Enum<E>> E decodeEnum(String argName, Class<E> enumType) throws StfException {\n\t\tString argValue = get(argName);\n\n    \t// Step through all enum values looking for a match\n    \tE result = null;\n\t    for (E enumValue : enumType.getEnumConstants()) {\n\t\t    if (argValue.equals(enumValue.name())) {\n\t\t    \tresult = enumValue;\n\t\t    \tbreak; // found it\n\t\t    }\n\t\t}",
        "start_line": 35,
        "end_line": 127,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 912,
        "node_type": null,
        "file_sha": "54b9f3be03ec8ad57b6de9a0a221a5702f3e1c9c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.928304"
      },
      "text": "public class StfTestArguments {\n\tprivate HashMap<String, String> testArgs;\n\t\n\tpublic StfTestArguments(String testArgsString, String... expectedTestArgs) throws StfException {\n\t\t// Build a set of expected property names.\n\t\t// Also set test property defaults, if described in the expected description\n\t\tHashSet<String> expectedPropertySet = new HashSet<String>();\n\t\ttestArgs = new HashMap<String, String>();\n\t\tfor (String expected : expectedTestArgs) {\n\t\t\t// Add to the set of property names\n\t\t\tString[] expectedParts = expected.trim().split(\"=\");\n\t\t\tString expectedName = expectedParts[0];\n\t\t\texpectedPropertySet.add(expectedName);\n\t\t\t\n\t\t\t// Optionally create a default name/value\n\t\t\tif (expectedParts.length > 1) {\n\t\t\t\tString defaultValue = expectedParts[1];\n\t\t\t\tif (!defaultValue.startsWith(\"[\") && !defaultValue.endsWith(\"]\")) {\n\t\t\t\t\tthrow new StfException(\"Default value not enclosed in within '[' and ']': '\" + expected + \"'\");\n\t\t\t\t}\n\t\t\t\tdefaultValue = defaultValue.substring(1, defaultValue.length()-1);\n\t\t\t\ttestArgs.put(expectedName, defaultValue);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Process the name value pairs in '-test-args'\n\t\tif (!testArgsString.isEmpty()) {\n\t\t\tfor (String nameValuePair : testArgsString.split(\",\")) {\n\t\t\t\tString[] singleValue = nameValuePair.trim().split(\"=\");\n\t\t\t\tif (singleValue.length != 2) {\n\t\t\t\t\tthrow new StfError(\"Failed to parse test specific arguments as name/value pairs. Value: '\" + nameValuePair + \"'\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// This is a special case for JCK where we may supply multiple sub-folders to run\n\t\t\t\tif( singleValue[1].contains(\";\")) {\n\t\t\t\t\tString [] tests = singleValue[1].split(\";\");\n\t\t\t\t\tString finalTarget = \"\";\n\t\t\t\t\tfor (int i = 0; i < tests.length; i++) {\n\t\t\t\t\t\tfinalTarget = finalTarget + tests[i]; \n\t\t\t\t\t\tif (i+1 < tests.length) {\n\t\t\t\t\t\t\t// JCK harness expects tests to be listed with a single space\n\t\t\t\t\t\t\tfinalTarget = finalTarget + \" \"; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttestArgs.put(singleValue[0], finalTarget);\n\t\t\t\t} else { \n\t\t\t\t\ttestArgs.put(singleValue[0], singleValue[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check for missing properties. \n\t\t// i.e. properties which were expected but have not been supplied for this test run.\n\t\tHashSet<String> missing = new HashSet<String>(expectedPropertySet);\n\t\tmissing.removeAll(testArgs.keySet());\n\t\tif (!missing.isEmpty()) {\n\t\t\tthrow new StfError(\"Test specific properties not supplied: '\" + missing + \"'. \"\n\t\t\t\t\t+ \"Allowed arguments are: \" + Arrays.toString(expectedTestArgs));\n\t\t}\n\n\t\t// Check for any extra properties.\n\t\t// i.e. The test has been started with test specific properties that the plugin is not expecting.\n\t\tHashSet<String> actuals = new HashSet<String>(testArgs.keySet());\n\t\tactuals.removeAll(expectedPropertySet);\n\t\tif (!actuals.isEmpty()) {\n\t\t\tthrow new StfError(\"Unknown test specific argument: '\" + actuals + \"'. \"\n\t\t\t\t\t+ \"Allowed arguments are: \" + Arrays.toString(expectedTestArgs));\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Converts an argument to it's corresponding enum equivalent.\n\t * \n\t * The main benefit of this method over a simple enum lookup is that it enforces\n\t * error checking and produces sensible error messages for invalid argument values.\n\t *  \n\t * @param argName is the name of the argument.\n\t * @param enumType is the class of enums to convert the value to\n\t * @return The enum constant for the value of argName.\n\t * @throws StfException if no enum constant can be found for the argument.\n\t */\n\tpublic <E extends Enum<E>> E decodeEnum(String argName, Class<E> enumType) throws StfException {\n\t\tString argValue = get(argName);\n\n    \t// Step through all enum values looking for a match\n    \tE result = null;\n\t    for (E enumValue : enumType.getEnumConstants()) {\n\t\t    if (argValue.equals(enumValue.name())) {\n\t\t    \tresult = enumValue;\n\t\t    \tbreak; // found it\n\t\t    }\n\t\t}"
    },
    "162": {
      "metadata": {
        "chunk_id": "ac662c8788762635e97d8a9d08c121120bcbb42b4b7a02abf9de8ed2e73868f8",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/StfTestArguments.java",
        "content": "// Step through all enum values looking for a match\n    \tE result = null;\n\t    for (E enumValue : enumType.getEnumConstants()) {\n\t\t    if (argValue.equals(enumValue.name())) {\n\t\t    \tresult = enumValue;\n\t\t    \tbreak; // found it\n\t\t    }\n\t\t}\n\n\t    // Fail if we weren't able to convert the argument value to an enum value\n\t    if (result == null) {\n\t    \t// Build string with names of all possible enum values\n\t    \tStringBuilder argNames = new StringBuilder();\n\t    \tfor (E enumValue : enumType.getEnumConstants()) {\n\t    \t\tif (argNames.length() > 0) { \n\t    \t\t\targNames.append(\", \");\n\t    \t\t}\n\t    \t\targNames.append(enumValue.name());\n\t    \t}\n\t    \t\n\t\t\tthrow new StfError(\"Invalid argument value for '\" + argName + \"'.\"\n\t\t\t\t\t+ \" Value of '\" + argValue + \"' is not one of : [\" + argNames.toString().trim() + \"]\");\n\t    }\n\t    \n\t    return result;\n\t}\n\n\t\n\t/**\n\t * Gets the value of a name test argument. \n\t * @param argName is the name of the argument to get the value of.\n\t * @return the value of the specified test argument.\n\t * @throws StfException if there is no value for the specified argument.\n\t */\n\tpublic String get(String argName) throws StfException {\n\t\tif (!testArgs.containsKey(argName)) {\n\t\t\tthrow new StfException(\"No test argument specified for '\" + argName + \"'\");\n\t\t}\n\t\t\n\t\treturn testArgs.get(argName);\n\t}\n\t\n\n\t/**\n\t * Returns the value of a test argument which points to a JVM directory.\n\t * \n\t * @param jvmHomeArg is the name of the argument which holds the location of the JVM.\n\t * @return A DirectoryRef object pointing at the JVM directory.\n\t * @throws StfException if the argument has not been provided or if it \n\t * doesn't point at a valid JVM.\n\t */\n\tpublic DirectoryRef getAsJvmHomeDirectory(String jvmHomeArg) throws StfException {\n\t\tString jvmHomeString = get(jvmHomeArg);\n\t\tDirectoryRef jvmHome = new DirectoryRef(jvmHomeString);\n\t\t\n\t\t// Validate that we really are pointing at a JVM image\n\t\tif (!jvmHome.exists()) {\n\t\t\tthrow new StfException(\"Argument '\" + jvmHomeArg + \"' doesn't point to a JVM image. Directory does not exist\");\n\t\t}\n\t\tFileRef java = jvmHome.childFile(\"bin/java\");\n\t\tFileRef javaExe = jvmHome.childFile(\"bin/java.exe\");\n\t\tif (!(java.asJavaFile().exists() || javaExe.asJavaFile().exists())) {\n\t\t\tthrow new StfException(\"Argument '\" + jvmHomeArg + \"' doesn't point to a JVM image. Image doesn't contain java at either '\" + java + \"' or '\" + javaExe + \"'\");\n\t\t}\n\t\tDirectoryRef confDir = jvmHome.childDirectory(\"conf\");\n\t\tif (!confDir.exists()) {\n\t\t\tthrow new StfException(\"Argument '\" + jvmHomeArg + \"' doesn't point to a JVM image. Directory does not exist at '\" + confDir + \"'\");\n\t\t}\n\t\t\n\t\treturn jvmHome;\n\t}\n}",
        "start_line": 128,
        "end_line": 199,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 690,
        "node_type": null,
        "file_sha": "54b9f3be03ec8ad57b6de9a0a221a5702f3e1c9c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.928307"
      },
      "text": "// Step through all enum values looking for a match\n    \tE result = null;\n\t    for (E enumValue : enumType.getEnumConstants()) {\n\t\t    if (argValue.equals(enumValue.name())) {\n\t\t    \tresult = enumValue;\n\t\t    \tbreak; // found it\n\t\t    }\n\t\t}\n\n\t    // Fail if we weren't able to convert the argument value to an enum value\n\t    if (result == null) {\n\t    \t// Build string with names of all possible enum values\n\t    \tStringBuilder argNames = new StringBuilder();\n\t    \tfor (E enumValue : enumType.getEnumConstants()) {\n\t    \t\tif (argNames.length() > 0) { \n\t    \t\t\targNames.append(\", \");\n\t    \t\t}\n\t    \t\targNames.append(enumValue.name());\n\t    \t}\n\t    \t\n\t\t\tthrow new StfError(\"Invalid argument value for '\" + argName + \"'.\"\n\t\t\t\t\t+ \" Value of '\" + argValue + \"' is not one of : [\" + argNames.toString().trim() + \"]\");\n\t    }\n\t    \n\t    return result;\n\t}\n\n\t\n\t/**\n\t * Gets the value of a name test argument. \n\t * @param argName is the name of the argument to get the value of.\n\t * @return the value of the specified test argument.\n\t * @throws StfException if there is no value for the specified argument.\n\t */\n\tpublic String get(String argName) throws StfException {\n\t\tif (!testArgs.containsKey(argName)) {\n\t\t\tthrow new StfException(\"No test argument specified for '\" + argName + \"'\");\n\t\t}\n\t\t\n\t\treturn testArgs.get(argName);\n\t}\n\t\n\n\t/**\n\t * Returns the value of a test argument which points to a JVM directory.\n\t * \n\t * @param jvmHomeArg is the name of the argument which holds the location of the JVM.\n\t * @return A DirectoryRef object pointing at the JVM directory.\n\t * @throws StfException if the argument has not been provided or if it \n\t * doesn't point at a valid JVM.\n\t */\n\tpublic DirectoryRef getAsJvmHomeDirectory(String jvmHomeArg) throws StfException {\n\t\tString jvmHomeString = get(jvmHomeArg);\n\t\tDirectoryRef jvmHome = new DirectoryRef(jvmHomeString);\n\t\t\n\t\t// Validate that we really are pointing at a JVM image\n\t\tif (!jvmHome.exists()) {\n\t\t\tthrow new StfException(\"Argument '\" + jvmHomeArg + \"' doesn't point to a JVM image. Directory does not exist\");\n\t\t}\n\t\tFileRef java = jvmHome.childFile(\"bin/java\");\n\t\tFileRef javaExe = jvmHome.childFile(\"bin/java.exe\");\n\t\tif (!(java.asJavaFile().exists() || javaExe.asJavaFile().exists())) {\n\t\t\tthrow new StfException(\"Argument '\" + jvmHomeArg + \"' doesn't point to a JVM image. Image doesn't contain java at either '\" + java + \"' or '\" + javaExe + \"'\");\n\t\t}\n\t\tDirectoryRef confDir = jvmHome.childDirectory(\"conf\");\n\t\tif (!confDir.exists()) {\n\t\t\tthrow new StfException(\"Argument '\" + jvmHomeArg + \"' doesn't point to a JVM image. Directory does not exist at '\" + confDir + \"'\");\n\t\t}\n\t\t\n\t\treturn jvmHome;\n\t}\n}"
    },
    "163": {
      "metadata": {
        "chunk_id": "22806480d03d54a9fe607bda33913714910b6414e149e61526130800edfb571d",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/properties/Argument.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment.properties;\n\n\n/**\n * This class defines a class to represent STF arguments.\n * \n * The actual arguments themselves are defined in the STF extension which supports\n * that particular argument.\n */\npublic class Argument {\n\t// This is the name of the extension which supports this argument.\n\t// Only used to help with debugging.\n\tprivate String extensionName;\n\t\n\t// This is the name of the argument. ie. the value you use on the command line.\n\tprivate String argumentName;\n\t\n\t// Set if this is a boolean argument. \n\t// If a value is supplied then it must be either 'true' or 'false'. \n\t// If no value is supplied then the value defaults to true.\n\tprivate boolean isBooleanArgument;\n\n\t// Values do not have to be supplied for optional arguments, whereas STF will fail \n\t// with an error if no value is supplied for a mandatory argument.\n\tprivate Required argumentType;\n\tpublic enum Required { OPTIONAL, MANDATORY };\n\t\n\t// This value is used to show that an argument doesn't actually have a value\n\tpublic static String EMPTY_VALUE = \"null\"; \n\t\n\n\t/**\n\t * Create an argument object.\n\t * \n\t * @param extensionName is the name of the extension which supports this argument.\n\t * @param argumentName\n\t * @param isBooleanArg\n\t * @param argumentType\n\t */\n\tpublic Argument(String extensionName, String argumentName, boolean isBooleanArg, Required argumentType) {\n\t\tthis.extensionName = extensionName;\n\t\tthis.argumentName = argumentName;\n\t\tthis.isBooleanArgument = false;\n\t\tthis.argumentType = argumentType;\n\t}\n\t\n\t\n\tpublic String getExtensionName() {\n\t\treturn extensionName;\n\t}\n\t\n\t\n\tpublic String getName() {\n\t\treturn argumentName;\n\t}\n\t\n\t\n\tpublic boolean isBooleanArgument() { \n\t\treturn isBooleanArgument;\n\t}\n\n\n\tpublic boolean isOptional() { \n\t\treturn argumentType == Required.OPTIONAL;\n\t}\n\n\t\n\tpublic String toString() { \n\t\treturn \"Extension=\" + extensionName \n\t\t\t\t+ \" Name=\" + argumentName \n\t\t\t\t+ \" isBoolean=\" + isBooleanArgument \n\t\t\t\t+ \" type=\" + argumentType;\n\t}\n}",
        "start_line": 0,
        "end_line": 87,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 581,
        "node_type": null,
        "file_sha": "689dd60041e56d13ceba757e01081bf61096dbe8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.939799"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment.properties;\n\n\n/**\n * This class defines a class to represent STF arguments.\n * \n * The actual arguments themselves are defined in the STF extension which supports\n * that particular argument.\n */\npublic class Argument {\n\t// This is the name of the extension which supports this argument.\n\t// Only used to help with debugging.\n\tprivate String extensionName;\n\t\n\t// This is the name of the argument. ie. the value you use on the command line.\n\tprivate String argumentName;\n\t\n\t// Set if this is a boolean argument. \n\t// If a value is supplied then it must be either 'true' or 'false'. \n\t// If no value is supplied then the value defaults to true.\n\tprivate boolean isBooleanArgument;\n\n\t// Values do not have to be supplied for optional arguments, whereas STF will fail \n\t// with an error if no value is supplied for a mandatory argument.\n\tprivate Required argumentType;\n\tpublic enum Required { OPTIONAL, MANDATORY };\n\t\n\t// This value is used to show that an argument doesn't actually have a value\n\tpublic static String EMPTY_VALUE = \"null\"; \n\t\n\n\t/**\n\t * Create an argument object.\n\t * \n\t * @param extensionName is the name of the extension which supports this argument.\n\t * @param argumentName\n\t * @param isBooleanArg\n\t * @param argumentType\n\t */\n\tpublic Argument(String extensionName, String argumentName, boolean isBooleanArg, Required argumentType) {\n\t\tthis.extensionName = extensionName;\n\t\tthis.argumentName = argumentName;\n\t\tthis.isBooleanArgument = false;\n\t\tthis.argumentType = argumentType;\n\t}\n\t\n\t\n\tpublic String getExtensionName() {\n\t\treturn extensionName;\n\t}\n\t\n\t\n\tpublic String getName() {\n\t\treturn argumentName;\n\t}\n\t\n\t\n\tpublic boolean isBooleanArgument() { \n\t\treturn isBooleanArgument;\n\t}\n\n\n\tpublic boolean isOptional() { \n\t\treturn argumentType == Required.OPTIONAL;\n\t}\n\n\t\n\tpublic String toString() { \n\t\treturn \"Extension=\" + extensionName \n\t\t\t\t+ \" Name=\" + argumentName \n\t\t\t\t+ \" isBoolean=\" + isBooleanArgument \n\t\t\t\t+ \" type=\" + argumentType;\n\t}\n}"
    },
    "164": {
      "metadata": {
        "chunk_id": "c89a3b1544d445bddf13e44632cd70033754b23c11da48678307b1ee3a18f77c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/properties/LayeredProperties.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment.properties;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;",
        "start_line": 0,
        "end_line": 28,
        "chunk_index": 0,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 211,
        "node_type": null,
        "file_sha": "ffda76310ddabb0a07eabea03bdb32aa745b9a2a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.948937"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment.properties;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;"
    },
    "165": {
      "metadata": {
        "chunk_id": "f44abe25396e61f7f7b35153a1557c0afdb24b9eea8eaaed81cb1a66f2b17b92",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/properties/LayeredProperties.java",
        "content": "public class LayeredProperties {\n\t// This array holds 1 or more layers of properties.\n\t// They are held in highest to lowest priority order. ie. values from, say, the first layer \n\t// will override values from subsequent layers.\n\tprivate ArrayList<OrderedProperties> layers = new ArrayList<OrderedProperties>();\n\t\n\tArrayList<Argument> supportedArguments = null;\n\t\n\tprivate HashSet<String> optionalProperties;\n\t\n\t\n\t/**\n\t * Constructs a new Layer properties object.\n\t * @param optionalProperties is a set of Strings listing optional properties, for which no value has to be supplied. \n\t */\n\tpublic LayeredProperties(ArrayList<OrderedProperties> allPropertyData, ArrayList<Argument> supportedArguments) {\n\t\tthis.layers = allPropertyData;\n\t\tthis.supportedArguments = supportedArguments;\n\t\t\n\t\t// Build up a set containing all optional properties\n\t\toptionalProperties = new LinkedHashSet<String>();\n\t\tfor (Argument argument : supportedArguments) {\n\t\t\tif (argument.isOptional()) {\n\t\t\t\toptionalProperties.add(argument.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic void addPropertyLayer(OrderedProperties properties) {\n\t    layers.add(properties);\t\n\t}\n\n\t\n\t/**\n\t * @returns the value for the named property.\n\t * \n\t * @throws StfException if the property is not known or if it has a null value.\n\t */\n\tpublic String getProperty(String propertyName) throws StfException {\n\t\tStack<String> resolutionAuditTrail = new Stack<String>();\n\t\treturn resolveProperty(propertyName, propertyName, resolutionAuditTrail);\n\t}\n\n\n\tpublic void updateProperty(Argument argument, String newValue) {\n\t\tOrderedProperties newLayer = new OrderedProperties(\"DynamicPropertyUpdate\");\n\t\tnewLayer.put(argument.getName(), newValue);\n\t\tlayers.add(0, newLayer);\n\t}\n\n\t\n\t/**\n\t * This is the key method which finds the current value for a named property.\n\t * It works it's way through the property layers trying to find a value for the property.\n\t * \n\t * If the value of a property contains a '${.*}' then every such occurrence is replaced \n\t * with the value of the corresponding environment variable or the value of another property.\n\t * Resolution of the referenced property starts at the highest level.\n\t * Example specification: 'java-execution-args=-Xmx128m ${fixed-args} ${extension-args}'\n     *\n\t * @param propertyName is the name of the property to find a value for. \n\t * @param originalPropertyName is the name of the property that we started looking for.\n\t * @param resolutionAuditTrail lists all properties that have been followed in an attempt to \n\t *        resolve a property. This is used to prevent infinite recursion and help produce more \n\t *        sensible error messages.\n\t * @return The value of the property. \n\t * @throws StfException if no value can be found for propertyName.\n\t */\n\tprivate String resolveProperty(String propertyName, String originalPropertyName, Stack<String> resolutionAuditTrail) throws StfException {\n\t\tresolutionAuditTrail.push(propertyName);\n\t\tif (resolutionAuditTrail.size() > 100) {\n\t\t\tString trailDescription = formatTrailDescription(resolutionAuditTrail);\n\t\t\tthrow new StfException(\"Excess property nesting detected for property '\" + originalPropertyName + \"'. \"\n\t\t\t\t\t\t+ \"Chain followed is: \" + trailDescription);\n\t\t}\n\t\t\n\t\t// Attempt to find the value for the requested property name by stepping through \n\t\t// all of the property layers. From topmost to lowest priority.\n\t\tfor (OrderedProperties layer : layers) { \n\t\t\tString value = layer.getProperty(propertyName);\n\t\t\tif (value != null) {\n\t\t\t\tvalue = value.trim();\n\t\t\t\t\n\t\t\t\tif (value.isEmpty() && !optionalProperties.contains(propertyName)) {\n\t\t\t\t\tthrow new StfError(\"Empty property found for '\" + propertyName + \"'\");\n\t\t\t\t\t\n\t\t\t\t} else if (value.equals(Argument.EMPTY_VALUE)) {\n\t\t\t\t\tif (optionalProperties.contains(propertyName)) {\n\t\t\t\t\t\tresolutionAuditTrail.pop();\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t\tthrow new StfError(\"No value specified for the mandatory property: '\" + propertyName + \"'\");",
        "start_line": 29,
        "end_line": 121,
        "chunk_index": 1,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 844,
        "node_type": null,
        "file_sha": "ffda76310ddabb0a07eabea03bdb32aa745b9a2a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.948946"
      },
      "text": "public class LayeredProperties {\n\t// This array holds 1 or more layers of properties.\n\t// They are held in highest to lowest priority order. ie. values from, say, the first layer \n\t// will override values from subsequent layers.\n\tprivate ArrayList<OrderedProperties> layers = new ArrayList<OrderedProperties>();\n\t\n\tArrayList<Argument> supportedArguments = null;\n\t\n\tprivate HashSet<String> optionalProperties;\n\t\n\t\n\t/**\n\t * Constructs a new Layer properties object.\n\t * @param optionalProperties is a set of Strings listing optional properties, for which no value has to be supplied. \n\t */\n\tpublic LayeredProperties(ArrayList<OrderedProperties> allPropertyData, ArrayList<Argument> supportedArguments) {\n\t\tthis.layers = allPropertyData;\n\t\tthis.supportedArguments = supportedArguments;\n\t\t\n\t\t// Build up a set containing all optional properties\n\t\toptionalProperties = new LinkedHashSet<String>();\n\t\tfor (Argument argument : supportedArguments) {\n\t\t\tif (argument.isOptional()) {\n\t\t\t\toptionalProperties.add(argument.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic void addPropertyLayer(OrderedProperties properties) {\n\t    layers.add(properties);\t\n\t}\n\n\t\n\t/**\n\t * @returns the value for the named property.\n\t * \n\t * @throws StfException if the property is not known or if it has a null value.\n\t */\n\tpublic String getProperty(String propertyName) throws StfException {\n\t\tStack<String> resolutionAuditTrail = new Stack<String>();\n\t\treturn resolveProperty(propertyName, propertyName, resolutionAuditTrail);\n\t}\n\n\n\tpublic void updateProperty(Argument argument, String newValue) {\n\t\tOrderedProperties newLayer = new OrderedProperties(\"DynamicPropertyUpdate\");\n\t\tnewLayer.put(argument.getName(), newValue);\n\t\tlayers.add(0, newLayer);\n\t}\n\n\t\n\t/**\n\t * This is the key method which finds the current value for a named property.\n\t * It works it's way through the property layers trying to find a value for the property.\n\t * \n\t * If the value of a property contains a '${.*}' then every such occurrence is replaced \n\t * with the value of the corresponding environment variable or the value of another property.\n\t * Resolution of the referenced property starts at the highest level.\n\t * Example specification: 'java-execution-args=-Xmx128m ${fixed-args} ${extension-args}'\n     *\n\t * @param propertyName is the name of the property to find a value for. \n\t * @param originalPropertyName is the name of the property that we started looking for.\n\t * @param resolutionAuditTrail lists all properties that have been followed in an attempt to \n\t *        resolve a property. This is used to prevent infinite recursion and help produce more \n\t *        sensible error messages.\n\t * @return The value of the property. \n\t * @throws StfException if no value can be found for propertyName.\n\t */\n\tprivate String resolveProperty(String propertyName, String originalPropertyName, Stack<String> resolutionAuditTrail) throws StfException {\n\t\tresolutionAuditTrail.push(propertyName);\n\t\tif (resolutionAuditTrail.size() > 100) {\n\t\t\tString trailDescription = formatTrailDescription(resolutionAuditTrail);\n\t\t\tthrow new StfException(\"Excess property nesting detected for property '\" + originalPropertyName + \"'. \"\n\t\t\t\t\t\t+ \"Chain followed is: \" + trailDescription);\n\t\t}\n\t\t\n\t\t// Attempt to find the value for the requested property name by stepping through \n\t\t// all of the property layers. From topmost to lowest priority.\n\t\tfor (OrderedProperties layer : layers) { \n\t\t\tString value = layer.getProperty(propertyName);\n\t\t\tif (value != null) {\n\t\t\t\tvalue = value.trim();\n\t\t\t\t\n\t\t\t\tif (value.isEmpty() && !optionalProperties.contains(propertyName)) {\n\t\t\t\t\tthrow new StfError(\"Empty property found for '\" + propertyName + \"'\");\n\t\t\t\t\t\n\t\t\t\t} else if (value.equals(Argument.EMPTY_VALUE)) {\n\t\t\t\t\tif (optionalProperties.contains(propertyName)) {\n\t\t\t\t\t\tresolutionAuditTrail.pop();\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t\tthrow new StfError(\"No value specified for the mandatory property: '\" + propertyName + \"'\");"
    },
    "166": {
      "metadata": {
        "chunk_id": "9b9cbba0b4bfaa4b964118b14947e65250b58b096845e030a2abbb90d652b179",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/properties/LayeredProperties.java",
        "content": "} else if (value.contains(\"${\")) {\n\t\t\t\t\t// The value looks like it references at least one other variable.\n\t\t\t\t\t// Update the property value by replacing the reference with the actual value(s). \n\t\t\t        Pattern pattern = Pattern.compile(\"\\\\$\\\\{.*?\\\\}\");  // ie: ${.*?}\n\t\t\t        Matcher matcher = pattern.matcher(value);\n\n\t\t\t        StringBuffer buff = new StringBuffer();\n\t\t\t        while(matcher.find()) {\n\t\t\t            String referenceSpec = matcher.group(0);\n\t\t\t            String referenceName = referenceSpec.substring(2, referenceSpec.length()-1);\n\t\t\t            \n\t\t\t            // To find the replacement value first try using an environment variable\n\t\t\t\t\t\tString replacementValue = System.getenv(referenceName);\n\t\t\t            if (replacementValue == null) {\n\t\t\t            \t// It's not a reference to an env.variable, so attempt to substitute another property value.\n\t\t\t            \treplacementValue = resolveProperty(referenceName, originalPropertyName, resolutionAuditTrail);\n\t\t\t            }\n\n\t\t\t            // The upcoming 'appendReplacement' looses '\\' characters! So prevent this by changing them to '\\\\'\n\t\t\t            replacementValue = replacementValue.replace(\"\\\\\",  \"\\\\\\\\\");\n\n\t\t\t            matcher.appendReplacement(buff, replacementValue);\n\t\t\t        }\n\t\t\t        matcher.appendTail(buff);\n\t\t\t        value = buff.toString();\n\t\t\t\t}\n\n\t\t\t\tresolutionAuditTrail.pop();\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If an optional property references an unset environment variable then we end up here.\n\t\tif (optionalProperties.contains(originalPropertyName)) {\n\t\t\t// It's optional so treat property as having an empty string value.\n\t\t\tresolutionAuditTrail.pop();\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Failed to find a value for propertyName\n\t\tif (propertyName.equals(originalPropertyName)) {\n\t\t\tthrow new StfError(\"No value specified for property '\" + propertyName + \"'\");\n\t\t} else {\n\t\t\tString trailDescription = formatTrailDescription(resolutionAuditTrail);\n\t\t\tthrow new StfError(\"Unable to succesfully build value for property '\" + originalPropertyName + \"'. \"\n\t\t\t\t\t+ \"There is no enviroment variable or property defined for '\" + propertyName + \"'. \" \n\t\t\t\t\t+ \"Chain followed is: \" + trailDescription);\n\t\t}\n\t}\n\n\n\tprivate String formatTrailDescription(Stack<String> resolutionAuditTrail) {\n\t\tStringBuilder trailDescription = new StringBuilder();\n\t\t\n\t\tboolean first = true;\n\t\tfor (String item : resolutionAuditTrail) {\n\t\t\tif (!first) {\n\t\t\t\ttrailDescription.append(\" -> \");\n\t\t\t}\n\t\t\tfirst = false;\n\t\t\ttrailDescription.append(item);\n\t\t}\n\t\t\n\t\treturn trailDescription.toString();\n\t}\n\n\t\n\t/**\n\t * @return an set containing the names of all arguments.\n\t */\n\tprivate LinkedHashSet<String> getAllArgumentNames() {\n\t\tLinkedHashSet<String> allArgumentNames = new LinkedHashSet<String>();\n\t\n\t\tfor (OrderedProperties layer : layers) {\n\t\t\tfor (Object key : layer.getEnvironmentNeutralkeys()) {\n\t\t\t\tString argName = (String) key;\n\t\t\t\tif (!allArgumentNames.contains(argName)) {\n\t\t\t\t\tallArgumentNames.add(argName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn allArgumentNames;\n\t}\n\n\t\n\t// Verifies that every property, from every layer, is known.\n\t// For a property to be known it must be a supported property of an extension \n\t// that is used by the current test.\n\t// An exception is thrown if an unknown property is found.\n\t// This method makes sure that all supplied properties are spelt correctly.\n\tpublic void checkForUnknownProperties() throws StfException {\n\t\t// Find all of the properties that are used in the current STF run\n\t\tHashSet<String> actualProperties = getAllArgumentNames();\n\t\t\n\t\t// From the list of the actual properties subtract all allowed arguments.\n\t\tfor (Argument supportedArgument : supportedArguments) {\n\t\t\tactualProperties.remove(supportedArgument.getName());\n\t\t}\n\t\t\n\t\t// Fail if there are any properties left, as these are not supported by any extension.\n\t\tif (!actualProperties.isEmpty()) {\n\t\t\tthrow new StfError(\"Unknown argument(s) supplied: \" + actualProperties);\n\t\t}\n\t}",
        "start_line": 122,
        "end_line": 226,
        "chunk_index": 2,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 842,
        "node_type": null,
        "file_sha": "ffda76310ddabb0a07eabea03bdb32aa745b9a2a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.948949"
      },
      "text": "} else if (value.contains(\"${\")) {\n\t\t\t\t\t// The value looks like it references at least one other variable.\n\t\t\t\t\t// Update the property value by replacing the reference with the actual value(s). \n\t\t\t        Pattern pattern = Pattern.compile(\"\\\\$\\\\{.*?\\\\}\");  // ie: ${.*?}\n\t\t\t        Matcher matcher = pattern.matcher(value);\n\n\t\t\t        StringBuffer buff = new StringBuffer();\n\t\t\t        while(matcher.find()) {\n\t\t\t            String referenceSpec = matcher.group(0);\n\t\t\t            String referenceName = referenceSpec.substring(2, referenceSpec.length()-1);\n\t\t\t            \n\t\t\t            // To find the replacement value first try using an environment variable\n\t\t\t\t\t\tString replacementValue = System.getenv(referenceName);\n\t\t\t            if (replacementValue == null) {\n\t\t\t            \t// It's not a reference to an env.variable, so attempt to substitute another property value.\n\t\t\t            \treplacementValue = resolveProperty(referenceName, originalPropertyName, resolutionAuditTrail);\n\t\t\t            }\n\n\t\t\t            // The upcoming 'appendReplacement' looses '\\' characters! So prevent this by changing them to '\\\\'\n\t\t\t            replacementValue = replacementValue.replace(\"\\\\\",  \"\\\\\\\\\");\n\n\t\t\t            matcher.appendReplacement(buff, replacementValue);\n\t\t\t        }\n\t\t\t        matcher.appendTail(buff);\n\t\t\t        value = buff.toString();\n\t\t\t\t}\n\n\t\t\t\tresolutionAuditTrail.pop();\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If an optional property references an unset environment variable then we end up here.\n\t\tif (optionalProperties.contains(originalPropertyName)) {\n\t\t\t// It's optional so treat property as having an empty string value.\n\t\t\tresolutionAuditTrail.pop();\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Failed to find a value for propertyName\n\t\tif (propertyName.equals(originalPropertyName)) {\n\t\t\tthrow new StfError(\"No value specified for property '\" + propertyName + \"'\");\n\t\t} else {\n\t\t\tString trailDescription = formatTrailDescription(resolutionAuditTrail);\n\t\t\tthrow new StfError(\"Unable to succesfully build value for property '\" + originalPropertyName + \"'. \"\n\t\t\t\t\t+ \"There is no enviroment variable or property defined for '\" + propertyName + \"'. \" \n\t\t\t\t\t+ \"Chain followed is: \" + trailDescription);\n\t\t}\n\t}\n\n\n\tprivate String formatTrailDescription(Stack<String> resolutionAuditTrail) {\n\t\tStringBuilder trailDescription = new StringBuilder();\n\t\t\n\t\tboolean first = true;\n\t\tfor (String item : resolutionAuditTrail) {\n\t\t\tif (!first) {\n\t\t\t\ttrailDescription.append(\" -> \");\n\t\t\t}\n\t\t\tfirst = false;\n\t\t\ttrailDescription.append(item);\n\t\t}\n\t\t\n\t\treturn trailDescription.toString();\n\t}\n\n\t\n\t/**\n\t * @return an set containing the names of all arguments.\n\t */\n\tprivate LinkedHashSet<String> getAllArgumentNames() {\n\t\tLinkedHashSet<String> allArgumentNames = new LinkedHashSet<String>();\n\t\n\t\tfor (OrderedProperties layer : layers) {\n\t\t\tfor (Object key : layer.getEnvironmentNeutralkeys()) {\n\t\t\t\tString argName = (String) key;\n\t\t\t\tif (!allArgumentNames.contains(argName)) {\n\t\t\t\t\tallArgumentNames.add(argName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn allArgumentNames;\n\t}\n\n\t\n\t// Verifies that every property, from every layer, is known.\n\t// For a property to be known it must be a supported property of an extension \n\t// that is used by the current test.\n\t// An exception is thrown if an unknown property is found.\n\t// This method makes sure that all supplied properties are spelt correctly.\n\tpublic void checkForUnknownProperties() throws StfException {\n\t\t// Find all of the properties that are used in the current STF run\n\t\tHashSet<String> actualProperties = getAllArgumentNames();\n\t\t\n\t\t// From the list of the actual properties subtract all allowed arguments.\n\t\tfor (Argument supportedArgument : supportedArguments) {\n\t\t\tactualProperties.remove(supportedArgument.getName());\n\t\t}\n\t\t\n\t\t// Fail if there are any properties left, as these are not supported by any extension.\n\t\tif (!actualProperties.isEmpty()) {\n\t\t\tthrow new StfError(\"Unknown argument(s) supplied: \" + actualProperties);\n\t\t}\n\t}"
    },
    "167": {
      "metadata": {
        "chunk_id": "6719eb581556b685599780a52e6ca91c9f120b837e08791110eb849d19c6fdd5",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/properties/LayeredProperties.java",
        "content": "// Write a list of all properties, with their resolved values, to a file.\n\t// They are written out in the same order as the list at the top of this class.\n\tpublic void dumpResolvedProperties(ArrayList<Argument> allArguments, File debugFile) throws StfException {\n\t\tStringBuilder builder = new StringBuilder();\n\t\t\n\t\t// Add title describing the contents of the file\n\t\tbuilder.append(\"# \\n\");\n\t\tbuilder.append(\"# Resolved property values.\\n\");\n\t\tbuilder.append(\"# \\n\");\n\t\tbuilder.append(\"# This file contains the actual value to be used for all properties.\\n\");\n\t\tbuilder.append(\"# \\n\\n\");\n\t\t\n\t\t// Add actual name/value pairs for all properties. \n\t\tfor (Argument argument : allArguments) {\n\t\t\tString argumentName = argument.getName();\n\t\t\tbuilder.append(argumentName + \" = \" + getProperty(argumentName) + \"\\n\");\n\t\t}\n\n\t\twriteFile(debugFile, builder.toString());\n\t}\n\t\n\n\t// Writes textual values of all properties to a file. \n\t// The properties are written layer by layer, from highest to lowest priority.\n\t// The values are written as-is. ie. their values are not resolved.\n\tpublic void dumpAllProperties(File outputFile) throws StfException {\n\t\tString fileHeader = \n\t\t\t\t  \"# \\n\"\n\t\t\t\t+ \"# This file contains the values for all properties in all layers.\\n\"\n\t\t\t\t+ \"# The layers are listed from highest to lowest priority\\n\"\n\t\t\t\t+ \"# \\n\"\n\t\t\t\t+ \"# See 'resolvedProperties.txt for the actual value resolved for each property.\\n\"\n\t\t\t\t+ \"# \\n\\n\";\n\t\t\n\t\twriteFile(outputFile, fileHeader + this.toString());\n\t}\n\n\n\t// Writes a string to an output file\n    private void writeFile(File outputFile, String content) throws StfException {\n        BufferedWriter output = null;\n        try {\n            output = new BufferedWriter(new FileWriter(outputFile));\n            output.write(content);\n        } catch (IOException e) {\n            throw new StfException(\"Failed to write to file: \" + outputFile.getAbsolutePath(), e);\n        } finally {\n            if (output != null) {\n            \ttry {\n\t\t\t\t\toutput.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StfException(\"Failed to close file: \" + outputFile.getAbsolutePath(), e);\n\t\t\t\t}\n            }\n        }\n    }\n\n\n\tpublic String toString() {\n\t\tStringBuilder builder = new StringBuilder();\n\n\t\tint layerNumber = 1;\n\t\tfor (OrderedProperties layer : layers) {\n\t\t\tbuilder.append(layerNumber + \") \");\n\t\t\tbuilder.append(layer.toString());\n\t\t\tbuilder.append(\"\\n\");\n\t\t\tlayerNumber++;\n\t\t}\n\t\t\n\t\treturn builder.toString();\n\t}\n}",
        "start_line": 227,
        "end_line": 298,
        "chunk_index": 3,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 547,
        "node_type": null,
        "file_sha": "ffda76310ddabb0a07eabea03bdb32aa745b9a2a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.948952"
      },
      "text": "// Write a list of all properties, with their resolved values, to a file.\n\t// They are written out in the same order as the list at the top of this class.\n\tpublic void dumpResolvedProperties(ArrayList<Argument> allArguments, File debugFile) throws StfException {\n\t\tStringBuilder builder = new StringBuilder();\n\t\t\n\t\t// Add title describing the contents of the file\n\t\tbuilder.append(\"# \\n\");\n\t\tbuilder.append(\"# Resolved property values.\\n\");\n\t\tbuilder.append(\"# \\n\");\n\t\tbuilder.append(\"# This file contains the actual value to be used for all properties.\\n\");\n\t\tbuilder.append(\"# \\n\\n\");\n\t\t\n\t\t// Add actual name/value pairs for all properties. \n\t\tfor (Argument argument : allArguments) {\n\t\t\tString argumentName = argument.getName();\n\t\t\tbuilder.append(argumentName + \" = \" + getProperty(argumentName) + \"\\n\");\n\t\t}\n\n\t\twriteFile(debugFile, builder.toString());\n\t}\n\t\n\n\t// Writes textual values of all properties to a file. \n\t// The properties are written layer by layer, from highest to lowest priority.\n\t// The values are written as-is. ie. their values are not resolved.\n\tpublic void dumpAllProperties(File outputFile) throws StfException {\n\t\tString fileHeader = \n\t\t\t\t  \"# \\n\"\n\t\t\t\t+ \"# This file contains the values for all properties in all layers.\\n\"\n\t\t\t\t+ \"# The layers are listed from highest to lowest priority\\n\"\n\t\t\t\t+ \"# \\n\"\n\t\t\t\t+ \"# See 'resolvedProperties.txt for the actual value resolved for each property.\\n\"\n\t\t\t\t+ \"# \\n\\n\";\n\t\t\n\t\twriteFile(outputFile, fileHeader + this.toString());\n\t}\n\n\n\t// Writes a string to an output file\n    private void writeFile(File outputFile, String content) throws StfException {\n        BufferedWriter output = null;\n        try {\n            output = new BufferedWriter(new FileWriter(outputFile));\n            output.write(content);\n        } catch (IOException e) {\n            throw new StfException(\"Failed to write to file: \" + outputFile.getAbsolutePath(), e);\n        } finally {\n            if (output != null) {\n            \ttry {\n\t\t\t\t\toutput.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StfException(\"Failed to close file: \" + outputFile.getAbsolutePath(), e);\n\t\t\t\t}\n            }\n        }\n    }\n\n\n\tpublic String toString() {\n\t\tStringBuilder builder = new StringBuilder();\n\n\t\tint layerNumber = 1;\n\t\tfor (OrderedProperties layer : layers) {\n\t\t\tbuilder.append(layerNumber + \") \");\n\t\t\tbuilder.append(layer.toString());\n\t\t\tbuilder.append(\"\\n\");\n\t\t\tlayerNumber++;\n\t\t}\n\t\t\n\t\treturn builder.toString();\n\t}\n}"
    },
    "168": {
      "metadata": {
        "chunk_id": "8b83e5e4b70965e3ba065e9c397d5e8c11b1f21897466aa33929525890a40b8d",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/properties/OrderedProperties.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment.properties;\n\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.LinkedHashSet;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\n\n/**\n * Properties class which keeps properties in the same order as read from the property file\n */",
        "start_line": 0,
        "end_line": 32,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 223,
        "node_type": null,
        "file_sha": "3e2e497cdb4220897e62360fd855dc3c19c8c9d4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.961348"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.environment.properties;\n\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.LinkedHashSet;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\n\n/**\n * Properties class which keeps properties in the same order as read from the property file\n */"
    },
    "169": {
      "metadata": {
        "chunk_id": "556d6160dea992b4abe59dd3c3819f6cdf7c78545bc1f6346eab3cb7e9931e5a",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/properties/OrderedProperties.java",
        "content": "public class OrderedProperties extends Properties \n{\n\tprivate static final long serialVersionUID = 2138723788L;\n\n\t// To help with debugging keep a note of where the properties have come from\n\tprivate String sourceFileName;\n\t\n\tprivate LinkedHashSet<Object> environmentNeutralkeys = new LinkedHashSet<Object>();\n\t\n\t\n\t// Inner class to hold details about a property file\n\tpublic static class PropertyFileDetails { \n\t\tpublic File file;\n\t\tpublic boolean mandatory;\n\n\t\tpublic PropertyFileDetails(File propertyFile, boolean mandatory) {\n\t\t\tthis.file = propertyFile;\n\t\t\tthis.mandatory = mandatory;\n\t\t}\n\n\t\tpublic String toString() { \n\t\t\treturn file.getAbsolutePath() + \" \" + mandatory;\n\t\t}\n\t}\n\n\n\tpublic OrderedProperties() {\n\t}\n\t\n\t\n\tpublic OrderedProperties(String sourceFileName) {\n\t\tthis.sourceFileName = sourceFileName;\n\t}\n\t\n\t\n\tpublic Set<Object> getEnvironmentNeutralkeys() {\n\t\treturn environmentNeutralkeys;\n\t}\n\t\n\t\n\tpublic Object put(Object fullName, Object valueObject)\n\t{\n\t\tString name  = ((String) fullName).trim();\n\t\tString value = ((String) valueObject).trim();\n\t\t\n\t\t// Remove a leading '-' from the name\n\t\tif (name.startsWith(\"-\")) {\n\t\t\tname = name.substring(1);\n\t\t}\n\n\t\t// Keep note of the property name without platform name for later error checking\n\t\tString cleanedName = PlatformFinder.removePlatformSuffix(name);\n\t\tgetEnvironmentNeutralkeys().add(cleanedName);\n\t\t\t\t\n\t\treturn super.put(name, value);\n\t}\n\t\n\t@Override\n\tpublic String getProperty(String propertyName) {\n\t\t// First try to find a value for the current platform.\n\t\ttry {\n\t\t\tString platformedKey = propertyName + \".\" + PlatformFinder.getPlatform().getShortName();\n\t\t\tString propertyValue = super.getProperty(platformedKey);\n\t\n\t\t\tif (propertyValue == null) {\n\t\t\t\t// No platform specific value, so look for version without the platform specified.\n\t\t\t\tpropertyValue = super.getProperty(propertyName);\n\t\t\t}\n\t\t\t\n\t\t\treturn propertyValue;\n\t\t} catch (StfException e) {\n\t\t\tthrow new IllegalStateException(\"Failed to get property: \" + propertyName, e);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Set<String> stringPropertyNames() \n\t{\n\t\tLinkedHashSet<String> keysAsStrings = new LinkedHashSet<String>();\n\n\t\tfor (Object key:keySet()) {\n\t    \tkeysAsStrings.add((String) key);\n\t\t}\n\t\t\n\t\treturn keysAsStrings;\n\t}\n\t\n\t\n\t/** Reads in a set of properties from a file\n\t * \n\t * @param fileName\n\t * @return\n\t * @throws StfException\n\t */\n\tpublic static OrderedProperties loadFromFile(PropertyFileDetails propertyFile) throws StfException { \n\t\tString propertyFileName = propertyFile.file.getAbsolutePath();\n\t\tOrderedProperties properties = new OrderedProperties(propertyFileName);\n\t\t\n\t\tif (propertyFile.mandatory && !propertyFile.file.exists()) {\n\t\t\tthrow new StfException(\"Mandatory property file does not exist: \" + propertyFileName);\n\t\t}\n\t\t\n\t\tif (propertyFile.file.exists()) {\n\t\t\t// Read in the contents of the property file\n\t\t\tString propertyFileContents;\n\t\t    BufferedReader bufferedReader = null;\n\t\t\ttry {\n\t\t\t\tbufferedReader = new BufferedReader(new FileReader(propertyFile.file));\n\t\t\t  \n\t\t\t\tStringBuffer fileContents = new StringBuffer();\n\t\t\t\tString line = null;\n\t\t\t\twhile ((line = bufferedReader.readLine()) != null) {\n\t\t\t\t   fileContents.append(line).append(\"\\n\");\n\t\t\t    }\n\t\t\t\tpropertyFileContents = fileContents.toString();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new StfException(e);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(e);\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tbufferedReader.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StfException(\"Failed to close file: \" + propertyFile.file);\n\t\t\t\t}\n\t\t\t}",
        "start_line": 33,
        "end_line": 158,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 797,
        "node_type": null,
        "file_sha": "3e2e497cdb4220897e62360fd855dc3c19c8c9d4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.961356"
      },
      "text": "public class OrderedProperties extends Properties \n{\n\tprivate static final long serialVersionUID = 2138723788L;\n\n\t// To help with debugging keep a note of where the properties have come from\n\tprivate String sourceFileName;\n\t\n\tprivate LinkedHashSet<Object> environmentNeutralkeys = new LinkedHashSet<Object>();\n\t\n\t\n\t// Inner class to hold details about a property file\n\tpublic static class PropertyFileDetails { \n\t\tpublic File file;\n\t\tpublic boolean mandatory;\n\n\t\tpublic PropertyFileDetails(File propertyFile, boolean mandatory) {\n\t\t\tthis.file = propertyFile;\n\t\t\tthis.mandatory = mandatory;\n\t\t}\n\n\t\tpublic String toString() { \n\t\t\treturn file.getAbsolutePath() + \" \" + mandatory;\n\t\t}\n\t}\n\n\n\tpublic OrderedProperties() {\n\t}\n\t\n\t\n\tpublic OrderedProperties(String sourceFileName) {\n\t\tthis.sourceFileName = sourceFileName;\n\t}\n\t\n\t\n\tpublic Set<Object> getEnvironmentNeutralkeys() {\n\t\treturn environmentNeutralkeys;\n\t}\n\t\n\t\n\tpublic Object put(Object fullName, Object valueObject)\n\t{\n\t\tString name  = ((String) fullName).trim();\n\t\tString value = ((String) valueObject).trim();\n\t\t\n\t\t// Remove a leading '-' from the name\n\t\tif (name.startsWith(\"-\")) {\n\t\t\tname = name.substring(1);\n\t\t}\n\n\t\t// Keep note of the property name without platform name for later error checking\n\t\tString cleanedName = PlatformFinder.removePlatformSuffix(name);\n\t\tgetEnvironmentNeutralkeys().add(cleanedName);\n\t\t\t\t\n\t\treturn super.put(name, value);\n\t}\n\t\n\t@Override\n\tpublic String getProperty(String propertyName) {\n\t\t// First try to find a value for the current platform.\n\t\ttry {\n\t\t\tString platformedKey = propertyName + \".\" + PlatformFinder.getPlatform().getShortName();\n\t\t\tString propertyValue = super.getProperty(platformedKey);\n\t\n\t\t\tif (propertyValue == null) {\n\t\t\t\t// No platform specific value, so look for version without the platform specified.\n\t\t\t\tpropertyValue = super.getProperty(propertyName);\n\t\t\t}\n\t\t\t\n\t\t\treturn propertyValue;\n\t\t} catch (StfException e) {\n\t\t\tthrow new IllegalStateException(\"Failed to get property: \" + propertyName, e);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Set<String> stringPropertyNames() \n\t{\n\t\tLinkedHashSet<String> keysAsStrings = new LinkedHashSet<String>();\n\n\t\tfor (Object key:keySet()) {\n\t    \tkeysAsStrings.add((String) key);\n\t\t}\n\t\t\n\t\treturn keysAsStrings;\n\t}\n\t\n\t\n\t/** Reads in a set of properties from a file\n\t * \n\t * @param fileName\n\t * @return\n\t * @throws StfException\n\t */\n\tpublic static OrderedProperties loadFromFile(PropertyFileDetails propertyFile) throws StfException { \n\t\tString propertyFileName = propertyFile.file.getAbsolutePath();\n\t\tOrderedProperties properties = new OrderedProperties(propertyFileName);\n\t\t\n\t\tif (propertyFile.mandatory && !propertyFile.file.exists()) {\n\t\t\tthrow new StfException(\"Mandatory property file does not exist: \" + propertyFileName);\n\t\t}\n\t\t\n\t\tif (propertyFile.file.exists()) {\n\t\t\t// Read in the contents of the property file\n\t\t\tString propertyFileContents;\n\t\t    BufferedReader bufferedReader = null;\n\t\t\ttry {\n\t\t\t\tbufferedReader = new BufferedReader(new FileReader(propertyFile.file));\n\t\t\t  \n\t\t\t\tStringBuffer fileContents = new StringBuffer();\n\t\t\t\tString line = null;\n\t\t\t\twhile ((line = bufferedReader.readLine()) != null) {\n\t\t\t\t   fileContents.append(line).append(\"\\n\");\n\t\t\t    }\n\t\t\t\tpropertyFileContents = fileContents.toString();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new StfException(e);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(e);\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tbufferedReader.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StfException(\"Failed to close file: \" + propertyFile.file);\n\t\t\t\t}\n\t\t\t}"
    },
    "170": {
      "metadata": {
        "chunk_id": "d952523654362971314b7fe858b38a0d03d6a528872e5c95289787de6e314cb2",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/environment/properties/OrderedProperties.java",
        "content": "// Fix windows specific problem when reading file specifications from property files.\n\t\t\t// Java property files containing backslash characters loose their backslash characters \n\t\t\t// when they are read in. \n\t\t\t// The workaround is to replace single backslash characters with double backslashes. \n\t\t\t// eg, 'c:\\tmp\\stf' from the original file is updated to 'c:\\\\tmp\\\\stf' which is read in as 'c:\\tmp\\stf'\n\t\t\tpropertyFileContents = propertyFileContents.replace(\"\\\\\", \"\\\\\\\\\");\n\n\t\t\t// Load properties from the corrected string\n\t\t\ttry {\n\t\t\t\tproperties.load(new ByteArrayInputStream(propertyFileContents.getBytes()));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Failed to load properties file: \" + propertyFileName, e);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn properties;\n\t}\n\t\n\t\n\tpublic synchronized String toString() {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tbuilder.append(\"PropertyFile: \" + sourceFileName + \"\\n\");\n\t\t\n\t\tif (!new File(sourceFileName).exists()) {\n\t\t\tbuilder.append(\"   No properties loaded. File does not exist\\n\");\n\t\t}\n\t\t\n\t\tfor (Object key : keySet()) { \n\t\t\tbuilder.append(\"  \" + key + \" = \" + super.getProperty((String) key) + \"\\n\");\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n}",
        "start_line": 159,
        "end_line": 192,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 284,
        "node_type": null,
        "file_sha": "3e2e497cdb4220897e62360fd855dc3c19c8c9d4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.961358"
      },
      "text": "// Fix windows specific problem when reading file specifications from property files.\n\t\t\t// Java property files containing backslash characters loose their backslash characters \n\t\t\t// when they are read in. \n\t\t\t// The workaround is to replace single backslash characters with double backslashes. \n\t\t\t// eg, 'c:\\tmp\\stf' from the original file is updated to 'c:\\\\tmp\\\\stf' which is read in as 'c:\\tmp\\stf'\n\t\t\tpropertyFileContents = propertyFileContents.replace(\"\\\\\", \"\\\\\\\\\");\n\n\t\t\t// Load properties from the corrected string\n\t\t\ttry {\n\t\t\t\tproperties.load(new ByteArrayInputStream(propertyFileContents.getBytes()));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Failed to load properties file: \" + propertyFileName, e);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn properties;\n\t}\n\t\n\t\n\tpublic synchronized String toString() {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tbuilder.append(\"PropertyFile: \" + sourceFileName + \"\\n\");\n\t\t\n\t\tif (!new File(sourceFileName).exists()) {\n\t\t\tbuilder.append(\"   No properties loaded. File does not exist\\n\");\n\t\t}\n\t\t\n\t\tfor (Object key : keySet()) { \n\t\t\tbuilder.append(\"  \" + key + \" = \" + super.getProperty((String) key) + \"\\n\");\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n}"
    },
    "171": {
      "metadata": {
        "chunk_id": "9d09db09635a1cf5361d2da93547b33ef76b148fe0428127da6535b84c144927",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/Stf.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.Argument.Required;\nimport net.adoptopenjdk.stf.extensions.interfaces.StfExtension;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This class runs as an extension class which is used in all STF runs, regardless of \n * the extensions which are actually used by the plugin class.\n */",
        "start_line": 0,
        "end_line": 28,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 261,
        "node_type": null,
        "file_sha": "bb6005687d7a1e1b52fe5a7982cb98a7d97338ec",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.971601"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.Argument.Required;\nimport net.adoptopenjdk.stf.extensions.interfaces.StfExtension;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This class runs as an extension class which is used in all STF runs, regardless of \n * the extensions which are actually used by the plugin class.\n */"
    },
    "172": {
      "metadata": {
        "chunk_id": "a18abd5ea8c9da258d3df6da6192161dad26edc40a170a30b1811324275d03bf",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/Stf.java",
        "content": "public class Stf implements StfExtension {\n\t//                        Java name                                                     Argument name                     Boolean          Type\n\t// Exclusively for perl layer\n\tpublic static Argument ARG_DRY_RUN                             = new Argument(\"stf\", \"dry-run\",                             true,  Required.OPTIONAL);\n\tpublic static Argument ARG_DEBUG_GENERATION                    = new Argument(\"stf\", \"debug-generation\",                    true,  Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_DEBUG_ARGS                     = new Argument(\"stf\", \"java-debug-args\",                     false, Required.MANDATORY);\n\tpublic static Argument ARG_CREATE_RESULTS_SYM_LINKS            = new Argument(\"stf\", \"create-results-sym-links\",            true,  Required.MANDATORY);\n\tpublic static Argument ARG_RM_PASS                             = new Argument(\"stf\", \"rm-pass\",                             true,  Required.OPTIONAL);\n\t// For perl and java\n\tpublic static Argument ARG_HELP                                = new Argument(\"stf\", \"help\",                                true,  Required.OPTIONAL);\n\tpublic static Argument ARG_LIST_TESTS                          = new Argument(\"stf\", \"list\",                                true,  Required.OPTIONAL);\t\n\tpublic static Argument ARG_TEST                                = new Argument(\"stf\", \"test\",                                false, Required.MANDATORY);\n\t// Exclusively for Java usage\n\tpublic static Argument ARG_TEST_ROOT                           = new Argument(\"stf\", \"test-root\",                           false, Required.OPTIONAL);\n\tpublic static Argument ARG_TEST_ARGS                           = new Argument(\"stf\", \"test-args\",                           false, Required.OPTIONAL);\n\tpublic static Argument ARG_STF_BIN_DIR                         = new Argument(\"stf\", \"stf-bin-dir\",                         false, Required.OPTIONAL);\n\tpublic static Argument ARG_SYSTEMTEST_PREREQS                  = new Argument(\"stf\", \"systemtest-prereqs\",                     false, Required.MANDATORY);\n\tpublic static Argument ARG_REPEAT_COUNT                        = new Argument(\"stf\", \"repeat\",                              false, Required.OPTIONAL);\n\tpublic static Argument ARG_VERBOSE                             = new Argument(\"stf\", \"v\",                                   true,  Required.OPTIONAL);\t\n\tpublic static Argument ARG_VERBOSE_VERBOSE                     = new Argument(\"stf\", \"vv\",                                  true,  Required.OPTIONAL);\t\n\tpublic static Argument ARG_JAVAHOME_GENERATION                 = new Argument(\"stf\", \"javahome-generation\",                 false, Required.MANDATORY);\n\tpublic static Argument ARG_JAVAHOME_SETUP                      = new Argument(\"stf\", \"javahome-setup\",                      false, Required.MANDATORY);\n\tpublic static Argument ARG_JAVAHOME_EXECUTE                    = new Argument(\"stf\", \"javahome-execute\",                    false, Required.MANDATORY);\n\tpublic static Argument ARG_JAVAHOME_EXECUTE_SECONDARY          = new Argument(\"stf\", \"javahome-execute-secondary\",          false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVAHOME_TEARDOWN                   = new Argument(\"stf\", \"javahome-teardown\",                   false, Required.MANDATORY);\n\tpublic static Argument ARG_RESULTS_ROOT                        = new Argument(\"stf\", \"results-root\",                        false, Required.MANDATORY);\n\tpublic static Argument ARG_PLATFORM                            = new Argument(\"stf\", \"platform\",                            false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS                           = new Argument(\"stf\", \"java-args\",                           false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_SETUP                     = new Argument(\"stf\", \"java-args-setup\",                     false, Required.OPTIONAL);",
        "start_line": 29,
        "end_line": 57,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 729,
        "node_type": null,
        "file_sha": "bb6005687d7a1e1b52fe5a7982cb98a7d97338ec",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.971611"
      },
      "text": "public class Stf implements StfExtension {\n\t//                        Java name                                                     Argument name                     Boolean          Type\n\t// Exclusively for perl layer\n\tpublic static Argument ARG_DRY_RUN                             = new Argument(\"stf\", \"dry-run\",                             true,  Required.OPTIONAL);\n\tpublic static Argument ARG_DEBUG_GENERATION                    = new Argument(\"stf\", \"debug-generation\",                    true,  Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_DEBUG_ARGS                     = new Argument(\"stf\", \"java-debug-args\",                     false, Required.MANDATORY);\n\tpublic static Argument ARG_CREATE_RESULTS_SYM_LINKS            = new Argument(\"stf\", \"create-results-sym-links\",            true,  Required.MANDATORY);\n\tpublic static Argument ARG_RM_PASS                             = new Argument(\"stf\", \"rm-pass\",                             true,  Required.OPTIONAL);\n\t// For perl and java\n\tpublic static Argument ARG_HELP                                = new Argument(\"stf\", \"help\",                                true,  Required.OPTIONAL);\n\tpublic static Argument ARG_LIST_TESTS                          = new Argument(\"stf\", \"list\",                                true,  Required.OPTIONAL);\t\n\tpublic static Argument ARG_TEST                                = new Argument(\"stf\", \"test\",                                false, Required.MANDATORY);\n\t// Exclusively for Java usage\n\tpublic static Argument ARG_TEST_ROOT                           = new Argument(\"stf\", \"test-root\",                           false, Required.OPTIONAL);\n\tpublic static Argument ARG_TEST_ARGS                           = new Argument(\"stf\", \"test-args\",                           false, Required.OPTIONAL);\n\tpublic static Argument ARG_STF_BIN_DIR                         = new Argument(\"stf\", \"stf-bin-dir\",                         false, Required.OPTIONAL);\n\tpublic static Argument ARG_SYSTEMTEST_PREREQS                  = new Argument(\"stf\", \"systemtest-prereqs\",                     false, Required.MANDATORY);\n\tpublic static Argument ARG_REPEAT_COUNT                        = new Argument(\"stf\", \"repeat\",                              false, Required.OPTIONAL);\n\tpublic static Argument ARG_VERBOSE                             = new Argument(\"stf\", \"v\",                                   true,  Required.OPTIONAL);\t\n\tpublic static Argument ARG_VERBOSE_VERBOSE                     = new Argument(\"stf\", \"vv\",                                  true,  Required.OPTIONAL);\t\n\tpublic static Argument ARG_JAVAHOME_GENERATION                 = new Argument(\"stf\", \"javahome-generation\",                 false, Required.MANDATORY);\n\tpublic static Argument ARG_JAVAHOME_SETUP                      = new Argument(\"stf\", \"javahome-setup\",                      false, Required.MANDATORY);\n\tpublic static Argument ARG_JAVAHOME_EXECUTE                    = new Argument(\"stf\", \"javahome-execute\",                    false, Required.MANDATORY);\n\tpublic static Argument ARG_JAVAHOME_EXECUTE_SECONDARY          = new Argument(\"stf\", \"javahome-execute-secondary\",          false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVAHOME_TEARDOWN                   = new Argument(\"stf\", \"javahome-teardown\",                   false, Required.MANDATORY);\n\tpublic static Argument ARG_RESULTS_ROOT                        = new Argument(\"stf\", \"results-root\",                        false, Required.MANDATORY);\n\tpublic static Argument ARG_PLATFORM                            = new Argument(\"stf\", \"platform\",                            false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS                           = new Argument(\"stf\", \"java-args\",                           false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_SETUP                     = new Argument(\"stf\", \"java-args-setup\",                     false, Required.OPTIONAL);"
    },
    "173": {
      "metadata": {
        "chunk_id": "e90f6941beeca40f21947a47b75f67d36888eaa9e98dfe34166c221b8b9cabb4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/Stf.java",
        "content": "public static Argument ARG_JAVAHOME_TEARDOWN                   = new Argument(\"stf\", \"javahome-teardown\",                   false, Required.MANDATORY);\n\tpublic static Argument ARG_RESULTS_ROOT                        = new Argument(\"stf\", \"results-root\",                        false, Required.MANDATORY);\n\tpublic static Argument ARG_PLATFORM                            = new Argument(\"stf\", \"platform\",                            false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS                           = new Argument(\"stf\", \"java-args\",                           false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_SETUP                     = new Argument(\"stf\", \"java-args-setup\",                     false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_INITIAL           = new Argument(\"stf\", \"java-args-execute-initial\",           false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE                   = new Argument(\"stf\", \"java-args-execute\",                   false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_COMMENT           = new Argument(\"stf\", \"java-args-execute-comment\",           false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL = new Argument(\"stf\", \"java-args-execute-secondary-initial\", false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_SECONDARY         = new Argument(\"stf\", \"java-args-execute-secondary\",         false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_SECONDARY_COMMENT = new Argument(\"stf\", \"java-args-execute-secondary-comment\", false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_TEARDOWN                  = new Argument(\"stf\", \"java-args-teardown\",                  false, Required.OPTIONAL);\n\t// Stf doesn't use these but since the perl layer requires defaults\n\t// in the properties file they get set, so need to tolerate them\n\t// To avoid confusion these aren't listed in the help output\n\tpublic static Argument ARG_RETAIN                              = new Argument(\"stf\", \"retain\",                              false, Required.OPTIONAL);\n\tpublic static Argument ARG_RETAIN_LIMIT                        = new Argument(\"stf\", \"retain-limit\",                        false, Required.OPTIONAL);\n\t\n\t@Override\n\tpublic Argument[] getSupportedArguments() {\n\t\treturn new Argument[] {\n\t\t\tARG_DRY_RUN,\n\t\t\tARG_DEBUG_GENERATION,\n\t\t\tARG_JAVA_DEBUG_ARGS,\n\t\t\tARG_CREATE_RESULTS_SYM_LINKS,\n\t\t\tARG_RM_PASS,\n\t\t\tARG_TEST_ROOT,\n\t\t\tARG_HELP,\n\t\t\tARG_LIST_TESTS,\n\t\t\tARG_TEST,                 \n\t\t\tARG_TEST_ARGS,            \n\t\t\tARG_STF_BIN_DIR,\n\t\t\tARG_SYSTEMTEST_PREREQS,\n\t\t\tARG_REPEAT_COUNT,\n\t\t\tARG_VERBOSE,\n\t\t\tARG_VERBOSE_VERBOSE,\n\t\t\tARG_JAVAHOME_GENERATION,\n\t\t\tARG_JAVAHOME_SETUP,\n\t\t\tARG_JAVAHOME_EXECUTE,\n\t\t\tARG_JAVAHOME_EXECUTE_SECONDARY,\n\t\t\tARG_JAVAHOME_TEARDOWN,\n\t\t\tARG_RESULTS_ROOT,\n\t\t\tARG_PLATFORM,\n\t\t\tARG_JAVA_ARGS,\n\t\t\tARG_JAVA_ARGS_SETUP,\n\t\t\tARG_JAVA_ARGS_EXECUTE_INITIAL,\n\t\t\tARG_JAVA_ARGS_EXECUTE,\n\t\t\tARG_JAVA_ARGS_EXECUTE_COMMENT,\n\t\t\tARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL,\n\t\t\tARG_JAVA_ARGS_EXECUTE_SECONDARY,\n\t\t\tARG_JAVA_ARGS_EXECUTE_SECONDARY_COMMENT,\n\t\t\tARG_JAVA_ARGS_TEARDOWN,\n\t\t\tARG_RETAIN,\n\t\t\tARG_RETAIN_LIMIT\n\t\t};\n\t}",
        "start_line": 58,
        "end_line": 113,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 747,
        "node_type": null,
        "file_sha": "bb6005687d7a1e1b52fe5a7982cb98a7d97338ec",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.971614"
      },
      "text": "public static Argument ARG_JAVAHOME_TEARDOWN                   = new Argument(\"stf\", \"javahome-teardown\",                   false, Required.MANDATORY);\n\tpublic static Argument ARG_RESULTS_ROOT                        = new Argument(\"stf\", \"results-root\",                        false, Required.MANDATORY);\n\tpublic static Argument ARG_PLATFORM                            = new Argument(\"stf\", \"platform\",                            false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS                           = new Argument(\"stf\", \"java-args\",                           false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_SETUP                     = new Argument(\"stf\", \"java-args-setup\",                     false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_INITIAL           = new Argument(\"stf\", \"java-args-execute-initial\",           false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE                   = new Argument(\"stf\", \"java-args-execute\",                   false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_COMMENT           = new Argument(\"stf\", \"java-args-execute-comment\",           false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL = new Argument(\"stf\", \"java-args-execute-secondary-initial\", false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_SECONDARY         = new Argument(\"stf\", \"java-args-execute-secondary\",         false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_EXECUTE_SECONDARY_COMMENT = new Argument(\"stf\", \"java-args-execute-secondary-comment\", false, Required.OPTIONAL);\n\tpublic static Argument ARG_JAVA_ARGS_TEARDOWN                  = new Argument(\"stf\", \"java-args-teardown\",                  false, Required.OPTIONAL);\n\t// Stf doesn't use these but since the perl layer requires defaults\n\t// in the properties file they get set, so need to tolerate them\n\t// To avoid confusion these aren't listed in the help output\n\tpublic static Argument ARG_RETAIN                              = new Argument(\"stf\", \"retain\",                              false, Required.OPTIONAL);\n\tpublic static Argument ARG_RETAIN_LIMIT                        = new Argument(\"stf\", \"retain-limit\",                        false, Required.OPTIONAL);\n\t\n\t@Override\n\tpublic Argument[] getSupportedArguments() {\n\t\treturn new Argument[] {\n\t\t\tARG_DRY_RUN,\n\t\t\tARG_DEBUG_GENERATION,\n\t\t\tARG_JAVA_DEBUG_ARGS,\n\t\t\tARG_CREATE_RESULTS_SYM_LINKS,\n\t\t\tARG_RM_PASS,\n\t\t\tARG_TEST_ROOT,\n\t\t\tARG_HELP,\n\t\t\tARG_LIST_TESTS,\n\t\t\tARG_TEST,                 \n\t\t\tARG_TEST_ARGS,            \n\t\t\tARG_STF_BIN_DIR,\n\t\t\tARG_SYSTEMTEST_PREREQS,\n\t\t\tARG_REPEAT_COUNT,\n\t\t\tARG_VERBOSE,\n\t\t\tARG_VERBOSE_VERBOSE,\n\t\t\tARG_JAVAHOME_GENERATION,\n\t\t\tARG_JAVAHOME_SETUP,\n\t\t\tARG_JAVAHOME_EXECUTE,\n\t\t\tARG_JAVAHOME_EXECUTE_SECONDARY,\n\t\t\tARG_JAVAHOME_TEARDOWN,\n\t\t\tARG_RESULTS_ROOT,\n\t\t\tARG_PLATFORM,\n\t\t\tARG_JAVA_ARGS,\n\t\t\tARG_JAVA_ARGS_SETUP,\n\t\t\tARG_JAVA_ARGS_EXECUTE_INITIAL,\n\t\t\tARG_JAVA_ARGS_EXECUTE,\n\t\t\tARG_JAVA_ARGS_EXECUTE_COMMENT,\n\t\t\tARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL,\n\t\t\tARG_JAVA_ARGS_EXECUTE_SECONDARY,\n\t\t\tARG_JAVA_ARGS_EXECUTE_SECONDARY_COMMENT,\n\t\t\tARG_JAVA_ARGS_TEARDOWN,\n\t\t\tARG_RETAIN,\n\t\t\tARG_RETAIN_LIMIT\n\t\t};\n\t}"
    },
    "174": {
      "metadata": {
        "chunk_id": "9e0b617e3dedc94877fec437ae040f582da7ea4836ab0bf02d7c0446fc99f59b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/Stf.java",
        "content": "@Override\n\tpublic void help(HelpTextGenerator help) {\n\t\thelp.outputSection(\"Stf extension options\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_TEST.getName(), \"NAME\");\n\t\thelp.outputArgDesc(\"This is the name of the test plugin to run. Stf runs a Java class \"\n\t\t\t\t    + \"matching this name which also implements an interface which ultimately \"\n\t\t\t\t    + \"implements StfPluginRootInterface.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_TEST_ROOT.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This mandatory argument points at one or more directories containing test cases, including \"\n\t\t\t\t    + \"the primary STF workspace, and seperated by semicolons. It should be set to point to one or more \"\n\t\t\t\t    + \"Eclipse workspaces, or the equivilent directory in the build output (ie. the directory that \"\n\t\t\t\t    + \"contains the project directories, which in turn hold the test case class files).\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_TEST_ARGS.getName(), \"VALUES\");\n\t\thelp.outputArgDesc(\"This optional argument allows test specific information to be supplied \"\n\t\t\t\t\t+ \"to a test plugin. It is formatted as one or more comma separated name/value pairs. \"\n\t\t\t\t\t+ \"For example '-test-args=\\\"suite=suite1, timeout=30m\\\"'.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_SYSTEMTEST_PREREQS.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"Points to the location of the mandatory jars, test material, etc.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_REPEAT_COUNT.getName());\n\t\thelp.outputArgDesc(\"This is the number of times that the test plugins execute method is called. \"\n\t\t\t\t\t+ \"Defaults to a value of 1.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_DRY_RUN.getName());\n\t\thelp.outputArgDesc(\"Generates the setup, execute and teardown scripts, but does not execute them. \"\n\t\t\t\t         + \"The commands needed for manual execution are listed.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_HELP.getName());\n\t\thelp.outputArgDesc(\"Produces help text. It lists the options supported by each extension used by the test plugin. \"\n                         + \"Note that because tests are free to use different extensions, so the actual \"\n                         + \"options available may vary between tests.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_LIST_TESTS.getName());\n\t\thelp.outputArgDesc(\"Searches the workspace for all test cases, which are then listed in project order.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_DEBUG_GENERATION.getName());\n\t\thelp.outputArgDesc(\"Setting this argument allows for the debugging on a test plugin. If set then \"\n\t\t\t\t+ \"debug arguments are added to the command used to run the Stf Java process.\");\n\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments to be used for Java processes run in the execute stage.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_SETUP.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments used by Java processes in the setup stage.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_INITIAL.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"This argument can supply JVM arguments for the unusual case in \"\n\t\t\t\t+ \"which the arguments need to appear before any JVM arguments that the testcase specifies. \"\n\t\t\t\t+ \"Only used in the exceute stage.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments used by Java processes in the execute stage. \"\n\t\t\t\t+ \"The arguments appear after those specified by the testcase. \"\n\t\t\t\t+ \"Default behaviour is to use the value of '-\" + ARG_JAVA_ARGS.getName() + \"'.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"As per the '-\" + ARG_JAVA_ARGS_EXECUTE_INITIAL.getName() +\"' argument, but for the secondary JVM.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_SECONDARY.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"As per the '-\" + ARG_JAVA_ARGS_EXECUTE.getName() +\"' argument, but for the secondary JVM.\");",
        "start_line": 114,
        "end_line": 177,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 905,
        "node_type": null,
        "file_sha": "bb6005687d7a1e1b52fe5a7982cb98a7d97338ec",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.971617"
      },
      "text": "@Override\n\tpublic void help(HelpTextGenerator help) {\n\t\thelp.outputSection(\"Stf extension options\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_TEST.getName(), \"NAME\");\n\t\thelp.outputArgDesc(\"This is the name of the test plugin to run. Stf runs a Java class \"\n\t\t\t\t    + \"matching this name which also implements an interface which ultimately \"\n\t\t\t\t    + \"implements StfPluginRootInterface.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_TEST_ROOT.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This mandatory argument points at one or more directories containing test cases, including \"\n\t\t\t\t    + \"the primary STF workspace, and seperated by semicolons. It should be set to point to one or more \"\n\t\t\t\t    + \"Eclipse workspaces, or the equivilent directory in the build output (ie. the directory that \"\n\t\t\t\t    + \"contains the project directories, which in turn hold the test case class files).\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_TEST_ARGS.getName(), \"VALUES\");\n\t\thelp.outputArgDesc(\"This optional argument allows test specific information to be supplied \"\n\t\t\t\t\t+ \"to a test plugin. It is formatted as one or more comma separated name/value pairs. \"\n\t\t\t\t\t+ \"For example '-test-args=\\\"suite=suite1, timeout=30m\\\"'.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_SYSTEMTEST_PREREQS.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"Points to the location of the mandatory jars, test material, etc.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_REPEAT_COUNT.getName());\n\t\thelp.outputArgDesc(\"This is the number of times that the test plugins execute method is called. \"\n\t\t\t\t\t+ \"Defaults to a value of 1.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_DRY_RUN.getName());\n\t\thelp.outputArgDesc(\"Generates the setup, execute and teardown scripts, but does not execute them. \"\n\t\t\t\t         + \"The commands needed for manual execution are listed.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_HELP.getName());\n\t\thelp.outputArgDesc(\"Produces help text. It lists the options supported by each extension used by the test plugin. \"\n                         + \"Note that because tests are free to use different extensions, so the actual \"\n                         + \"options available may vary between tests.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_LIST_TESTS.getName());\n\t\thelp.outputArgDesc(\"Searches the workspace for all test cases, which are then listed in project order.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_DEBUG_GENERATION.getName());\n\t\thelp.outputArgDesc(\"Setting this argument allows for the debugging on a test plugin. If set then \"\n\t\t\t\t+ \"debug arguments are added to the command used to run the Stf Java process.\");\n\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments to be used for Java processes run in the execute stage.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_SETUP.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments used by Java processes in the setup stage.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_INITIAL.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"This argument can supply JVM arguments for the unusual case in \"\n\t\t\t\t+ \"which the arguments need to appear before any JVM arguments that the testcase specifies. \"\n\t\t\t\t+ \"Only used in the exceute stage.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments used by Java processes in the execute stage. \"\n\t\t\t\t+ \"The arguments appear after those specified by the testcase. \"\n\t\t\t\t+ \"Default behaviour is to use the value of '-\" + ARG_JAVA_ARGS.getName() + \"'.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"As per the '-\" + ARG_JAVA_ARGS_EXECUTE_INITIAL.getName() +\"' argument, but for the secondary JVM.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_SECONDARY.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"As per the '-\" + ARG_JAVA_ARGS_EXECUTE.getName() +\"' argument, but for the secondary JVM.\");"
    },
    "175": {
      "metadata": {
        "chunk_id": "f139844df1623f998e3cb794ef67bf9034224d9fcfe013755f7921b28e46ca6a",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/Stf.java",
        "content": "help.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments used by Java processes in the execute stage. \"\n\t\t\t\t+ \"The arguments appear after those specified by the testcase. \"\n\t\t\t\t+ \"Default behaviour is to use the value of '-\" + ARG_JAVA_ARGS.getName() + \"'.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"As per the '-\" + ARG_JAVA_ARGS_EXECUTE_INITIAL.getName() +\"' argument, but for the secondary JVM.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_SECONDARY.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"As per the '-\" + ARG_JAVA_ARGS_EXECUTE.getName() +\"' argument, but for the secondary JVM.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_TEARDOWN.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments used by Java processes in the teardown stage.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_DEBUG_ARGS.getName(), \"JAVA-DEBUG-ARGS\");\n\t\thelp.outputArgDesc(\"This contains the debugging options to allow a java debugger to connect to \"\n\t\t\t\t+ \"the Stf generator program. The current default is set to '-Xdebug -Xrunjdwp:transport=dt_socket,address=8999,server=y,suspend=y'.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_GENERATION.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This JVM will be used during the perl generation stage.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_SETUP.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This JVM will be used by the generated setup script.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_EXECUTE.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This JVM will be used by the generated execute script.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_EXECUTE_SECONDARY.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"Points at a second JVM, for tests which want to run with 2 different versions of Java.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_TEARDOWN.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This JVM will be used by the generated teardown script.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_RESULTS_ROOT.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This is a directory points to the results directory and is set by the stf.pl script.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_PLATFORM.getName(), \"NAME\");\n\t\thelp.outputArgDesc(\"The name of the platform is usually calculated by examining the Java \"\n\t\t\t\t+ \"properties, but for testing purposes another value can be supplied. The \"\n\t\t\t\t+ \"platform name should be in the form '<os-name>_<architecture>-<wordsize>', eg, linux_x86-64\");\n\n\t\thelp.outputArgName(\"-\" + ARG_VERBOSE.getName());\n\t\thelp.outputArgDesc(\"Enables verbose output. Produces a summary of STF internal activity.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_VERBOSE_VERBOSE.getName());\n\t\thelp.outputArgDesc(\"Enables super-verbose output. Produces detailed information \"\n\t\t\t\t+ \"about what STF is doing. This is usually only used for STF debugging.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_CREATE_RESULTS_SYM_LINKS.getName());\n\t\thelp.outputArgDesc(\"If set to true then stf.pl creates a symbolic link to the latest set of results, \"\n\t\t\t\t+ \"eg, /tmp/stf/UtilLoadTest -> /tmp/stf/20161107-134621-UtilLoadTest. \" \n\t\t\t\t+ \"This is can be useful when repeatedly running the same test as the result/tmp files will \"\n\t\t\t\t+ \"always be at the same location.\\n\"\n\t\t\t\t+ \"Only supported on systems which support symbolic links.\\n\"\n\t\t\t\t+ \"Disabled by default to prevent.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_RM_PASS.getName());\n\t\thelp.outputArgDesc(\"If set to true (or just passed as a flag) then stf.pl deletes the results directory if the test passes.\"\n\t\t\t\t+ \"Disabled by default.\");\n\t}\n\n\t@Override\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t}\n}",
        "start_line": 178,
        "end_line": 242,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 932,
        "node_type": null,
        "file_sha": "bb6005687d7a1e1b52fe5a7982cb98a7d97338ec",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.971621"
      },
      "text": "help.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments used by Java processes in the execute stage. \"\n\t\t\t\t+ \"The arguments appear after those specified by the testcase. \"\n\t\t\t\t+ \"Default behaviour is to use the value of '-\" + ARG_JAVA_ARGS.getName() + \"'.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_SECONDARY_INITIAL.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"As per the '-\" + ARG_JAVA_ARGS_EXECUTE_INITIAL.getName() +\"' argument, but for the secondary JVM.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_EXECUTE_SECONDARY.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"As per the '-\" + ARG_JAVA_ARGS_EXECUTE.getName() +\"' argument, but for the secondary JVM.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_ARGS_TEARDOWN.getName(), \"JAVA-ARGS\");\n\t\thelp.outputArgDesc(\"Set Java arguments used by Java processes in the teardown stage.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVA_DEBUG_ARGS.getName(), \"JAVA-DEBUG-ARGS\");\n\t\thelp.outputArgDesc(\"This contains the debugging options to allow a java debugger to connect to \"\n\t\t\t\t+ \"the Stf generator program. The current default is set to '-Xdebug -Xrunjdwp:transport=dt_socket,address=8999,server=y,suspend=y'.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_GENERATION.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This JVM will be used during the perl generation stage.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_SETUP.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This JVM will be used by the generated setup script.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_EXECUTE.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This JVM will be used by the generated execute script.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_EXECUTE_SECONDARY.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"Points at a second JVM, for tests which want to run with 2 different versions of Java.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JAVAHOME_TEARDOWN.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This JVM will be used by the generated teardown script.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_RESULTS_ROOT.getName(), \"DIRECTORY\");\n\t\thelp.outputArgDesc(\"This is a directory points to the results directory and is set by the stf.pl script.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_PLATFORM.getName(), \"NAME\");\n\t\thelp.outputArgDesc(\"The name of the platform is usually calculated by examining the Java \"\n\t\t\t\t+ \"properties, but for testing purposes another value can be supplied. The \"\n\t\t\t\t+ \"platform name should be in the form '<os-name>_<architecture>-<wordsize>', eg, linux_x86-64\");\n\n\t\thelp.outputArgName(\"-\" + ARG_VERBOSE.getName());\n\t\thelp.outputArgDesc(\"Enables verbose output. Produces a summary of STF internal activity.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_VERBOSE_VERBOSE.getName());\n\t\thelp.outputArgDesc(\"Enables super-verbose output. Produces detailed information \"\n\t\t\t\t+ \"about what STF is doing. This is usually only used for STF debugging.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_CREATE_RESULTS_SYM_LINKS.getName());\n\t\thelp.outputArgDesc(\"If set to true then stf.pl creates a symbolic link to the latest set of results, \"\n\t\t\t\t+ \"eg, /tmp/stf/UtilLoadTest -> /tmp/stf/20161107-134621-UtilLoadTest. \" \n\t\t\t\t+ \"This is can be useful when repeatedly running the same test as the result/tmp files will \"\n\t\t\t\t+ \"always be at the same location.\\n\"\n\t\t\t\t+ \"Only supported on systems which support symbolic links.\\n\"\n\t\t\t\t+ \"Disabled by default to prevent.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_RM_PASS.getName());\n\t\thelp.outputArgDesc(\"If set to true (or just passed as a flag) then stf.pl deletes the results directory if the test passes.\"\n\t\t\t\t+ \"Disabled by default.\");\n\t}\n\n\t@Override\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t}\n}"
    },
    "176": {
      "metadata": {
        "chunk_id": "e8d0bb3255ba8aeba00f07a172eec5408938bc2677462b47fc30d769a5c8adb1",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/StfExtensionBase.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.StfExitCodes;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator.CommandDetails;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome.OutcomeType;\nimport net.adoptopenjdk.stf.processes.definitions.ProcessDefinition;\n\n\n/**\n * This class sits between the extension classes and the perl code generator.\n * Its responsibilities are:\n *   - keep track of running processes (regardless of which extension started them)\n *   - generate full list of processes for a die command (again regardless of particular extension)\n *   - holds code usable by multiple extensions.\n *   - reduces the work required by an extension to implement a 'do' operation.\n *   \n * At runtime there is a single instance of this class which is shared between all extensions.\n */",
        "start_line": 0,
        "end_line": 41,
        "chunk_index": 0,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 407,
        "node_type": null,
        "file_sha": "21710f29829cf0281075139ed1e59b37e40d9175",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.982041"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.StfExitCodes;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator.CommandDetails;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome.OutcomeType;\nimport net.adoptopenjdk.stf.processes.definitions.ProcessDefinition;\n\n\n/**\n * This class sits between the extension classes and the perl code generator.\n * Its responsibilities are:\n *   - keep track of running processes (regardless of which extension started them)\n *   - generate full list of processes for a die command (again regardless of particular extension)\n *   - holds code usable by multiple extensions.\n *   - reduces the work required by an extension to implement a 'do' operation.\n *   \n * At runtime there is a single instance of this class which is shared between all extensions.\n */"
    },
    "177": {
      "metadata": {
        "chunk_id": "7ae6ea303621a66bdc06a8e26eddacee438b5c9916755c2306ce1d32d15005d9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/StfExtensionBase.java",
        "content": "public class StfExtensionBase {\n\tprivate StfEnvironmentCore environmentCore;\n\tprivate PerlCodeGenerator generator;\n\t\n\tprivate ArrayList<StfProcess> childProcesses = new ArrayList<StfProcess>();\n\t\n\t\n\tpublic StfExtensionBase(StfEnvironmentCore environmentCore, PerlCodeGenerator generator) {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.generator = generator;\n\t}\n\t\n\t\n\t/**\n\t * Adds a block of perl which makes sure that a perl variable is has the expected value.\n\t * If the condition is true then an error message is produced and the process aborts.\n\t * \n\t * @param command is a short description of the command for which code is being generated.\n\t * @param comment is a description from the test plugin describing why the current command is being run.\n\t * @param resultVariable is the perl variable whose result is being checked.\n\t * @param operator is the comparison operator used to compare the resultVariable with the successValue \n\t * @param successValue contains the values which resultVariable can contain for a successful execution.\n\t * @throws StfException if we fail to write to the output file.\n\t */\n\tpublic void outputFailIfTrue(String command, String comment, String resultVariable, String operator, StfExitCodes successValues) throws StfException {\n\t\tList<Integer> successExitCodes = successValues.getAllowableExitCodes();\n\t\tif (successExitCodes.size() != 1) {\n\t\t\tthrow new StfException(\"successValues should only contain a single exit code value: \" + successValues.toString());\n\t\t}\n\t\t\n\t\tString resultValue = successExitCodes.get(0).toString();\n\t\tgenerator.outputFailIfTrue(command, comment, resultVariable, operator, resultValue, null, getRunningProcesses());\n\t}\n\n\t/**\n\t * Variant of outputFailIfTrue which allows the caller to specify some extra\n\t * lines of perl for the body of the if statement. \n\t * These lines are supplied in the 'extraErrorLines' argument.\n\t */\n\tpublic void outputFailIfTrue(String command, String comment, \n\t\t\tString resultVariable, String operator, String resultValue, \n\t\t\tArrayList<String> extraErrorLines) throws StfException {\n\t\tgenerator.outputFailIfTrue(command, comment, resultVariable, operator, resultValue, extraErrorLines, getRunningProcesses());\n\t}\n\t \n\t/**\n\t * Convenience method of outputFailIfTrue() which takes an int resultValue.\n\t */\n\tpublic void outputFailIfTrue(String command, String comment, String resultVariable, String operator, int resultValue) throws StfException {\n\t\tString resultValueAsStr = Integer.toString(resultValue);\n\t\tgenerator.outputFailIfTrue(command, comment, resultVariable, operator, resultValueAsStr, null, getRunningProcesses());\n\t}\n\n\n\t/**\n\t * Adds a block of perl which makes sure that a perl variable is set to '0'.\n\t * If the perl variable has a different value then an error message is produced and the \n\t * process aborts.\n\t * \n\t * @param command is a short description of the command for which code is being generated.\n\t * @param comment is a description from the test plugin describing why the current command is being run.\n\t * @param resultVariable is the perl variable whose result is being checked.\n\t * @throws StfException if 'resultVariable' is not a valid perl variable name or if we fail to write to the output file.\n\t */\n\tpublic void outputErrorCheck(String command, String comment, String resultVariable) throws StfException {\n\t\tgenerator.outputErrorCheck(command, comment, resultVariable, getRunningProcesses());\n    }",
        "start_line": 42,
        "end_line": 108,
        "chunk_index": 1,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 749,
        "node_type": null,
        "file_sha": "21710f29829cf0281075139ed1e59b37e40d9175",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.982049"
      },
      "text": "public class StfExtensionBase {\n\tprivate StfEnvironmentCore environmentCore;\n\tprivate PerlCodeGenerator generator;\n\t\n\tprivate ArrayList<StfProcess> childProcesses = new ArrayList<StfProcess>();\n\t\n\t\n\tpublic StfExtensionBase(StfEnvironmentCore environmentCore, PerlCodeGenerator generator) {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.generator = generator;\n\t}\n\t\n\t\n\t/**\n\t * Adds a block of perl which makes sure that a perl variable is has the expected value.\n\t * If the condition is true then an error message is produced and the process aborts.\n\t * \n\t * @param command is a short description of the command for which code is being generated.\n\t * @param comment is a description from the test plugin describing why the current command is being run.\n\t * @param resultVariable is the perl variable whose result is being checked.\n\t * @param operator is the comparison operator used to compare the resultVariable with the successValue \n\t * @param successValue contains the values which resultVariable can contain for a successful execution.\n\t * @throws StfException if we fail to write to the output file.\n\t */\n\tpublic void outputFailIfTrue(String command, String comment, String resultVariable, String operator, StfExitCodes successValues) throws StfException {\n\t\tList<Integer> successExitCodes = successValues.getAllowableExitCodes();\n\t\tif (successExitCodes.size() != 1) {\n\t\t\tthrow new StfException(\"successValues should only contain a single exit code value: \" + successValues.toString());\n\t\t}\n\t\t\n\t\tString resultValue = successExitCodes.get(0).toString();\n\t\tgenerator.outputFailIfTrue(command, comment, resultVariable, operator, resultValue, null, getRunningProcesses());\n\t}\n\n\t/**\n\t * Variant of outputFailIfTrue which allows the caller to specify some extra\n\t * lines of perl for the body of the if statement. \n\t * These lines are supplied in the 'extraErrorLines' argument.\n\t */\n\tpublic void outputFailIfTrue(String command, String comment, \n\t\t\tString resultVariable, String operator, String resultValue, \n\t\t\tArrayList<String> extraErrorLines) throws StfException {\n\t\tgenerator.outputFailIfTrue(command, comment, resultVariable, operator, resultValue, extraErrorLines, getRunningProcesses());\n\t}\n\t \n\t/**\n\t * Convenience method of outputFailIfTrue() which takes an int resultValue.\n\t */\n\tpublic void outputFailIfTrue(String command, String comment, String resultVariable, String operator, int resultValue) throws StfException {\n\t\tString resultValueAsStr = Integer.toString(resultValue);\n\t\tgenerator.outputFailIfTrue(command, comment, resultVariable, operator, resultValueAsStr, null, getRunningProcesses());\n\t}\n\n\n\t/**\n\t * Adds a block of perl which makes sure that a perl variable is set to '0'.\n\t * If the perl variable has a different value then an error message is produced and the \n\t * process aborts.\n\t * \n\t * @param command is a short description of the command for which code is being generated.\n\t * @param comment is a description from the test plugin describing why the current command is being run.\n\t * @param resultVariable is the perl variable whose result is being checked.\n\t * @throws StfException if 'resultVariable' is not a valid perl variable name or if we fail to write to the output file.\n\t */\n\tpublic void outputErrorCheck(String command, String comment, String resultVariable) throws StfException {\n\t\tgenerator.outputErrorCheck(command, comment, resultVariable, getRunningProcesses());\n    }"
    },
    "178": {
      "metadata": {
        "chunk_id": "e2875ad3ea4452e83633243a67c8308d974adc521780206f841a3edc9cb1db65",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/StfExtensionBase.java",
        "content": "/**\n\t * Adds a block of perl code which scans a log file and counts the number of matches for supplied strings. \n\t * \n\t * It does this by creating a while loop which opens a log and does a regex match on each line.\n\t * If a match is found the count variable is incremented, this method also supports multiple expected messages and\n\t * builds the if statement arguments accordingly.\n\t * \n\t * @param resultVariable is the perl variable which holds the match count. eg, '$error_count'\n\t * @param log is the log file whose output is scanned.\n\t * @param expectedResultMessages contains the message/s that the log file is expected to contain.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void outputCountFileMatches(String resultVariable, FileRef log, String... expectedResultMessages) throws StfException {\n\t\tgenerator.outputCountFileMatches(resultVariable, log, getRunningProcesses(), expectedResultMessages);\n\t}\n\n\t\n\t/**\n\t * Adds a block of perl code to echo the contents of a file.\n\t */\n\tpublic void outputEchoFile(FileRef targetFile) throws StfException {\n\t\tgenerator.outputEchoFile(targetFile, getRunningProcesses());\n\t}\n\t\n\t\n\t/**\n\t * Outputs a perl die command which will kill all processes that may be running at the current time.\n\t * @param dieMessage is a string describing the reason for generating the die command.\n\t */\n\tpublic void outputDieCommand(String dieMessage) throws StfException {\n\t\tgenerator.outputDieCommand(getRunningProcesses(), dieMessage);\n\t}\n\n\n\t/*\n\t * Returns an ArrayList containing references to all processes which may currently be running.\n\t * \n\t * If a process has been killed then it is not returned as it must have been terminated.\n\t * A process which has been through a monitor step, and is due to complete with an exit \n\t * code or crash is not returned as it must have completed.\n\t * \n\t * In all other cases the process _may_ still be running and therefore needs to be killed.\n\t * The perl layer kill command is tolerant of being asked to kill a process which is not \n\t * running. It needs to be tolerant as the process may of course have completed at any time\n\t * between the last monitor command and the current point in time. \n\t */\n\tprivate ArrayList<StfProcess> getRunningProcesses() {\n\t\tArrayList<StfProcess> runningProcesses = new ArrayList<StfProcess>();\n\t\tfor (StfProcess p : childProcesses) {\n\t\t\tif (p.isRunning()) {\n\t\t\t\trunningProcesses.add(p);\n\t\t\t}\n\t\t}\n\t\treturn runningProcesses;\n\t}\n\n\t\n\t/**\n\t * Generates perl code for synchronously running a single process.\n\t */\n\tpublic StfProcess runForegroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tStfProcess[] processes = generateProcessExecute(comment, processMnemonic, 1, echoSetting, \"run_process\", false, expectedOutcome, processDetails);\n\t\treturn processes[0];\n\t}\n\n\n\t/**\n\t * Generates perl code for synchronously running multiple processes.\n\t */\n\tpublic StfProcess[] runForegroundProcesses(String comment, String processMnemonic, int numInstances, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tif (numInstances <= 1) {\n\t\t\tthrow new StfException(\"Invalid number of concurrent process instances '\" + numInstances + \"'. \"\n\t\t\t\t\t+ \"To run a single process call doRunForegroundProcess()\");\n\t\t}\n\t\t\n\t\treturn generateProcessExecute(comment, processMnemonic, numInstances, echoSetting, \"run_processes\", false, expectedOutcome, processDetails);\n\t}\n\n\n\t/**\n\t * Generates perl code to start a single process.\n\t */\n\tpublic StfProcess runBackgroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tStfProcess[] processes = generateProcessExecute(comment, processMnemonic, 1, echoSetting, \"start_process\", true, expectedOutcome, processDetails);\n\t\treturn processes[0];\n\t}",
        "start_line": 109,
        "end_line": 194,
        "chunk_index": 2,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 872,
        "node_type": null,
        "file_sha": "21710f29829cf0281075139ed1e59b37e40d9175",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.982051"
      },
      "text": "/**\n\t * Adds a block of perl code which scans a log file and counts the number of matches for supplied strings. \n\t * \n\t * It does this by creating a while loop which opens a log and does a regex match on each line.\n\t * If a match is found the count variable is incremented, this method also supports multiple expected messages and\n\t * builds the if statement arguments accordingly.\n\t * \n\t * @param resultVariable is the perl variable which holds the match count. eg, '$error_count'\n\t * @param log is the log file whose output is scanned.\n\t * @param expectedResultMessages contains the message/s that the log file is expected to contain.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void outputCountFileMatches(String resultVariable, FileRef log, String... expectedResultMessages) throws StfException {\n\t\tgenerator.outputCountFileMatches(resultVariable, log, getRunningProcesses(), expectedResultMessages);\n\t}\n\n\t\n\t/**\n\t * Adds a block of perl code to echo the contents of a file.\n\t */\n\tpublic void outputEchoFile(FileRef targetFile) throws StfException {\n\t\tgenerator.outputEchoFile(targetFile, getRunningProcesses());\n\t}\n\t\n\t\n\t/**\n\t * Outputs a perl die command which will kill all processes that may be running at the current time.\n\t * @param dieMessage is a string describing the reason for generating the die command.\n\t */\n\tpublic void outputDieCommand(String dieMessage) throws StfException {\n\t\tgenerator.outputDieCommand(getRunningProcesses(), dieMessage);\n\t}\n\n\n\t/*\n\t * Returns an ArrayList containing references to all processes which may currently be running.\n\t * \n\t * If a process has been killed then it is not returned as it must have been terminated.\n\t * A process which has been through a monitor step, and is due to complete with an exit \n\t * code or crash is not returned as it must have completed.\n\t * \n\t * In all other cases the process _may_ still be running and therefore needs to be killed.\n\t * The perl layer kill command is tolerant of being asked to kill a process which is not \n\t * running. It needs to be tolerant as the process may of course have completed at any time\n\t * between the last monitor command and the current point in time. \n\t */\n\tprivate ArrayList<StfProcess> getRunningProcesses() {\n\t\tArrayList<StfProcess> runningProcesses = new ArrayList<StfProcess>();\n\t\tfor (StfProcess p : childProcesses) {\n\t\t\tif (p.isRunning()) {\n\t\t\t\trunningProcesses.add(p);\n\t\t\t}\n\t\t}\n\t\treturn runningProcesses;\n\t}\n\n\t\n\t/**\n\t * Generates perl code for synchronously running a single process.\n\t */\n\tpublic StfProcess runForegroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tStfProcess[] processes = generateProcessExecute(comment, processMnemonic, 1, echoSetting, \"run_process\", false, expectedOutcome, processDetails);\n\t\treturn processes[0];\n\t}\n\n\n\t/**\n\t * Generates perl code for synchronously running multiple processes.\n\t */\n\tpublic StfProcess[] runForegroundProcesses(String comment, String processMnemonic, int numInstances, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tif (numInstances <= 1) {\n\t\t\tthrow new StfException(\"Invalid number of concurrent process instances '\" + numInstances + \"'. \"\n\t\t\t\t\t+ \"To run a single process call doRunForegroundProcess()\");\n\t\t}\n\t\t\n\t\treturn generateProcessExecute(comment, processMnemonic, numInstances, echoSetting, \"run_processes\", false, expectedOutcome, processDetails);\n\t}\n\n\n\t/**\n\t * Generates perl code to start a single process.\n\t */\n\tpublic StfProcess runBackgroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tStfProcess[] processes = generateProcessExecute(comment, processMnemonic, 1, echoSetting, \"start_process\", true, expectedOutcome, processDetails);\n\t\treturn processes[0];\n\t}"
    },
    "179": {
      "metadata": {
        "chunk_id": "e41c5def72d09e01c3589af5317b354a5843a075fa8f630686ffb7bde40c85c7",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/StfExtensionBase.java",
        "content": "/**\n\t * Generates perl code to start a single process.\n\t */\n\tpublic StfProcess runBackgroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tStfProcess[] processes = generateProcessExecute(comment, processMnemonic, 1, echoSetting, \"start_process\", true, expectedOutcome, processDetails);\n\t\treturn processes[0];\n\t}\n\n\t/**\n\t * Generates perl code to start multiple process.\n\t */\n\tpublic StfProcess[] runBackgroundProcesses(String comment, String processMnemonic, int numInstances, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tif (numInstances <= 1) {\n\t\t\tthrow new StfException(\"Invalid number of concurrent process instances '\" + numInstances + \"'. \"\n\t\t\t\t\t+ \"To run a single process call doRunBackgroundProcess()\");\n\t\t}\n\t\t\n\t\treturn generateProcessExecute(comment, processMnemonic, numInstances, echoSetting, \"start_processes\", true, expectedOutcome, processDetails);\n\t}\n\n\t\n\t/**\n\t * Core method for generating perl code to run processes, either synchronously or asynchronously. \n\t * @param comment is the description explaining why the process is being started.\n\t * @param processMnemonic is a 3 character mnemonic for the process(es). Used as prefix for output produced by the process.\n\t * @param numInstances is the number of instances to be started.\n\t * @param echoSetting turns on/off process echoing.\n\t * @param perlMethod is the name of the perl method that is to be invoked.\n\t * @param asynchronousProcess if true process will be run in the background (and require later monitoring or killing) \n\t * @param expectedOutcome\n\t * @param processDetails\n\t * @return\n\t * @throws StfException\n\t */\n\tprivate StfProcess[] generateProcessExecute(String comment, String processMnemonic, int numInstances, Echo echoSetting, String perlMethod,\n\t\t\tboolean asynchronousProcess, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tprocessMnemonic = processMnemonic.trim();\n\n\t\t// Make sure the mnemonic string is not too long\n\t\tint maximumMnemonicLen = numInstances == 1 ? 4 : 3;\n\t\tif (processMnemonic.length() > maximumMnemonicLen) {\n\t\t\tthrow new StfException(\"Process mnemonic too long. Maximum length is \" + maximumMnemonicLen + \": \" + processMnemonic);\n\t\t}\n\t\t\n\t\t// Build the command to be run\n\t\tCommandDetails command;\n\t\tif (processDetails.isJdkProgram()) {\n\t\t\tcommand = generator.buildJvmCommand(processMnemonic, numInstances, processDetails);\n\t\t} else {\n\t\t\tString[] args = processDetails.asArgsArray().toArray(new String[0]);\n\t\t\tcommand = generator.buildCommand(processMnemonic, numInstances, null, processDetails.getCommand(), args);\n\t\t}\n\t\t\n\t\t//Add any related processes to the CommandDetails object so the Perl generator can use them if needed.\n\t\tcommand.setRelatedProcesses(processDetails.getRelatedProcesses(),processDetails.getRelatedProcessesData());\n\n\t\t// Generate code to run java process\n\t\tStfProcess[] processes = generator.generateRunProcess2(comment, command.getArgumentComment(), processMnemonic, numInstances, echoSetting, perlMethod, expectedOutcome, command);\n\t\t// Keep track of the state of all processes. To make sure they are monitored or killed.\n\t\tfor (StfProcess process : processes) {\n\t\t\tchildProcesses.add(process);\n\t\t}\n\t\t\n\t\t// Generate code to check the return code\n\t\tStfExitCodes runCommandSuccess = StfExitCodes.expected(0);\n\t\toutputFailIfTrue(processDetails.getCommand(), comment, \"$rc\", \"!=\", runCommandSuccess);",
        "start_line": 195,
        "end_line": 260,
        "chunk_index": 3,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 798,
        "node_type": null,
        "file_sha": "21710f29829cf0281075139ed1e59b37e40d9175",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.982053"
      },
      "text": "/**\n\t * Generates perl code to start a single process.\n\t */\n\tpublic StfProcess runBackgroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tStfProcess[] processes = generateProcessExecute(comment, processMnemonic, 1, echoSetting, \"start_process\", true, expectedOutcome, processDetails);\n\t\treturn processes[0];\n\t}\n\n\t/**\n\t * Generates perl code to start multiple process.\n\t */\n\tpublic StfProcess[] runBackgroundProcesses(String comment, String processMnemonic, int numInstances, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tif (numInstances <= 1) {\n\t\t\tthrow new StfException(\"Invalid number of concurrent process instances '\" + numInstances + \"'. \"\n\t\t\t\t\t+ \"To run a single process call doRunBackgroundProcess()\");\n\t\t}\n\t\t\n\t\treturn generateProcessExecute(comment, processMnemonic, numInstances, echoSetting, \"start_processes\", true, expectedOutcome, processDetails);\n\t}\n\n\t\n\t/**\n\t * Core method for generating perl code to run processes, either synchronously or asynchronously. \n\t * @param comment is the description explaining why the process is being started.\n\t * @param processMnemonic is a 3 character mnemonic for the process(es). Used as prefix for output produced by the process.\n\t * @param numInstances is the number of instances to be started.\n\t * @param echoSetting turns on/off process echoing.\n\t * @param perlMethod is the name of the perl method that is to be invoked.\n\t * @param asynchronousProcess if true process will be run in the background (and require later monitoring or killing) \n\t * @param expectedOutcome\n\t * @param processDetails\n\t * @return\n\t * @throws StfException\n\t */\n\tprivate StfProcess[] generateProcessExecute(String comment, String processMnemonic, int numInstances, Echo echoSetting, String perlMethod,\n\t\t\tboolean asynchronousProcess, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tprocessMnemonic = processMnemonic.trim();\n\n\t\t// Make sure the mnemonic string is not too long\n\t\tint maximumMnemonicLen = numInstances == 1 ? 4 : 3;\n\t\tif (processMnemonic.length() > maximumMnemonicLen) {\n\t\t\tthrow new StfException(\"Process mnemonic too long. Maximum length is \" + maximumMnemonicLen + \": \" + processMnemonic);\n\t\t}\n\t\t\n\t\t// Build the command to be run\n\t\tCommandDetails command;\n\t\tif (processDetails.isJdkProgram()) {\n\t\t\tcommand = generator.buildJvmCommand(processMnemonic, numInstances, processDetails);\n\t\t} else {\n\t\t\tString[] args = processDetails.asArgsArray().toArray(new String[0]);\n\t\t\tcommand = generator.buildCommand(processMnemonic, numInstances, null, processDetails.getCommand(), args);\n\t\t}\n\t\t\n\t\t//Add any related processes to the CommandDetails object so the Perl generator can use them if needed.\n\t\tcommand.setRelatedProcesses(processDetails.getRelatedProcesses(),processDetails.getRelatedProcessesData());\n\n\t\t// Generate code to run java process\n\t\tStfProcess[] processes = generator.generateRunProcess2(comment, command.getArgumentComment(), processMnemonic, numInstances, echoSetting, perlMethod, expectedOutcome, command);\n\t\t// Keep track of the state of all processes. To make sure they are monitored or killed.\n\t\tfor (StfProcess process : processes) {\n\t\t\tchildProcesses.add(process);\n\t\t}\n\t\t\n\t\t// Generate code to check the return code\n\t\tStfExitCodes runCommandSuccess = StfExitCodes.expected(0);\n\t\toutputFailIfTrue(processDetails.getCommand(), comment, \"$rc\", \"!=\", runCommandSuccess);"
    },
    "180": {
      "metadata": {
        "chunk_id": "87634457629b75d9ca80705ec13b67c2a890be0772ba3aafcbd7b25c5e48bb46",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/StfExtensionBase.java",
        "content": "// Generate code to run java process\n\t\tStfProcess[] processes = generator.generateRunProcess2(comment, command.getArgumentComment(), processMnemonic, numInstances, echoSetting, perlMethod, expectedOutcome, command);\n\t\t// Keep track of the state of all processes. To make sure they are monitored or killed.\n\t\tfor (StfProcess process : processes) {\n\t\t\tchildProcesses.add(process);\n\t\t}\n\t\t\n\t\t// Generate code to check the return code\n\t\tStfExitCodes runCommandSuccess = StfExitCodes.expected(0);\n\t\toutputFailIfTrue(processDetails.getCommand(), comment, \"$rc\", \"!=\", runCommandSuccess);\n\n\t\t// Synchronous process must now be complete. They have either \n\t\t//   1) Completed as expected (success, error, crash, etc), or \n\t\t//   2) Exceeded their timeout, and have been killed by outputResultCheck().\n\t\tif (!asynchronousProcess) {\n\t\t\tfor (StfProcess process : processes) {\n\t\t\t\tprocess.updateStateToCompleted();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Give the process definition a chance to do any extra work for this invocation\n\t\tprocessDetails.generationCompleted(command.getCommandSerialNum(), processMnemonic);\n\t\t\n\t\treturn processes;\n\t}\n\n\t\n\t/**\n\t * Generates the code for a monitor_process java call.\n\t * @param comment is a description summarising the purpose of the monitor call.\n\t * @param processesToMonitor is a list of processes which need to be monitored.\n\t * @throws StfException if a logic error in the automation code is detected, \n\t * or if code generation fails.\n\t */\n\tpublic void internalDoMonitorProcesses(String comment, ArrayList<StfProcess> processesToMonitor) throws StfException {\n\t\t// Don't allow monitoring of processes which are not running\n\t\tfor (StfProcess p : processesToMonitor) {\n\t\t\tif (p.processHasCompleted()) {\n\t\t\t\tthrow new StfException(\"Can't monitor process '\" + p.getMnemonic() + \"' in step '\" + comment + \"' \"\n\t\t\t\t\t\t+ \"as it has already finished.\");\n\t\t\t}\n\t\t\tif (p.processHasBeenKilled()) {\n\t\t\t\tthrow new StfException(\"Can't monitor process '\" + p.getMnemonic() + \"' in step '\" + comment + \"' \"\n\t\t\t\t\t\t+ \"as it has already been killed.\");\n\t\t\t}\n\t\t}\n\n\t\t// Make sure that at least one of of the monitored processes is actually going to finish.\n\t\t// The monitor call does not make any sense otherwise, so abort if the caller is attempting to \n\t\t// monitor processes which are going to run forever.\n\t\tboolean foundTerminalProcess = false;\n\t\tfor (StfProcess p : processesToMonitor) {\n\t\t\tif (p.getExpectedCompletion().getExpectedOutcome() != OutcomeType.NEVER) {\n\t\t\t\tfoundTerminalProcess = true;\n\t\t\t}\n\t\t}\n\t\tif (!foundTerminalProcess) {\n\t\t\tthrow new StfException(\"Can't monitor process list for step '\" + comment + \"'\" \n\t\t\t\t\t\t+ \" as none of the processes are expected to finish.\");\n\t\t}\n\n\t\t// Generate the code to kill all processes which may still be running\n\t\tgenerator.monitorProcesses(processesToMonitor);\n\t\t\n\t\t// Check the return code\n\t\tStfExitCodes expectedExitCode = StfExitCodes.expected(0);\n\t\toutputFailIfTrue(\"java\", comment, \"$rc\", \"!=\", expectedExitCode);\n\t\t\n\t\t// Update the known process state\n\t\tfor (StfProcess p : processesToMonitor) {\n\t\t\tif (p.getExpectedCompletion().getExpectedOutcome() != OutcomeType.NEVER) {\n\t\t\t\tp.updateStateToCompleted();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Generates the code for a kill command.\n\t * @param processesToKill is a list of processes which are to be killed.\n\t */\n\tpublic void internalDoKillProcess(String comment, ArrayList<StfProcess> processesToKill) throws StfException {\n\t\t// Verify that all of the processes are still running\n\t\tfor (StfProcess p : processesToKill) {\n\t\t\tif (!p.isRunning()) {\n\t\t\t\tthrow new StfException(\"Can't kill process '\" + p.getMnemonic() + \"' \"\n\t\t\t\t\t\t+ \"in test \" + environmentCore.getSourceFileName() + \" as it not running at this point\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Update known process state\n\t\tfor (StfProcess p : processesToKill) {\n\t\t\tp.updateStateToKilled();\n\t\t}",
        "start_line": 261,
        "end_line": 354,
        "chunk_index": 4,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 955,
        "node_type": null,
        "file_sha": "21710f29829cf0281075139ed1e59b37e40d9175",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.982056"
      },
      "text": "// Generate code to run java process\n\t\tStfProcess[] processes = generator.generateRunProcess2(comment, command.getArgumentComment(), processMnemonic, numInstances, echoSetting, perlMethod, expectedOutcome, command);\n\t\t// Keep track of the state of all processes. To make sure they are monitored or killed.\n\t\tfor (StfProcess process : processes) {\n\t\t\tchildProcesses.add(process);\n\t\t}\n\t\t\n\t\t// Generate code to check the return code\n\t\tStfExitCodes runCommandSuccess = StfExitCodes.expected(0);\n\t\toutputFailIfTrue(processDetails.getCommand(), comment, \"$rc\", \"!=\", runCommandSuccess);\n\n\t\t// Synchronous process must now be complete. They have either \n\t\t//   1) Completed as expected (success, error, crash, etc), or \n\t\t//   2) Exceeded their timeout, and have been killed by outputResultCheck().\n\t\tif (!asynchronousProcess) {\n\t\t\tfor (StfProcess process : processes) {\n\t\t\t\tprocess.updateStateToCompleted();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Give the process definition a chance to do any extra work for this invocation\n\t\tprocessDetails.generationCompleted(command.getCommandSerialNum(), processMnemonic);\n\t\t\n\t\treturn processes;\n\t}\n\n\t\n\t/**\n\t * Generates the code for a monitor_process java call.\n\t * @param comment is a description summarising the purpose of the monitor call.\n\t * @param processesToMonitor is a list of processes which need to be monitored.\n\t * @throws StfException if a logic error in the automation code is detected, \n\t * or if code generation fails.\n\t */\n\tpublic void internalDoMonitorProcesses(String comment, ArrayList<StfProcess> processesToMonitor) throws StfException {\n\t\t// Don't allow monitoring of processes which are not running\n\t\tfor (StfProcess p : processesToMonitor) {\n\t\t\tif (p.processHasCompleted()) {\n\t\t\t\tthrow new StfException(\"Can't monitor process '\" + p.getMnemonic() + \"' in step '\" + comment + \"' \"\n\t\t\t\t\t\t+ \"as it has already finished.\");\n\t\t\t}\n\t\t\tif (p.processHasBeenKilled()) {\n\t\t\t\tthrow new StfException(\"Can't monitor process '\" + p.getMnemonic() + \"' in step '\" + comment + \"' \"\n\t\t\t\t\t\t+ \"as it has already been killed.\");\n\t\t\t}\n\t\t}\n\n\t\t// Make sure that at least one of of the monitored processes is actually going to finish.\n\t\t// The monitor call does not make any sense otherwise, so abort if the caller is attempting to \n\t\t// monitor processes which are going to run forever.\n\t\tboolean foundTerminalProcess = false;\n\t\tfor (StfProcess p : processesToMonitor) {\n\t\t\tif (p.getExpectedCompletion().getExpectedOutcome() != OutcomeType.NEVER) {\n\t\t\t\tfoundTerminalProcess = true;\n\t\t\t}\n\t\t}\n\t\tif (!foundTerminalProcess) {\n\t\t\tthrow new StfException(\"Can't monitor process list for step '\" + comment + \"'\" \n\t\t\t\t\t\t+ \" as none of the processes are expected to finish.\");\n\t\t}\n\n\t\t// Generate the code to kill all processes which may still be running\n\t\tgenerator.monitorProcesses(processesToMonitor);\n\t\t\n\t\t// Check the return code\n\t\tStfExitCodes expectedExitCode = StfExitCodes.expected(0);\n\t\toutputFailIfTrue(\"java\", comment, \"$rc\", \"!=\", expectedExitCode);\n\t\t\n\t\t// Update the known process state\n\t\tfor (StfProcess p : processesToMonitor) {\n\t\t\tif (p.getExpectedCompletion().getExpectedOutcome() != OutcomeType.NEVER) {\n\t\t\t\tp.updateStateToCompleted();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Generates the code for a kill command.\n\t * @param processesToKill is a list of processes which are to be killed.\n\t */\n\tpublic void internalDoKillProcess(String comment, ArrayList<StfProcess> processesToKill) throws StfException {\n\t\t// Verify that all of the processes are still running\n\t\tfor (StfProcess p : processesToKill) {\n\t\t\tif (!p.isRunning()) {\n\t\t\t\tthrow new StfException(\"Can't kill process '\" + p.getMnemonic() + \"' \"\n\t\t\t\t\t\t+ \"in test \" + environmentCore.getSourceFileName() + \" as it not running at this point\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Update known process state\n\t\tfor (StfProcess p : processesToKill) {\n\t\t\tp.updateStateToKilled();\n\t\t}"
    },
    "181": {
      "metadata": {
        "chunk_id": "b8d65d9c9ea33d3546d1b764fe3fc5a988e32f83928bc2ddf065e22f2c1c54f9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/StfExtensionBase.java",
        "content": "/**\n\t * Generates the code for a kill command.\n\t * @param processesToKill is a list of processes which are to be killed.\n\t */\n\tpublic void internalDoKillProcess(String comment, ArrayList<StfProcess> processesToKill) throws StfException {\n\t\t// Verify that all of the processes are still running\n\t\tfor (StfProcess p : processesToKill) {\n\t\t\tif (!p.isRunning()) {\n\t\t\t\tthrow new StfException(\"Can't kill process '\" + p.getMnemonic() + \"' \"\n\t\t\t\t\t\t+ \"in test \" + environmentCore.getSourceFileName() + \" as it not running at this point\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Update known process state\n\t\tfor (StfProcess p : processesToKill) {\n\t\t\tp.updateStateToKilled();\n\t\t}\n\n\t\t// Generate the code to monitor the processes\n\t\tgenerator.outputKillProcesses(processesToKill, \"$rc = \");\n\t\t\n\t\t// Check the return code\n\t\tStfExitCodes expectedExitCode = StfExitCodes.expected(0);\n\t\toutputFailIfTrue(\"java\", comment, \"$rc\", \"!=\", expectedExitCode);\n\t}\n\n\t\n\tpublic void verifyNoOrphanChildProcesses(String sourceFileName) throws StfException {\n\t\tfor (StfProcess p : childProcesses) { \n\t\t\tif (p.isRunning()) {\n\t\t\t\tthrow new StfException(\"Possible orphan process in '\" + environmentCore.getSourceFileName() + \".java'. \"\n\t\t\t\t\t\t+ \"The '\" + p.getMnemonic() + \"' process has neither completed monitoring or been killed\");\n\t\t\t}\n\t\t}\n\t}\n}",
        "start_line": 355,
        "end_line": 390,
        "chunk_index": 5,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 338,
        "node_type": null,
        "file_sha": "21710f29829cf0281075139ed1e59b37e40d9175",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.982058"
      },
      "text": "/**\n\t * Generates the code for a kill command.\n\t * @param processesToKill is a list of processes which are to be killed.\n\t */\n\tpublic void internalDoKillProcess(String comment, ArrayList<StfProcess> processesToKill) throws StfException {\n\t\t// Verify that all of the processes are still running\n\t\tfor (StfProcess p : processesToKill) {\n\t\t\tif (!p.isRunning()) {\n\t\t\t\tthrow new StfException(\"Can't kill process '\" + p.getMnemonic() + \"' \"\n\t\t\t\t\t\t+ \"in test \" + environmentCore.getSourceFileName() + \" as it not running at this point\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Update known process state\n\t\tfor (StfProcess p : processesToKill) {\n\t\t\tp.updateStateToKilled();\n\t\t}\n\n\t\t// Generate the code to monitor the processes\n\t\tgenerator.outputKillProcesses(processesToKill, \"$rc = \");\n\t\t\n\t\t// Check the return code\n\t\tStfExitCodes expectedExitCode = StfExitCodes.expected(0);\n\t\toutputFailIfTrue(\"java\", comment, \"$rc\", \"!=\", expectedExitCode);\n\t}\n\n\t\n\tpublic void verifyNoOrphanChildProcesses(String sourceFileName) throws StfException {\n\t\tfor (StfProcess p : childProcesses) { \n\t\t\tif (p.isRunning()) {\n\t\t\t\tthrow new StfException(\"Possible orphan process in '\" + environmentCore.getSourceFileName() + \".java'. \"\n\t\t\t\t\t\t+ \"The '\" + p.getMnemonic() + \"' process has neither completed monitoring or been killed\");\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "182": {
      "metadata": {
        "chunk_id": "08bf745cd9f2a0b28b5e2ae2887062ae472e7b470ec8a0abf22fde03a681b02c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions.core;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.StfExitCodes;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.codeGeneration.Stage;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator.CommandDetails;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.Argument.Required;\nimport net.adoptopenjdk.stf.extensions.Stf;\nimport net.adoptopenjdk.stf.extensions.StfExtensionBase;\nimport net.adoptopenjdk.stf.extensions.interfaces.StfExtension;\nimport net.adoptopenjdk.stf.modes.ModeDecoder;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.JDKToolProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JlinkDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JmodDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.LoadTestProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.ProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.SystemProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition.JarId;\nimport net.adoptopenjdk.stf.results.ReportFilteredTestResults;\nimport net.adoptopenjdk.stf.runner.StfClassLoader;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\nimport net.adoptopenjdk.stf.supportApps.junit.JUnitRunner;\nimport net.adoptopenjdk.stf.util.StringSplitter;\n\n\n/**\n * This STF extension implements basic test support functions.\n * \n * It is anticipated that the functions provided by this extension \n * are applicable to a wide range of tests.\n */",
        "start_line": 0,
        "end_line": 66,
        "chunk_index": 0,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 698,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994447"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions.core;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.StfExitCodes;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.codeGeneration.Stage;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator.CommandDetails;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.Argument.Required;\nimport net.adoptopenjdk.stf.extensions.Stf;\nimport net.adoptopenjdk.stf.extensions.StfExtensionBase;\nimport net.adoptopenjdk.stf.extensions.interfaces.StfExtension;\nimport net.adoptopenjdk.stf.modes.ModeDecoder;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.JDKToolProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JlinkDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JmodDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.LoadTestProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.ProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.SystemProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition.JarId;\nimport net.adoptopenjdk.stf.results.ReportFilteredTestResults;\nimport net.adoptopenjdk.stf.runner.StfClassLoader;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\nimport net.adoptopenjdk.stf.supportApps.junit.JUnitRunner;\nimport net.adoptopenjdk.stf.util.StringSplitter;\n\n\n/**\n * This STF extension implements basic test support functions.\n * \n * It is anticipated that the functions provided by this extension \n * are applicable to a wide range of tests.\n */"
    },
    "183": {
      "metadata": {
        "chunk_id": "7a5fd267cdd9e30a9a7f9688f289a77683615b0687557f314d849dc8932afb32",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "public class StfCoreExtension implements StfExtension {\n\tStfEnvironmentCore environmentCore;\n\tStfEnvironment environment;\n\t\n\tStfExtensionBase extensionBase;\n    PerlCodeGenerator generator;\n\n    //                        Java name                         Extension    Argument name     Boolean            Type\n\tpublic static Argument ARG_JUNIT_JAR         = new Argument(\"stfCore\", \"junit-jar\",         false,  Required.MANDATORY);\n\tpublic static Argument ARG_HAMCREST_CORE_JAR = new Argument(\"stfCore\", \"hamcrest-core-jar\", false,  Required.MANDATORY);\n\tpublic static Argument ARG_LOG4J_API_JAR     = new Argument(\"stfCore\", \"log4j-api-jar\",     false,  Required.MANDATORY);\n\tpublic static Argument ARG_LOG4J_CORE_JAR    = new Argument(\"stfCore\", \"log4j-core-jar\",    false,  Required.MANDATORY);\n\tpublic static Argument ARG_ASM_JAR           = new Argument(\"stfCore\", \"asm-jar\",           false,  Required.MANDATORY);\n\tpublic static Argument ARG_ASM_COMMONS_JAR   = new Argument(\"stfCore\", \"asm-commons-jar\",   false,  Required.MANDATORY);\n\tpublic static Argument ARG_APPS_ROOT         = new Argument(\"stfCore\", \"apps-root\",         false,  Required.MANDATORY);\n\tpublic static Argument ARG_MODE              = new Argument(\"stfCore\", \"mode\",              false,  Required.MANDATORY);\n\n    private DirectoryRef appsRoot;\n    \n    // This extension may go through the init cycle many times, so prevent duplicate\n    // attempts to decode the mode by parsing modes.xml or variations.xml. \n    // The javaArgsExecuteInitial are remembered so that a run with '-mode=random'\n    // with a '-repeat' value can each get a new set of random args for each invocation.\n    private static boolean needToDecodedMode = true;\n    String javaArgsExecuteInitial = null;\n\n\t@Override\n\tpublic Argument[] getSupportedArguments() {\n\t\treturn new Argument[] {\n\t\t\t\tARG_JUNIT_JAR, \n\t\t\t\tARG_HAMCREST_CORE_JAR,\n\t\t\t\tARG_LOG4J_API_JAR,\n\t\t\t\tARG_LOG4J_CORE_JAR,\n\t\t\t\tARG_ASM_JAR,\n\t\t\t\tARG_ASM_COMMONS_JAR,\n\t\t\t\tARG_APPS_ROOT,\n\t\t\t\tARG_MODE,\n\t\t\t};\n\t}\n\t\n\t@Override\n\tpublic void help(HelpTextGenerator help) {\n\t\thelp.outputSection(\"Stf-core extension options.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JUNIT_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the junit jar file.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_HAMCREST_CORE_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the hamcrest jar file.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_LOG4J_API_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the log4j api jar file.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_LOG4J_CORE_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the log4j core jar file.\");\n\t\n\t\thelp.outputArgName(\"-\" + ARG_ASM_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the asm jar file.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_ASM_COMMONS_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the asm-commons jar file.\");\n\t}\n\t\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.environment = new StfEnvironment(environmentCore);\n\t\tthis.extensionBase = extensionBase;\n\t\tthis.generator = generator;\n\t\t// Find out where the apps directory is\n\t\tthis.appsRoot = environmentCore.createDirectoryRefFromProperty(ARG_APPS_ROOT);",
        "start_line": 67,
        "end_line": 136,
        "chunk_index": 1,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 842,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994456"
      },
      "text": "public class StfCoreExtension implements StfExtension {\n\tStfEnvironmentCore environmentCore;\n\tStfEnvironment environment;\n\t\n\tStfExtensionBase extensionBase;\n    PerlCodeGenerator generator;\n\n    //                        Java name                         Extension    Argument name     Boolean            Type\n\tpublic static Argument ARG_JUNIT_JAR         = new Argument(\"stfCore\", \"junit-jar\",         false,  Required.MANDATORY);\n\tpublic static Argument ARG_HAMCREST_CORE_JAR = new Argument(\"stfCore\", \"hamcrest-core-jar\", false,  Required.MANDATORY);\n\tpublic static Argument ARG_LOG4J_API_JAR     = new Argument(\"stfCore\", \"log4j-api-jar\",     false,  Required.MANDATORY);\n\tpublic static Argument ARG_LOG4J_CORE_JAR    = new Argument(\"stfCore\", \"log4j-core-jar\",    false,  Required.MANDATORY);\n\tpublic static Argument ARG_ASM_JAR           = new Argument(\"stfCore\", \"asm-jar\",           false,  Required.MANDATORY);\n\tpublic static Argument ARG_ASM_COMMONS_JAR   = new Argument(\"stfCore\", \"asm-commons-jar\",   false,  Required.MANDATORY);\n\tpublic static Argument ARG_APPS_ROOT         = new Argument(\"stfCore\", \"apps-root\",         false,  Required.MANDATORY);\n\tpublic static Argument ARG_MODE              = new Argument(\"stfCore\", \"mode\",              false,  Required.MANDATORY);\n\n    private DirectoryRef appsRoot;\n    \n    // This extension may go through the init cycle many times, so prevent duplicate\n    // attempts to decode the mode by parsing modes.xml or variations.xml. \n    // The javaArgsExecuteInitial are remembered so that a run with '-mode=random'\n    // with a '-repeat' value can each get a new set of random args for each invocation.\n    private static boolean needToDecodedMode = true;\n    String javaArgsExecuteInitial = null;\n\n\t@Override\n\tpublic Argument[] getSupportedArguments() {\n\t\treturn new Argument[] {\n\t\t\t\tARG_JUNIT_JAR, \n\t\t\t\tARG_HAMCREST_CORE_JAR,\n\t\t\t\tARG_LOG4J_API_JAR,\n\t\t\t\tARG_LOG4J_CORE_JAR,\n\t\t\t\tARG_ASM_JAR,\n\t\t\t\tARG_ASM_COMMONS_JAR,\n\t\t\t\tARG_APPS_ROOT,\n\t\t\t\tARG_MODE,\n\t\t\t};\n\t}\n\t\n\t@Override\n\tpublic void help(HelpTextGenerator help) {\n\t\thelp.outputSection(\"Stf-core extension options.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_JUNIT_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the junit jar file.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_HAMCREST_CORE_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the hamcrest jar file.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_LOG4J_API_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the log4j api jar file.\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_LOG4J_CORE_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the log4j core jar file.\");\n\t\n\t\thelp.outputArgName(\"-\" + ARG_ASM_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the asm jar file.\");\n\n\t\thelp.outputArgName(\"-\" + ARG_ASM_COMMONS_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the asm-commons jar file.\");\n\t}\n\t\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.environment = new StfEnvironment(environmentCore);\n\t\tthis.extensionBase = extensionBase;\n\t\tthis.generator = generator;\n\t\t// Find out where the apps directory is\n\t\tthis.appsRoot = environmentCore.createDirectoryRefFromProperty(ARG_APPS_ROOT);"
    },
    "184": {
      "metadata": {
        "chunk_id": "7bbd9d4a021db049d4b0d8d3638c08855c2ced683f1af5f335540eccc1184650",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "help.outputArgName(\"-\" + ARG_ASM_COMMONS_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the asm-commons jar file.\");\n\t}\n\t\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.environment = new StfEnvironment(environmentCore);\n\t\tthis.extensionBase = extensionBase;\n\t\tthis.generator = generator;\n\t\t// Find out where the apps directory is\n\t\tthis.appsRoot = environmentCore.createDirectoryRefFromProperty(ARG_APPS_ROOT);\n\n\t\t// Convert the '-mode' name to java-args. But only do it once if possible \n\t\tString modeName = environmentCore.getProperty(ARG_MODE);\n\t\tif (needToDecodedMode || modeName.toLowerCase().startsWith(\"random\")) {\n\t\t\t// Translate the mode string to JVM arguments\n\t\t\t// Although the decoded mode arguments are only to be used in the execute stage do it\n\t\t\t// for all stages so that the values are available for checking in a tests init method.\n\t\t\t// Use the mode file to find out what arguments should be used\n\t\t\tString modeArguments = ModeDecoder.decodeModeName(environmentCore, modeName);\n\t\t\n\t\t\tif (javaArgsExecuteInitial == null) {\n\t\t\t\t// Only remember the initial values once (so that it can be reused multiple times. Even for random args)\n\t\t\t\tjavaArgsExecuteInitial = environmentCore.getProperty(Stf.ARG_JAVA_ARGS_EXECUTE_INITIAL);\n\t\t\t}\n\t\t\n\t\t\t// Prepend the mode arguments to any existing initial JVM arguments.\n\t\t\t// The mode values are added at the start of the java command to allow\n\t\t\t// plugin code to override any of the values.\n\t\t\tString fullOptions = modeArguments + \" \" + javaArgsExecuteInitial;\n\t\t\tenvironmentCore.updateProperty(Stf.ARG_JAVA_ARGS_EXECUTE_INITIAL, fullOptions);\n\t\t\tneedToDecodedMode = false;\n\t\t}\n\n\t}\n\t\n\t\n\t/**\n\t * Provides access to the StfEnvironment object, which can be used to discover \n\t * details about the environment in which a plugin is running.\n\t * Allows access to the results directory, temp directory and current platform. \n\t * \n\t * @return an StfEnvironment object.\n\t */\n\tpublic StfEnvironment env() {\n\t\treturn environment;\n\t}\n\n\t\n\t/**\n\t * Some test material is held in the third party apps directory tree.\n\t * This method provides access to its location for the current run.\n\t *  \n\t * @return a Directory reference pointing to the top of the apps directory.\n\t */\n\tpublic DirectoryRef getAppsRoot() {\n\t\treturn appsRoot;\n\t}\n\n\t/**\n\t * Removes a directory when the test executes.\n \t * This is equivalent to running the Unix 'rm -rf' command on a directory. \n\t * The test will fail at runtime if the directory does not exist or the \n\t * file cannot be deleted.\n\t * \n\t * @param comment is a short summary describing why the test is performing this step.\n\t * @param targetDir is the directory to remove.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doRm(String comment, DirectoryRef targetDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"rm\", \"Recursively delete a directory\", \n\t\t\t\t\t\t\"Directory:\", targetDir.getSpec());\n\t\t\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\tgenerator.outputLine(\"stf::stfUtility->splatTree( dir => \" + \"'\" + targetDir.getSpec() + \"' );\");\n\t\t} else {\n\t\t\tgenerator.outputLine(\"rmtree( \" + \"'\" + targetDir.getSpec() + \"', {error => \\\\$err\" + \"});\");\n\t\t\textensionBase.outputErrorCheck(\"rm\", comment, \"@$err\");\n\t\t}\n\t}",
        "start_line": 137,
        "end_line": 216,
        "chunk_index": 2,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 814,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994459"
      },
      "text": "help.outputArgName(\"-\" + ARG_ASM_COMMONS_JAR.getName(), \"FILE\");\n\t\thelp.outputArgDesc(\"Points to the location of the asm-commons jar file.\");\n\t}\n\t\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.environment = new StfEnvironment(environmentCore);\n\t\tthis.extensionBase = extensionBase;\n\t\tthis.generator = generator;\n\t\t// Find out where the apps directory is\n\t\tthis.appsRoot = environmentCore.createDirectoryRefFromProperty(ARG_APPS_ROOT);\n\n\t\t// Convert the '-mode' name to java-args. But only do it once if possible \n\t\tString modeName = environmentCore.getProperty(ARG_MODE);\n\t\tif (needToDecodedMode || modeName.toLowerCase().startsWith(\"random\")) {\n\t\t\t// Translate the mode string to JVM arguments\n\t\t\t// Although the decoded mode arguments are only to be used in the execute stage do it\n\t\t\t// for all stages so that the values are available for checking in a tests init method.\n\t\t\t// Use the mode file to find out what arguments should be used\n\t\t\tString modeArguments = ModeDecoder.decodeModeName(environmentCore, modeName);\n\t\t\n\t\t\tif (javaArgsExecuteInitial == null) {\n\t\t\t\t// Only remember the initial values once (so that it can be reused multiple times. Even for random args)\n\t\t\t\tjavaArgsExecuteInitial = environmentCore.getProperty(Stf.ARG_JAVA_ARGS_EXECUTE_INITIAL);\n\t\t\t}\n\t\t\n\t\t\t// Prepend the mode arguments to any existing initial JVM arguments.\n\t\t\t// The mode values are added at the start of the java command to allow\n\t\t\t// plugin code to override any of the values.\n\t\t\tString fullOptions = modeArguments + \" \" + javaArgsExecuteInitial;\n\t\t\tenvironmentCore.updateProperty(Stf.ARG_JAVA_ARGS_EXECUTE_INITIAL, fullOptions);\n\t\t\tneedToDecodedMode = false;\n\t\t}\n\n\t}\n\t\n\t\n\t/**\n\t * Provides access to the StfEnvironment object, which can be used to discover \n\t * details about the environment in which a plugin is running.\n\t * Allows access to the results directory, temp directory and current platform. \n\t * \n\t * @return an StfEnvironment object.\n\t */\n\tpublic StfEnvironment env() {\n\t\treturn environment;\n\t}\n\n\t\n\t/**\n\t * Some test material is held in the third party apps directory tree.\n\t * This method provides access to its location for the current run.\n\t *  \n\t * @return a Directory reference pointing to the top of the apps directory.\n\t */\n\tpublic DirectoryRef getAppsRoot() {\n\t\treturn appsRoot;\n\t}\n\n\t/**\n\t * Removes a directory when the test executes.\n \t * This is equivalent to running the Unix 'rm -rf' command on a directory. \n\t * The test will fail at runtime if the directory does not exist or the \n\t * file cannot be deleted.\n\t * \n\t * @param comment is a short summary describing why the test is performing this step.\n\t * @param targetDir is the directory to remove.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doRm(String comment, DirectoryRef targetDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"rm\", \"Recursively delete a directory\", \n\t\t\t\t\t\t\"Directory:\", targetDir.getSpec());\n\t\t\n\t\tif (PlatformFinder.isWindows()) {\n\t\t\tgenerator.outputLine(\"stf::stfUtility->splatTree( dir => \" + \"'\" + targetDir.getSpec() + \"' );\");\n\t\t} else {\n\t\t\tgenerator.outputLine(\"rmtree( \" + \"'\" + targetDir.getSpec() + \"', {error => \\\\$err\" + \"});\");\n\t\t\textensionBase.outputErrorCheck(\"rm\", comment, \"@$err\");\n\t\t}\n\t}"
    },
    "185": {
      "metadata": {
        "chunk_id": "533b33cbcb24c19e89343d522664452ca300d4890ee3b3578c33e46afd1ca3a0",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * Removes a file when the test executes.\n \t * This is equivalent to the Unix rm command when used to delete a file. \n\t * The test will fail at runtime if the file does not exist or the \n\t * file cannot be deleted.\n\t * \n\t * @param comment is a short summary describing why the test is performing this step.\n\t * @param targetFile is the file to remove.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doRm(String comment, FileRef targetFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"rm\", \"Delete a file\", \"File: \", targetFile.getSpec());\n\t\tgenerator.outputLine(\"rmtree \" + \"'\" + targetFile.getSpec() + \"';\");\n\t}\n\n\t\n\t/**\n\t * Copy a file to a directory.\n\t * This is equivalent to the Unix cp command. \n\t * The cp will fail at runtime if the sourceFile does not exist, or it cannot write to destDir.\n\t * \n\t * @param comment is a short summary describing why the test is performing this step.\n\t * @param sourceFile is the file which is to be copied.\n\t * @param destDir is the directory to copy the file to.\n\t * @return a file reference to the file in the destination directory.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic FileRef doCp(String comment, FileRef sourceFile, DirectoryRef destDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"cp\", \"Copy a file to another directory\",\n\t\t\t\t\t\t\"Source file:\", sourceFile.getSpec(),\n\t\t\t\t\t\t\"Dest dir:\", destDir.getSpec());\n\t\t\n\t\tgenerator.outputLine(\"$rc = copy \" + \"'\" + sourceFile.getSpec() + \"', '\" + destDir.getSpec() + \"';\");\n\t\textensionBase.outputFailIfTrue(\"cp\", comment, \"$rc\", \"!=\", StfExitCodes.expected(1));\n\t\t\n\t\treturn destDir.childFile(sourceFile.getName());\n\t}\n\t\n\t\n\t/**\n\t * Copy a directory tree recursively. The contents from the source directory are recursively copied to \n\t * the destination directory. \n\t * Note that the same directory structure will be recursively copied.\n\t * The copy will fail at runtime if the source directory does not exist. The destination directory will \n\t * be created if it does not exist.\n\t * \n\t * @param comment is a short summary describing why the test is copying a directory.\n\t * @param sourceDir is the directory to be copied. This must already exist.\n\t * @param destDir is the directory to copy to. This does not exist before running the command.\n\t * @return a directory reference to the newly created directory.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic DirectoryRef doCpDir(String comment, DirectoryRef sourceDir, DirectoryRef destDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"cpDir\", \"Copy a directory to a new directory\",\n\t\t\t\t\t\t\"Source dir:\", sourceDir.getSpec(),\n\t\t\t\t\t\t\"Dest dir:\", destDir.getSpec());\n\n\t\tgenerator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"');\");\t\t\n\t\textensionBase.outputFailIfTrue(\"cpDir\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t\t\n\t\treturn destDir;\n\t}",
        "start_line": 217,
        "end_line": 278,
        "chunk_index": 3,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 736,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994462"
      },
      "text": "/**\n\t * Removes a file when the test executes.\n \t * This is equivalent to the Unix rm command when used to delete a file. \n\t * The test will fail at runtime if the file does not exist or the \n\t * file cannot be deleted.\n\t * \n\t * @param comment is a short summary describing why the test is performing this step.\n\t * @param targetFile is the file to remove.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doRm(String comment, FileRef targetFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"rm\", \"Delete a file\", \"File: \", targetFile.getSpec());\n\t\tgenerator.outputLine(\"rmtree \" + \"'\" + targetFile.getSpec() + \"';\");\n\t}\n\n\t\n\t/**\n\t * Copy a file to a directory.\n\t * This is equivalent to the Unix cp command. \n\t * The cp will fail at runtime if the sourceFile does not exist, or it cannot write to destDir.\n\t * \n\t * @param comment is a short summary describing why the test is performing this step.\n\t * @param sourceFile is the file which is to be copied.\n\t * @param destDir is the directory to copy the file to.\n\t * @return a file reference to the file in the destination directory.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic FileRef doCp(String comment, FileRef sourceFile, DirectoryRef destDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"cp\", \"Copy a file to another directory\",\n\t\t\t\t\t\t\"Source file:\", sourceFile.getSpec(),\n\t\t\t\t\t\t\"Dest dir:\", destDir.getSpec());\n\t\t\n\t\tgenerator.outputLine(\"$rc = copy \" + \"'\" + sourceFile.getSpec() + \"', '\" + destDir.getSpec() + \"';\");\n\t\textensionBase.outputFailIfTrue(\"cp\", comment, \"$rc\", \"!=\", StfExitCodes.expected(1));\n\t\t\n\t\treturn destDir.childFile(sourceFile.getName());\n\t}\n\t\n\t\n\t/**\n\t * Copy a directory tree recursively. The contents from the source directory are recursively copied to \n\t * the destination directory. \n\t * Note that the same directory structure will be recursively copied.\n\t * The copy will fail at runtime if the source directory does not exist. The destination directory will \n\t * be created if it does not exist.\n\t * \n\t * @param comment is a short summary describing why the test is copying a directory.\n\t * @param sourceDir is the directory to be copied. This must already exist.\n\t * @param destDir is the directory to copy to. This does not exist before running the command.\n\t * @return a directory reference to the newly created directory.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic DirectoryRef doCpDir(String comment, DirectoryRef sourceDir, DirectoryRef destDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"cpDir\", \"Copy a directory to a new directory\",\n\t\t\t\t\t\t\"Source dir:\", sourceDir.getSpec(),\n\t\t\t\t\t\t\"Dest dir:\", destDir.getSpec());\n\n\t\tgenerator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"');\");\t\t\n\t\textensionBase.outputFailIfTrue(\"cpDir\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t\t\n\t\treturn destDir;\n\t}"
    },
    "186": {
      "metadata": {
        "chunk_id": "f87ff13d00fd7c996696c8d4327e5537e2d3fe5d1ad7a07336cc4d295b513b54",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "generator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"');\");\t\t\n\t\textensionBase.outputFailIfTrue(\"cpDir\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t\t\n\t\treturn destDir;\n\t}\n\t\n\n\t/**\n\t * Copy files with the filtering options of including only files with a given \n\t * set of extensions and/or a list of file names to exclude from the destination directory. \n\t * Only the files that match the specified extensions are copied from the source to the destination. \n\t * If a matching file from within the source tree is copied then any intervening directories are \n\t * created in the destination. For example, a match of $source/x/y/zob.jar would result in the creation of $dest/x/y/zob.jar.\n\t * The copy will fail at runtime if the source directory does not exist. The destination directory will \n\t * be created if it does not exist.\n\t * All files specified in the list of excludes will be absent in the destination directory .  \n\t * \n\t * @param comment is a short summary describing why the test is copying a directory.\n\t * @param sourceDir is the directory to be copied.\n\t * @param destDir is the directory to copy to.\n\t * @param includeSpec a comma separated list of file extensions to copy.\n\t * @param excludeSpec a comma separated list of filenames to exclude.\n\t * @return a directory reference to the newly created directory.\n\t * @throws StfException if there is an internal error.\n\t */\t\n\tpublic DirectoryRef doCpDir(String comment, DirectoryRef sourceDir, DirectoryRef destDir, String includeSpec,\n\t\t\tString excludeSpec) throws StfException {\n\t\tif (includeSpec == null && excludeSpec == null) {\n\t\t\treturn doCpDir(comment, sourceDir, destDir);\n\t\t}\n\t\t\n\t\tString formattedIncludeList = formatCommaSeparatedList(includeSpec);; \n\t\tString formattedExcludeList = formatCommaSeparatedList(excludeSpec);\n\t\t\n\t\tgenerator.startNewCommand(comment, \"cpDir\", \"Partial directory copy. Only matching files copied.\",\n\t\t\t\t\"Source dir:\", sourceDir.getSpec(), \n\t\t\t\t\"Dest dir:\", destDir.getSpec(), \n\t\t\t\t\"Extensions:\", formattedIncludeList, \n\t\t\t\t\"Excludes:\", formattedExcludeList);\n\t\t\n\t\treturn runCpDir(comment, sourceDir, destDir, formattedIncludeList, formattedExcludeList);\n\t}\n\t\n\t\n\t/**\n\t * Private utility method that copies a source directory to a destination directory after applying \n\t * filters to include and exclude files. This method is used by doCpDir() and doCreateProjectJar() methods. \n\t * */\n\tprivate DirectoryRef runCpDir(String comment, DirectoryRef sourceDir, DirectoryRef destDir, String includeList,\n\t\t\tString excludeList) throws StfException {\n\t\tif (includeList != null && excludeList != null) {\n\t\t\tgenerator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"',\"\n\t\t\t\t\t+ \"includeList => \" + includeList + \", excludelist => \" + excludeList + \");\");\n\t\t} else if (includeList == null && excludeList != null) {\n\t\t\tgenerator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"',\"\n\t\t\t\t\t+ \"excludelist => \" + excludeList + \");\");\n\t\t} else if (includeList != null && excludeList == null) {\n\t\t\tgenerator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"',\"\n\t\t\t\t\t+ \"includeList => \" + includeList + \");\");\n\t\t} else {\n\t\t\tthrow new StfException (\"Wrong argument supplied for include list and / or exclude list\");\n\t\t}\n\t\textensionBase.outputFailIfTrue(\"cpDir\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\n\t\treturn destDir;\n\t}",
        "start_line": 279,
        "end_line": 344,
        "chunk_index": 4,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 877,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994465"
      },
      "text": "generator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"');\");\t\t\n\t\textensionBase.outputFailIfTrue(\"cpDir\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t\t\n\t\treturn destDir;\n\t}\n\t\n\n\t/**\n\t * Copy files with the filtering options of including only files with a given \n\t * set of extensions and/or a list of file names to exclude from the destination directory. \n\t * Only the files that match the specified extensions are copied from the source to the destination. \n\t * If a matching file from within the source tree is copied then any intervening directories are \n\t * created in the destination. For example, a match of $source/x/y/zob.jar would result in the creation of $dest/x/y/zob.jar.\n\t * The copy will fail at runtime if the source directory does not exist. The destination directory will \n\t * be created if it does not exist.\n\t * All files specified in the list of excludes will be absent in the destination directory .  \n\t * \n\t * @param comment is a short summary describing why the test is copying a directory.\n\t * @param sourceDir is the directory to be copied.\n\t * @param destDir is the directory to copy to.\n\t * @param includeSpec a comma separated list of file extensions to copy.\n\t * @param excludeSpec a comma separated list of filenames to exclude.\n\t * @return a directory reference to the newly created directory.\n\t * @throws StfException if there is an internal error.\n\t */\t\n\tpublic DirectoryRef doCpDir(String comment, DirectoryRef sourceDir, DirectoryRef destDir, String includeSpec,\n\t\t\tString excludeSpec) throws StfException {\n\t\tif (includeSpec == null && excludeSpec == null) {\n\t\t\treturn doCpDir(comment, sourceDir, destDir);\n\t\t}\n\t\t\n\t\tString formattedIncludeList = formatCommaSeparatedList(includeSpec);; \n\t\tString formattedExcludeList = formatCommaSeparatedList(excludeSpec);\n\t\t\n\t\tgenerator.startNewCommand(comment, \"cpDir\", \"Partial directory copy. Only matching files copied.\",\n\t\t\t\t\"Source dir:\", sourceDir.getSpec(), \n\t\t\t\t\"Dest dir:\", destDir.getSpec(), \n\t\t\t\t\"Extensions:\", formattedIncludeList, \n\t\t\t\t\"Excludes:\", formattedExcludeList);\n\t\t\n\t\treturn runCpDir(comment, sourceDir, destDir, formattedIncludeList, formattedExcludeList);\n\t}\n\t\n\t\n\t/**\n\t * Private utility method that copies a source directory to a destination directory after applying \n\t * filters to include and exclude files. This method is used by doCpDir() and doCreateProjectJar() methods. \n\t * */\n\tprivate DirectoryRef runCpDir(String comment, DirectoryRef sourceDir, DirectoryRef destDir, String includeList,\n\t\t\tString excludeList) throws StfException {\n\t\tif (includeList != null && excludeList != null) {\n\t\t\tgenerator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"',\"\n\t\t\t\t\t+ \"includeList => \" + includeList + \", excludelist => \" + excludeList + \");\");\n\t\t} else if (includeList == null && excludeList != null) {\n\t\t\tgenerator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"',\"\n\t\t\t\t\t+ \"excludelist => \" + excludeList + \");\");\n\t\t} else if (includeList != null && excludeList == null) {\n\t\t\tgenerator.outputLine(\"$rc = stf::stfUtility->copyTree(from => '\" + sourceDir + \"', to => '\" + destDir + \"',\"\n\t\t\t\t\t+ \"includeList => \" + includeList + \");\");\n\t\t} else {\n\t\t\tthrow new StfException (\"Wrong argument supplied for include list and / or exclude list\");\n\t\t}\n\t\textensionBase.outputFailIfTrue(\"cpDir\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\n\t\treturn destDir;\n\t}"
    },
    "187": {
      "metadata": {
        "chunk_id": "07ecc7394118c990ae6fca79190b0f6926b2631936a262cd5b41e3884a9c5399",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "return destDir;\n\t}\n\n\t\n\t/**\n\t * Explicitly changes access permission in a given folder using chmod command.\n\t * @param comment is a short summary describing why the test is explicitly changing permissions.\n\t * @param targetDir is the directory where permission is to be changed. \n\t * @param modeBits is the Numeric notation of permission modes, e.g., 777. \n\t * @param isRecursive is the flag set if chmod is to be applied recursively in the given directory. \n\t * @throws StfException is thrown if there is an internal error. \n\t */\n\tpublic void doChmod(String comment, DirectoryRef targetDir, String modeBits, Boolean isRecursive) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"chmod\", \"Change file permission\", \"targetDir:\", targetDir.getSpec(), \"modeBits:\", modeBits);\n\t\tString command = \"system('\" + \"chmod\";\n\t\tif (isRecursive) { \n\t\t\tcommand = command + \" -R\";\n\t\t}\n\t\tcommand = command + \" \" + modeBits  + \" \\\"\" + targetDir + \"\\\"\" + \"')\";\n\t\t\n\t\tgenerator.outputLine(\"$rc = \" + command + \";\");\n\t\textensionBase.outputFailIfTrue(\"chmod\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t}\n\n\n\t/**\n\t * Explicitly changes access permission to a given file.\n\t * @param comment is a short summary describing why the test is explicitly changing permissions.\n\t * @param targetFile is the file whose permission is to be changed. \n\t * @param modeBits is the Numeric notation of permission modes, e.g., 777. \n\t * @throws StfException is thrown if there is an internal error. \n\t */\n\tpublic void doChmod(String comment, FileRef targetFile, String modeBits) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"chmod\", \"Change file permission\", \"targetFile:\", targetFile.getSpec(), \"modeBits:\", modeBits);\n\t\tif (PlatformFinder.isLinux() || PlatformFinder.isAix() || PlatformFinder.isZOS() || PlatformFinder.isOSX() || PlatformFinder.isSolaris()) {\n\t\t\t String command = \"system('\" + \"chmod\";\n\t\t\t command = command + \" \" + modeBits  + \" \\\"\" + targetFile+ \"\\\"\" + \"')\";\n\t\t\t generator.outputLine(\"$rc = \" + command + \";\");\n\t\t\t extensionBase.outputFailIfTrue(\"chmod\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t\t} else if (PlatformFinder.isWindows()) {\n\t\t    if (modeBits.equals(\"600\")) {\n\t\t    \tString currentUser = System.getProperty(\"user.name\");\n\t\t    \tString targetFilePath = targetFile.getSpec().replace(\"/\",\"\\\\\"); // Make sure we have Windows style slashes before issuing icacls commands\n\t\t    \trunCmd(\"Remove inherited permission for jmxremote.password file\", \"system('icacls \" + targetFilePath + \" /inheritance:r')\");\n\t\t\t    runCmd(\"Re-assign ownership for jmxremote.password file\", \"system('takeown /f \" + targetFilePath +\"')\");\n\t\t\t    runCmd(\"Grant restricted ownership to current user\", \"system('icacls \" + targetFilePath + \" /grant \" + currentUser + \":(r,w)')\");\n\t\t    } else {\n\t\t        throw new StfException(\"Unsupported mode...\");\n\t\t    }\n\t\t} else {\n\t\t    throw new StfError(\"Unsported platform...\");\n\t\t}\n\t}\n\t\n\t\n\t// Helper method to run arbitrary commands \n\tprivate void runCmd(String comment, String commandToRun) throws StfException {\n\t\tgenerator.outputLine(\"$rc = \" + commandToRun + \";\");\n\t\textensionBase.outputFailIfTrue(commandToRun, comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t}\n\t\n\t\n\t/**\n\t * Create a new directory.\n\t * This is equivalent to the Unix mkdir command.\n\t * The mkdir command will fail at runtime if targetDir cannot be created.\n\t * \n\t * @param comment is a short summary describing why the test is creating a new directory.\n\t * @param targetDir is the directory to create.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doMkdir(String comment, DirectoryRef targetDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"mkdir\", \"Create new directory\", \"Directory:\", targetDir.getSpec());\n\t\tgenerator.outputLine(\"$rc = mkpath( \" + \"'\" + targetDir.toString() + \"', {error => \\\\$err} );\");\n\t\textensionBase.outputErrorCheck(\"mkdir\", comment, \"@$err\");\n\t}",
        "start_line": 345,
        "end_line": 420,
        "chunk_index": 5,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 968,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994467"
      },
      "text": "return destDir;\n\t}\n\n\t\n\t/**\n\t * Explicitly changes access permission in a given folder using chmod command.\n\t * @param comment is a short summary describing why the test is explicitly changing permissions.\n\t * @param targetDir is the directory where permission is to be changed. \n\t * @param modeBits is the Numeric notation of permission modes, e.g., 777. \n\t * @param isRecursive is the flag set if chmod is to be applied recursively in the given directory. \n\t * @throws StfException is thrown if there is an internal error. \n\t */\n\tpublic void doChmod(String comment, DirectoryRef targetDir, String modeBits, Boolean isRecursive) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"chmod\", \"Change file permission\", \"targetDir:\", targetDir.getSpec(), \"modeBits:\", modeBits);\n\t\tString command = \"system('\" + \"chmod\";\n\t\tif (isRecursive) { \n\t\t\tcommand = command + \" -R\";\n\t\t}\n\t\tcommand = command + \" \" + modeBits  + \" \\\"\" + targetDir + \"\\\"\" + \"')\";\n\t\t\n\t\tgenerator.outputLine(\"$rc = \" + command + \";\");\n\t\textensionBase.outputFailIfTrue(\"chmod\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t}\n\n\n\t/**\n\t * Explicitly changes access permission to a given file.\n\t * @param comment is a short summary describing why the test is explicitly changing permissions.\n\t * @param targetFile is the file whose permission is to be changed. \n\t * @param modeBits is the Numeric notation of permission modes, e.g., 777. \n\t * @throws StfException is thrown if there is an internal error. \n\t */\n\tpublic void doChmod(String comment, FileRef targetFile, String modeBits) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"chmod\", \"Change file permission\", \"targetFile:\", targetFile.getSpec(), \"modeBits:\", modeBits);\n\t\tif (PlatformFinder.isLinux() || PlatformFinder.isAix() || PlatformFinder.isZOS() || PlatformFinder.isOSX() || PlatformFinder.isSolaris()) {\n\t\t\t String command = \"system('\" + \"chmod\";\n\t\t\t command = command + \" \" + modeBits  + \" \\\"\" + targetFile+ \"\\\"\" + \"')\";\n\t\t\t generator.outputLine(\"$rc = \" + command + \";\");\n\t\t\t extensionBase.outputFailIfTrue(\"chmod\", comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t\t} else if (PlatformFinder.isWindows()) {\n\t\t    if (modeBits.equals(\"600\")) {\n\t\t    \tString currentUser = System.getProperty(\"user.name\");\n\t\t    \tString targetFilePath = targetFile.getSpec().replace(\"/\",\"\\\\\"); // Make sure we have Windows style slashes before issuing icacls commands\n\t\t    \trunCmd(\"Remove inherited permission for jmxremote.password file\", \"system('icacls \" + targetFilePath + \" /inheritance:r')\");\n\t\t\t    runCmd(\"Re-assign ownership for jmxremote.password file\", \"system('takeown /f \" + targetFilePath +\"')\");\n\t\t\t    runCmd(\"Grant restricted ownership to current user\", \"system('icacls \" + targetFilePath + \" /grant \" + currentUser + \":(r,w)')\");\n\t\t    } else {\n\t\t        throw new StfException(\"Unsupported mode...\");\n\t\t    }\n\t\t} else {\n\t\t    throw new StfError(\"Unsported platform...\");\n\t\t}\n\t}\n\t\n\t\n\t// Helper method to run arbitrary commands \n\tprivate void runCmd(String comment, String commandToRun) throws StfException {\n\t\tgenerator.outputLine(\"$rc = \" + commandToRun + \";\");\n\t\textensionBase.outputFailIfTrue(commandToRun, comment, \"$rc\", \"!=\", StfExitCodes.expected(0));\n\t}\n\t\n\t\n\t/**\n\t * Create a new directory.\n\t * This is equivalent to the Unix mkdir command.\n\t * The mkdir command will fail at runtime if targetDir cannot be created.\n\t * \n\t * @param comment is a short summary describing why the test is creating a new directory.\n\t * @param targetDir is the directory to create.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doMkdir(String comment, DirectoryRef targetDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"mkdir\", \"Create new directory\", \"Directory:\", targetDir.getSpec());\n\t\tgenerator.outputLine(\"$rc = mkpath( \" + \"'\" + targetDir.toString() + \"', {error => \\\\$err} );\");\n\t\textensionBase.outputErrorCheck(\"mkdir\", comment, \"@$err\");\n\t}"
    },
    "188": {
      "metadata": {
        "chunk_id": "a5955dd36889c5271d6813ac15aae7b0e3330dc53e4e9ecf3b9dbc3159eae076",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * Changes the current working directory.\n\t * This is equivalent to the Unix cd command.\n\t * The cd will fail at runtime if targetDir does not exist.\n\t * \n\t * @param comment is a short summary describing why the test is changing directory.\n\t * @param targetDir is the directory to move to.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doCd(String comment, DirectoryRef targetDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"cd\", \"Change current working directory\", \"To:\", targetDir.getSpec());\n\t\tgenerator.outputLine(\"$rc = chdir \" + \"'\" + targetDir + \"';\");\n\t\textensionBase.outputFailIfTrue(\"cd\", comment, \"$rc\", \"!=\", StfExitCodes.expected(1));\n\t}\n\n\t\n\t/**\n\t * Unpacks the contents of an archive into the current working directory.\n\t * This is a platform specific action.\n\t *   aix - unzips files with '.zip' extension.\n\t *   win - unzips files with '.zip' extension.\n\t *   other - uses tar to unpack '.tar.gz' or unzip to unpack '.zip' files.\n\t * The unpacking will fail at runtime if the archive does not exist, or if it \n\t * cannot be written to the current location (eg, permissions or lack of space).  \n\t * \n\t * @param comment is a short summary describing why the test is unpacking an archive.\n\t * @param zipFile is the archive to be unpacked.\n\t * @throws StfException asked to unpack an archive which is not supported for the current platform.\n\t */\n\tpublic void doUnzip(String comment, FileRef zipFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"unzip\", \"Unpack archive file\", \"Archive:\", zipFile.getSpec());\n\t\t\n\t\tCommandDetails command;\n\t\tString mnemonic = \"UZIP\";\n\t\t\n\t\tif (!PlatformFinder.isWindows()) {\n\t\t\tif (PlatformFinder.isAix()) {\n\t\t\t    // On aix expect zips only and unzip with \"unzip -qq -o -C <file>\n\t\t\t\tgenerator.verify(zipFile.getSpec().endsWith(\".zip\") , \"archive must end with .zip extension: \" + zipFile);\n\t\t\t\tcommand = generator.buildCommand(mnemonic, 1, null, \"unzip\", \"-qq\", \"-o\", \"-C\", zipFile.getSpec());\n\t\t   \t} else if (zipFile.getSpec().endsWith(\".tar.gz\")) {\n\t\t\t    // Any other unix untar tar files with tar -xzf <file>\n\t\t\t\tcommand = generator.buildCommand(mnemonic, 1, null, \"tar\", \"-xzf\", zipFile.getSpec());\n\t   \t\t} else if (zipFile.getSpec().endsWith(\".zip\")) {\n\t\t\t    // Or unzip zip files with unzip - o <file>\n\t\t\t\tcommand = generator.buildCommand(mnemonic, 1, null, \"unzip\", \"-o\", zipFile.getSpec());\n\t   \t\t} else {\n\t   \t\t\tthrow new StfException(\"Unexpected archive type: \" + zipFile);\n\t   \t\t}\n\t\t} else {\n\t\t    // On Windows we can unpack with the JDK jar program\n\t\t\tgenerator.verify(zipFile.getSpec().endsWith(\".zip\"), \"archive must end with .zip extension: \" + zipFile);\n\t\t\tString program = environmentCore.getJavaHome().childFile(\"bin/jar\").getSpec();\n\t\t\tcommand = generator.buildCommand(mnemonic, 1, comment, program, \"-xf\", zipFile.getSpec());\n\t\t}\n\n\t\t// Generate perl to unpack the archive\n\t\tSystemProcessDefinition processDefinition = createSystemProcessDefinition()\n\t\t\t\t.setProcessName(command.getExecutableName())\n\t\t\t\t.addArg(command.getArgs());\n\t\textensionBase.runForegroundProcess(comment, mnemonic, ECHO_ON, ExpectedOutcome.cleanRun().within(\"15m\"), processDefinition);\n\t}\n\n\t\n\t/**\n\t * Creates a new file with the specified content.\n\t * In general the test should build up the full string of the files contents and then \n\t * write it one operation with this action.\n\t * The file write will fail at runtime if the output file cannot be created. \n\t * \n\t * @param comment is a short summary describing why the test creating a new file.\n\t * @param outputFile is the file to be created.\n\t * @param fileContents is the content to write to the file.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doWriteFile(String comment, FileRef outputFile, String fileContents) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"writeFile\", \"Create new file\", \"File:\", outputFile.getSpec());",
        "start_line": 421,
        "end_line": 497,
        "chunk_index": 6,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 990,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994470"
      },
      "text": "/**\n\t * Changes the current working directory.\n\t * This is equivalent to the Unix cd command.\n\t * The cd will fail at runtime if targetDir does not exist.\n\t * \n\t * @param comment is a short summary describing why the test is changing directory.\n\t * @param targetDir is the directory to move to.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doCd(String comment, DirectoryRef targetDir) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"cd\", \"Change current working directory\", \"To:\", targetDir.getSpec());\n\t\tgenerator.outputLine(\"$rc = chdir \" + \"'\" + targetDir + \"';\");\n\t\textensionBase.outputFailIfTrue(\"cd\", comment, \"$rc\", \"!=\", StfExitCodes.expected(1));\n\t}\n\n\t\n\t/**\n\t * Unpacks the contents of an archive into the current working directory.\n\t * This is a platform specific action.\n\t *   aix - unzips files with '.zip' extension.\n\t *   win - unzips files with '.zip' extension.\n\t *   other - uses tar to unpack '.tar.gz' or unzip to unpack '.zip' files.\n\t * The unpacking will fail at runtime if the archive does not exist, or if it \n\t * cannot be written to the current location (eg, permissions or lack of space).  \n\t * \n\t * @param comment is a short summary describing why the test is unpacking an archive.\n\t * @param zipFile is the archive to be unpacked.\n\t * @throws StfException asked to unpack an archive which is not supported for the current platform.\n\t */\n\tpublic void doUnzip(String comment, FileRef zipFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"unzip\", \"Unpack archive file\", \"Archive:\", zipFile.getSpec());\n\t\t\n\t\tCommandDetails command;\n\t\tString mnemonic = \"UZIP\";\n\t\t\n\t\tif (!PlatformFinder.isWindows()) {\n\t\t\tif (PlatformFinder.isAix()) {\n\t\t\t    // On aix expect zips only and unzip with \"unzip -qq -o -C <file>\n\t\t\t\tgenerator.verify(zipFile.getSpec().endsWith(\".zip\") , \"archive must end with .zip extension: \" + zipFile);\n\t\t\t\tcommand = generator.buildCommand(mnemonic, 1, null, \"unzip\", \"-qq\", \"-o\", \"-C\", zipFile.getSpec());\n\t\t   \t} else if (zipFile.getSpec().endsWith(\".tar.gz\")) {\n\t\t\t    // Any other unix untar tar files with tar -xzf <file>\n\t\t\t\tcommand = generator.buildCommand(mnemonic, 1, null, \"tar\", \"-xzf\", zipFile.getSpec());\n\t   \t\t} else if (zipFile.getSpec().endsWith(\".zip\")) {\n\t\t\t    // Or unzip zip files with unzip - o <file>\n\t\t\t\tcommand = generator.buildCommand(mnemonic, 1, null, \"unzip\", \"-o\", zipFile.getSpec());\n\t   \t\t} else {\n\t   \t\t\tthrow new StfException(\"Unexpected archive type: \" + zipFile);\n\t   \t\t}\n\t\t} else {\n\t\t    // On Windows we can unpack with the JDK jar program\n\t\t\tgenerator.verify(zipFile.getSpec().endsWith(\".zip\"), \"archive must end with .zip extension: \" + zipFile);\n\t\t\tString program = environmentCore.getJavaHome().childFile(\"bin/jar\").getSpec();\n\t\t\tcommand = generator.buildCommand(mnemonic, 1, comment, program, \"-xf\", zipFile.getSpec());\n\t\t}\n\n\t\t// Generate perl to unpack the archive\n\t\tSystemProcessDefinition processDefinition = createSystemProcessDefinition()\n\t\t\t\t.setProcessName(command.getExecutableName())\n\t\t\t\t.addArg(command.getArgs());\n\t\textensionBase.runForegroundProcess(comment, mnemonic, ECHO_ON, ExpectedOutcome.cleanRun().within(\"15m\"), processDefinition);\n\t}\n\n\t\n\t/**\n\t * Creates a new file with the specified content.\n\t * In general the test should build up the full string of the files contents and then \n\t * write it one operation with this action.\n\t * The file write will fail at runtime if the output file cannot be created. \n\t * \n\t * @param comment is a short summary describing why the test creating a new file.\n\t * @param outputFile is the file to be created.\n\t * @param fileContents is the content to write to the file.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doWriteFile(String comment, FileRef outputFile, String fileContents) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"writeFile\", \"Create new file\", \"File:\", outputFile.getSpec());"
    },
    "189": {
      "metadata": {
        "chunk_id": "7f30bedca8b9aec2455621572e8e778ff9eb6bcc4e7a93215dab1e4d91a186d1",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * Creates a new file with the specified content.\n\t * In general the test should build up the full string of the files contents and then \n\t * write it one operation with this action.\n\t * The file write will fail at runtime if the output file cannot be created. \n\t * \n\t * @param comment is a short summary describing why the test creating a new file.\n\t * @param outputFile is the file to be created.\n\t * @param fileContents is the content to write to the file.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doWriteFile(String comment, FileRef outputFile, String fileContents) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"writeFile\", \"Create new file\", \"File:\", outputFile.getSpec());\n\n\t\t// Double back slash needs to be replaced with 4 backslashes, so that generated file contains 2 backslashes\n\t\tStringBuilder contents = new StringBuilder(fileContents.replace(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")); \n\t\t\n\t\tgenerator.outputLine(\"stf::stfUtility->writeToFile(file => '\" + outputFile.getSpec() + \"', \");\n\t\tgenerator.outputLine(\"            content => ['\" + contents + \"']);\");\n\t}\n\n\n\t/**\n\t * Generates perl code to run iconv against a file.\n\t * \n\t * @param comment is a short summary describing why the test creating a new file.\n\t * @param file is the file to be converted.\n\t * @param fromCharset is the character set to convert from.\n\t * @param toCharset is the character set to convert to.\n\t * @throws StfException if there is an internal error.\n\t */\n    public void doIconvFile(String comment, String fromFullPath, String fromCharset, String toCharset) throws StfException {\n        generator.startNewCommand(comment, \"iconvFile\", \"Convert file:\", \"File:\", fromFullPath, \", fromCharset:\", fromCharset, \", toCharset:\", toCharset);\n\n        CommandDetails command;\n        String mnemonic = \"ICNV\";\n        FileRef fromFile = environmentCore.createFileRef(fromFullPath);\n        DirectoryRef tempdir  = environmentCore.createDirectoryRef(System.getProperty(\"java.io.tmpdir\"));\n\n        FileRef tempfile = doCp(\"Copy \" + fromFullPath + \" to \" + tempdir, fromFile, tempdir);\n\n        command = generator.buildCommand(mnemonic, 1, comment, \"iconv\", \"-f\", fromCharset, \"-t\", toCharset, tempfile.getSpec(), \">\" + fromFullPath );\n\n        // Generate perl to run iconv\n        SystemProcessDefinition processDefinition = createSystemProcessDefinition()\n                        .setProcessName(command.getExecutableName())\n                        .addArg(command.getArgs());\n        extensionBase.runForegroundProcess(comment, mnemonic, ECHO_ON, ExpectedOutcome.cleanRun().within(\"15m\"), processDefinition);\n}\n\t/**\n\t * Generates perl code so that tests can echo the contents of a file.\n\t * If the file cannot be opened then all running processes are killed and the test fails.\n\t * @param comment is a short summary describing why the test creating a new file.\n\t * @param targetFile points to the file to be echoed.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doEchoFile(String comment, FileRef targetFile) throws StfException {\n\t\textensionBase.outputEchoFile(targetFile);\n\t}",
        "start_line": 498,
        "end_line": 556,
        "chunk_index": 7,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 708,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994473"
      },
      "text": "/**\n\t * Creates a new file with the specified content.\n\t * In general the test should build up the full string of the files contents and then \n\t * write it one operation with this action.\n\t * The file write will fail at runtime if the output file cannot be created. \n\t * \n\t * @param comment is a short summary describing why the test creating a new file.\n\t * @param outputFile is the file to be created.\n\t * @param fileContents is the content to write to the file.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doWriteFile(String comment, FileRef outputFile, String fileContents) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"writeFile\", \"Create new file\", \"File:\", outputFile.getSpec());\n\n\t\t// Double back slash needs to be replaced with 4 backslashes, so that generated file contains 2 backslashes\n\t\tStringBuilder contents = new StringBuilder(fileContents.replace(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")); \n\t\t\n\t\tgenerator.outputLine(\"stf::stfUtility->writeToFile(file => '\" + outputFile.getSpec() + \"', \");\n\t\tgenerator.outputLine(\"            content => ['\" + contents + \"']);\");\n\t}\n\n\n\t/**\n\t * Generates perl code to run iconv against a file.\n\t * \n\t * @param comment is a short summary describing why the test creating a new file.\n\t * @param file is the file to be converted.\n\t * @param fromCharset is the character set to convert from.\n\t * @param toCharset is the character set to convert to.\n\t * @throws StfException if there is an internal error.\n\t */\n    public void doIconvFile(String comment, String fromFullPath, String fromCharset, String toCharset) throws StfException {\n        generator.startNewCommand(comment, \"iconvFile\", \"Convert file:\", \"File:\", fromFullPath, \", fromCharset:\", fromCharset, \", toCharset:\", toCharset);\n\n        CommandDetails command;\n        String mnemonic = \"ICNV\";\n        FileRef fromFile = environmentCore.createFileRef(fromFullPath);\n        DirectoryRef tempdir  = environmentCore.createDirectoryRef(System.getProperty(\"java.io.tmpdir\"));\n\n        FileRef tempfile = doCp(\"Copy \" + fromFullPath + \" to \" + tempdir, fromFile, tempdir);\n\n        command = generator.buildCommand(mnemonic, 1, comment, \"iconv\", \"-f\", fromCharset, \"-t\", toCharset, tempfile.getSpec(), \">\" + fromFullPath );\n\n        // Generate perl to run iconv\n        SystemProcessDefinition processDefinition = createSystemProcessDefinition()\n                        .setProcessName(command.getExecutableName())\n                        .addArg(command.getArgs());\n        extensionBase.runForegroundProcess(comment, mnemonic, ECHO_ON, ExpectedOutcome.cleanRun().within(\"15m\"), processDefinition);\n}\n\t/**\n\t * Generates perl code so that tests can echo the contents of a file.\n\t * If the file cannot be opened then all running processes are killed and the test fails.\n\t * @param comment is a short summary describing why the test creating a new file.\n\t * @param targetFile points to the file to be echoed.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doEchoFile(String comment, FileRef targetFile) throws StfException {\n\t\textensionBase.outputEchoFile(targetFile);\n\t}"
    },
    "190": {
      "metadata": {
        "chunk_id": "5342f66e7f78236d29381b3b0fcff00b403496ebb28f1d35c845fd0a85cc7145",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * Apply text replacement to an existing file.\n\t * The test will fail at runtime if the file does not exist.\n\t * It will also fail at runtime if the actual number of replacements does not\n\t * match the expected number. This expected vs. actual runtime check is done \n\t * so as to add as much checking as possible that a test run is going as expected, and\n\t * also prevents stale test code which is attempting an edit which no longer actually\n\t * does any replacements.\n\t * \n\t * @param comment is a short summary describing why the test is editing the file.\n\t * @param file is the file to edit.\n\t * @param sourceText is the text to be replaced.\n\t * @param replacementText is the text to use instead of the sourceText.\n\t * @param expectedNumReplacements is the number of replacements that the test expects to be done.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doFileEdit(String comment, FileRef file, String sourceText, String replacementText, int expectedNumReplacements) throws StfException {\n\t\tint commandNum = generator.startNewCommand(comment, \"FileEdit\", \"Automated file edit\",\n\t\t\t\t\t\"File:\",    file.getSpec(),\n\t\t\t\t\t\"Search:\",  sourceText,\n\t\t\t\t\t\"Replace:\", replacementText);\n\t\t\n\t\tString countVariable = \"$count\" + commandNum;\n\t\tgenerator.outputLine(\"my \" + countVariable + \" = stf::stfUtility->searchReplace(\");\n\t\tgenerator.outputLine(\"                    file => '\" + file.getSpec() + \"',\");\n\t\tgenerator.outputLine(\"                    search => '\" + sourceText + \"',\");\n\t\tgenerator.outputLine(\"                    replace => '\" + replacementText + \"');\");\n\t\textensionBase.outputFailIfTrue(\"FileEdit\", comment, countVariable, \"!=\", expectedNumReplacements);\n\t}",
        "start_line": 557,
        "end_line": 585,
        "chunk_index": 8,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 397,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994476"
      },
      "text": "/**\n\t * Apply text replacement to an existing file.\n\t * The test will fail at runtime if the file does not exist.\n\t * It will also fail at runtime if the actual number of replacements does not\n\t * match the expected number. This expected vs. actual runtime check is done \n\t * so as to add as much checking as possible that a test run is going as expected, and\n\t * also prevents stale test code which is attempting an edit which no longer actually\n\t * does any replacements.\n\t * \n\t * @param comment is a short summary describing why the test is editing the file.\n\t * @param file is the file to edit.\n\t * @param sourceText is the text to be replaced.\n\t * @param replacementText is the text to use instead of the sourceText.\n\t * @param expectedNumReplacements is the number of replacements that the test expects to be done.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic void doFileEdit(String comment, FileRef file, String sourceText, String replacementText, int expectedNumReplacements) throws StfException {\n\t\tint commandNum = generator.startNewCommand(comment, \"FileEdit\", \"Automated file edit\",\n\t\t\t\t\t\"File:\",    file.getSpec(),\n\t\t\t\t\t\"Search:\",  sourceText,\n\t\t\t\t\t\"Replace:\", replacementText);\n\t\t\n\t\tString countVariable = \"$count\" + commandNum;\n\t\tgenerator.outputLine(\"my \" + countVariable + \" = stf::stfUtility->searchReplace(\");\n\t\tgenerator.outputLine(\"                    file => '\" + file.getSpec() + \"',\");\n\t\tgenerator.outputLine(\"                    search => '\" + sourceText + \"',\");\n\t\tgenerator.outputLine(\"                    replace => '\" + replacementText + \"');\");\n\t\textensionBase.outputFailIfTrue(\"FileEdit\", comment, countVariable, \"!=\", expectedNumReplacements);\n\t}"
    },
    "191": {
      "metadata": {
        "chunk_id": "082ed08e2786128c9083e9850211449d9af0d50c5dadafc1df10d74a1dbc964d",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * Creates a process definition to run JUnit tests.\n\t * \n\t * The caller can then decide on how to execute the tests: synchronously or \n\t * asynchronously, number of instances, expected run time, etc).\n\t * This model also allows the caller to add extra jar files, etc, to the \n\t * process definition.\n\t * See SampleJUnitTestRun.java for an example.\n\t * \n\t * The test fails at runtime if the JUnit test run fails, due to one or \n\t * more of the JUnits tests failing.  \n\t * \n\t * Tests known to fail for valid reasons can be treated as a non-fatal error\n\t * by adding them in the testExclusions file. Each line of the file contains \n\t * a rule describing one ore more tests which are allowed to fail. See STF \n\t * documentation for a full description of the rules. In it's simplest form \n\t * it lists individually failing tests. eg:\n\t *    test=outOfMemoryTest\n\t * There are many ways in which this action can fail at runtime:\n\t *   - classpath error. eg project does not exist in the workspace.\n\t *   - one or more tests fail.\n\t *   - tests run for longer than their allowed duration.\n\t *\n\t * @param project is the name of a project which needs to be added to the classpath.\n\t * @param testExclusions is a reference to a file containing rules for matching\n\t * known failures, or null if there are no expected failures.\n\t * @param junitClasses is one or more classes containing JUnit tests.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic JavaProcessDefinition createJUnitProcessDefinition(String project, FileRef testExclusions, Class<?>... junitClasses) throws StfException {\n\t\tJavaProcessDefinition junitProcessDef = createJavaProcessDefinition()\n\t\t\t.addPrereqJarToClasspath(JarId.JUNIT)\n\t\t\t.addPrereqJarToClasspath(JarId.HAMCREST)\n\t\t\t.addProjectToClasspath(\"stf.core\")      // To run JUnitRunner\n\t\t\t.addProjectToClasspath(project)\n\t\t\t.runClass(JUnitRunner.class);      // STF utility class. Exit code indicates overall pass/fail\n\t\t\n\t    // If there is an exclusions file then it is the first argument to JUnitRunner\n\t    if (testExclusions != null) {\n\t    \tjunitProcessDef.addArg(testExclusions.getSpec());\n\t    }\n\t    \n\t\t// Add all the names of the actual JUnit test classes\n\t\tfor (Class<?> testClass : junitClasses) {\n\t\t\tjunitProcessDef.addArg(testClass.getName());\n\t\t}\n\t\t\n\t\tjunitProcessDef.resetStageChecking();\n\n\t\treturn junitProcessDef;\n\t}",
        "start_line": 586,
        "end_line": 636,
        "chunk_index": 9,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 590,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994478"
      },
      "text": "/**\n\t * Creates a process definition to run JUnit tests.\n\t * \n\t * The caller can then decide on how to execute the tests: synchronously or \n\t * asynchronously, number of instances, expected run time, etc).\n\t * This model also allows the caller to add extra jar files, etc, to the \n\t * process definition.\n\t * See SampleJUnitTestRun.java for an example.\n\t * \n\t * The test fails at runtime if the JUnit test run fails, due to one or \n\t * more of the JUnits tests failing.  \n\t * \n\t * Tests known to fail for valid reasons can be treated as a non-fatal error\n\t * by adding them in the testExclusions file. Each line of the file contains \n\t * a rule describing one ore more tests which are allowed to fail. See STF \n\t * documentation for a full description of the rules. In it's simplest form \n\t * it lists individually failing tests. eg:\n\t *    test=outOfMemoryTest\n\t * There are many ways in which this action can fail at runtime:\n\t *   - classpath error. eg project does not exist in the workspace.\n\t *   - one or more tests fail.\n\t *   - tests run for longer than their allowed duration.\n\t *\n\t * @param project is the name of a project which needs to be added to the classpath.\n\t * @param testExclusions is a reference to a file containing rules for matching\n\t * known failures, or null if there are no expected failures.\n\t * @param junitClasses is one or more classes containing JUnit tests.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic JavaProcessDefinition createJUnitProcessDefinition(String project, FileRef testExclusions, Class<?>... junitClasses) throws StfException {\n\t\tJavaProcessDefinition junitProcessDef = createJavaProcessDefinition()\n\t\t\t.addPrereqJarToClasspath(JarId.JUNIT)\n\t\t\t.addPrereqJarToClasspath(JarId.HAMCREST)\n\t\t\t.addProjectToClasspath(\"stf.core\")      // To run JUnitRunner\n\t\t\t.addProjectToClasspath(project)\n\t\t\t.runClass(JUnitRunner.class);      // STF utility class. Exit code indicates overall pass/fail\n\t\t\n\t    // If there is an exclusions file then it is the first argument to JUnitRunner\n\t    if (testExclusions != null) {\n\t    \tjunitProcessDef.addArg(testExclusions.getSpec());\n\t    }\n\t    \n\t\t// Add all the names of the actual JUnit test classes\n\t\tfor (Class<?> testClass : junitClasses) {\n\t\t\tjunitProcessDef.addArg(testClass.getName());\n\t\t}\n\t\t\n\t\tjunitProcessDef.resetStageChecking();\n\n\t\treturn junitProcessDef;\n\t}"
    },
    "192": {
      "metadata": {
        "chunk_id": "9b3ffd66822154755bfb7404c83e1ef0d772a87211af39eea47a7850b41209b8",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "return junitProcessDef;\n\t}\n\n\t\n\t/**\n\t * This method finds a tests resource file. \n\t * The resource file must be in the same directory as the test plugin.\n\t * \n\t * @return a FileRef of the named resource file.\n\t * @throws StfException if the resource file could not be found. \n\t */\n\tpublic FileRef locateResourceFile(String resourceFileName) throws StfException {\n\t\t// Finding the file is trickier than it perhaps should be, as it has to work it multiple \n\t\t// environments. Things are easy in the Eclipse workspace, as the resource file will have been \n\t\t// copied to the same bin directory as the plugins class, but not so easy when running \n\t\t// from a command line build as the resource file is not copied to the bin directory so need to \n\t\t// find it in the source directory.\n\t\t\n\t\tString testName = environmentCore.getProperty(Stf.ARG_TEST);\n\t\t\n\t\t// To find the resource file we need to know the class name for the test plugin.\n\t\t// This is done by looking at the stack traces.\n\t\t// Find the oldest method whose class name matches the current test name.\n\t\t// Note that we search backwards instead of forwards just in case the actual test \n\t\t// code has called another class with a similar name. \n\t\tint testMethodIndex = -1;\n        StackTraceElement[] stElements = Thread.currentThread().getStackTrace();\n        for (int i=stElements.length-1; i>0; i--) {\n        \tif (stElements[i].getClassName().endsWith(\".\"+testName)) {\n        \t\ttestMethodIndex = i;\n        \t}\n        }\n        \n        // Work out the source directory for the project containing the current test class\n        String testClassName = stElements[testMethodIndex].getClassName();\n        String projectBinDir = StfClassLoader.getProjectName(testClassName);\n\t\tFile projectDir = new File(projectBinDir).getParentFile();\n\t\tFile projectSrcDir = new File(projectDir, \"src\");\n\t\t\n\t\t// Step down into a java 9 style project directory which is at the top of the src dir\n\t\tFile[] sourceRootCandidates = projectSrcDir.listFiles();\n\t\tif (sourceRootCandidates.length != 1) {\n\t\t\tthrow new StfException(\"Unexpectedly found more than one file/directory in the project source at: \" + projectSrcDir.getAbsolutePath());\n\t\t}\n\t\tFile sourceRoot = sourceRootCandidates[0];\n\t\t\n\t\t// Build the path to the test source file\n\t\tString packagePath = stElements[testMethodIndex].getClassName().replace(\".\", \"/\");\n\t\tFile sourceFile = new File(sourceRoot, packagePath + \".java\");\n\t\tif (!sourceFile.exists()) {\n\t\t\tthrow new StfException(\"Failed to find test source code at:\" + sourceFile.getAbsolutePath());\n\t\t}\n\t\t\n\t\t// Now look for the resource file in the same directory as the source file\n\t\tFile resourceFile = new File(sourceFile.getParentFile(), resourceFileName);\n\t\tif (!resourceFile.exists()) {\n\t\t\tthrow new StfException(\"Failed to find resource file at:\" + resourceFile.getAbsolutePath());\n\t\t}\n\t\t\n\t\treturn environmentCore.createFileRef(resourceFile.getAbsolutePath().replace(\"\\\\\", \"/\"));\n\t}",
        "start_line": 637,
        "end_line": 697,
        "chunk_index": 10,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 677,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994481"
      },
      "text": "return junitProcessDef;\n\t}\n\n\t\n\t/**\n\t * This method finds a tests resource file. \n\t * The resource file must be in the same directory as the test plugin.\n\t * \n\t * @return a FileRef of the named resource file.\n\t * @throws StfException if the resource file could not be found. \n\t */\n\tpublic FileRef locateResourceFile(String resourceFileName) throws StfException {\n\t\t// Finding the file is trickier than it perhaps should be, as it has to work it multiple \n\t\t// environments. Things are easy in the Eclipse workspace, as the resource file will have been \n\t\t// copied to the same bin directory as the plugins class, but not so easy when running \n\t\t// from a command line build as the resource file is not copied to the bin directory so need to \n\t\t// find it in the source directory.\n\t\t\n\t\tString testName = environmentCore.getProperty(Stf.ARG_TEST);\n\t\t\n\t\t// To find the resource file we need to know the class name for the test plugin.\n\t\t// This is done by looking at the stack traces.\n\t\t// Find the oldest method whose class name matches the current test name.\n\t\t// Note that we search backwards instead of forwards just in case the actual test \n\t\t// code has called another class with a similar name. \n\t\tint testMethodIndex = -1;\n        StackTraceElement[] stElements = Thread.currentThread().getStackTrace();\n        for (int i=stElements.length-1; i>0; i--) {\n        \tif (stElements[i].getClassName().endsWith(\".\"+testName)) {\n        \t\ttestMethodIndex = i;\n        \t}\n        }\n        \n        // Work out the source directory for the project containing the current test class\n        String testClassName = stElements[testMethodIndex].getClassName();\n        String projectBinDir = StfClassLoader.getProjectName(testClassName);\n\t\tFile projectDir = new File(projectBinDir).getParentFile();\n\t\tFile projectSrcDir = new File(projectDir, \"src\");\n\t\t\n\t\t// Step down into a java 9 style project directory which is at the top of the src dir\n\t\tFile[] sourceRootCandidates = projectSrcDir.listFiles();\n\t\tif (sourceRootCandidates.length != 1) {\n\t\t\tthrow new StfException(\"Unexpectedly found more than one file/directory in the project source at: \" + projectSrcDir.getAbsolutePath());\n\t\t}\n\t\tFile sourceRoot = sourceRootCandidates[0];\n\t\t\n\t\t// Build the path to the test source file\n\t\tString packagePath = stElements[testMethodIndex].getClassName().replace(\".\", \"/\");\n\t\tFile sourceFile = new File(sourceRoot, packagePath + \".java\");\n\t\tif (!sourceFile.exists()) {\n\t\t\tthrow new StfException(\"Failed to find test source code at:\" + sourceFile.getAbsolutePath());\n\t\t}\n\t\t\n\t\t// Now look for the resource file in the same directory as the source file\n\t\tFile resourceFile = new File(sourceFile.getParentFile(), resourceFileName);\n\t\tif (!resourceFile.exists()) {\n\t\t\tthrow new StfException(\"Failed to find resource file at:\" + resourceFile.getAbsolutePath());\n\t\t}\n\t\t\n\t\treturn environmentCore.createFileRef(resourceFile.getAbsolutePath().replace(\"\\\\\", \"/\"));\n\t}"
    },
    "193": {
      "metadata": {
        "chunk_id": "42ab61ac9123947a4939dec3a58b811f3909c70460f73f170738635bb006e0fb",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * This method is used to check to see if a test has passed or failed. \n\t * It applies a result filter file and checks to see if all tests passed.\n\t * The filter file allows a test to run, and pass, with known issues.\n\t * \n\t * The steps performed are:\n\t *  1) Search the result directory for .tr files. \n\t *  2) Read in all .tr result files.\n\t *  3) Read in the filter file. \n\t *  4) Report test pass/fail numbers before filtering\n\t *  5) Examine test results, with failing tests being matched against every filter rule.\n\t *     Failing tests which match a filter are promoted to a pass.\n\t *  6) Report post filtering pass/fail numbers.\n\t *  7) Set process exit code to 0 if all tests passed, otherwise 1.\n\t * \n\t * @param comment is a brief description about what is happening.\n\t * @param resultsDirectory is a directory containing one or more '.tr' result files.\n\t * @param filterFileString Is the name of the filter file. It is also in '.tr' format.\n\t * @throws StfException If there was a problem reading the result or filter files.\n\t */\n\tpublic void doReportFilteredTestResults(String comment, DirectoryRef resultsDirectory, String filterFileString) throws StfException {\n\t\tFileRef filterFile = locateResourceFile(filterFileString);\n\t\t\n\t\tgenerator.startNewCommand(comment, \"report\", \"Analyse .tr test result files\",\n\t\t\t\t\t\t\"Mnemonic:\",    \"RTR\",\n\t\t\t\t\t\t\"Results dir:\", resultsDirectory.getSpec(),\n\t\t\t\t\t\t\"Filter file:\", filterFile.getSpec());\n\n\t\t// New examine the xml results file to see if all tests have passed\n\t\textensionBase.runForegroundProcess(comment, \"RTR\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"), \n\t\t\t\tcreateJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf\")\n\t\t\t\t\t.runClass(ReportFilteredTestResults.class)\n\t\t\t\t\t.addArg(resultsDirectory.getSpec())   // arg1 - the directory containing the .tr result files\n\t\t\t\t\t.addArg(filterFile.getSpec()));       // arg2 - local exclusions file\n\t}",
        "start_line": 698,
        "end_line": 733,
        "chunk_index": 11,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 486,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994483"
      },
      "text": "/**\n\t * This method is used to check to see if a test has passed or failed. \n\t * It applies a result filter file and checks to see if all tests passed.\n\t * The filter file allows a test to run, and pass, with known issues.\n\t * \n\t * The steps performed are:\n\t *  1) Search the result directory for .tr files. \n\t *  2) Read in all .tr result files.\n\t *  3) Read in the filter file. \n\t *  4) Report test pass/fail numbers before filtering\n\t *  5) Examine test results, with failing tests being matched against every filter rule.\n\t *     Failing tests which match a filter are promoted to a pass.\n\t *  6) Report post filtering pass/fail numbers.\n\t *  7) Set process exit code to 0 if all tests passed, otherwise 1.\n\t * \n\t * @param comment is a brief description about what is happening.\n\t * @param resultsDirectory is a directory containing one or more '.tr' result files.\n\t * @param filterFileString Is the name of the filter file. It is also in '.tr' format.\n\t * @throws StfException If there was a problem reading the result or filter files.\n\t */\n\tpublic void doReportFilteredTestResults(String comment, DirectoryRef resultsDirectory, String filterFileString) throws StfException {\n\t\tFileRef filterFile = locateResourceFile(filterFileString);\n\t\t\n\t\tgenerator.startNewCommand(comment, \"report\", \"Analyse .tr test result files\",\n\t\t\t\t\t\t\"Mnemonic:\",    \"RTR\",\n\t\t\t\t\t\t\"Results dir:\", resultsDirectory.getSpec(),\n\t\t\t\t\t\t\"Filter file:\", filterFile.getSpec());\n\n\t\t// New examine the xml results file to see if all tests have passed\n\t\textensionBase.runForegroundProcess(comment, \"RTR\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"), \n\t\t\t\tcreateJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf\")\n\t\t\t\t\t.runClass(ReportFilteredTestResults.class)\n\t\t\t\t\t.addArg(resultsDirectory.getSpec())   // arg1 - the directory containing the .tr result files\n\t\t\t\t\t.addArg(filterFile.getSpec()));       // arg2 - local exclusions file\n\t}"
    },
    "194": {
      "metadata": {
        "chunk_id": "5ac448bd1504aafe627cc060d5c9e11bdabd5edf407ea75a5c81f454d33487c4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "// New examine the xml results file to see if all tests have passed\n\t\textensionBase.runForegroundProcess(comment, \"RTR\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"), \n\t\t\t\tcreateJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf\")\n\t\t\t\t\t.runClass(ReportFilteredTestResults.class)\n\t\t\t\t\t.addArg(resultsDirectory.getSpec())   // arg1 - the directory containing the .tr result files\n\t\t\t\t\t.addArg(filterFile.getSpec()));       // arg2 - local exclusions file\n\t}\n\n\n\t/**\n\t * Validates that a file exists.\n\t * The test run will fail if the file does not exist.\n\t * \n\t * @param comment is a brief description summarising why the test wants to do the validation.\n\t * @param targetFile is a reference to the file which must exist.\n\t * @throws StfException \n\t */\n\tpublic void doValidateFileExists(String comment, FileRef targetFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"fileCheck\", \"Validate file exists\", \"File:\", targetFile.getSpec());\n\t\t\n\t\tgenerator.outputLine(\"if (!-f '\" + targetFile.getSpec() + \"') {\");\n\t\tgenerator.increaseIndentation();\n\t\textensionBase.outputDieCommand(StfConstants.FAILURE_PREFIX \n\t\t\t\t\t+ \"at \" + generator.describeCommand(\"fileCheck\", comment) + \". \" \n\t\t\t\t\t+ \"File does not exist: \" + targetFile.getSpec());\n\t\tgenerator.decreaseIndentation();\n\t\tgenerator.outputLine(\"}\");\n\t\tgenerator.outputEmptyLine();\n\t}\n\t\n\t\n\t/**\n\t * Validates that a file does not exists\n\t * The test run will fail if the file exists.\n\t * \n\t * @param comment is a brief description summarising why the test wants to do the validation.\n\t * @param targetFile is a reference to the file which must not exist.\n\t * @throws StfException \n\t */\n\tpublic void doValidateFileAbsent(String comment, FileRef targetFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"fileCheck\", \"Validate file absent\", \"File:\", targetFile.getSpec());\n\t\t\n\t\tgenerator.outputLine(\"if (-f '\" + targetFile.getSpec() + \"') {\");\n\t\tgenerator.increaseIndentation();\n\t\textensionBase.outputDieCommand(StfConstants.FAILURE_PREFIX \n\t\t\t\t\t+ \"at \" + generator.describeCommand(\"fileCheck\", comment) + \". \" \n\t\t\t\t\t+ \"File exists: \" + targetFile.getSpec());\n\t\tgenerator.decreaseIndentation();\n\t\tgenerator.outputLine(\"}\");\n\t\tgenerator.outputEmptyLine();\n\t}\n\t\n\t\n\t/**\n\t * This step verifies that a display is available. If there is no display \n\t * configured then the test will fail.\n\t * Windows is assumed to always have a display attached.\n\t * \n\t * @param comment is a brief description about what is happening.\n\t * @throws StfException if perl code generation failed.\n\t */\n\tpublic void doVerifyDisplayAvailable(String comment) throws StfException {\n\t\tif (!PlatformFinder.isWindows()) {\n\t\t\tgenerator.startNewCommand(comment, \"display\", \"Verify display is available\");\n\t\t\n\t\t\tgenerator.outputLine(\"if (!defined $ENV{'DISPLAY'}) {\");\n\t\t\tgenerator.increaseIndentation();\n\t\t\textensionBase.outputDieCommand(StfConstants.FAILURE_PREFIX \n\t\t\t\t\t\t+ \"at \" + generator.describeCommand(\"display\", comment) + \". \" \n\t\t\t\t\t\t+ \"Display variable not set\");\n\t\t\tgenerator.decreaseIndentation();\n\t\t\tgenerator.outputLine(\"}\");\n\t\t\tgenerator.outputEmptyLine();\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Returns the java arguments that would be used when executing a java program\n\t * in the current phase.\n\t * This allows test automation code to verify that it is running with arguments\n\t * which are mandatory for that particular test.\n\t *\n\t * @return a string containing the java arguments to be used in the current setup/execute or teardown phase.\n\t * @throws StfException if invokes from the pluginInit() method.\n\t */\n\tpublic String getJavaArgs(JavaVersion jvm) throws StfException {\n\t\treturn generator.getBaseJvmOptions(jvm);\n\t}\n\n\n\t// Whenever a process is started the caller needs to decide if they want STF to\n\t// echo the output of the child process to the STF output.\n\t// Reference using: import static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.*;\n    public enum Echo { ECHO_ON, ECHO_OFF };",
        "start_line": 734,
        "end_line": 829,
        "chunk_index": 12,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 960,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994485"
      },
      "text": "// New examine the xml results file to see if all tests have passed\n\t\textensionBase.runForegroundProcess(comment, \"RTR\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"), \n\t\t\t\tcreateJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf\")\n\t\t\t\t\t.runClass(ReportFilteredTestResults.class)\n\t\t\t\t\t.addArg(resultsDirectory.getSpec())   // arg1 - the directory containing the .tr result files\n\t\t\t\t\t.addArg(filterFile.getSpec()));       // arg2 - local exclusions file\n\t}\n\n\n\t/**\n\t * Validates that a file exists.\n\t * The test run will fail if the file does not exist.\n\t * \n\t * @param comment is a brief description summarising why the test wants to do the validation.\n\t * @param targetFile is a reference to the file which must exist.\n\t * @throws StfException \n\t */\n\tpublic void doValidateFileExists(String comment, FileRef targetFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"fileCheck\", \"Validate file exists\", \"File:\", targetFile.getSpec());\n\t\t\n\t\tgenerator.outputLine(\"if (!-f '\" + targetFile.getSpec() + \"') {\");\n\t\tgenerator.increaseIndentation();\n\t\textensionBase.outputDieCommand(StfConstants.FAILURE_PREFIX \n\t\t\t\t\t+ \"at \" + generator.describeCommand(\"fileCheck\", comment) + \". \" \n\t\t\t\t\t+ \"File does not exist: \" + targetFile.getSpec());\n\t\tgenerator.decreaseIndentation();\n\t\tgenerator.outputLine(\"}\");\n\t\tgenerator.outputEmptyLine();\n\t}\n\t\n\t\n\t/**\n\t * Validates that a file does not exists\n\t * The test run will fail if the file exists.\n\t * \n\t * @param comment is a brief description summarising why the test wants to do the validation.\n\t * @param targetFile is a reference to the file which must not exist.\n\t * @throws StfException \n\t */\n\tpublic void doValidateFileAbsent(String comment, FileRef targetFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"fileCheck\", \"Validate file absent\", \"File:\", targetFile.getSpec());\n\t\t\n\t\tgenerator.outputLine(\"if (-f '\" + targetFile.getSpec() + \"') {\");\n\t\tgenerator.increaseIndentation();\n\t\textensionBase.outputDieCommand(StfConstants.FAILURE_PREFIX \n\t\t\t\t\t+ \"at \" + generator.describeCommand(\"fileCheck\", comment) + \". \" \n\t\t\t\t\t+ \"File exists: \" + targetFile.getSpec());\n\t\tgenerator.decreaseIndentation();\n\t\tgenerator.outputLine(\"}\");\n\t\tgenerator.outputEmptyLine();\n\t}\n\t\n\t\n\t/**\n\t * This step verifies that a display is available. If there is no display \n\t * configured then the test will fail.\n\t * Windows is assumed to always have a display attached.\n\t * \n\t * @param comment is a brief description about what is happening.\n\t * @throws StfException if perl code generation failed.\n\t */\n\tpublic void doVerifyDisplayAvailable(String comment) throws StfException {\n\t\tif (!PlatformFinder.isWindows()) {\n\t\t\tgenerator.startNewCommand(comment, \"display\", \"Verify display is available\");\n\t\t\n\t\t\tgenerator.outputLine(\"if (!defined $ENV{'DISPLAY'}) {\");\n\t\t\tgenerator.increaseIndentation();\n\t\t\textensionBase.outputDieCommand(StfConstants.FAILURE_PREFIX \n\t\t\t\t\t\t+ \"at \" + generator.describeCommand(\"display\", comment) + \". \" \n\t\t\t\t\t\t+ \"Display variable not set\");\n\t\t\tgenerator.decreaseIndentation();\n\t\t\tgenerator.outputLine(\"}\");\n\t\t\tgenerator.outputEmptyLine();\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Returns the java arguments that would be used when executing a java program\n\t * in the current phase.\n\t * This allows test automation code to verify that it is running with arguments\n\t * which are mandatory for that particular test.\n\t *\n\t * @return a string containing the java arguments to be used in the current setup/execute or teardown phase.\n\t * @throws StfException if invokes from the pluginInit() method.\n\t */\n\tpublic String getJavaArgs(JavaVersion jvm) throws StfException {\n\t\treturn generator.getBaseJvmOptions(jvm);\n\t}\n\n\n\t// Whenever a process is started the caller needs to decide if they want STF to\n\t// echo the output of the child process to the STF output.\n\t// Reference using: import static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.*;\n    public enum Echo { ECHO_ON, ECHO_OFF };"
    },
    "195": {
      "metadata": {
        "chunk_id": "c83e9e0dc56e44a12bc2ae75bbb5e3188489a99019e23e64039eb47f26854740",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "// Whenever a process is started the caller needs to decide if they want STF to\n\t// echo the output of the child process to the STF output.\n\t// Reference using: import static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.*;\n    public enum Echo { ECHO_ON, ECHO_OFF };\n\n\t\n\t/**\n\t * Synchronously runs a java process.\n\t * The test will fail at runtime if:\n\t *   - the process exits with a non-zero exit value.\n\t *   - the process completes, but the actual outcome does not match the expected outcome.\n\t *   - process runtime exceeds the expected runtime.\n\t * See SampleRunProcess.java for an example.\n\t * \n\t * @param comment is a brief summary describing why the test is running the process.\n\t * @param processMnemonic is a 3 letter code for this process. This is prefixed \n\t * to the processes output when echoed by STF.\n\t * @param echoSetting used to turn on/off echoing of process output. \n\t * @param expectedOutcome describes what the test expects to happen when executed, and \n\t * for specifies a maximum run time for processes which are going to complete. \n\t * For example, completes with exit-code 0, crashes, never exits, etc.\n\t * @param processDetails describes how to run the process.\n\t * @return a STFProcess object to represent the process.\n\t * @throws StfException if process runtime limit not set.\n\t */\n\tpublic StfProcess doRunForegroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tString programName = getProgramName(processDetails);\n\t\t\n\t\tgenerator.startNewCommand(comment, \"Run \" + programName, \"Run foreground process\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic: \",   processMnemonic,\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\n\t\treturn extensionBase.runForegroundProcess(comment, processMnemonic, echoSetting, expectedOutcome, processDetails);\n\t}\n\n\t\n\t/**\n\t * Runs multiple processes using the same process definition.\n\t * At runtime this call results in test execution blocking until the final process completes.\n\t * Other than the numInstances parameter, all other arguments are as described by doRunForegroundProcess(). \n\t */\n\tpublic StfProcess[] doRunForegroundProcesses(String comment, String processMnemonic, int numInstances, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\n\t\tString commandDescription = \"Run \" + getProgramName(processDetails) + \"*\" + numInstances;\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Run multiple concurrent foreground processes\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\t\t\"Instances:\",   Integer.toString(numInstances),\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\n\t\treturn extensionBase.runForegroundProcesses(comment, processMnemonic, numInstances, echoSetting, expectedOutcome, processDetails);\n\t}",
        "start_line": 830,
        "end_line": 884,
        "chunk_index": 13,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 660,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994487"
      },
      "text": "// Whenever a process is started the caller needs to decide if they want STF to\n\t// echo the output of the child process to the STF output.\n\t// Reference using: import static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.*;\n    public enum Echo { ECHO_ON, ECHO_OFF };\n\n\t\n\t/**\n\t * Synchronously runs a java process.\n\t * The test will fail at runtime if:\n\t *   - the process exits with a non-zero exit value.\n\t *   - the process completes, but the actual outcome does not match the expected outcome.\n\t *   - process runtime exceeds the expected runtime.\n\t * See SampleRunProcess.java for an example.\n\t * \n\t * @param comment is a brief summary describing why the test is running the process.\n\t * @param processMnemonic is a 3 letter code for this process. This is prefixed \n\t * to the processes output when echoed by STF.\n\t * @param echoSetting used to turn on/off echoing of process output. \n\t * @param expectedOutcome describes what the test expects to happen when executed, and \n\t * for specifies a maximum run time for processes which are going to complete. \n\t * For example, completes with exit-code 0, crashes, never exits, etc.\n\t * @param processDetails describes how to run the process.\n\t * @return a STFProcess object to represent the process.\n\t * @throws StfException if process runtime limit not set.\n\t */\n\tpublic StfProcess doRunForegroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\t\tString programName = getProgramName(processDetails);\n\t\t\n\t\tgenerator.startNewCommand(comment, \"Run \" + programName, \"Run foreground process\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic: \",   processMnemonic,\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\n\t\treturn extensionBase.runForegroundProcess(comment, processMnemonic, echoSetting, expectedOutcome, processDetails);\n\t}\n\n\t\n\t/**\n\t * Runs multiple processes using the same process definition.\n\t * At runtime this call results in test execution blocking until the final process completes.\n\t * Other than the numInstances parameter, all other arguments are as described by doRunForegroundProcess(). \n\t */\n\tpublic StfProcess[] doRunForegroundProcesses(String comment, String processMnemonic, int numInstances, Echo echoSetting, ExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\n\t\tString commandDescription = \"Run \" + getProgramName(processDetails) + \"*\" + numInstances;\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Run multiple concurrent foreground processes\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\t\t\"Instances:\",   Integer.toString(numInstances),\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\n\t\treturn extensionBase.runForegroundProcesses(comment, processMnemonic, numInstances, echoSetting, expectedOutcome, processDetails);\n\t}"
    },
    "196": {
      "metadata": {
        "chunk_id": "3ec1a4c2b783d85a163a23a6e1ddd5e165a46f91bbab287e3e3ac576bf144ce8",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "String commandDescription = \"Run \" + getProgramName(processDetails) + \"*\" + numInstances;\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Run multiple concurrent foreground processes\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\t\t\"Instances:\",   Integer.toString(numInstances),\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\n\t\treturn extensionBase.runForegroundProcesses(comment, processMnemonic, numInstances, echoSetting, expectedOutcome, processDetails);\n\t}\n\n\t\n\t/**\n\t * Start running a process in the background.\n\t * Once the process has been started it can be referenced in a monitor call.\n\t * Processes which never complete need to be killed before the end of the test stage.\n\t * \n \t * See STF-Manual.hmtl for more detailed information.\n\t * See SampleClientServer.java or SampleConcurrentProcesses.java for an example.\n\t * \n\t * The test will fail at runtime if there is an error starting the process. \n\t * \n\t * @param comment describes why the test is starting the process.\n\t * @param processMnemonic is a 3 character mnemonic used to identify the process.\n\t * @param echoSetting used to turn on/off echoing of process output. \n\t * @param expectedOutcome describes what the test expects to happen when executed.\n\t * @param processDetails describes how to run the process.\n\t * @return a STFProcess object to represent the process.\n\t * @throws StfException if process runtime limit not set.\n\t */\n\tpublic StfProcess doRunBackgroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, \n\t\t\tProcessDefinition processDetails) throws StfException {\n\t\t\n\t\tString commandDescription = \"Run \" + getProgramName(processDetails);\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Start background process\", \n\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\t\t\n\t\treturn extensionBase.runBackgroundProcess(comment, processMnemonic, echoSetting, expectedOutcome, processDetails);\n\t}\n\n\t/**\n\t * This is a variation of doRunBackgroundProcess, and is used when you want to start 2\n\t * or more processes with the same definition.\n\t *  \n\t * @param comment describes why the test is starting the process.\n\t * @param processMnemonic is a 3 character mnemonic used to identify the process.\n\t * @param numInstances is the number of concurrent processes to start.\n\t * @param echoSetting used to turn on/off echoing of process output. \n\t * @param expectedOutcome describes what the test expects to happen when executed.\n\t * @param processDetails describes how to run the process.\n\t * @return a STFProcess object to represent the set of processes.\n\t * @throws StfException if process runtime limit not set, or if numInstances < 2.\n\t */\n\tpublic StfProcess[] doRunBackgroundProcesses(String comment, String processMnemonic, int numInstances, Echo echoSetting, \n\t\t\tExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\n\t\tString commandDescription = \"Run \" + getProgramName(processDetails) + \"*\" + numInstances;\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Start multiple concurrent background processes\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\t\t\"Instances:\",   Integer.toString(numInstances),\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\t\t\n\t\treturn extensionBase.runBackgroundProcesses(comment, processMnemonic, numInstances, echoSetting, expectedOutcome, processDetails);\n\t}",
        "start_line": 885,
        "end_line": 953,
        "chunk_index": 14,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 804,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994489"
      },
      "text": "String commandDescription = \"Run \" + getProgramName(processDetails) + \"*\" + numInstances;\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Run multiple concurrent foreground processes\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\t\t\"Instances:\",   Integer.toString(numInstances),\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\n\t\treturn extensionBase.runForegroundProcesses(comment, processMnemonic, numInstances, echoSetting, expectedOutcome, processDetails);\n\t}\n\n\t\n\t/**\n\t * Start running a process in the background.\n\t * Once the process has been started it can be referenced in a monitor call.\n\t * Processes which never complete need to be killed before the end of the test stage.\n\t * \n \t * See STF-Manual.hmtl for more detailed information.\n\t * See SampleClientServer.java or SampleConcurrentProcesses.java for an example.\n\t * \n\t * The test will fail at runtime if there is an error starting the process. \n\t * \n\t * @param comment describes why the test is starting the process.\n\t * @param processMnemonic is a 3 character mnemonic used to identify the process.\n\t * @param echoSetting used to turn on/off echoing of process output. \n\t * @param expectedOutcome describes what the test expects to happen when executed.\n\t * @param processDetails describes how to run the process.\n\t * @return a STFProcess object to represent the process.\n\t * @throws StfException if process runtime limit not set.\n\t */\n\tpublic StfProcess doRunBackgroundProcess(String comment, String processMnemonic, Echo echoSetting, ExpectedOutcome expectedOutcome, \n\t\t\tProcessDefinition processDetails) throws StfException {\n\t\t\n\t\tString commandDescription = \"Run \" + getProgramName(processDetails);\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Start background process\", \n\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\t\t\n\t\treturn extensionBase.runBackgroundProcess(comment, processMnemonic, echoSetting, expectedOutcome, processDetails);\n\t}\n\n\t/**\n\t * This is a variation of doRunBackgroundProcess, and is used when you want to start 2\n\t * or more processes with the same definition.\n\t *  \n\t * @param comment describes why the test is starting the process.\n\t * @param processMnemonic is a 3 character mnemonic used to identify the process.\n\t * @param numInstances is the number of concurrent processes to start.\n\t * @param echoSetting used to turn on/off echoing of process output. \n\t * @param expectedOutcome describes what the test expects to happen when executed.\n\t * @param processDetails describes how to run the process.\n\t * @return a STFProcess object to represent the set of processes.\n\t * @throws StfException if process runtime limit not set, or if numInstances < 2.\n\t */\n\tpublic StfProcess[] doRunBackgroundProcesses(String comment, String processMnemonic, int numInstances, Echo echoSetting, \n\t\t\tExpectedOutcome expectedOutcome, ProcessDefinition processDetails) throws StfException {\n\n\t\tString commandDescription = \"Run \" + getProgramName(processDetails) + \"*\" + numInstances;\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Start multiple concurrent background processes\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\t\t\"Instances:\",   Integer.toString(numInstances),\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\t\t\n\t\treturn extensionBase.runBackgroundProcesses(comment, processMnemonic, numInstances, echoSetting, expectedOutcome, processDetails);\n\t}"
    },
    "197": {
      "metadata": {
        "chunk_id": "cfd3b2ade8193f7c0ee006f7e57451266e1e741a2b0dbaae4a84c5aa9532461a",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "String commandDescription = \"Run \" + getProgramName(processDetails) + \"*\" + numInstances;\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Start multiple concurrent background processes\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\t\t\"Instances:\",   Integer.toString(numInstances),\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\t\t\n\t\treturn extensionBase.runBackgroundProcesses(comment, processMnemonic, numInstances, echoSetting, expectedOutcome, processDetails);\n\t}\n\n\n\t// Extract the name of the program which this processDetails object plans to run\n\tprivate String getProgramName(ProcessDefinition processDetails) throws StfException {\n\t\t// If the command to run contains a path then extract just the name of the program \n\t\tString[] commandElements = processDetails.getCommand().split(\"[\\\\\\\\/]\");\n\t\tString programName = commandElements[commandElements.length-1];\n\t\treturn programName;\n\t}\n\n\t\n\t/**\n\t * This action allows the test to wait for one or more processes.\n\t * The test blocks until the earliest of the following occours:\n\t *   - a process completes but not as expected (test fails).\n\t *   - core file detected for a process which is not expected to crash (test fails).\n\t *   - a process exceeds its allowed runtime (test fails).\n\t *   - all process which are expected to complete actually complete (test continues).\n\t *   \n\t * See STF-Manual.hmtl for more detailed information.\n\t * See SampleClientServer.java or SampleConcurrentProcesses.java for an example.\n\t * \n\t * @param comment is a brief comment to describe why the test is waiting. \n\t * @param processesToMonitor is one or more processes to monitor. Accepts 3 types of arguments:\n\t *   1) A StfProcess object or \n\t *   2) An array of StfProcess objects.\n\t *   3) Null. Ignoring null process references simplifies test case logic\n\t * @throws StfException if attempting to monitor a process which must have already completed.\n\t * Also throws a StfException if attempting to monitor only processes which never complete.\n\t */\n\tpublic void doMonitorProcesses(String comment, Object... processesToMonitor) throws StfException {\n\t\tArrayList<StfProcess> processesList = convertToProcessList(processesToMonitor);\n\t\t\n\t\tif (!processesList.isEmpty()) {\n\t\t\tgenerator.startNewCommand(comment, \"Monitor\", \"Wait for processes to meet expectations\", \n\t\t\t\t\t\t\"Processes:\", processesList.toString());\n\n\t\t\textensionBase.internalDoMonitorProcesses(comment, processesList);\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Kills one or more processes. \n\t * The processes being killed must have been started with one of the doRun process methods.\n\t * \n\t * See STF-Manual.hmtl for more detailed information.\n\t * See SampleClientServer.java or SampleConcurrentProcesses.java for an example.\n\t * \n\t * @param comment is a brief comment summarising why the test is killing the process(es).\n\t * @param processesesToKill is one or more processes to kill. Accepts 2 types of \n\t * arguments. 1) A StfProcess object or 2) An array of StfProcess objects.\n\t * @throws StfException if attempting to kill a process which must have already completed.\n\t */\n\tpublic void doKillProcesses(String comment, StfProcess... processesToKill) throws StfException {\n\t\tArrayList<StfProcess> processesList = convertToProcessList(processesToKill);\n\t\t\n\t\tgenerator.startNewCommand(comment, \"kill\", \"Kill running processes\",\n\t\t\t\t\t\t\"Processes:\", processesList.toString());\n\n\t\textensionBase.internalDoKillProcess(comment, processesList);\n\t}",
        "start_line": 954,
        "end_line": 1025,
        "chunk_index": 15,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 802,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994491"
      },
      "text": "String commandDescription = \"Run \" + getProgramName(processDetails) + \"*\" + numInstances;\n\t\tgenerator.startNewCommand(comment, commandDescription, \"Start multiple concurrent background processes\",\n\t\t\t\t\t\t\"Program:\",     processDetails.getCommand(),\n\t\t\t\t\t\t\"Mnemonic:\",    processMnemonic,\n\t\t\t\t\t\t\"Instances:\",   Integer.toString(numInstances),\n\t\t\t\t\t\t\"Echo:\",        echoSetting.name(),\n\t\t\t\t\t\t\"Expectation:\", expectedOutcome.toString());\n\t\t\n\t\treturn extensionBase.runBackgroundProcesses(comment, processMnemonic, numInstances, echoSetting, expectedOutcome, processDetails);\n\t}\n\n\n\t// Extract the name of the program which this processDetails object plans to run\n\tprivate String getProgramName(ProcessDefinition processDetails) throws StfException {\n\t\t// If the command to run contains a path then extract just the name of the program \n\t\tString[] commandElements = processDetails.getCommand().split(\"[\\\\\\\\/]\");\n\t\tString programName = commandElements[commandElements.length-1];\n\t\treturn programName;\n\t}\n\n\t\n\t/**\n\t * This action allows the test to wait for one or more processes.\n\t * The test blocks until the earliest of the following occours:\n\t *   - a process completes but not as expected (test fails).\n\t *   - core file detected for a process which is not expected to crash (test fails).\n\t *   - a process exceeds its allowed runtime (test fails).\n\t *   - all process which are expected to complete actually complete (test continues).\n\t *   \n\t * See STF-Manual.hmtl for more detailed information.\n\t * See SampleClientServer.java or SampleConcurrentProcesses.java for an example.\n\t * \n\t * @param comment is a brief comment to describe why the test is waiting. \n\t * @param processesToMonitor is one or more processes to monitor. Accepts 3 types of arguments:\n\t *   1) A StfProcess object or \n\t *   2) An array of StfProcess objects.\n\t *   3) Null. Ignoring null process references simplifies test case logic\n\t * @throws StfException if attempting to monitor a process which must have already completed.\n\t * Also throws a StfException if attempting to monitor only processes which never complete.\n\t */\n\tpublic void doMonitorProcesses(String comment, Object... processesToMonitor) throws StfException {\n\t\tArrayList<StfProcess> processesList = convertToProcessList(processesToMonitor);\n\t\t\n\t\tif (!processesList.isEmpty()) {\n\t\t\tgenerator.startNewCommand(comment, \"Monitor\", \"Wait for processes to meet expectations\", \n\t\t\t\t\t\t\"Processes:\", processesList.toString());\n\n\t\t\textensionBase.internalDoMonitorProcesses(comment, processesList);\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Kills one or more processes. \n\t * The processes being killed must have been started with one of the doRun process methods.\n\t * \n\t * See STF-Manual.hmtl for more detailed information.\n\t * See SampleClientServer.java or SampleConcurrentProcesses.java for an example.\n\t * \n\t * @param comment is a brief comment summarising why the test is killing the process(es).\n\t * @param processesesToKill is one or more processes to kill. Accepts 2 types of \n\t * arguments. 1) A StfProcess object or 2) An array of StfProcess objects.\n\t * @throws StfException if attempting to kill a process which must have already completed.\n\t */\n\tpublic void doKillProcesses(String comment, StfProcess... processesToKill) throws StfException {\n\t\tArrayList<StfProcess> processesList = convertToProcessList(processesToKill);\n\t\t\n\t\tgenerator.startNewCommand(comment, \"kill\", \"Kill running processes\",\n\t\t\t\t\t\t\"Processes:\", processesList.toString());\n\n\t\textensionBase.internalDoKillProcess(comment, processesList);\n\t}"
    },
    "198": {
      "metadata": {
        "chunk_id": "def824db140bad7ff4d9500132d2c9a2b9f1a28a4a0a5b8e84ab2d24c32a9d10",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "extensionBase.internalDoKillProcess(comment, processesList);\n\t}\n\n\t\n\t/**\n\t * Converts a bunch of processes into a typed ArrayList of StfProcess objects.\n\t * Accepts arguments which are either:\n\t *   1) A StfProcess object, for a single background process.\n\t *   2) An array of StfProcess objects, for when multiple instances have been started.\n\t * This method does type validation and unpacks the array to returns an ArrayList of StfProcess objects. \n\t */\n\tprivate ArrayList<StfProcess> convertToProcessList(Object[] processesToMonitor) throws StfException {\n\t\t// Unpack any arrays so that we have a flattened set of arguments \n\t\tArrayList<Object> flattenedArguments = new ArrayList<Object>();\n\t\tfor (Object o : processesToMonitor) {\n\t\t\tif (o == null) {\n\t\t\t\t// Ignore. Looks like test didn't start the process after all.\n\t\t\t} else if (o.getClass().isArray()) {\n\t\t\t\tObject[] objArray = (Object[]) o;\n\t\t\t\tfor (int i=0; i<objArray.length; i++) {\n\t\t\t\t\tflattenedArguments.add(objArray[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflattenedArguments.add(o);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Produce return structure. Everything going in to it must be an StfProcess\n\t\tArrayList<StfProcess> processesList = new ArrayList<StfProcess>();\n\t\tfor (Object o : flattenedArguments) { \n\t\t\tif (o instanceof StfProcess) {\n\t\t\t\tprocessesList.add((StfProcess) o);\n\t\t\t} else {\n\t\t\t\tthrow new StfException(\"Supplied object is neither of 1) a StfProcess object or, 2) an array of StfProcess objects. \" + o.toString());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn processesList;\n\t}\n\t\n\n\t/**\n\t * Creates an object which tests use to describe how to run a Java process using the primary JVM.\n\t * Once populated the JavaProcessDefinition can be used to start a JVM.\n\t * \n\t * @return a new JavaProcessDefinition object.\n\t * @throws StfException \n\t */\n\tpublic JavaProcessDefinition createJavaProcessDefinition() throws StfException {\n\t\treturn new JavaProcessDefinition(environmentCore);\n\t}\n\n\n\t/**\n\t * Creates an object which tests use to describe how to run a Java process.\n\t * Once populated the JavaProcessDefinition can be used to start a JVM.\n\t * This method is only needed by tests which need to use the secondary JVM.\n\t * \n\t * @param jvm describes the jvm to use. Either primary or secondary jvm.\n\t * @return a new JavaProcessDefinition object.\n\t * @throws StfException \n\t */\n\tpublic JavaProcessDefinition createJavaProcessDefinition(JavaVersion jvm) throws StfException {\n\t\treturn new JavaProcessDefinition(environmentCore, jvm);\n\t}\n\n\n\t/**\n\t * Creates an object which tests use to describe how to run a JDK tool or utility.\n\t * Once populated the JavaProcessDefinition can be used to start the process\n\t * in the foreground or the background.\n\t * \n\t * @return a new JDKToolProcessDefinition object.\n\t */\n\tpublic JDKToolProcessDefinition createJDKToolProcessDefinition() {\n\t\treturn new JDKToolProcessDefinition(environmentCore);\n\t}\n\n\n\t/**\n\t * Creates the bare bones process setup needed by a load test, using the primary jvm. \n\t * \n     * @return A new load test process definition.\n\t * @throws StfException if an internal error is detected.\n\t */\n\tpublic LoadTestProcessDefinition createLoadTestSpecification() throws StfException {\n\t\treturn createLoadTestSpecification(environmentCore.primaryJvm());\n\t}",
        "start_line": 1026,
        "end_line": 1113,
        "chunk_index": 16,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 781,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994493"
      },
      "text": "extensionBase.internalDoKillProcess(comment, processesList);\n\t}\n\n\t\n\t/**\n\t * Converts a bunch of processes into a typed ArrayList of StfProcess objects.\n\t * Accepts arguments which are either:\n\t *   1) A StfProcess object, for a single background process.\n\t *   2) An array of StfProcess objects, for when multiple instances have been started.\n\t * This method does type validation and unpacks the array to returns an ArrayList of StfProcess objects. \n\t */\n\tprivate ArrayList<StfProcess> convertToProcessList(Object[] processesToMonitor) throws StfException {\n\t\t// Unpack any arrays so that we have a flattened set of arguments \n\t\tArrayList<Object> flattenedArguments = new ArrayList<Object>();\n\t\tfor (Object o : processesToMonitor) {\n\t\t\tif (o == null) {\n\t\t\t\t// Ignore. Looks like test didn't start the process after all.\n\t\t\t} else if (o.getClass().isArray()) {\n\t\t\t\tObject[] objArray = (Object[]) o;\n\t\t\t\tfor (int i=0; i<objArray.length; i++) {\n\t\t\t\t\tflattenedArguments.add(objArray[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflattenedArguments.add(o);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Produce return structure. Everything going in to it must be an StfProcess\n\t\tArrayList<StfProcess> processesList = new ArrayList<StfProcess>();\n\t\tfor (Object o : flattenedArguments) { \n\t\t\tif (o instanceof StfProcess) {\n\t\t\t\tprocessesList.add((StfProcess) o);\n\t\t\t} else {\n\t\t\t\tthrow new StfException(\"Supplied object is neither of 1) a StfProcess object or, 2) an array of StfProcess objects. \" + o.toString());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn processesList;\n\t}\n\t\n\n\t/**\n\t * Creates an object which tests use to describe how to run a Java process using the primary JVM.\n\t * Once populated the JavaProcessDefinition can be used to start a JVM.\n\t * \n\t * @return a new JavaProcessDefinition object.\n\t * @throws StfException \n\t */\n\tpublic JavaProcessDefinition createJavaProcessDefinition() throws StfException {\n\t\treturn new JavaProcessDefinition(environmentCore);\n\t}\n\n\n\t/**\n\t * Creates an object which tests use to describe how to run a Java process.\n\t * Once populated the JavaProcessDefinition can be used to start a JVM.\n\t * This method is only needed by tests which need to use the secondary JVM.\n\t * \n\t * @param jvm describes the jvm to use. Either primary or secondary jvm.\n\t * @return a new JavaProcessDefinition object.\n\t * @throws StfException \n\t */\n\tpublic JavaProcessDefinition createJavaProcessDefinition(JavaVersion jvm) throws StfException {\n\t\treturn new JavaProcessDefinition(environmentCore, jvm);\n\t}\n\n\n\t/**\n\t * Creates an object which tests use to describe how to run a JDK tool or utility.\n\t * Once populated the JavaProcessDefinition can be used to start the process\n\t * in the foreground or the background.\n\t * \n\t * @return a new JDKToolProcessDefinition object.\n\t */\n\tpublic JDKToolProcessDefinition createJDKToolProcessDefinition() {\n\t\treturn new JDKToolProcessDefinition(environmentCore);\n\t}\n\n\n\t/**\n\t * Creates the bare bones process setup needed by a load test, using the primary jvm. \n\t * \n     * @return A new load test process definition.\n\t * @throws StfException if an internal error is detected.\n\t */\n\tpublic LoadTestProcessDefinition createLoadTestSpecification() throws StfException {\n\t\treturn createLoadTestSpecification(environmentCore.primaryJvm());\n\t}"
    },
    "199": {
      "metadata": {
        "chunk_id": "107cedc19c21822e4ed7a2b17f02ef7595e1ea7d54df6eee7042aa0c5a4a47f5",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * Creates an object which tests use to describe how to run a JDK tool or utility.\n\t * Once populated the JavaProcessDefinition can be used to start the process\n\t * in the foreground or the background.\n\t * \n\t * @return a new JDKToolProcessDefinition object.\n\t */\n\tpublic JDKToolProcessDefinition createJDKToolProcessDefinition() {\n\t\treturn new JDKToolProcessDefinition(environmentCore);\n\t}\n\n\n\t/**\n\t * Creates the bare bones process setup needed by a load test, using the primary jvm. \n\t * \n     * @return A new load test process definition.\n\t * @throws StfException if an internal error is detected.\n\t */\n\tpublic LoadTestProcessDefinition createLoadTestSpecification() throws StfException {\n\t\treturn createLoadTestSpecification(environmentCore.primaryJvm());\n\t}\n\n\t\n\t/**\n\t * Creates the bare bones process setup needed by a load test. \n\t *\n\t * @param jvm specifies if the load test should be run with the primary or secondary jvm.\n     * @return A new load test process definition.\n\t * @throws StfException if an internal error is detected.\n\t */\n\tpublic LoadTestProcessDefinition createLoadTestSpecification(JavaVersion jvm) throws StfException {\n\t\tString agentPath = System.getProperty(\"load.agent.path\");\n\t\tLoadTestProcessDefinition loadTestInvocation = new LoadTestProcessDefinition(environmentCore, jvm)\n\t\t\t.addJvmOption(\"-javaagent:\" + agentPath)\n\t\t\t.addProjectToClasspath(\"stf.load\")       // stf.load goes first to make sure we pick up the correct log4j config file\n\t\t\t.addProjectToClasspath(\"stf.core\")\n\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.LOG4J_API)\n\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.LOG4J_CORE)\n\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.ASM)\n\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.ASM_COMMONS)\n\t\t\t.runClass(\"net.adoptopenjdk.loadTest.LoadTest\")\n\t\t\t.setResultsDir(environmentCore.getResultsDir());\n\t\t\n\t\tloadTestInvocation.resetStageChecking();\n\t\t\n\t\treturn loadTestInvocation;\n\t}\n\n\t\n\t/**\n\t * Runs the jmod tool, to create Java jmod files.\n\t *\n\t * @param comment is a brief comment summarising why the test is killing the process(es).\n\t * @param jmodDefition which describes how the jmod tool should be run.\n\t * @return a ModuleRef object which points at the created jmod file.\n\t */\n\tpublic ModuleRef doCreateJmod(String comment, JmodDefinition jmodDefinition) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"jmod\", \"Run jmod utility\", \n\t\t\t\t\"jmod:\", jmodDefinition.getJmodModuleRef().getName());\n\t\t\n\t\t// Run the jmod command to create a jmod file\n\t\textensionBase.runForegroundProcess(\"Run jmod\", \"JMOD\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"), jmodDefinition);\n\t\t\t\t\n\t\treturn jmodDefinition.getJmodModuleRef();\n\t}",
        "start_line": 1114,
        "end_line": 1178,
        "chunk_index": 17,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 678,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994495"
      },
      "text": "/**\n\t * Creates an object which tests use to describe how to run a JDK tool or utility.\n\t * Once populated the JavaProcessDefinition can be used to start the process\n\t * in the foreground or the background.\n\t * \n\t * @return a new JDKToolProcessDefinition object.\n\t */\n\tpublic JDKToolProcessDefinition createJDKToolProcessDefinition() {\n\t\treturn new JDKToolProcessDefinition(environmentCore);\n\t}\n\n\n\t/**\n\t * Creates the bare bones process setup needed by a load test, using the primary jvm. \n\t * \n     * @return A new load test process definition.\n\t * @throws StfException if an internal error is detected.\n\t */\n\tpublic LoadTestProcessDefinition createLoadTestSpecification() throws StfException {\n\t\treturn createLoadTestSpecification(environmentCore.primaryJvm());\n\t}\n\n\t\n\t/**\n\t * Creates the bare bones process setup needed by a load test. \n\t *\n\t * @param jvm specifies if the load test should be run with the primary or secondary jvm.\n     * @return A new load test process definition.\n\t * @throws StfException if an internal error is detected.\n\t */\n\tpublic LoadTestProcessDefinition createLoadTestSpecification(JavaVersion jvm) throws StfException {\n\t\tString agentPath = System.getProperty(\"load.agent.path\");\n\t\tLoadTestProcessDefinition loadTestInvocation = new LoadTestProcessDefinition(environmentCore, jvm)\n\t\t\t.addJvmOption(\"-javaagent:\" + agentPath)\n\t\t\t.addProjectToClasspath(\"stf.load\")       // stf.load goes first to make sure we pick up the correct log4j config file\n\t\t\t.addProjectToClasspath(\"stf.core\")\n\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.LOG4J_API)\n\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.LOG4J_CORE)\n\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.ASM)\n\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.ASM_COMMONS)\n\t\t\t.runClass(\"net.adoptopenjdk.loadTest.LoadTest\")\n\t\t\t.setResultsDir(environmentCore.getResultsDir());\n\t\t\n\t\tloadTestInvocation.resetStageChecking();\n\t\t\n\t\treturn loadTestInvocation;\n\t}\n\n\t\n\t/**\n\t * Runs the jmod tool, to create Java jmod files.\n\t *\n\t * @param comment is a brief comment summarising why the test is killing the process(es).\n\t * @param jmodDefition which describes how the jmod tool should be run.\n\t * @return a ModuleRef object which points at the created jmod file.\n\t */\n\tpublic ModuleRef doCreateJmod(String comment, JmodDefinition jmodDefinition) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"jmod\", \"Run jmod utility\", \n\t\t\t\t\"jmod:\", jmodDefinition.getJmodModuleRef().getName());\n\t\t\n\t\t// Run the jmod command to create a jmod file\n\t\textensionBase.runForegroundProcess(\"Run jmod\", \"JMOD\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"), jmodDefinition);\n\t\t\t\t\n\t\treturn jmodDefinition.getJmodModuleRef();\n\t}"
    },
    "200": {
      "metadata": {
        "chunk_id": "027111f7dce92e75c2b30542eafd3e93801d1758d7abcf7190be7fa77398bef6",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * Runs the jmod tool, to create Java jmod files.\n\t *\n\t * @param comment is a brief comment summarising why the test is killing the process(es).\n\t * @param jmodDefition which describes how the jmod tool should be run.\n\t * @return a ModuleRef object which points at the created jmod file.\n\t */\n\tpublic ModuleRef doCreateJmod(String comment, JmodDefinition jmodDefinition) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"jmod\", \"Run jmod utility\", \n\t\t\t\t\"jmod:\", jmodDefinition.getJmodModuleRef().getName());\n\t\t\n\t\t// Run the jmod command to create a jmod file\n\t\textensionBase.runForegroundProcess(\"Run jmod\", \"JMOD\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"), jmodDefinition);\n\t\t\t\t\n\t\treturn jmodDefinition.getJmodModuleRef();\n\t}\n\n\t\n\t/**\n\t * Creates an object which can be used to run a program on the system path.\n\t * This method should only be used after careful consideration of all options, as\n\t * it has the potential to create fragile system dependent tests.\n\t * \n\t * @return a new SystemProcessDefinition object.\n\t */\n\tprivate SystemProcessDefinition createSystemProcessDefinition() {\n\t\treturn SystemProcessDefinition.create();\n\t}\n\t\n\t\n\t/**\n\t * Jars the contents of a compiled project.\n\t *  \n\t * It basically runs commands such as:\n\t *   jar --create --file /stf/.../tmp/common.jar -C /tmp/runtimestest_build/ascii/test.modularity/bin/common com\n\t *   \n     * @param comment is a short explanation of why the test is creating a jar.\n\t * @param projectSpec describes the location of the project code within the workspace. eg, \"test.modularity/bin/common\"\n\t * @param archiveSpec contains the sub-directory or files to be added to the jar. \n\t * All names are relative to the projectSpec. eg, \"com\" or \"net\"\n\t * @return a FileRef object which holds the location of the created jar.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic FileRef doCreateProjectJar(String comment, String projectSpec, String... archiveSpec) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"jar\", \"Create project jar\",\n\t\t\t\t\"ProjectSpec:\", projectSpec,\n\t\t\t\t\"ArchiveSpec:\", formatStringArray(archiveSpec).toString());\n\t\n\t\t// Verify that the projectSpec is references an existing directory\n\t\tDirectoryRef projectDir = environmentCore.findTestDirectory(projectSpec);\n\t\tif (!projectDir.asJavaFile().exists()) { \n\t\t\tthrow new StfException(\"Project spec '\" + projectSpec + \"' does not point at a valid project. Full path is: \" + projectDir);\n\t\t}\n\t\t\n\t\t// Work out what the jar will be called and where to create it\n\t\tString projectName;\n\t\tif (projectSpec.contains(\"/\")) {\n\t\t\tprojectName = projectSpec.substring(projectSpec.lastIndexOf('/')+1);  // Use last part of the project spec\n\t\t} else {\n\t\t\tprojectName = projectSpec;\n\t\t}\n\t\tString jarName = projectName + \".jar\";\n\t\tFileRef jarFile = environmentCore.getTmpDir().childFile(jarName);\n\n\t\t// Build the arguments for the jar process\n\t\tJDKToolProcessDefinition jarProcessDef = createJDKToolProcessDefinition()\n\t\t\t\t.setJDKToolOrUtility(\"jar\")\n\t\t\t\t.addArg(\"--create\")\n\t\t\t\t.addArg(\"--file\", jarFile.getSpec())\n\t\t        .addArg(\"-C\", projectDir.getSpec());\n\t\t        \n        if (archiveSpec != null) {\n\t\t\tjarProcessDef.addArg(archiveSpec);\n\t\t} else {\n\t\t\tjarProcessDef.addArg(\".\");\n\t\t}",
        "start_line": 1179,
        "end_line": 1254,
        "chunk_index": 18,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 811,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994497"
      },
      "text": "/**\n\t * Runs the jmod tool, to create Java jmod files.\n\t *\n\t * @param comment is a brief comment summarising why the test is killing the process(es).\n\t * @param jmodDefition which describes how the jmod tool should be run.\n\t * @return a ModuleRef object which points at the created jmod file.\n\t */\n\tpublic ModuleRef doCreateJmod(String comment, JmodDefinition jmodDefinition) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"jmod\", \"Run jmod utility\", \n\t\t\t\t\"jmod:\", jmodDefinition.getJmodModuleRef().getName());\n\t\t\n\t\t// Run the jmod command to create a jmod file\n\t\textensionBase.runForegroundProcess(\"Run jmod\", \"JMOD\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"), jmodDefinition);\n\t\t\t\t\n\t\treturn jmodDefinition.getJmodModuleRef();\n\t}\n\n\t\n\t/**\n\t * Creates an object which can be used to run a program on the system path.\n\t * This method should only be used after careful consideration of all options, as\n\t * it has the potential to create fragile system dependent tests.\n\t * \n\t * @return a new SystemProcessDefinition object.\n\t */\n\tprivate SystemProcessDefinition createSystemProcessDefinition() {\n\t\treturn SystemProcessDefinition.create();\n\t}\n\t\n\t\n\t/**\n\t * Jars the contents of a compiled project.\n\t *  \n\t * It basically runs commands such as:\n\t *   jar --create --file /stf/.../tmp/common.jar -C /tmp/runtimestest_build/ascii/test.modularity/bin/common com\n\t *   \n     * @param comment is a short explanation of why the test is creating a jar.\n\t * @param projectSpec describes the location of the project code within the workspace. eg, \"test.modularity/bin/common\"\n\t * @param archiveSpec contains the sub-directory or files to be added to the jar. \n\t * All names are relative to the projectSpec. eg, \"com\" or \"net\"\n\t * @return a FileRef object which holds the location of the created jar.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic FileRef doCreateProjectJar(String comment, String projectSpec, String... archiveSpec) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"jar\", \"Create project jar\",\n\t\t\t\t\"ProjectSpec:\", projectSpec,\n\t\t\t\t\"ArchiveSpec:\", formatStringArray(archiveSpec).toString());\n\t\n\t\t// Verify that the projectSpec is references an existing directory\n\t\tDirectoryRef projectDir = environmentCore.findTestDirectory(projectSpec);\n\t\tif (!projectDir.asJavaFile().exists()) { \n\t\t\tthrow new StfException(\"Project spec '\" + projectSpec + \"' does not point at a valid project. Full path is: \" + projectDir);\n\t\t}\n\t\t\n\t\t// Work out what the jar will be called and where to create it\n\t\tString projectName;\n\t\tif (projectSpec.contains(\"/\")) {\n\t\t\tprojectName = projectSpec.substring(projectSpec.lastIndexOf('/')+1);  // Use last part of the project spec\n\t\t} else {\n\t\t\tprojectName = projectSpec;\n\t\t}\n\t\tString jarName = projectName + \".jar\";\n\t\tFileRef jarFile = environmentCore.getTmpDir().childFile(jarName);\n\n\t\t// Build the arguments for the jar process\n\t\tJDKToolProcessDefinition jarProcessDef = createJDKToolProcessDefinition()\n\t\t\t\t.setJDKToolOrUtility(\"jar\")\n\t\t\t\t.addArg(\"--create\")\n\t\t\t\t.addArg(\"--file\", jarFile.getSpec())\n\t\t        .addArg(\"-C\", projectDir.getSpec());\n\t\t        \n        if (archiveSpec != null) {\n\t\t\tjarProcessDef.addArg(archiveSpec);\n\t\t} else {\n\t\t\tjarProcessDef.addArg(\".\");\n\t\t}"
    },
    "201": {
      "metadata": {
        "chunk_id": "c59b6dd98905c0fe259f05019a3fdf788c7c13b6ee1f84f6615c36e00a7963e9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "// Build the arguments for the jar process\n\t\tJDKToolProcessDefinition jarProcessDef = createJDKToolProcessDefinition()\n\t\t\t\t.setJDKToolOrUtility(\"jar\")\n\t\t\t\t.addArg(\"--create\")\n\t\t\t\t.addArg(\"--file\", jarFile.getSpec())\n\t\t        .addArg(\"-C\", projectDir.getSpec());\n\t\t        \n        if (archiveSpec != null) {\n\t\t\tjarProcessDef.addArg(archiveSpec);\n\t\t} else {\n\t\t\tjarProcessDef.addArg(\".\");\n\t\t}\n\n        // Run the jar process to create the jar\n\t\textensionBase.runForegroundProcess(comment, \"JAR\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"2m\"), jarProcessDef);\n\t\tgenerator.outputLine(\"info('Created project jar: \" + jarName + \"');\");\n\t\t\n\t\treturn jarFile;\n\t}\n\t\n\t\n\t/**\n\t * Jars the contents of a compiled project with the option to include and / or exclude certain files.\n\t *  \n\t * It first copies over the source folder into a temporary directory. \n\t * During the copy process it makes sure to only include the files that match the given list of \n\t * file extensions (if provided), and exclude the files that are specified in the list of excludes (if provided). \n\t * It then runs the jar command on the copied temp directory. \n\t * \n\t * @param comment is a short explanation of why the test is creating a jar.\n\t * @param projectSpec describes the location of the project code within the workspace. eg, \"test.modularity/bin/common\"\n\t * @param archiveSpec contains the sub-directory or files to be added to the jar. \n\t * All names are relative to the projectSpec. eg, \"com\" or \"net\"\n\t * @param includeSpec a comma separated list of file extensions to copy (optional).\n\t * @param excludeSpec a comma separated list of filenames to exclude (optional).\n\t * @return a FileRef object which holds the location of the created jar.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic FileRef doCreateProjectJar(String comment, String projectSpec, String archiveSpec, \n\t\t\tString includeSpec, String excludeSpec) throws StfException {\n\t\t\n\t\tString formattedIncludeList = formatCommaSeparatedList(includeSpec);\n\t\tString formattedExcludeList = formatCommaSeparatedList(excludeSpec);\n\t\t\n\t\tint commandNumber = generator.startNewCommand(comment, \"jar\", \"Create project jar\",\n\t\t\t\t\"ProjectSpec:\", projectSpec,\n\t\t\t\t\"ArchiveSpec:\", formatStringArray(archiveSpec).toString(),\n\t\t\t\t\"ExtensionList:\", formattedIncludeList,\n\t\t\t\t\"ExcludeFileList:\", formattedExcludeList);\n\t\t\n\t\t// Verify that the projectSpec is references an existing directory\n\t\tDirectoryRef projectDir = environmentCore.findTestDirectory(projectSpec);\n\t\tif (!projectDir.asJavaFile().exists()) { \n\t\t\tthrow new StfException(\"Project spec '\" + projectSpec + \"' does not point at a valid project. Full path is: \" + projectDir);\n\t\t}\n\t\t\n\t\t// Create a temporary directory in which to copy over the source after applying the filters \n\t\tDirectoryRef filteredProjectDir = environmentCore.getTmpDir().childDirectory(commandNumber + \"FilteredProjDir\"); \n\t\t\n\t\trunCpDir(\"Copying source directory to a temporary directory to apply filters\", \n\t\t\t\tprojectDir, filteredProjectDir, formattedIncludeList, formattedExcludeList);\n\t\t\n\t\t// Work out what the jar will be called and where to create it\n\t\tString projectName = null;\n\t\t\n\t\tif (projectSpec.contains(\"/\")) {\n\t\t\tprojectName = projectSpec.substring(projectSpec.lastIndexOf('/')+1);  // Use last part of the project spec\n\t\t} else {\n\t\t\tprojectName = projectSpec;\n\t\t}",
        "start_line": 1255,
        "end_line": 1324,
        "chunk_index": 19,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 791,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994499"
      },
      "text": "// Build the arguments for the jar process\n\t\tJDKToolProcessDefinition jarProcessDef = createJDKToolProcessDefinition()\n\t\t\t\t.setJDKToolOrUtility(\"jar\")\n\t\t\t\t.addArg(\"--create\")\n\t\t\t\t.addArg(\"--file\", jarFile.getSpec())\n\t\t        .addArg(\"-C\", projectDir.getSpec());\n\t\t        \n        if (archiveSpec != null) {\n\t\t\tjarProcessDef.addArg(archiveSpec);\n\t\t} else {\n\t\t\tjarProcessDef.addArg(\".\");\n\t\t}\n\n        // Run the jar process to create the jar\n\t\textensionBase.runForegroundProcess(comment, \"JAR\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"2m\"), jarProcessDef);\n\t\tgenerator.outputLine(\"info('Created project jar: \" + jarName + \"');\");\n\t\t\n\t\treturn jarFile;\n\t}\n\t\n\t\n\t/**\n\t * Jars the contents of a compiled project with the option to include and / or exclude certain files.\n\t *  \n\t * It first copies over the source folder into a temporary directory. \n\t * During the copy process it makes sure to only include the files that match the given list of \n\t * file extensions (if provided), and exclude the files that are specified in the list of excludes (if provided). \n\t * It then runs the jar command on the copied temp directory. \n\t * \n\t * @param comment is a short explanation of why the test is creating a jar.\n\t * @param projectSpec describes the location of the project code within the workspace. eg, \"test.modularity/bin/common\"\n\t * @param archiveSpec contains the sub-directory or files to be added to the jar. \n\t * All names are relative to the projectSpec. eg, \"com\" or \"net\"\n\t * @param includeSpec a comma separated list of file extensions to copy (optional).\n\t * @param excludeSpec a comma separated list of filenames to exclude (optional).\n\t * @return a FileRef object which holds the location of the created jar.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic FileRef doCreateProjectJar(String comment, String projectSpec, String archiveSpec, \n\t\t\tString includeSpec, String excludeSpec) throws StfException {\n\t\t\n\t\tString formattedIncludeList = formatCommaSeparatedList(includeSpec);\n\t\tString formattedExcludeList = formatCommaSeparatedList(excludeSpec);\n\t\t\n\t\tint commandNumber = generator.startNewCommand(comment, \"jar\", \"Create project jar\",\n\t\t\t\t\"ProjectSpec:\", projectSpec,\n\t\t\t\t\"ArchiveSpec:\", formatStringArray(archiveSpec).toString(),\n\t\t\t\t\"ExtensionList:\", formattedIncludeList,\n\t\t\t\t\"ExcludeFileList:\", formattedExcludeList);\n\t\t\n\t\t// Verify that the projectSpec is references an existing directory\n\t\tDirectoryRef projectDir = environmentCore.findTestDirectory(projectSpec);\n\t\tif (!projectDir.asJavaFile().exists()) { \n\t\t\tthrow new StfException(\"Project spec '\" + projectSpec + \"' does not point at a valid project. Full path is: \" + projectDir);\n\t\t}\n\t\t\n\t\t// Create a temporary directory in which to copy over the source after applying the filters \n\t\tDirectoryRef filteredProjectDir = environmentCore.getTmpDir().childDirectory(commandNumber + \"FilteredProjDir\"); \n\t\t\n\t\trunCpDir(\"Copying source directory to a temporary directory to apply filters\", \n\t\t\t\tprojectDir, filteredProjectDir, formattedIncludeList, formattedExcludeList);\n\t\t\n\t\t// Work out what the jar will be called and where to create it\n\t\tString projectName = null;\n\t\t\n\t\tif (projectSpec.contains(\"/\")) {\n\t\t\tprojectName = projectSpec.substring(projectSpec.lastIndexOf('/')+1);  // Use last part of the project spec\n\t\t} else {\n\t\t\tprojectName = projectSpec;\n\t\t}"
    },
    "202": {
      "metadata": {
        "chunk_id": "4951b7e77eca97199186e4ec222b12b41b7986312b2180b873f2e8dfe1023755",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "String prefix = Integer.toString(commandNumber) + \".\"; \n\t\tDirectoryRef targetDir = environmentCore.getModulesDir(); \n\t\t\n\t\t// If we are creating an automatic module jar, we must have the original name of the module.\n\t\t// In this case we will create the jar in the temp directory instead of the module directory\n\t\t// to avoid potential name conflicts with other jars (e.g. modular jars) that may be created \n\t\t// for the same module. \n\t\tif (formattedExcludeList.contains(\"module-info.class\")) {\n\t\t\tprefix = \"\"; \n\t\t\ttargetDir = environmentCore.getTmpDir();\n\t\t}\n\t\t\n\t\tString jarName = prefix + projectName + \".jar\";\n\t\tFileRef jarFile = targetDir.childFile(jarName);\n\n\t\t// Build the arguments for the jar process\n\t\tJDKToolProcessDefinition jarProcessDef = createJDKToolProcessDefinition()\n\t\t\t\t.setJDKToolOrUtility(\"jar\")\n\t\t\t\t.addArg(\"--create\")\n\t\t\t\t.addArg(\"--file\", jarFile.getSpec())\n\t\t        .addArg(\"-C\", filteredProjectDir.getSpec());\n\t\t\n\t\tif (archiveSpec != null) {\n\t\t\tjarProcessDef.addArg(archiveSpec);\n\t\t} else {\n\t\t\tjarProcessDef.addArg(\".\");\n\t\t}\n\t\t\n\t\t// Run the jar process to create the jar\n\t\textensionBase.runForegroundProcess(comment, \"JAR\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"2m\"), jarProcessDef);\n\t\tgenerator.outputLine(\"info('Created project jar: \" + jarName + \"');\");\n\t\t\n\t\treturn jarFile;\n\t}\n\n\t\n\t/**\n\t * This action creates a modular jar. \n\t * It basically runs commands such as the following:\n\t *   jar --create --file=mlib/com.greetings.jar --main-class=com.greetings.Main -C mods/com.greetings .\n\t *\n\t * @param comment is a short explanation of why the test is creating a modular jar.\n\t * @param moduleSpec describes the location of the module within the workspace. eg, \"test.modularity/bin/common-mods\"\n\t * @param moduleVersion is an optional version number for the modular jar, eg \"1.0\"\n\t * @param mainClass is the optional main class for the modular jar.\n\t * @param hashModules is the optional hash dependencies pattern for the modular jar.\n\t * @return a FileRef object which holds the location of the created modular jar.\n\t * @throws StfException \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec, String moduleVersion, Class<?> mainClass, String hashModules) throws StfException {\n\t\tint commandNum = generator.startNewCommand(comment, \"jar\", \"Create modular jar\",\n\t\t\t\t\"ModuleSpec:\",    moduleSpec,\n\t\t\t\t\"ModuleVersion:\", moduleVersion,\n\t\t\t\t\"MainClass:\",     (mainClass==null) ? null : mainClass.getName(),\n\t\t\t\t\"HashModules:\",     (hashModules==null) ? null : hashModules);\n\t\n\t\t// Verify that the moduleSpec really is pointing at a compiled module\n\t\tDirectoryRef moduleDir = environmentCore.findTestDirectory(moduleSpec);\n\t\tFileRef moduleInfoFile = moduleDir.childFile(\"module-info.class\");\n\t\tif (!moduleInfoFile.asJavaFile().exists()) { \n\t\t\tthrow new StfException(\"Module spec '\" + moduleSpec + \"' does not point at a valid module. \"\n\t\t\t\t\t+ \"Expected module-info.class file does not exist at: \" + moduleInfoFile.getSpec());\n\t\t}\n\t\t\n\t\t// Work out what the jar will be called and where to create it\n\t\tString versionSpec = (moduleVersion != null && !moduleVersion.isEmpty()) ? \"@\"+moduleVersion : \"\"; \n\t\tString moduleName = moduleDir.asJavaFile().getName();\n\t\tString jarName = commandNum + \".\" + moduleName + versionSpec + \".jar\";\n\t\tFileRef jarFile = environmentCore.getModulesDir().childFile(jarName);",
        "start_line": 1325,
        "end_line": 1393,
        "chunk_index": 20,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 835,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994502"
      },
      "text": "String prefix = Integer.toString(commandNumber) + \".\"; \n\t\tDirectoryRef targetDir = environmentCore.getModulesDir(); \n\t\t\n\t\t// If we are creating an automatic module jar, we must have the original name of the module.\n\t\t// In this case we will create the jar in the temp directory instead of the module directory\n\t\t// to avoid potential name conflicts with other jars (e.g. modular jars) that may be created \n\t\t// for the same module. \n\t\tif (formattedExcludeList.contains(\"module-info.class\")) {\n\t\t\tprefix = \"\"; \n\t\t\ttargetDir = environmentCore.getTmpDir();\n\t\t}\n\t\t\n\t\tString jarName = prefix + projectName + \".jar\";\n\t\tFileRef jarFile = targetDir.childFile(jarName);\n\n\t\t// Build the arguments for the jar process\n\t\tJDKToolProcessDefinition jarProcessDef = createJDKToolProcessDefinition()\n\t\t\t\t.setJDKToolOrUtility(\"jar\")\n\t\t\t\t.addArg(\"--create\")\n\t\t\t\t.addArg(\"--file\", jarFile.getSpec())\n\t\t        .addArg(\"-C\", filteredProjectDir.getSpec());\n\t\t\n\t\tif (archiveSpec != null) {\n\t\t\tjarProcessDef.addArg(archiveSpec);\n\t\t} else {\n\t\t\tjarProcessDef.addArg(\".\");\n\t\t}\n\t\t\n\t\t// Run the jar process to create the jar\n\t\textensionBase.runForegroundProcess(comment, \"JAR\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"2m\"), jarProcessDef);\n\t\tgenerator.outputLine(\"info('Created project jar: \" + jarName + \"');\");\n\t\t\n\t\treturn jarFile;\n\t}\n\n\t\n\t/**\n\t * This action creates a modular jar. \n\t * It basically runs commands such as the following:\n\t *   jar --create --file=mlib/com.greetings.jar --main-class=com.greetings.Main -C mods/com.greetings .\n\t *\n\t * @param comment is a short explanation of why the test is creating a modular jar.\n\t * @param moduleSpec describes the location of the module within the workspace. eg, \"test.modularity/bin/common-mods\"\n\t * @param moduleVersion is an optional version number for the modular jar, eg \"1.0\"\n\t * @param mainClass is the optional main class for the modular jar.\n\t * @param hashModules is the optional hash dependencies pattern for the modular jar.\n\t * @return a FileRef object which holds the location of the created modular jar.\n\t * @throws StfException \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec, String moduleVersion, Class<?> mainClass, String hashModules) throws StfException {\n\t\tint commandNum = generator.startNewCommand(comment, \"jar\", \"Create modular jar\",\n\t\t\t\t\"ModuleSpec:\",    moduleSpec,\n\t\t\t\t\"ModuleVersion:\", moduleVersion,\n\t\t\t\t\"MainClass:\",     (mainClass==null) ? null : mainClass.getName(),\n\t\t\t\t\"HashModules:\",     (hashModules==null) ? null : hashModules);\n\t\n\t\t// Verify that the moduleSpec really is pointing at a compiled module\n\t\tDirectoryRef moduleDir = environmentCore.findTestDirectory(moduleSpec);\n\t\tFileRef moduleInfoFile = moduleDir.childFile(\"module-info.class\");\n\t\tif (!moduleInfoFile.asJavaFile().exists()) { \n\t\t\tthrow new StfException(\"Module spec '\" + moduleSpec + \"' does not point at a valid module. \"\n\t\t\t\t\t+ \"Expected module-info.class file does not exist at: \" + moduleInfoFile.getSpec());\n\t\t}\n\t\t\n\t\t// Work out what the jar will be called and where to create it\n\t\tString versionSpec = (moduleVersion != null && !moduleVersion.isEmpty()) ? \"@\"+moduleVersion : \"\"; \n\t\tString moduleName = moduleDir.asJavaFile().getName();\n\t\tString jarName = commandNum + \".\" + moduleName + versionSpec + \".jar\";\n\t\tFileRef jarFile = environmentCore.getModulesDir().childFile(jarName);"
    },
    "203": {
      "metadata": {
        "chunk_id": "85478376f8f3076fe4d865b5c3dc7a074e49a0a85212a626ee4a286d58c2588f",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "// Build the arguments for the jar process\n\t\tJDKToolProcessDefinition jarProcessDef = createJDKToolProcessDefinition()\n\t\t\t\t.setJDKToolOrUtility(\"jar\")\n\t\t\t\t.addArg(\"--create\")\n\t\t\t\t.addArg(\"--file\", jarFile.getSpec());\n\t\tif (moduleVersion != null && !moduleVersion.isEmpty()) {\n\t\t\tjarProcessDef = jarProcessDef.addArg(\"--module-version=\" + moduleVersion);\n\t\t}\n\t\tif (mainClass != null) {\n\t\t\tjarProcessDef = jarProcessDef.addArg(\"--main-class=\" + mainClass.getName());\n\t\t}\n\t\tif (hashModules != null && !hashModules.isEmpty()) {\n\t\t\tjarProcessDef = jarProcessDef.addArg(\"--hash-modules=\" + hashModules);\n\t\t}\n\t\tjarProcessDef = jarProcessDef.addArg(\"-C\", moduleDir.getSpec(), \".\");\n\t\t\n\t\t// Run the jar process to create the modular jar\n\t\textensionBase.runForegroundProcess(comment, \"CMJ\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"2m\"), jarProcessDef);\n\t\tgenerator.outputLine(\"info('Created modular jar: \" + jarName + \"');\");\n\t\t\n\t\treturn new ModuleRef(moduleName, jarFile);\n\t}\n\n\n\t/**\n\t * Convenience method for creating modular jars which have neither a version number or main class.\n\t * @see doCreateModularJar(String, String, String, Class<?>, String) \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec) throws StfException {\n\t\treturn doCreateModularJar(comment, moduleSpec, null, null, null);\n\t}\n\n\t/**\n\t * Convenience method for creating modular jars with a version but without a main class.\n\t * @see doCreateModularJar(String, String, String, Class<?>, String) \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec, String moduleVersion) throws StfException {\n\t\treturn doCreateModularJar(comment, moduleSpec, moduleVersion, null, null);\n\t}\n\n\t/**\n\t * Convenience method for creating modular jars with a main class but without a version number.\n\t * @see doCreateModularJar(String, String, String, Class<?>, String) \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec, Class<?> mainClass) throws StfException {\n\t\treturn doCreateModularJar(comment, moduleSpec, null, mainClass, null);\n\t}\n\t\n\t/**\n\t * Convenience method for creating modular jars which have no main class, but a hash-module value.\n\t * @see doCreateModularJar(String, String, String, Class<?>, String) \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec, String moduleVersion, String hashModules) throws StfException {\n\t\treturn doCreateModularJar(comment, moduleSpec, moduleVersion, null, hashModules);\n\t}\n\t\n\n\t/**\n\t * Runs java9's jlink command, to create a runtime image.\n\t * The image is create in the tmp dir of the results area.\n\t * For example it may create a directory '/stf/20160722-142737-CpMpJlinkTest/tmp/2.HiJVM' \n\t * which contains 'bin/java'.\n\t * \n\t * This method ends up running commands such as:\n\t *   jlink --module-path /home/user/jdks/jdk-9_linux-x64_bin/jdk-9/jmods:/media/ramdisk/stf/20160720-132549-CpMpModularJarTest3/results/modules --add-modules com.hi --output /tmp/x\n\t * \n     * @param comment is a short explanation of what the test is doing.\n     * @param jlinkDefinition describes the jlink options which the test requires.\n\t * @return A reference to the directory which will hold the custom JVM image.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic DirectoryRef doRunJlink(String comment, JlinkDefinition jlinkDefinition) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"jlink\", \"Run jlink to create runtime image\",\n\t\t\t\t\"ImageName:\", jlinkDefinition.getOutputImageName());",
        "start_line": 1394,
        "end_line": 1467,
        "chunk_index": 21,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 892,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994504"
      },
      "text": "// Build the arguments for the jar process\n\t\tJDKToolProcessDefinition jarProcessDef = createJDKToolProcessDefinition()\n\t\t\t\t.setJDKToolOrUtility(\"jar\")\n\t\t\t\t.addArg(\"--create\")\n\t\t\t\t.addArg(\"--file\", jarFile.getSpec());\n\t\tif (moduleVersion != null && !moduleVersion.isEmpty()) {\n\t\t\tjarProcessDef = jarProcessDef.addArg(\"--module-version=\" + moduleVersion);\n\t\t}\n\t\tif (mainClass != null) {\n\t\t\tjarProcessDef = jarProcessDef.addArg(\"--main-class=\" + mainClass.getName());\n\t\t}\n\t\tif (hashModules != null && !hashModules.isEmpty()) {\n\t\t\tjarProcessDef = jarProcessDef.addArg(\"--hash-modules=\" + hashModules);\n\t\t}\n\t\tjarProcessDef = jarProcessDef.addArg(\"-C\", moduleDir.getSpec(), \".\");\n\t\t\n\t\t// Run the jar process to create the modular jar\n\t\textensionBase.runForegroundProcess(comment, \"CMJ\", Echo.ECHO_ON, ExpectedOutcome.cleanRun().within(\"2m\"), jarProcessDef);\n\t\tgenerator.outputLine(\"info('Created modular jar: \" + jarName + \"');\");\n\t\t\n\t\treturn new ModuleRef(moduleName, jarFile);\n\t}\n\n\n\t/**\n\t * Convenience method for creating modular jars which have neither a version number or main class.\n\t * @see doCreateModularJar(String, String, String, Class<?>, String) \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec) throws StfException {\n\t\treturn doCreateModularJar(comment, moduleSpec, null, null, null);\n\t}\n\n\t/**\n\t * Convenience method for creating modular jars with a version but without a main class.\n\t * @see doCreateModularJar(String, String, String, Class<?>, String) \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec, String moduleVersion) throws StfException {\n\t\treturn doCreateModularJar(comment, moduleSpec, moduleVersion, null, null);\n\t}\n\n\t/**\n\t * Convenience method for creating modular jars with a main class but without a version number.\n\t * @see doCreateModularJar(String, String, String, Class<?>, String) \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec, Class<?> mainClass) throws StfException {\n\t\treturn doCreateModularJar(comment, moduleSpec, null, mainClass, null);\n\t}\n\t\n\t/**\n\t * Convenience method for creating modular jars which have no main class, but a hash-module value.\n\t * @see doCreateModularJar(String, String, String, Class<?>, String) \n\t */\n\tpublic ModuleRef doCreateModularJar(String comment, String moduleSpec, String moduleVersion, String hashModules) throws StfException {\n\t\treturn doCreateModularJar(comment, moduleSpec, moduleVersion, null, hashModules);\n\t}\n\t\n\n\t/**\n\t * Runs java9's jlink command, to create a runtime image.\n\t * The image is create in the tmp dir of the results area.\n\t * For example it may create a directory '/stf/20160722-142737-CpMpJlinkTest/tmp/2.HiJVM' \n\t * which contains 'bin/java'.\n\t * \n\t * This method ends up running commands such as:\n\t *   jlink --module-path /home/user/jdks/jdk-9_linux-x64_bin/jdk-9/jmods:/media/ramdisk/stf/20160720-132549-CpMpModularJarTest3/results/modules --add-modules com.hi --output /tmp/x\n\t * \n     * @param comment is a short explanation of what the test is doing.\n     * @param jlinkDefinition describes the jlink options which the test requires.\n\t * @return A reference to the directory which will hold the custom JVM image.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic DirectoryRef doRunJlink(String comment, JlinkDefinition jlinkDefinition) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"jlink\", \"Run jlink to create runtime image\",\n\t\t\t\t\"ImageName:\", jlinkDefinition.getOutputImageName());"
    },
    "204": {
      "metadata": {
        "chunk_id": "d3dfb424d8623d0aef1eb9c34cb34061c2f1691198a94f79296da4462c9db387",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "// If the test is deciding where to create the image then guard against\n\t\t// possibility that it may already contain an image by deleting its contents.\n\t\tDirectoryRef jlinkOutputDir = jlinkDefinition.getOutputImageDir();\n\t\tif (jlinkDefinition.usingCustomOuputImageDir()) {\n\t\t\tif (PlatformFinder.isWindows()) {\n\t\t\t\tgenerator.outputLine(\"stf::stfUtility->splatTree( dir => \" + \"'\" + jlinkOutputDir.getSpec() + \"' );\");\n\t\t\t} else {\n\t\t\t\tgenerator.outputLine(\"rmtree( \" + \"'\" + jlinkOutputDir.getSpec() + \"', {error => \\\\$err\" + \"});\");\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t// Run the jlink command to create a custom JVM image\n\t\textensionBase.runForegroundProcess(\"Run jlink\", \"JLNK\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"2m\"), jlinkDefinition);\n\n\t\treturn jlinkDefinition.getOutputImageDir();\n\t}\n\n\n\t/**\n\t * Adds a block of perl code which scans a log file and counts the number of matches for supplied strings.\n\t * The test will fail if the actual number of matches does not equal the expected number. \n\t * \n\t * It does this by creating a while loop which opens a log and does a regex match on each line.\n\t * If a match is found the count variable is incremented, this method also supports multiple expected messages and\n\t * builds the if statement arguments accordingly.\n\t * \n     * @param comment is a short explanation of what the test is doing.\n\t * @param file is the file whose output is scanned.\n\t * @param expectedCount is the expected number of matches for the patterns in the file. \n\t * @param patterns contains the strings that the data file is expected to contain.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void doCountFileMatches(String comment, FileRef file, int expectedCount, String... patterns) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"count\", \"Count file matches\",\n\t\t\t\t\"TargetFile:\", file.getSpec(),\n\t\t\t\t\"ExpectedNumMatches:\", Integer.toString(expectedCount),\n\t\t\t\t\"SearchStrings:\", formatStringArray(patterns).toString());\n\n\t\t// Generate perl to count how many matches there are in the file\n\t\textensionBase.outputCountFileMatches(\"$file_match_count\", file, patterns);\n\t\t\n\t\t// Fail if the actual number of matches does not equal the expected number\n\t\textensionBase.outputFailIfTrue(\"java\", comment, \"$file_match_count\", \"!=\", expectedCount);\n\t\tgenerator.outputLine(\"info('Found \" + expectedCount + \" instances of \" + formatStringArray(patterns) + \"');\");\n\t}\n\t\n\n\t/**\n\t * Adds a block of perl code which scans a log file for supplied strings.\n\t * The test will pass if there is *any* number of matches found for the supplied \n\t * string. It will fail if no occurrence of the given string is found in the log.  \n\t * \n\t * It does this by creating a while loop which opens a log and does a regex match on each line.\n\t * If a match is found the count variable is incremented, this method also supports multiple expected messages and\n\t * builds the if statement arguments accordingly.\n\t * \n     * @param comment is a short explanation of what the test is doing.\n\t * @param file is the file whose output is scanned.\n\t * @param patterns contains the strings that the data file is expected to contain.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void doFindFileMatches(String comment, FileRef file, String... patterns) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"count\", \"Count file matches\",\n\t\t\t\t\"TargetFile:\", file.getSpec(),\n\t\t\t\t\"SearchStrings:\", formatStringArray(patterns).toString());",
        "start_line": 1468,
        "end_line": 1532,
        "chunk_index": 22,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 824,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994506"
      },
      "text": "// If the test is deciding where to create the image then guard against\n\t\t// possibility that it may already contain an image by deleting its contents.\n\t\tDirectoryRef jlinkOutputDir = jlinkDefinition.getOutputImageDir();\n\t\tif (jlinkDefinition.usingCustomOuputImageDir()) {\n\t\t\tif (PlatformFinder.isWindows()) {\n\t\t\t\tgenerator.outputLine(\"stf::stfUtility->splatTree( dir => \" + \"'\" + jlinkOutputDir.getSpec() + \"' );\");\n\t\t\t} else {\n\t\t\t\tgenerator.outputLine(\"rmtree( \" + \"'\" + jlinkOutputDir.getSpec() + \"', {error => \\\\$err\" + \"});\");\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t// Run the jlink command to create a custom JVM image\n\t\textensionBase.runForegroundProcess(\"Run jlink\", \"JLNK\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"2m\"), jlinkDefinition);\n\n\t\treturn jlinkDefinition.getOutputImageDir();\n\t}\n\n\n\t/**\n\t * Adds a block of perl code which scans a log file and counts the number of matches for supplied strings.\n\t * The test will fail if the actual number of matches does not equal the expected number. \n\t * \n\t * It does this by creating a while loop which opens a log and does a regex match on each line.\n\t * If a match is found the count variable is incremented, this method also supports multiple expected messages and\n\t * builds the if statement arguments accordingly.\n\t * \n     * @param comment is a short explanation of what the test is doing.\n\t * @param file is the file whose output is scanned.\n\t * @param expectedCount is the expected number of matches for the patterns in the file. \n\t * @param patterns contains the strings that the data file is expected to contain.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void doCountFileMatches(String comment, FileRef file, int expectedCount, String... patterns) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"count\", \"Count file matches\",\n\t\t\t\t\"TargetFile:\", file.getSpec(),\n\t\t\t\t\"ExpectedNumMatches:\", Integer.toString(expectedCount),\n\t\t\t\t\"SearchStrings:\", formatStringArray(patterns).toString());\n\n\t\t// Generate perl to count how many matches there are in the file\n\t\textensionBase.outputCountFileMatches(\"$file_match_count\", file, patterns);\n\t\t\n\t\t// Fail if the actual number of matches does not equal the expected number\n\t\textensionBase.outputFailIfTrue(\"java\", comment, \"$file_match_count\", \"!=\", expectedCount);\n\t\tgenerator.outputLine(\"info('Found \" + expectedCount + \" instances of \" + formatStringArray(patterns) + \"');\");\n\t}\n\t\n\n\t/**\n\t * Adds a block of perl code which scans a log file for supplied strings.\n\t * The test will pass if there is *any* number of matches found for the supplied \n\t * string. It will fail if no occurrence of the given string is found in the log.  \n\t * \n\t * It does this by creating a while loop which opens a log and does a regex match on each line.\n\t * If a match is found the count variable is incremented, this method also supports multiple expected messages and\n\t * builds the if statement arguments accordingly.\n\t * \n     * @param comment is a short explanation of what the test is doing.\n\t * @param file is the file whose output is scanned.\n\t * @param patterns contains the strings that the data file is expected to contain.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void doFindFileMatches(String comment, FileRef file, String... patterns) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"count\", \"Count file matches\",\n\t\t\t\t\"TargetFile:\", file.getSpec(),\n\t\t\t\t\"SearchStrings:\", formatStringArray(patterns).toString());"
    },
    "205": {
      "metadata": {
        "chunk_id": "925449ed9124b94d3074d5e1f76b2a3381fc0a5646e810dba22f0fba6fe36dff",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "// Generate perl to count how many matches there are in the file\n\t\textensionBase.outputCountFileMatches(\"$file_match_count\", file, patterns);\n\t\t\n\t\t// Fail if the actual number of matches does not equal the expected number\n\t\textensionBase.outputFailIfTrue(\"java\", comment, \"$file_match_count\", \"==\", 0);\n\t\tgenerator.outputLine(\"info('Found instances of \" + formatStringArray(patterns) + \"');\");\n\t}\n\t\n\t\n\t// Given an array of Strings, builds a coma separated list of Strings with double quote around each string\n\t// Added to prevent perl parsing errors by escaping string arguments which start and end\n\t// with single quotes. \n\tprivate StringBuilder formatStringArray(String... arguments) {\n\t\tStringBuilder buff = new StringBuilder();\n\t\tif (arguments == null || arguments.length == 0 || arguments[0] == null) {\n\t\t\treturn buff;\n\t\t}\n\t\t\n\t\tbuff.append(\"[\");\n\t\tfor (int i=0; i<arguments.length; i++) {\n\t\t\tif (i>0) { \n\t\t\t\tbuff.append(\", \");\n\t\t\t}\n\t\t\tString argValue = arguments[i];\n\t\t\targValue = argValue.replaceAll(\"'\", \"\\\"\");\n\t\t\tbuff.append(\"\\\"\" + argValue + \"\\\"\");\n\t\t}\n\t\tbuff.append(\"]\");\n\t\treturn buff;\n\t}\n\n\n\t// Utility method to process a comma separated list of includes or excludes\n\t// and invoke formatStringArray() method to create the formatted StringBuilder\n\tprivate String formatCommaSeparatedList(String list) {\n\t\tif (list == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn formatStringArray(list.split(\",\")).toString();\n\t}  \n\t\n\t\n\t/**\n\t * Verifies that java processes using the primary JVM will be run with the listed arguments.\n\t * The test will fail with an error if any of the mandatory arguments are not present.\n\t * \n\t * @param stage is the stage whose arguments should be checked.\n\t * @param mandatoryArgs contains 1 or more java arguments.\n\t * @throws StfException if this method is called from the setup, execute or teardown stages.\n\t */\n\tpublic void verifyJavaArgsContains(Stage stage, String... mandatoryArgs) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Java argument verification is not valid for the initialisation stage.\");\n\t\t}\n\n\t\t// Get hold of the mandatory and actual java arguments\n\t\tList<String> mandatoryArgsList = Arrays.asList(mandatoryArgs);\n\t\tArrayList<String> actualArgs = getActiveJavaArgs(stage);\n\n\t\t// Subtract the actual args from the mandatory. \n\t\t// The remaining args are mandatories which haven't been given a value.\n\t\tSet<String> mandatoryArgsSet = new LinkedHashSet<String>(mandatoryArgsList);\n\t\tSet<String> actualArgsSet = new LinkedHashSet<String>(actualArgs);\n\t\tmandatoryArgsSet.removeAll(actualArgsSet);\n\n\t\tif (!mandatoryArgsSet.isEmpty()) {\n\t\t\tthrow new StfError(\"Unable to run test as the \" + stage.getMethodName() + \" stage \"\n\t\t\t\t\t+ \"is missing the following mandatory Java arguments: \\\"\" + convertToString(new ArrayList<String>(mandatoryArgsSet)) + \"\\\". \"\n\t\t\t\t\t+ \"Actual Java arguments for this stage are \\\"\" + convertToString(actualArgs) + \"\\\"\");\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Checks if that java processes using the primary JVM contains the given JVM option\n\t * \n\t * @param stage is the stage whose arguments should be checked.\n\t * @param argToCheck contains 1 java arguments.\n\t */\n\tpublic boolean isJavaArgPresent(Stage stage, String argToCheck) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Java argument verification is not valid for the initialisation stage.\");\n\t\t}\n\n\t\t// Get hold of the mandatory and actual java arguments\n\t\tArrayList<String> actualArgs = getActiveJavaArgs(stage);\n\t\tSet<String> actualArgsSet = new LinkedHashSet<String>(actualArgs);\n\t\treturn actualArgsSet.contains(argToCheck);\n\t}",
        "start_line": 1533,
        "end_line": 1621,
        "chunk_index": 23,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 849,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994508"
      },
      "text": "// Generate perl to count how many matches there are in the file\n\t\textensionBase.outputCountFileMatches(\"$file_match_count\", file, patterns);\n\t\t\n\t\t// Fail if the actual number of matches does not equal the expected number\n\t\textensionBase.outputFailIfTrue(\"java\", comment, \"$file_match_count\", \"==\", 0);\n\t\tgenerator.outputLine(\"info('Found instances of \" + formatStringArray(patterns) + \"');\");\n\t}\n\t\n\t\n\t// Given an array of Strings, builds a coma separated list of Strings with double quote around each string\n\t// Added to prevent perl parsing errors by escaping string arguments which start and end\n\t// with single quotes. \n\tprivate StringBuilder formatStringArray(String... arguments) {\n\t\tStringBuilder buff = new StringBuilder();\n\t\tif (arguments == null || arguments.length == 0 || arguments[0] == null) {\n\t\t\treturn buff;\n\t\t}\n\t\t\n\t\tbuff.append(\"[\");\n\t\tfor (int i=0; i<arguments.length; i++) {\n\t\t\tif (i>0) { \n\t\t\t\tbuff.append(\", \");\n\t\t\t}\n\t\t\tString argValue = arguments[i];\n\t\t\targValue = argValue.replaceAll(\"'\", \"\\\"\");\n\t\t\tbuff.append(\"\\\"\" + argValue + \"\\\"\");\n\t\t}\n\t\tbuff.append(\"]\");\n\t\treturn buff;\n\t}\n\n\n\t// Utility method to process a comma separated list of includes or excludes\n\t// and invoke formatStringArray() method to create the formatted StringBuilder\n\tprivate String formatCommaSeparatedList(String list) {\n\t\tif (list == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn formatStringArray(list.split(\",\")).toString();\n\t}  \n\t\n\t\n\t/**\n\t * Verifies that java processes using the primary JVM will be run with the listed arguments.\n\t * The test will fail with an error if any of the mandatory arguments are not present.\n\t * \n\t * @param stage is the stage whose arguments should be checked.\n\t * @param mandatoryArgs contains 1 or more java arguments.\n\t * @throws StfException if this method is called from the setup, execute or teardown stages.\n\t */\n\tpublic void verifyJavaArgsContains(Stage stage, String... mandatoryArgs) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Java argument verification is not valid for the initialisation stage.\");\n\t\t}\n\n\t\t// Get hold of the mandatory and actual java arguments\n\t\tList<String> mandatoryArgsList = Arrays.asList(mandatoryArgs);\n\t\tArrayList<String> actualArgs = getActiveJavaArgs(stage);\n\n\t\t// Subtract the actual args from the mandatory. \n\t\t// The remaining args are mandatories which haven't been given a value.\n\t\tSet<String> mandatoryArgsSet = new LinkedHashSet<String>(mandatoryArgsList);\n\t\tSet<String> actualArgsSet = new LinkedHashSet<String>(actualArgs);\n\t\tmandatoryArgsSet.removeAll(actualArgsSet);\n\n\t\tif (!mandatoryArgsSet.isEmpty()) {\n\t\t\tthrow new StfError(\"Unable to run test as the \" + stage.getMethodName() + \" stage \"\n\t\t\t\t\t+ \"is missing the following mandatory Java arguments: \\\"\" + convertToString(new ArrayList<String>(mandatoryArgsSet)) + \"\\\". \"\n\t\t\t\t\t+ \"Actual Java arguments for this stage are \\\"\" + convertToString(actualArgs) + \"\\\"\");\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Checks if that java processes using the primary JVM contains the given JVM option\n\t * \n\t * @param stage is the stage whose arguments should be checked.\n\t * @param argToCheck contains 1 java arguments.\n\t */\n\tpublic boolean isJavaArgPresent(Stage stage, String argToCheck) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Java argument verification is not valid for the initialisation stage.\");\n\t\t}\n\n\t\t// Get hold of the mandatory and actual java arguments\n\t\tArrayList<String> actualArgs = getActiveJavaArgs(stage);\n\t\tSet<String> actualArgsSet = new LinkedHashSet<String>(actualArgs);\n\t\treturn actualArgsSet.contains(argToCheck);\n\t}"
    },
    "206": {
      "metadata": {
        "chunk_id": "744f7f0fccde3669ff4a5cc386b7c7f8b892ee0f1eb6532f88307c3e715de19f",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "// Get hold of the mandatory and actual java arguments\n\t\tArrayList<String> actualArgs = getActiveJavaArgs(stage);\n\t\tSet<String> actualArgsSet = new LinkedHashSet<String>(actualArgs);\n\t\treturn actualArgsSet.contains(argToCheck);\n\t}\n\n\n\t/**\n\t * Verifies that none of the specified java arguments will be used when running\n\t * java processes running on the primary JVM.\n\t * The test will fail with an error if any of the arguments are present.\n\t * \n\t * @param stage is the stage whose java arguments the caller wants to check.\n\t * @param invalidArgs contains 1 or more java arguments.\n\t * @throws StfError if any invalid argument would be used for Java processes.\n\t */\n\tpublic void verifyJavaArgsDoesntContain(Stage stage, String... invalidArgs) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Java argument verification is not valid for the initialisation stage.\");\n\t\t}\n\n\t\t// Get hold of the mandatory and actual java arguments\n\t\tList<String> invalidArgsList = Arrays.asList(invalidArgs);\n\t\tArrayList<String> actualArgs = getActiveJavaArgs(stage);\n\n\t\t// Work out the intersection between the invalid args and the actual args.\n\t\t// Anything left in 'invalidArgsSet' is an arg than the caller says is invalid \n\t\t// but which the current stage has a value for.\n\t\tSet<String> invalidArgsSet = new LinkedHashSet<String>(invalidArgsList);\n\t\tSet<String> actualArgsSet = new LinkedHashSet<String>(actualArgs);\n\t\tinvalidArgsSet.retainAll(actualArgsSet);\n\n\t\tif (!invalidArgsSet.isEmpty()) {\n\t\t\tthrow new StfError(\"Unable to run test as the \" + stage.getMethodName() + \" stage \"\n\t\t\t\t\t+ \"is has been given values for Java arguments that are not compatible with the test: \\\"\" + convertToString(new ArrayList<String>(invalidArgsSet)) + \"\\\". \"\n\t\t\t\t\t+ \"Actual Java arguments for this stage are \\\"\" + convertToString(actualArgs) + \"\\\"\");\n\t\t}\n\t}\n\t\n\t\n\t// Returns the java arguments which are used for the specified stage.\n\tprivate ArrayList<String> getActiveJavaArgs(Stage stage) throws StfException {\n\t\tArrayList<String> commandArgs = new ArrayList<String>();\n\t\t\n\t\tif (stage == Stage.EXECUTE) {\n\t\t\t// Add in the arguments that can optionally be supplied for the execute stage. \n\t\t\t// This value will also contain the arguments derived from use of the -mode=xxxx option. \n\t\t\tString initialJvmOptions = environmentCore.getProperty(Stf.ARG_JAVA_ARGS_EXECUTE_INITIAL);\n\t\t\tArrayList<String> jvmOptionArgs = StringSplitter.splitArguments(initialJvmOptions);\n\t\t\tcommandArgs.addAll(jvmOptionArgs);\n\t\t}\n\t\t\n\t\t// Get hold of the java arguments for the specified stage\n\t\tArgument baseJvmOptionsArgument = stage.getJavaArg(environmentCore.primaryJvm());\n\t\tString stageJavaArgs = environmentCore.getProperty(baseJvmOptionsArgument);\n\t\t\n\t\t// Add the regular java arguments for the stage onto the known command arguments\n\t\tcommandArgs.addAll(StringSplitter.splitArguments(stageJavaArgs));\n\t\t\n\t\treturn commandArgs;\n\t}\n\t\n\t\n\t// Concatenate together a list of strings.\n\t// @returns a String without commas between the elements so that the  \n\t// resulting string can be fed back in as java arguments.\n\tprivate String convertToString(List<String> mandatoryArgsList) {\n\t\tStringBuilder mandatorySpec = new StringBuilder();\n\t\tfor (String s : mandatoryArgsList) {\n\t\t\tif (mandatorySpec.length() > 0) {\n\t\t\t\tmandatorySpec.append(\" \");\n\t\t\t}\n\t\t\tmandatorySpec.append(s);\n\t\t}\n\t\t\n\t\treturn mandatorySpec.toString();\n\t}\n\t\n\t\n\t/**\n\t * Creates an environment variable.\n\t * \n\t * @param variable is the environment variable that we want to set\n\t * @param value is the value of the environment variable being set\n\t * @throws StfException if something goes wrong\n\t */\n\tpublic void doSetEnvVariable(String comment, String variable, String value) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"$ENV{variable}=value\", \"Set environment variable\",\n\t\t\t\t\"Variable:\", variable,\n\t\t\t\t\"Value:\", value);\n\t\t\n\t\tgenerator.outputLine(\"$ENV{'\" + variable + \"'} = \\\"\" + value + \"\\\";\");\n\t}",
        "start_line": 1622,
        "end_line": 1714,
        "chunk_index": 24,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 914,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994510"
      },
      "text": "// Get hold of the mandatory and actual java arguments\n\t\tArrayList<String> actualArgs = getActiveJavaArgs(stage);\n\t\tSet<String> actualArgsSet = new LinkedHashSet<String>(actualArgs);\n\t\treturn actualArgsSet.contains(argToCheck);\n\t}\n\n\n\t/**\n\t * Verifies that none of the specified java arguments will be used when running\n\t * java processes running on the primary JVM.\n\t * The test will fail with an error if any of the arguments are present.\n\t * \n\t * @param stage is the stage whose java arguments the caller wants to check.\n\t * @param invalidArgs contains 1 or more java arguments.\n\t * @throws StfError if any invalid argument would be used for Java processes.\n\t */\n\tpublic void verifyJavaArgsDoesntContain(Stage stage, String... invalidArgs) throws StfException {\n\t\tif (stage == Stage.INITIALISATION) {\n\t\t\tthrow new StfException(\"Java argument verification is not valid for the initialisation stage.\");\n\t\t}\n\n\t\t// Get hold of the mandatory and actual java arguments\n\t\tList<String> invalidArgsList = Arrays.asList(invalidArgs);\n\t\tArrayList<String> actualArgs = getActiveJavaArgs(stage);\n\n\t\t// Work out the intersection between the invalid args and the actual args.\n\t\t// Anything left in 'invalidArgsSet' is an arg than the caller says is invalid \n\t\t// but which the current stage has a value for.\n\t\tSet<String> invalidArgsSet = new LinkedHashSet<String>(invalidArgsList);\n\t\tSet<String> actualArgsSet = new LinkedHashSet<String>(actualArgs);\n\t\tinvalidArgsSet.retainAll(actualArgsSet);\n\n\t\tif (!invalidArgsSet.isEmpty()) {\n\t\t\tthrow new StfError(\"Unable to run test as the \" + stage.getMethodName() + \" stage \"\n\t\t\t\t\t+ \"is has been given values for Java arguments that are not compatible with the test: \\\"\" + convertToString(new ArrayList<String>(invalidArgsSet)) + \"\\\". \"\n\t\t\t\t\t+ \"Actual Java arguments for this stage are \\\"\" + convertToString(actualArgs) + \"\\\"\");\n\t\t}\n\t}\n\t\n\t\n\t// Returns the java arguments which are used for the specified stage.\n\tprivate ArrayList<String> getActiveJavaArgs(Stage stage) throws StfException {\n\t\tArrayList<String> commandArgs = new ArrayList<String>();\n\t\t\n\t\tif (stage == Stage.EXECUTE) {\n\t\t\t// Add in the arguments that can optionally be supplied for the execute stage. \n\t\t\t// This value will also contain the arguments derived from use of the -mode=xxxx option. \n\t\t\tString initialJvmOptions = environmentCore.getProperty(Stf.ARG_JAVA_ARGS_EXECUTE_INITIAL);\n\t\t\tArrayList<String> jvmOptionArgs = StringSplitter.splitArguments(initialJvmOptions);\n\t\t\tcommandArgs.addAll(jvmOptionArgs);\n\t\t}\n\t\t\n\t\t// Get hold of the java arguments for the specified stage\n\t\tArgument baseJvmOptionsArgument = stage.getJavaArg(environmentCore.primaryJvm());\n\t\tString stageJavaArgs = environmentCore.getProperty(baseJvmOptionsArgument);\n\t\t\n\t\t// Add the regular java arguments for the stage onto the known command arguments\n\t\tcommandArgs.addAll(StringSplitter.splitArguments(stageJavaArgs));\n\t\t\n\t\treturn commandArgs;\n\t}\n\t\n\t\n\t// Concatenate together a list of strings.\n\t// @returns a String without commas between the elements so that the  \n\t// resulting string can be fed back in as java arguments.\n\tprivate String convertToString(List<String> mandatoryArgsList) {\n\t\tStringBuilder mandatorySpec = new StringBuilder();\n\t\tfor (String s : mandatoryArgsList) {\n\t\t\tif (mandatorySpec.length() > 0) {\n\t\t\t\tmandatorySpec.append(\" \");\n\t\t\t}\n\t\t\tmandatorySpec.append(s);\n\t\t}\n\t\t\n\t\treturn mandatorySpec.toString();\n\t}\n\t\n\t\n\t/**\n\t * Creates an environment variable.\n\t * \n\t * @param variable is the environment variable that we want to set\n\t * @param value is the value of the environment variable being set\n\t * @throws StfException if something goes wrong\n\t */\n\tpublic void doSetEnvVariable(String comment, String variable, String value) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"$ENV{variable}=value\", \"Set environment variable\",\n\t\t\t\t\"Variable:\", variable,\n\t\t\t\t\"Value:\", value);\n\t\t\n\t\tgenerator.outputLine(\"$ENV{'\" + variable + \"'} = \\\"\" + value + \"\\\";\");\n\t}"
    },
    "207": {
      "metadata": {
        "chunk_id": "435523b4f428e5b8667fe51bfa6394ba7fd40b8d5ad6207179a2174d70a13ff6",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfCoreExtension.java",
        "content": "/**\n\t * This is a crude function to sleep for a given period in seconds. \n\t * \n\t * It is not normally a good approach to have sleep calls but this \n\t * provides a workaround until STF has an API to sync processes and \n\t * wait for specific events.   \n\t * \n\t * @param period is the period in seconds to sleep for\n\t * @throws StfException if something goes wrong\n\t */\n\tpublic void doSleep(String comment, String period) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"sleep(time)\", \"Sleep for a given period\",\n\t\t\t\t\"period:\", period);\n\t\t\n\t\tgenerator.outputLine(\"sleep(\" + period + \");\");\n\t}\n}",
        "start_line": 1715,
        "end_line": 1731,
        "chunk_index": 25,
        "total_chunks": 26,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 150,
        "node_type": null,
        "file_sha": "073ca13e0f1e149d90689ad4e9abcf2830bf4a4e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:51.994512"
      },
      "text": "/**\n\t * This is a crude function to sleep for a given period in seconds. \n\t * \n\t * It is not normally a good approach to have sleep calls but this \n\t * provides a workaround until STF has an API to sync processes and \n\t * wait for specific events.   \n\t * \n\t * @param period is the period in seconds to sleep for\n\t * @throws StfException if something goes wrong\n\t */\n\tpublic void doSleep(String comment, String period) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"sleep(time)\", \"Sleep for a given period\",\n\t\t\t\t\"period:\", period);\n\t\t\n\t\tgenerator.outputLine(\"sleep(\" + period + \");\");\n\t}\n}"
    },
    "208": {
      "metadata": {
        "chunk_id": "d8356002240667b2cae4ec6d06c2777d5687d67a4e08da0615dd722c8d0fe9a1",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfEnvironment.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions.core;\n\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.StfTestArguments;\nimport net.adoptopenjdk.stf.extensions.Stf;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition.JarId;\n\n\n/**\n * This class provides simplified environment information to plugins using the 'Stf' extension.\n */",
        "start_line": 0,
        "end_line": 30,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 264,
        "node_type": null,
        "file_sha": "90782c8f36791db838387b59fba143fbf16e787a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.009277"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions.core;\n\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.StfTestArguments;\nimport net.adoptopenjdk.stf.extensions.Stf;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition.JarId;\n\n\n/**\n * This class provides simplified environment information to plugins using the 'Stf' extension.\n */"
    },
    "209": {
      "metadata": {
        "chunk_id": "b68d8bf73388caf358f514fa3c53104e435e8473aa6eb845de834afb5d045438",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfEnvironment.java",
        "content": "public class StfEnvironment {\n    // Holds a reference to the full STF environment data.\n\t// This class is used to provide test plugins with the relevant subset of \n\t// the environmental data. \n\tprivate StfEnvironmentCore environmentCore;\n\t\n\t\n\tStfEnvironment(StfEnvironmentCore environmentCore) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t}\n\t\n\t\n\t/**\n\t * Takes a directory path without a root, and tries to find that directory inside \n\t * each of our test roots. If it cannot be found, an exception is thrown.\n\t * @param directoryRef  The path of the directory we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find directory\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found directory >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A DirectoryRef for the directory we were trying to find.\n\t * @throws StfException In case we cannot find the directory, or if we found it in more than one test root.\n\t */\n\tpublic DirectoryRef findTestDirectory(String directoryRef, String... errorPrefixes) throws StfException {\n\t\treturn environmentCore.findTestDirectory(directoryRef, errorPrefixes);\n\t}\n\t\n\t\n\t/**\n\t * Takes a file path without a root, and tries to find that file inside each of our test \n\t * roots. If it cannot be found, an exception is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find file\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found file >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A FileRef for the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one test root.\n\t */\n\tpublic FileRef findTestFile(String fileRef, String... errorPrefixes) throws StfException {\n\t\treturn environmentCore.findTestFile(fileRef, errorPrefixes);\n\t}\n\t\n\t\n\t/**\n\t * Takes a directory path without a root, and tries to find that directory inside \n\t * each of our prereq roots. If it cannot be found, an exception is thrown.\n\t * @param directoryRef  The path of the directory we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find directory\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found directory >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A DirectoryRef for the directory we were trying to find.\n\t * @throws StfException In case we cannot find the directory, or if we found it in more than one prereq root.\n\t */\n\tpublic DirectoryRef findPrereqDirectory(String directoryRef, String... errorPrefixes) throws StfException {\n\t\treturn environmentCore.findPrereqDirectory(directoryRef, errorPrefixes);\n\t}\n\t\n\t\n\t/**\n\t * Takes a file path without a root, and tries to find that file inside each of our prereq \n\t * roots. If it cannot be found, an exception is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find file\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found file >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A FileRef for the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one prereq root.\n\t */\n\tpublic FileRef findPrereqFile(String fileRef, String... errorPrefixes) throws StfException {",
        "start_line": 31,
        "end_line": 98,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 908,
        "node_type": null,
        "file_sha": "90782c8f36791db838387b59fba143fbf16e787a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.009284"
      },
      "text": "public class StfEnvironment {\n    // Holds a reference to the full STF environment data.\n\t// This class is used to provide test plugins with the relevant subset of \n\t// the environmental data. \n\tprivate StfEnvironmentCore environmentCore;\n\t\n\t\n\tStfEnvironment(StfEnvironmentCore environmentCore) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t}\n\t\n\t\n\t/**\n\t * Takes a directory path without a root, and tries to find that directory inside \n\t * each of our test roots. If it cannot be found, an exception is thrown.\n\t * @param directoryRef  The path of the directory we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find directory\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found directory >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A DirectoryRef for the directory we were trying to find.\n\t * @throws StfException In case we cannot find the directory, or if we found it in more than one test root.\n\t */\n\tpublic DirectoryRef findTestDirectory(String directoryRef, String... errorPrefixes) throws StfException {\n\t\treturn environmentCore.findTestDirectory(directoryRef, errorPrefixes);\n\t}\n\t\n\t\n\t/**\n\t * Takes a file path without a root, and tries to find that file inside each of our test \n\t * roots. If it cannot be found, an exception is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find file\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found file >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A FileRef for the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one test root.\n\t */\n\tpublic FileRef findTestFile(String fileRef, String... errorPrefixes) throws StfException {\n\t\treturn environmentCore.findTestFile(fileRef, errorPrefixes);\n\t}\n\t\n\t\n\t/**\n\t * Takes a directory path without a root, and tries to find that directory inside \n\t * each of our prereq roots. If it cannot be found, an exception is thrown.\n\t * @param directoryRef  The path of the directory we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find directory\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found directory >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A DirectoryRef for the directory we were trying to find.\n\t * @throws StfException In case we cannot find the directory, or if we found it in more than one prereq root.\n\t */\n\tpublic DirectoryRef findPrereqDirectory(String directoryRef, String... errorPrefixes) throws StfException {\n\t\treturn environmentCore.findPrereqDirectory(directoryRef, errorPrefixes);\n\t}\n\t\n\t\n\t/**\n\t * Takes a file path without a root, and tries to find that file inside each of our prereq \n\t * roots. If it cannot be found, an exception is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find file\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found file >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A FileRef for the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one prereq root.\n\t */\n\tpublic FileRef findPrereqFile(String fileRef, String... errorPrefixes) throws StfException {"
    },
    "210": {
      "metadata": {
        "chunk_id": "8abfb7c2dc8324dfc4694d8981a31ec66577c8a2d2b06da5cc0da5aa674691c9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfEnvironment.java",
        "content": "* roots. If it cannot be found, an exception is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find file\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found file >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A FileRef for the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one prereq root.\n\t */\n\tpublic FileRef findPrereqFile(String fileRef, String... errorPrefixes) throws StfException {\n\t\treturn environmentCore.findPrereqFile(fileRef, errorPrefixes);\n\t}\n\t\n\t\n\t/**\n\t * Allows the caller to find the test cases root directory. i.e. The directory specified\n\t * via the -test-root=xxx argument. \n\t */\n\tpublic ArrayList<DirectoryRef> getTestRoots() {\n\t\treturn environmentCore.getTestRoots();\n\t}\n\t\n\t/**\n\t * Allows the caller to find the prereqs directories. i.e. The locations \n\t * of the third-party executables, jars, etc.\n\t * If not specified on the command line or in a properties file, the location \n\t * is found by working upwards from each of the test root directories, searching each\n\t * directory for a child directory called prereqs.\n\t * @return an array of DirectoryRefs pointing at prereq locations.\n\t * \n\t */\n\tpublic ArrayList<DirectoryRef> getPrereqRoots() {\n\t\treturn environmentCore.getPrereqRoots();\n\t}\n\t\n\t\n\t/**\n\t * Tests which need temporary files or directories should create them in the \n\t * temporary directory. \n\t * Tests do not need to clean up the temporary directory, as this will \n\t * be done when the next test starts running.\n\t * @return A reference to a temporary directory created for the current test.\n\t */\n\tpublic DirectoryRef getTmpDir() { \n\t\treturn environmentCore.getTmpDir();\n\t}\n\t\n\t/**\n\t * Test results and similar information should be written to the results directory.\n\t * @return a reference to the results directory for the current test.\n\t */\n\tpublic DirectoryRef getResultsDir() { \n\t\treturn environmentCore.getResultsDir();\n\t}\n\t\n\t/**\n\t * Any data which may be helpful for debugging can be written to this directory.\n\t * @return a directory reference to a directory which holds debugging information.\n\t */\n\tpublic DirectoryRef getDebugDir() { \n\t\treturn environmentCore.getDebugDir();\n\t}\n\t\n\t\n\t/**\n\t * Creates a DirectoryRef.\n\t * @param fileName      The directory path.\n\t * @return              A DirectoryRef for the directory.\n\t * @throws StfException\n\t */\n\tpublic DirectoryRef createDirectoryRef(String fileName) throws StfException {\n\t\treturn environmentCore.createDirectoryRef(fileName);\n\t}\n\t\n\t/**\n\t * Creates a FileRef.\n\t * @param fileName      The file path.\n\t * @return              A FileRef for the file.\n\t * @throws StfException\n\t */\n\tpublic FileRef createFileRef(String fileName) throws StfException {\n\t\treturn environmentCore.createFileRef(fileName);\n\t}\n\t\n\t/**\n\t * @return a string containing the platform name, eg 'linux_x86-64'\n\t * @throws StfException if there was a problem interpreting the current platform.\n\t */\n\tpublic String getPlatform() throws StfException {\n\t\treturn environmentCore.getPlatform();\n\t}\n\t\n\t/**\n\t * @return a simple name for platform e.g. win, osx, zos etc\n\t * @throws StfException if there was a problem interpreting the current platform.\n\t */\n\tpublic String getPlatformSimple() throws StfException {\n\t\treturn environmentCore.getPlatformSimple();\n\t}\n\t\n\t/**\n\t * This method provides access to the test specific properties. The argument \n\t * values are given to STF at runtime through the '-test-args' parameter.\n\t * This takes 1 or more comma separated values. For example: \n\t *   stf -test=MyTest -test-args=\"arg1=value1,arg2=value2\"\n\t * \n\t * Each value for expectedPropertyNames can be specified in 1 of 2 forms:\n\t *   - Either a string containing the name of the property. This makes the",
        "start_line": 99,
        "end_line": 205,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 949,
        "node_type": null,
        "file_sha": "90782c8f36791db838387b59fba143fbf16e787a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.009287"
      },
      "text": "* roots. If it cannot be found, an exception is thrown.\n\t * @param fileRef       The path of the file we are trying to find, minus the root.\n\t * @param errorPrefixes (optional) the first string will be prefixed onto a \"cannot find file\" error message.\n\t *                      (optional) the second string will be prefixed onto a \"found file >once\" error message.\n\t *                      (optional) the third+ string/s will be ignored.\n\t * @return              A FileRef for the file we were trying to find.\n\t * @throws StfException In case we cannot find the file, or if we found it in more than one prereq root.\n\t */\n\tpublic FileRef findPrereqFile(String fileRef, String... errorPrefixes) throws StfException {\n\t\treturn environmentCore.findPrereqFile(fileRef, errorPrefixes);\n\t}\n\t\n\t\n\t/**\n\t * Allows the caller to find the test cases root directory. i.e. The directory specified\n\t * via the -test-root=xxx argument. \n\t */\n\tpublic ArrayList<DirectoryRef> getTestRoots() {\n\t\treturn environmentCore.getTestRoots();\n\t}\n\t\n\t/**\n\t * Allows the caller to find the prereqs directories. i.e. The locations \n\t * of the third-party executables, jars, etc.\n\t * If not specified on the command line or in a properties file, the location \n\t * is found by working upwards from each of the test root directories, searching each\n\t * directory for a child directory called prereqs.\n\t * @return an array of DirectoryRefs pointing at prereq locations.\n\t * \n\t */\n\tpublic ArrayList<DirectoryRef> getPrereqRoots() {\n\t\treturn environmentCore.getPrereqRoots();\n\t}\n\t\n\t\n\t/**\n\t * Tests which need temporary files or directories should create them in the \n\t * temporary directory. \n\t * Tests do not need to clean up the temporary directory, as this will \n\t * be done when the next test starts running.\n\t * @return A reference to a temporary directory created for the current test.\n\t */\n\tpublic DirectoryRef getTmpDir() { \n\t\treturn environmentCore.getTmpDir();\n\t}\n\t\n\t/**\n\t * Test results and similar information should be written to the results directory.\n\t * @return a reference to the results directory for the current test.\n\t */\n\tpublic DirectoryRef getResultsDir() { \n\t\treturn environmentCore.getResultsDir();\n\t}\n\t\n\t/**\n\t * Any data which may be helpful for debugging can be written to this directory.\n\t * @return a directory reference to a directory which holds debugging information.\n\t */\n\tpublic DirectoryRef getDebugDir() { \n\t\treturn environmentCore.getDebugDir();\n\t}\n\t\n\t\n\t/**\n\t * Creates a DirectoryRef.\n\t * @param fileName      The directory path.\n\t * @return              A DirectoryRef for the directory.\n\t * @throws StfException\n\t */\n\tpublic DirectoryRef createDirectoryRef(String fileName) throws StfException {\n\t\treturn environmentCore.createDirectoryRef(fileName);\n\t}\n\t\n\t/**\n\t * Creates a FileRef.\n\t * @param fileName      The file path.\n\t * @return              A FileRef for the file.\n\t * @throws StfException\n\t */\n\tpublic FileRef createFileRef(String fileName) throws StfException {\n\t\treturn environmentCore.createFileRef(fileName);\n\t}\n\t\n\t/**\n\t * @return a string containing the platform name, eg 'linux_x86-64'\n\t * @throws StfException if there was a problem interpreting the current platform.\n\t */\n\tpublic String getPlatform() throws StfException {\n\t\treturn environmentCore.getPlatform();\n\t}\n\t\n\t/**\n\t * @return a simple name for platform e.g. win, osx, zos etc\n\t * @throws StfException if there was a problem interpreting the current platform.\n\t */\n\tpublic String getPlatformSimple() throws StfException {\n\t\treturn environmentCore.getPlatformSimple();\n\t}\n\t\n\t/**\n\t * This method provides access to the test specific properties. The argument \n\t * values are given to STF at runtime through the '-test-args' parameter.\n\t * This takes 1 or more comma separated values. For example: \n\t *   stf -test=MyTest -test-args=\"arg1=value1,arg2=value2\"\n\t * \n\t * Each value for expectedPropertyNames can be specified in 1 of 2 forms:\n\t *   - Either a string containing the name of the property. This makes the"
    },
    "211": {
      "metadata": {
        "chunk_id": "aa9734c821f040360ec3f45a1d29409861b210ceb389fb45cd521660c2267cc2",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfEnvironment.java",
        "content": "public String getPlatform() throws StfException {\n\t\treturn environmentCore.getPlatform();\n\t}\n\t\n\t/**\n\t * @return a simple name for platform e.g. win, osx, zos etc\n\t * @throws StfException if there was a problem interpreting the current platform.\n\t */\n\tpublic String getPlatformSimple() throws StfException {\n\t\treturn environmentCore.getPlatformSimple();\n\t}\n\t\n\t/**\n\t * This method provides access to the test specific properties. The argument \n\t * values are given to STF at runtime through the '-test-args' parameter.\n\t * This takes 1 or more comma separated values. For example: \n\t *   stf -test=MyTest -test-args=\"arg1=value1,arg2=value2\"\n\t * \n\t * Each value for expectedPropertyNames can be specified in 1 of 2 forms:\n\t *   - Either a string containing the name of the property. This makes the\n\t *     property mandatory, so if not supplied the test will fail with a runtime \n\t *     error. eg, \"suite\"\n\t *   - or, a String containing a default value. A value can be supplied at runtime\n\t *     but if not then the default value is used. eg, \"reporter=[LIVE]\"\n\t * \n\t * @param expectedPropertyNames is the names of the properties which the test expects.\n\t * @return a StfTestArguments object holding the name/value pairs of the 'test-args'.\n\t * @throws StfException if either:\n\t *    1) The test expects properties but they have not been supplied. ie. missing properties. \n\t *    2) Properties were supplied but the test doesn't expect them. ie. extra properties.\n\t */\n\tpublic StfTestArguments getTestProperties(String... expectedPropertyNames) throws StfException {\n\t\treturn environmentCore.getTestProperties(expectedPropertyNames);\n\t}",
        "start_line": 206,
        "end_line": 239,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 403,
        "node_type": null,
        "file_sha": "90782c8f36791db838387b59fba143fbf16e787a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.009289"
      },
      "text": "public String getPlatform() throws StfException {\n\t\treturn environmentCore.getPlatform();\n\t}\n\t\n\t/**\n\t * @return a simple name for platform e.g. win, osx, zos etc\n\t * @throws StfException if there was a problem interpreting the current platform.\n\t */\n\tpublic String getPlatformSimple() throws StfException {\n\t\treturn environmentCore.getPlatformSimple();\n\t}\n\t\n\t/**\n\t * This method provides access to the test specific properties. The argument \n\t * values are given to STF at runtime through the '-test-args' parameter.\n\t * This takes 1 or more comma separated values. For example: \n\t *   stf -test=MyTest -test-args=\"arg1=value1,arg2=value2\"\n\t * \n\t * Each value for expectedPropertyNames can be specified in 1 of 2 forms:\n\t *   - Either a string containing the name of the property. This makes the\n\t *     property mandatory, so if not supplied the test will fail with a runtime \n\t *     error. eg, \"suite\"\n\t *   - or, a String containing a default value. A value can be supplied at runtime\n\t *     but if not then the default value is used. eg, \"reporter=[LIVE]\"\n\t * \n\t * @param expectedPropertyNames is the names of the properties which the test expects.\n\t * @return a StfTestArguments object holding the name/value pairs of the 'test-args'.\n\t * @throws StfException if either:\n\t *    1) The test expects properties but they have not been supplied. ie. missing properties. \n\t *    2) Properties were supplied but the test doesn't expect them. ie. extra properties.\n\t */\n\tpublic StfTestArguments getTestProperties(String... expectedPropertyNames) throws StfException {\n\t\treturn environmentCore.getTestProperties(expectedPropertyNames);\n\t}"
    },
    "212": {
      "metadata": {
        "chunk_id": "0a351de66e7333b83cb0771562439e9c2fe16f52892d20394956f69d6d473476",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/core/StfEnvironment.java",
        "content": "/** \n\t * Returns the osgi.os name.\n\t * Expected return values are win32, linux, aix, macosx\n\t */\n\tpublic String getOsgiOperatingSystemName() throws StfException {\n\t\treturn environmentCore.getOsgiOperatingSystemName();\n\t}\n\n\t/** \n\t * Returns the osgi.ws value.\n\t * Expected return values are win32, gtk\n\t */\n\tpublic String getOsgiWindowingSystemName() throws StfException {\n\t\treturn environmentCore.getOsgiWindowingSystemName();\n\t}\n\n\t/** \n\t * Returns the osgi.arch name.\n\t * Expected return values are x86, x86_64, ppc, ppc64, arm\n\t */\n\tpublic String getOsgiProcessorArchitecture() throws StfException {\n\t\treturn environmentCore.getOsgiProcessorArchitecture();\n\t}\n\t\n\t/**\n\t * Returns object to represent the primary JVM available to the test.\n\t * @throws StfException if the JVM is not specified.\n\t */\n\tpublic JavaVersion primaryJvm() throws StfException { \n\t\treturn environmentCore.primaryJvm();\n\t}\n\t\n\t/**\n\t * Returns an object to represent the secondary JVM.\n\t * @throws StfException if secondary JVM not configured. \n\t */\n\tpublic JavaVersion secondaryJvm() throws StfException { \n\t\treturn environmentCore.secondaryJvm();\n\t}\n\t\n\t/**\n\t * @return true if a secondary JVM has been configured.\n\t * @throws StfException if argument resolution failed.\n\t */\n\tpublic boolean secondaryJvmConfigured() throws StfException {\n\t\tString javahome = environmentCore.getProperty(Stf.ARG_JAVAHOME_EXECUTE_SECONDARY);\n\t\treturn javahome.length() > 0;\n\t}\n\t\n\t/**\n\t * Shortcut method for checking that the primary JVM is using IBM Java.\n\t * @throws StfException \n\t */\n\tpublic void isIBMJvm() throws StfException {\n\t\tprimaryJvm().isIBMJvm();\n\t}\n\n\t/**\n\t * Shortcut method for verifying that the primary JVM is using IBM Java.\n\t * @throws StfException \n\t */\n\tpublic void verifyUsingIBMJava() throws StfException {\n\t\tprimaryJvm().verifyUsingIBMJava();\n\t}\n\t\n\t/**\n\t * Returns the directory of Java home for the currently executing stage.\n\t * @return a DirectoryRef pointing at the current Java home.\n\t * @throws StfException if called during the initialisation stage.\n\t */\n\tpublic DirectoryRef getJavaHome() throws StfException {\n\t\treturn environmentCore.getJavaHome();\n\t}\n\t\n\t/**\n\t * Allows a test to obtain a Jar path given a Jar Id. \n\t * @return the jar path in String of a given Jar id. \n\t * @throws StfException if the jar file is not found. \n\t */\n\tpublic FileRef getJarLocation(JarId id) throws StfException {\n\t\tString relativeJarLocation = environmentCore.getProperty(id.getArgument()).replace(\"/systemtest-prereqs/\", \"\");\n\t\tFileRef jarFileRef = environmentCore.findPrereqFile(relativeJarLocation);\n\t\tif (!jarFileRef.asJavaFile().exists()) {\n\t\t\tthrow new StfException(\"Jar file does not exist: \" + jarFileRef.getSpec());\n\t\t} \n\t\treturn jarFileRef;\n    }\n}",
        "start_line": 240,
        "end_line": 327,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 682,
        "node_type": null,
        "file_sha": "90782c8f36791db838387b59fba143fbf16e787a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.009291"
      },
      "text": "/** \n\t * Returns the osgi.os name.\n\t * Expected return values are win32, linux, aix, macosx\n\t */\n\tpublic String getOsgiOperatingSystemName() throws StfException {\n\t\treturn environmentCore.getOsgiOperatingSystemName();\n\t}\n\n\t/** \n\t * Returns the osgi.ws value.\n\t * Expected return values are win32, gtk\n\t */\n\tpublic String getOsgiWindowingSystemName() throws StfException {\n\t\treturn environmentCore.getOsgiWindowingSystemName();\n\t}\n\n\t/** \n\t * Returns the osgi.arch name.\n\t * Expected return values are x86, x86_64, ppc, ppc64, arm\n\t */\n\tpublic String getOsgiProcessorArchitecture() throws StfException {\n\t\treturn environmentCore.getOsgiProcessorArchitecture();\n\t}\n\t\n\t/**\n\t * Returns object to represent the primary JVM available to the test.\n\t * @throws StfException if the JVM is not specified.\n\t */\n\tpublic JavaVersion primaryJvm() throws StfException { \n\t\treturn environmentCore.primaryJvm();\n\t}\n\t\n\t/**\n\t * Returns an object to represent the secondary JVM.\n\t * @throws StfException if secondary JVM not configured. \n\t */\n\tpublic JavaVersion secondaryJvm() throws StfException { \n\t\treturn environmentCore.secondaryJvm();\n\t}\n\t\n\t/**\n\t * @return true if a secondary JVM has been configured.\n\t * @throws StfException if argument resolution failed.\n\t */\n\tpublic boolean secondaryJvmConfigured() throws StfException {\n\t\tString javahome = environmentCore.getProperty(Stf.ARG_JAVAHOME_EXECUTE_SECONDARY);\n\t\treturn javahome.length() > 0;\n\t}\n\t\n\t/**\n\t * Shortcut method for checking that the primary JVM is using IBM Java.\n\t * @throws StfException \n\t */\n\tpublic void isIBMJvm() throws StfException {\n\t\tprimaryJvm().isIBMJvm();\n\t}\n\n\t/**\n\t * Shortcut method for verifying that the primary JVM is using IBM Java.\n\t * @throws StfException \n\t */\n\tpublic void verifyUsingIBMJava() throws StfException {\n\t\tprimaryJvm().verifyUsingIBMJava();\n\t}\n\t\n\t/**\n\t * Returns the directory of Java home for the currently executing stage.\n\t * @return a DirectoryRef pointing at the current Java home.\n\t * @throws StfException if called during the initialisation stage.\n\t */\n\tpublic DirectoryRef getJavaHome() throws StfException {\n\t\treturn environmentCore.getJavaHome();\n\t}\n\t\n\t/**\n\t * Allows a test to obtain a Jar path given a Jar Id. \n\t * @return the jar path in String of a given Jar id. \n\t * @throws StfException if the jar file is not found. \n\t */\n\tpublic FileRef getJarLocation(JarId id) throws StfException {\n\t\tString relativeJarLocation = environmentCore.getProperty(id.getArgument()).replace(\"/systemtest-prereqs/\", \"\");\n\t\tFileRef jarFileRef = environmentCore.findPrereqFile(relativeJarLocation);\n\t\tif (!jarFileRef.asJavaFile().exists()) {\n\t\t\tthrow new StfException(\"Jar file does not exist: \" + jarFileRef.getSpec());\n\t\t} \n\t\treturn jarFileRef;\n    }\n}"
    },
    "213": {
      "metadata": {
        "chunk_id": "2e3ae9075aaff316c39ce6726e1a6697bf5186ce825e2821d3f384f92139cf96",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/extensions/interfaces/StfExtension.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions.interfaces;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.extensions.StfExtensionBase;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * All STF extension classes must implement this interface.\n */\npublic interface StfExtension {\n\t/**\n\t * When this method is called the extension must return an array of the arguments \n\t * which it understands and supports.\n\t * \n\t * The project should also contain a property file in which all of the supported \n\t * arguments have default values defined, even if the value is only 'null'.\n\t * The property file should live in the config directory of the extensions \n\t * project, and be placed in a file '<extension-name>.properties', where \n\t * 'extension-name' is the name of the java file containing the extension.\n\t * \n\t * Note that STF will throw an exception if 2 or more extensions report that they\n\t * support the same argument.\n\t */\n\tpublic Argument[] getSupportedArguments();\n\t\n\t/**\n\t * Stf has a help option and to produce full help each extension must describe the \n\t * options which it supports. \n\t * @param help is a utility class which formats and outputs the help information. \n\t */\n\tpublic void help(HelpTextGenerator help);\n\t\t\t\n\t/**\n\t * This method will be called when an extension needs to initialise itself.\n\t * The extension should fail if it detects any failure whatsoever.\n\t * \n\t * @param environmentCore provides access to the current STF environment.\n\t * @param extensionBase is the base layer shared across all extensions.\n\t * @param generator gives access to the current perl output file.\n\t * @throws StfException if initialisation fails in any way.\n\t */\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException;\n}",
        "start_line": 0,
        "end_line": 60,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 570,
        "node_type": null,
        "file_sha": "c757be470119d23fe261231ba6fced0c79eed273",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.021042"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extensions.interfaces;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.extensions.StfExtensionBase;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * All STF extension classes must implement this interface.\n */\npublic interface StfExtension {\n\t/**\n\t * When this method is called the extension must return an array of the arguments \n\t * which it understands and supports.\n\t * \n\t * The project should also contain a property file in which all of the supported \n\t * arguments have default values defined, even if the value is only 'null'.\n\t * The property file should live in the config directory of the extensions \n\t * project, and be placed in a file '<extension-name>.properties', where \n\t * 'extension-name' is the name of the java file containing the extension.\n\t * \n\t * Note that STF will throw an exception if 2 or more extensions report that they\n\t * support the same argument.\n\t */\n\tpublic Argument[] getSupportedArguments();\n\t\n\t/**\n\t * Stf has a help option and to produce full help each extension must describe the \n\t * options which it supports. \n\t * @param help is a utility class which formats and outputs the help information. \n\t */\n\tpublic void help(HelpTextGenerator help);\n\t\t\t\n\t/**\n\t * This method will be called when an extension needs to initialise itself.\n\t * The extension should fail if it detects any failure whatsoever.\n\t * \n\t * @param environmentCore provides access to the current STF environment.\n\t * @param extensionBase is the base layer shared across all extensions.\n\t * @param generator gives access to the current perl output file.\n\t * @throws StfException if initialisation fails in any way.\n\t */\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException;\n}"
    },
    "214": {
      "metadata": {
        "chunk_id": "1a56b75d64f63e7659697cf1385ec1928a2f9ebb7fad5c3fcaa1d7ce4033ef11",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/JvmArgDetails.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.io.File;\n\n\n/**\n * Simple object which holds information about some java-args and their originating file.\n */\npublic class JvmArgDetails {\n\tprivate File originatingFile;\n\tprivate String javaArgs;\n\t\n\tpublic JvmArgDetails(File originatingFile, String javaArgs) {\n\t\tthis.originatingFile = originatingFile;\n\t\tthis.javaArgs = javaArgs.trim();\n\t}\n\n\tpublic File getOriginatingFile() {\n\t\treturn originatingFile;\n\t}\n\n\tpublic String getJavaArgs() {\n\t\treturn javaArgs;\n\t}\n}",
        "start_line": 0,
        "end_line": 38,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 238,
        "node_type": null,
        "file_sha": "bb553e7c341b823eb58905ee2f8a1d63de11d60e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.033788"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.io.File;\n\n\n/**\n * Simple object which holds information about some java-args and their originating file.\n */\npublic class JvmArgDetails {\n\tprivate File originatingFile;\n\tprivate String javaArgs;\n\t\n\tpublic JvmArgDetails(File originatingFile, String javaArgs) {\n\t\tthis.originatingFile = originatingFile;\n\t\tthis.javaArgs = javaArgs.trim();\n\t}\n\n\tpublic File getOriginatingFile() {\n\t\treturn originatingFile;\n\t}\n\n\tpublic String getJavaArgs() {\n\t\treturn javaArgs;\n\t}\n}"
    },
    "215": {
      "metadata": {
        "chunk_id": "95f3edbc53a761bd622e249627fd49c964470b0c9386275f2171d45f02297e73",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/ModeDecoder.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.extensions.Stf;\n\n\n/**\n * Returns a set of JVM arguments for a given mode.\n * eg, '-mode=105', '-mode=Random' or '-mode=Random_s26654791' \n */",
        "start_line": 0,
        "end_line": 33,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 262,
        "node_type": null,
        "file_sha": "ebe7c9e379964394d6802e23fa727ee639fb0c2c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.048525"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.extensions.Stf;\n\n\n/**\n * Returns a set of JVM arguments for a given mode.\n * eg, '-mode=105', '-mode=Random' or '-mode=Random_s26654791' \n */"
    },
    "216": {
      "metadata": {
        "chunk_id": "00ebf0904263f39fd0ad5a3661ec75ed11fba770d04c4916053ac37e37d59577",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/ModeDecoder.java",
        "content": "public class ModeDecoder {\n    private static final Logger logger = LogManager.getLogger(ModeDecoder.class.getName());\n\n    // Lookup the contents of the modes file to translate a mode name to actual VM arguments.\n\tpublic static String decodeModeName(StfEnvironmentCore environmentCore, String modeName) throws StfException {\n\t\tlogger.debug(\"Attempting to find java-args for mode/variation '\" + modeName + \"'\");\n\t\t\n\t\tif (!modeName.equals(\"NoOptions\") && !environmentCore.isUsingIBMJava()) {\n\t\t\tthrow new StfError(\"Modes are not supported on non-IBM JVMs\");\n\t\t}\n\t\t\n\t\tString args;\n\t\tif (modeName.equals(\"NoOptions\")) {\n\t\t\targs = \"\";\n\t\t\tlogger.info(\"Using Mode \" + modeName + \". Values = '\" + args.trim() + \"'\");\n\n\t\t} else if (modeName.toLowerCase().startsWith(\"random\")) {\n\t\t\t// Extract optional count and seed values, eg -mode=random_c3_s34543566\n\t\t\tlong count       = extractOptionalNumber(modeName, \"_c(\\\\d+)\", 1);\n\t\t\tlong initialSeed = extractOptionalNumber(modeName, \"_s(\\\\d+)\", -1);\n\t\t\t\n\t\t\t// Generate a new set of random JVM arguments\n\t\t\tint wordSize = environmentCore.getWordSize();\n\t\t\tRandomModesGenerator randModes = new RandomModesGenerator(wordSize, initialSeed, (int) count);\n\t\t\targs = randModes.getRandomModeData(wordSize, initialSeed, (int) count);\n\t\t\t\n\t\t\t// Capture the seed used, to allow later reproduction\n\t\t  \tString argumentComment = \", using seed \" + randModes.getSeed();\n\t\t\tenvironmentCore.updateProperty(Stf.ARG_JAVA_ARGS_EXECUTE_COMMENT, argumentComment);\n\n\t\t\tlogger.info(\"Using Mode \" + modeName + \". Values = '\" + args.trim() + \"'\");\n\t\t\t\n\t\t} else {\n\t\t\t// Decode the named mode/variation\n\t\t\t// Look at both the modes.xml file and the potential multiple values from the testplan files\n\t\t\tArrayList<JvmArgDetails> modeJavaArgs = ModeFileReader.decodeModeName(environmentCore, modeName);\n\t\t\tArrayList<JvmArgDetails> testplanJavaArgs = new VariationsSearcher().findMode(environmentCore, modeName);\n\t\t\t\n\t\t\t// Amalgamate the results of searching modes.xml and the testplan variations\n\t\t\tArrayList<JvmArgDetails> allJavaArgs = new ArrayList<JvmArgDetails>();\n\t\t\tallJavaArgs.addAll(modeJavaArgs);\n\t\t\tallJavaArgs.addAll(testplanJavaArgs);\n\t\t\tlogger.debug(\"Found \" + allJavaArgs.size() + \" definitions for mode/variation: \" + modeName);\n\n\t\t\t// Fail if mode doesn't exist\n\t\t\tif (allJavaArgs.isEmpty()) {\n\t\t\t\tthrow new StfError(\"Unknown mode/variation: '\" + modeName + \"'. Check modes.xml or variations.xml files\");\n\t\t\t}\n\t\t\t\n\t\t\t// Make sure that discovered java-args are the same\n\t\t\tHashSet<String> argsSet = new HashSet<String>();\n\t\t\tfor (JvmArgDetails mode : allJavaArgs) {\n\t\t\t\targsSet.add(mode.getJavaArgs());\n\t\t\t}\n\t\t\tif (argsSet.size() > 1) {\n\t\t\t\tStringBuilder errorText = new StringBuilder(\"Mode/variation '\" + modeName + \"' has ambiguous java-args. \" + argsSet.size() + \" different definitions found:\");\n\t\t\t\tint argSetNum = 1;\n\t\t\t\tfor (String argStr : argsSet) {\n\t\t\t\t\terrorText.append(\"\\n\" + argSetNum + \") \" + argStr);\n\t\t\t\t\targSetNum++;\n\t\t\t\t\tfor (JvmArgDetails argDetails : allJavaArgs) {\n\t\t\t\t\t\tif (argDetails.getJavaArgs().equals(argStr)) {\n\t\t\t\t\t\t\terrorText.append(\"\\n       Used in: \" + argDetails.getOriginatingFile().getAbsolutePath());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new StfError(errorText.toString());\n\t\t\t}\n\t\t\t\n\t\t\t// To reach this point all java-args must have the same value, so just use the first set of values\n\t\t\targs = allJavaArgs.get(0).getJavaArgs();\n\n\t\t\t// Show java-args that are going to be used and where they have come from\n\t\t\tString filesText = allJavaArgs.size() == 1 ? \"file\" : \"files\";\n\t\t\tlogger.info(\"Using Mode \" + modeName + \". Values = '\" + args.trim() + \"', which was found in \" + allJavaArgs.size() + \" \" + filesText + \":\");\n\t\t\tfor (JvmArgDetails argDetails : allJavaArgs) {\n\t\t\t\tlogger.info(\"  \" + argDetails.getOriginatingFile().getAbsolutePath());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn args;\n\t}",
        "start_line": 34,
        "end_line": 115,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 975,
        "node_type": null,
        "file_sha": "ebe7c9e379964394d6802e23fa727ee639fb0c2c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.048532"
      },
      "text": "public class ModeDecoder {\n    private static final Logger logger = LogManager.getLogger(ModeDecoder.class.getName());\n\n    // Lookup the contents of the modes file to translate a mode name to actual VM arguments.\n\tpublic static String decodeModeName(StfEnvironmentCore environmentCore, String modeName) throws StfException {\n\t\tlogger.debug(\"Attempting to find java-args for mode/variation '\" + modeName + \"'\");\n\t\t\n\t\tif (!modeName.equals(\"NoOptions\") && !environmentCore.isUsingIBMJava()) {\n\t\t\tthrow new StfError(\"Modes are not supported on non-IBM JVMs\");\n\t\t}\n\t\t\n\t\tString args;\n\t\tif (modeName.equals(\"NoOptions\")) {\n\t\t\targs = \"\";\n\t\t\tlogger.info(\"Using Mode \" + modeName + \". Values = '\" + args.trim() + \"'\");\n\n\t\t} else if (modeName.toLowerCase().startsWith(\"random\")) {\n\t\t\t// Extract optional count and seed values, eg -mode=random_c3_s34543566\n\t\t\tlong count       = extractOptionalNumber(modeName, \"_c(\\\\d+)\", 1);\n\t\t\tlong initialSeed = extractOptionalNumber(modeName, \"_s(\\\\d+)\", -1);\n\t\t\t\n\t\t\t// Generate a new set of random JVM arguments\n\t\t\tint wordSize = environmentCore.getWordSize();\n\t\t\tRandomModesGenerator randModes = new RandomModesGenerator(wordSize, initialSeed, (int) count);\n\t\t\targs = randModes.getRandomModeData(wordSize, initialSeed, (int) count);\n\t\t\t\n\t\t\t// Capture the seed used, to allow later reproduction\n\t\t  \tString argumentComment = \", using seed \" + randModes.getSeed();\n\t\t\tenvironmentCore.updateProperty(Stf.ARG_JAVA_ARGS_EXECUTE_COMMENT, argumentComment);\n\n\t\t\tlogger.info(\"Using Mode \" + modeName + \". Values = '\" + args.trim() + \"'\");\n\t\t\t\n\t\t} else {\n\t\t\t// Decode the named mode/variation\n\t\t\t// Look at both the modes.xml file and the potential multiple values from the testplan files\n\t\t\tArrayList<JvmArgDetails> modeJavaArgs = ModeFileReader.decodeModeName(environmentCore, modeName);\n\t\t\tArrayList<JvmArgDetails> testplanJavaArgs = new VariationsSearcher().findMode(environmentCore, modeName);\n\t\t\t\n\t\t\t// Amalgamate the results of searching modes.xml and the testplan variations\n\t\t\tArrayList<JvmArgDetails> allJavaArgs = new ArrayList<JvmArgDetails>();\n\t\t\tallJavaArgs.addAll(modeJavaArgs);\n\t\t\tallJavaArgs.addAll(testplanJavaArgs);\n\t\t\tlogger.debug(\"Found \" + allJavaArgs.size() + \" definitions for mode/variation: \" + modeName);\n\n\t\t\t// Fail if mode doesn't exist\n\t\t\tif (allJavaArgs.isEmpty()) {\n\t\t\t\tthrow new StfError(\"Unknown mode/variation: '\" + modeName + \"'. Check modes.xml or variations.xml files\");\n\t\t\t}\n\t\t\t\n\t\t\t// Make sure that discovered java-args are the same\n\t\t\tHashSet<String> argsSet = new HashSet<String>();\n\t\t\tfor (JvmArgDetails mode : allJavaArgs) {\n\t\t\t\targsSet.add(mode.getJavaArgs());\n\t\t\t}\n\t\t\tif (argsSet.size() > 1) {\n\t\t\t\tStringBuilder errorText = new StringBuilder(\"Mode/variation '\" + modeName + \"' has ambiguous java-args. \" + argsSet.size() + \" different definitions found:\");\n\t\t\t\tint argSetNum = 1;\n\t\t\t\tfor (String argStr : argsSet) {\n\t\t\t\t\terrorText.append(\"\\n\" + argSetNum + \") \" + argStr);\n\t\t\t\t\targSetNum++;\n\t\t\t\t\tfor (JvmArgDetails argDetails : allJavaArgs) {\n\t\t\t\t\t\tif (argDetails.getJavaArgs().equals(argStr)) {\n\t\t\t\t\t\t\terrorText.append(\"\\n       Used in: \" + argDetails.getOriginatingFile().getAbsolutePath());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new StfError(errorText.toString());\n\t\t\t}\n\t\t\t\n\t\t\t// To reach this point all java-args must have the same value, so just use the first set of values\n\t\t\targs = allJavaArgs.get(0).getJavaArgs();\n\n\t\t\t// Show java-args that are going to be used and where they have come from\n\t\t\tString filesText = allJavaArgs.size() == 1 ? \"file\" : \"files\";\n\t\t\tlogger.info(\"Using Mode \" + modeName + \". Values = '\" + args.trim() + \"', which was found in \" + allJavaArgs.size() + \" \" + filesText + \":\");\n\t\t\tfor (JvmArgDetails argDetails : allJavaArgs) {\n\t\t\t\tlogger.info(\"  \" + argDetails.getOriginatingFile().getAbsolutePath());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn args;\n\t}"
    },
    "217": {
      "metadata": {
        "chunk_id": "813e5ec00ee8c41d6906bc8ae5dd451079173241932b507b347b1f7d8a63a21b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/ModeDecoder.java",
        "content": "// Show java-args that are going to be used and where they have come from\n\t\t\tString filesText = allJavaArgs.size() == 1 ? \"file\" : \"files\";\n\t\t\tlogger.info(\"Using Mode \" + modeName + \". Values = '\" + args.trim() + \"', which was found in \" + allJavaArgs.size() + \" \" + filesText + \":\");\n\t\t\tfor (JvmArgDetails argDetails : allJavaArgs) {\n\t\t\t\tlogger.info(\"  \" + argDetails.getOriginatingFile().getAbsolutePath());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn args;\n\t}\n\n\n\t// Attempts to parse a number for optional mode arguments\n\tprivate static long extractOptionalNumber(String modeName, String regex, int defaultValue) {\n\t\tlong result = defaultValue;\n\t\t\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher m = p.matcher(modeName);\n\t\twhile (m.find()) {\n\t\t\tresult = Long.parseLong(m.group(1));\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n}",
        "start_line": 116,
        "end_line": 140,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 207,
        "node_type": null,
        "file_sha": "ebe7c9e379964394d6802e23fa727ee639fb0c2c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.048534"
      },
      "text": "// Show java-args that are going to be used and where they have come from\n\t\t\tString filesText = allJavaArgs.size() == 1 ? \"file\" : \"files\";\n\t\t\tlogger.info(\"Using Mode \" + modeName + \". Values = '\" + args.trim() + \"', which was found in \" + allJavaArgs.size() + \" \" + filesText + \":\");\n\t\t\tfor (JvmArgDetails argDetails : allJavaArgs) {\n\t\t\t\tlogger.info(\"  \" + argDetails.getOriginatingFile().getAbsolutePath());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn args;\n\t}\n\n\n\t// Attempts to parse a number for optional mode arguments\n\tprivate static long extractOptionalNumber(String modeName, String regex, int defaultValue) {\n\t\tlong result = defaultValue;\n\t\t\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher m = p.matcher(modeName);\n\t\twhile (m.find()) {\n\t\t\tresult = Long.parseLong(m.group(1));\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n}"
    },
    "218": {
      "metadata": {
        "chunk_id": "459b2783b9ed78aad06833819a8bc1c99c4baa447f07fcb39774898a4dcce6ec",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/ModeFileReader.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DynamicVariableReplacer;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\n\n\n/**\n * This class takes a mode number and returns the corresponding set of JVM options.\n * The actual JVM options are read from the modes.xml file.\n */\npublic class ModeFileReader {\n\tprivate static final String MODES_FILE = \"config/modes.xml\";\n\n\n\t// Lookup the contents of the modes file to translate a mode name to actual VM arguments.\n\tpublic static ArrayList<JvmArgDetails> decodeModeName(StfEnvironmentCore environmentCore, String modeName) throws StfException {\n\t\t\n\t\t// Create a file object to point to the modes.xml file\n\t\tFile projectDir = environmentCore.findTestDirectory(\"stf.core\").asJavaFile();\n\t\tFile modeFile = new File(projectDir, MODES_FILE);\n\t\t\n\t\tif (!modeFile.exists()) { \n\t\t\tthrow new StfException(\"Mode configuration file does not exist: \" + modeFile.getAbsolutePath());\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t// Read the contents of the modes xml file\n\t\t\tDocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tDocument doc = db.parse(modeFile);\n\t\t\t\n\t\t\t// Find the 'value' attributes to be used for the specified mode\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression expr = xpath.compile(\"/modes/mode[@number=\\\"\" + modeName + \"\\\"]/settings/setting/envVar/@value\");\n\t\t\t\n\t\t\t// Run the xpath query to extract the mode values\n\t\t\tNodeList nl = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);\n\t\t\tif (nl.getLength() == 0) {\n\t\t\t\t// Not found\n\t\t\t\treturn new ArrayList<JvmArgDetails>();\n\t\t\t}\n\t\t\t\n\t\t\t// Concatenate the mode strings to produce the full list of JVM arguments\n\t\t\tStringBuilder modeArguments = new StringBuilder();\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tmodeArguments.append(node.getNodeValue() + \" \");\n\t\t\t}\n\t\t\t\n\t\t\t// Update the modes string if it contains any references such as '-XcacheName:${resultsDir.childDir(bigCache)}'\n\t\t\tString modeArgumentsString = new DynamicVariableReplacer(environmentCore).process(modeArguments.toString());\n\t\t\n\t\t\tArrayList<JvmArgDetails> javaArgs = new ArrayList<JvmArgDetails>();\n\t\t\tjavaArgs.add(new JvmArgDetails(modeFile, modeArgumentsString));\n\t\t\treturn javaArgs;\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to read mode '\" + modeName + \"' from mode file: \" + modeFile.getAbsolutePath(), e);\n\t\t}\n\t}\n}",
        "start_line": 0,
        "end_line": 87,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 781,
        "node_type": null,
        "file_sha": "5ebfd9e6592e6241d5053bafb8f948b44b232221",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.062695"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DynamicVariableReplacer;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\n\n\n/**\n * This class takes a mode number and returns the corresponding set of JVM options.\n * The actual JVM options are read from the modes.xml file.\n */\npublic class ModeFileReader {\n\tprivate static final String MODES_FILE = \"config/modes.xml\";\n\n\n\t// Lookup the contents of the modes file to translate a mode name to actual VM arguments.\n\tpublic static ArrayList<JvmArgDetails> decodeModeName(StfEnvironmentCore environmentCore, String modeName) throws StfException {\n\t\t\n\t\t// Create a file object to point to the modes.xml file\n\t\tFile projectDir = environmentCore.findTestDirectory(\"stf.core\").asJavaFile();\n\t\tFile modeFile = new File(projectDir, MODES_FILE);\n\t\t\n\t\tif (!modeFile.exists()) { \n\t\t\tthrow new StfException(\"Mode configuration file does not exist: \" + modeFile.getAbsolutePath());\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t// Read the contents of the modes xml file\n\t\t\tDocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tDocument doc = db.parse(modeFile);\n\t\t\t\n\t\t\t// Find the 'value' attributes to be used for the specified mode\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression expr = xpath.compile(\"/modes/mode[@number=\\\"\" + modeName + \"\\\"]/settings/setting/envVar/@value\");\n\t\t\t\n\t\t\t// Run the xpath query to extract the mode values\n\t\t\tNodeList nl = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);\n\t\t\tif (nl.getLength() == 0) {\n\t\t\t\t// Not found\n\t\t\t\treturn new ArrayList<JvmArgDetails>();\n\t\t\t}\n\t\t\t\n\t\t\t// Concatenate the mode strings to produce the full list of JVM arguments\n\t\t\tStringBuilder modeArguments = new StringBuilder();\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tmodeArguments.append(node.getNodeValue() + \" \");\n\t\t\t}\n\t\t\t\n\t\t\t// Update the modes string if it contains any references such as '-XcacheName:${resultsDir.childDir(bigCache)}'\n\t\t\tString modeArgumentsString = new DynamicVariableReplacer(environmentCore).process(modeArguments.toString());\n\t\t\n\t\t\tArrayList<JvmArgDetails> javaArgs = new ArrayList<JvmArgDetails>();\n\t\t\tjavaArgs.add(new JvmArgDetails(modeFile, modeArgumentsString));\n\t\t\treturn javaArgs;\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to read mode '\" + modeName + \"' from mode file: \" + modeFile.getAbsolutePath(), e);\n\t\t}\n\t}\n}"
    },
    "219": {
      "metadata": {
        "chunk_id": "6a24b3862e13e6f5d4151403362e1cda4a62e5b032cf5ae04a55ee9723178d4b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/RandomModesGenerator.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\n\n/**\n * This class generates random sets of JVM options for testing purposes. \n * The options generated will always contain 1 jit and 1 gc option.\n *  \n * To run within STF the mode string needs to start with 'random...'.\n * If mode string is 'random_cXXX' where X is numeric, then XXX options will be generated\n * If mode string is 'random_sXXX' where X is numeric, then XXX will be used to seed\n * the random number generator that drives selection of mode options.\n * Combination options such as 'random_c21_s1234' can also be used.\n *\n * This code currently only generates IBM SDK options.\n */",
        "start_line": 0,
        "end_line": 35,
        "chunk_index": 0,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 304,
        "node_type": null,
        "file_sha": "28429a68640de554e409fa04fa8aa1ad437f22cf",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.076353"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\n\n/**\n * This class generates random sets of JVM options for testing purposes. \n * The options generated will always contain 1 jit and 1 gc option.\n *  \n * To run within STF the mode string needs to start with 'random...'.\n * If mode string is 'random_cXXX' where X is numeric, then XXX options will be generated\n * If mode string is 'random_sXXX' where X is numeric, then XXX will be used to seed\n * the random number generator that drives selection of mode options.\n * Combination options such as 'random_c21_s1234' can also be used.\n *\n * This code currently only generates IBM SDK options.\n */"
    },
    "220": {
      "metadata": {
        "chunk_id": "0ff5bd50a1c3204bafaefab4d213bb5bd121b897fbd451005ef9d2a9b7b01928",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/RandomModesGenerator.java",
        "content": "public class RandomModesGenerator {\n    private static final Logger logger = LogManager.getLogger(RandomModesGenerator.class.getName());\n\n    private static Random rnd = null;\n\tprivate long seed;\n\t\n\tprivate int bitSize;\n\n\t\n\t/*\n\t * Will return an array containing randomly generated JVM option strings.\n\t * Takes an integer, which is the number of options to return.\n\t */\n\tprivate ArrayList<String> getRandomOptions(int numberRequested) {\n\t\tif (numberRequested < 1) {\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\t\n\t\tArrayList<String> options = new ArrayList<String>();\n\t\toptions.addAll(getOptions(numberRequested));\n\t\toptions.addAll(getGCOptions());\n\t\toptions.add(getJITOptions());\n\t\toptions.addAll(getJVMOptions());\n\t\toptions.add(getCompressedReferencesOption());\n\t\t\n\t\treturn options;\n\t}\n\t\n\t\n\t/*\n\t * Returns some random mode data. Optionally takes a hash of arguments, which\n     * may specify a seed and a number of options to be generated.\n     */\n\tString getRandomModeData(int bitSize, long seed, int count) {\n\t\tArrayList<String> options = getRandomOptions(count);\n\n\t\t// Convert into a space separated string\n\t\tStringBuilder args = new StringBuilder();\n\t\tfor (String o : options) {\n\t\t\tif (args.length() != 0) {\n\t\t\t\targs.append(\" \");\n\t\t\t}\n\t\t\targs.append(o);\n\t\t}\n\t\t\n\t\treturn args.toString();\n\t}\n\t\n\t\n\tRandomModesGenerator(int bitSize, long seed, long count) {\n\t\tthis.bitSize = bitSize;\n\t\t\n\t\tif (RandomModesGenerator.rnd == null) {\n\t\t\t// Initialise random number generator\n\t\t\tif (seed == -1) {\n\t\t\t\t// First time through with no explicit seed, so pick one.\n\t\t\t\tseed = System.currentTimeMillis();\n\t\t\t\tlogger.info(\"Running with random seed. Reproduce with '-mode=random_s\" + seed + \"'\");\n\t\t\t}\n\t\t\tRandomModesGenerator.rnd = new Random(seed);\n\t\t}\n\n\t\t// Pick a seed for this instance\n\t  \tthis.seed = RandomModesGenerator.rnd.nextLong();\n\t  \tRandomModesGenerator.rnd.setSeed(this.seed);\n\t}\n\n\t\n\tprivate ArrayList<String> getOptions(int count) {\n\t\tString[] singleOptions = {\n\t\t\t\t\"-Xcheck:jni\",\n\t\t\t\t\"-Xcheck:gc:all:all:suppresslocal,verbose\",\n\t\t\t\t\"-Xcheck:vm:debuginfo\",\n\t\t\t\t\"-Xthr:minimizeUserCPU\",\n\t\t\t\t\"-XtlhPrefetch\",\n\t\t\t\t\"-Xtune:virtualized\",\n\t\t\t\t\"-Xtrace:none\",\n\t\t};\n\t\t\n\t\tArrayList<String> options = randomlyPick(singleOptions, Math.min(count, singleOptions.length));\n\t\treturn options;\n\t}\n\n\n\t// Functions for choosing a JIT option(s), eg randomGen,disableMergeStackMaps,optLevel=hot,count=0, etc\n\t// TODO when randomGen is selected, need to add randomSeed=x, where x is an integer I believe,\n\t// but need to select appropriate values.\n\tprivate String[] getJitOptions() {\n\t\tString[] jitOptions = {\n\t\t\t\t\"randomGen\", \n\t\t\t\t\"disableMergeStackMaps\", \n\t\t\t\t\"noJitUntilMain\", \n\t\t\t\t\"optLevel\", \n\t\t\t\t\"count\", \n\t\t\t\t\"gcOnResolve\",\n\t\t\t\t\"jitCodeCacheOptions\",\n\t\t\t\t\"jitDataCacheOptions\",\t\t\t\t  \n\t\t\t\t\"jitRecompilationOptions\",\n\t\t\t\t\"rtResolve\",\n\t\t\t\t\"quickProfile\", \n\t\t\t\t\"reserveAllLocks\",\n\t\t\t\t\"sampleInterval\"\n\t\t};\n\t\treturn jitOptions;\n\t}\n\n\tprivate String[] optLevels = { \"noOpt\", \"cold\", \"warm\", \"hot\", \"veryHot\", \"scorching\" };",
        "start_line": 36,
        "end_line": 142,
        "chunk_index": 1,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 767,
        "node_type": null,
        "file_sha": "28429a68640de554e409fa04fa8aa1ad437f22cf",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.076363"
      },
      "text": "public class RandomModesGenerator {\n    private static final Logger logger = LogManager.getLogger(RandomModesGenerator.class.getName());\n\n    private static Random rnd = null;\n\tprivate long seed;\n\t\n\tprivate int bitSize;\n\n\t\n\t/*\n\t * Will return an array containing randomly generated JVM option strings.\n\t * Takes an integer, which is the number of options to return.\n\t */\n\tprivate ArrayList<String> getRandomOptions(int numberRequested) {\n\t\tif (numberRequested < 1) {\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\t\n\t\tArrayList<String> options = new ArrayList<String>();\n\t\toptions.addAll(getOptions(numberRequested));\n\t\toptions.addAll(getGCOptions());\n\t\toptions.add(getJITOptions());\n\t\toptions.addAll(getJVMOptions());\n\t\toptions.add(getCompressedReferencesOption());\n\t\t\n\t\treturn options;\n\t}\n\t\n\t\n\t/*\n\t * Returns some random mode data. Optionally takes a hash of arguments, which\n     * may specify a seed and a number of options to be generated.\n     */\n\tString getRandomModeData(int bitSize, long seed, int count) {\n\t\tArrayList<String> options = getRandomOptions(count);\n\n\t\t// Convert into a space separated string\n\t\tStringBuilder args = new StringBuilder();\n\t\tfor (String o : options) {\n\t\t\tif (args.length() != 0) {\n\t\t\t\targs.append(\" \");\n\t\t\t}\n\t\t\targs.append(o);\n\t\t}\n\t\t\n\t\treturn args.toString();\n\t}\n\t\n\t\n\tRandomModesGenerator(int bitSize, long seed, long count) {\n\t\tthis.bitSize = bitSize;\n\t\t\n\t\tif (RandomModesGenerator.rnd == null) {\n\t\t\t// Initialise random number generator\n\t\t\tif (seed == -1) {\n\t\t\t\t// First time through with no explicit seed, so pick one.\n\t\t\t\tseed = System.currentTimeMillis();\n\t\t\t\tlogger.info(\"Running with random seed. Reproduce with '-mode=random_s\" + seed + \"'\");\n\t\t\t}\n\t\t\tRandomModesGenerator.rnd = new Random(seed);\n\t\t}\n\n\t\t// Pick a seed for this instance\n\t  \tthis.seed = RandomModesGenerator.rnd.nextLong();\n\t  \tRandomModesGenerator.rnd.setSeed(this.seed);\n\t}\n\n\t\n\tprivate ArrayList<String> getOptions(int count) {\n\t\tString[] singleOptions = {\n\t\t\t\t\"-Xcheck:jni\",\n\t\t\t\t\"-Xcheck:gc:all:all:suppresslocal,verbose\",\n\t\t\t\t\"-Xcheck:vm:debuginfo\",\n\t\t\t\t\"-Xthr:minimizeUserCPU\",\n\t\t\t\t\"-XtlhPrefetch\",\n\t\t\t\t\"-Xtune:virtualized\",\n\t\t\t\t\"-Xtrace:none\",\n\t\t};\n\t\t\n\t\tArrayList<String> options = randomlyPick(singleOptions, Math.min(count, singleOptions.length));\n\t\treturn options;\n\t}\n\n\n\t// Functions for choosing a JIT option(s), eg randomGen,disableMergeStackMaps,optLevel=hot,count=0, etc\n\t// TODO when randomGen is selected, need to add randomSeed=x, where x is an integer I believe,\n\t// but need to select appropriate values.\n\tprivate String[] getJitOptions() {\n\t\tString[] jitOptions = {\n\t\t\t\t\"randomGen\", \n\t\t\t\t\"disableMergeStackMaps\", \n\t\t\t\t\"noJitUntilMain\", \n\t\t\t\t\"optLevel\", \n\t\t\t\t\"count\", \n\t\t\t\t\"gcOnResolve\",\n\t\t\t\t\"jitCodeCacheOptions\",\n\t\t\t\t\"jitDataCacheOptions\",\t\t\t\t  \n\t\t\t\t\"jitRecompilationOptions\",\n\t\t\t\t\"rtResolve\",\n\t\t\t\t\"quickProfile\", \n\t\t\t\t\"reserveAllLocks\",\n\t\t\t\t\"sampleInterval\"\n\t\t};\n\t\treturn jitOptions;\n\t}\n\n\tprivate String[] optLevels = { \"noOpt\", \"cold\", \"warm\", \"hot\", \"veryHot\", \"scorching\" };"
    },
    "221": {
      "metadata": {
        "chunk_id": "2e59e74d000aaebbb8055dbcdf18b8a785dc363f3b885ea3991c99381c1aeaf3",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/RandomModesGenerator.java",
        "content": "// Functions for choosing a JIT option(s), eg randomGen,disableMergeStackMaps,optLevel=hot,count=0, etc\n\t// TODO when randomGen is selected, need to add randomSeed=x, where x is an integer I believe,\n\t// but need to select appropriate values.\n\tprivate String[] getJitOptions() {\n\t\tString[] jitOptions = {\n\t\t\t\t\"randomGen\", \n\t\t\t\t\"disableMergeStackMaps\", \n\t\t\t\t\"noJitUntilMain\", \n\t\t\t\t\"optLevel\", \n\t\t\t\t\"count\", \n\t\t\t\t\"gcOnResolve\",\n\t\t\t\t\"jitCodeCacheOptions\",\n\t\t\t\t\"jitDataCacheOptions\",\t\t\t\t  \n\t\t\t\t\"jitRecompilationOptions\",\n\t\t\t\t\"rtResolve\",\n\t\t\t\t\"quickProfile\", \n\t\t\t\t\"reserveAllLocks\",\n\t\t\t\t\"sampleInterval\"\n\t\t};\n\t\treturn jitOptions;\n\t}\n\n\tprivate String[] optLevels = { \"noOpt\", \"cold\", \"warm\", \"hot\", \"veryHot\", \"scorching\" };\n\n\t\n\tprivate String getJITOptions() {\n\t\tArrayList<String> optionsCopy = new ArrayList<String>(Arrays.asList(getJitOptions()));\n\t\tint optionCount = rnd.nextInt(optionsCopy.size()) + 1;  // make sure there is always one\n\t\tStringBuilder selected = new StringBuilder();\n\t\tfor (int listIndex=0; listIndex<optionCount; listIndex++) {\n\t\t\tint optionIndex = rnd.nextInt(optionsCopy.size());\n\t\t\tString newOption = optionsCopy.get(optionIndex);\n\t\t\toptionsCopy.remove(optionIndex);\n\t\t\t\n\t\t\tif (newOption.equals(\"count\")) {\n\t\t\t\tnewOption = newOption + \"=\" + rnd.nextInt(5);\n\t\t\t}\n\t\t\t// The JIT Code Cache options alter the default settings for the JIT code cache\n\t\t\t// The code cache is where code compiled by the JIT is stored for re-use\n\t\t\t// The default code cache options as of Dec 2012 are (in MB):\n\t\t\t//  code=2048 (1024 on 32bit Windows, 512 on 32bit Linux x86)\n\t\t\t//  numCodeCachesOnStartup=1\n\t\t\t//  codeTotal=128000 (64000 on 31/32 bit)\n\t\t\tif (newOption.equals(\"jitCodeCacheOptions\")) {\n\t\t\t\tnewOption = jitCodeCacheOptions();\n\t\t\t}\n\t\t\t// The JIT Data Cache options alter the default settings for the JIT data cache.\n\t\t\t// The data cache contains \"meta data\" for compiled methods. \n\t\t\t// Compiled code goes in the code cache, which is separate from the data cache.\n\t\t\tif (newOption.equals(\"jitDataCacheOptions\")) {\n\t\t\t\tnewOption = \"dataCacheMinQuanta=\" + (rnd.nextInt(16) + 1);\n\t\t\t\tnewOption += \",dataCacheQuantumSize=\" + (rnd.nextInt(64) + 1);\n\t\t\t\tnewOption += \",paintDataCacheOnFree,data=\" + (rnd.nextInt(4096) + 1);\n\t\t\t}\n\t\t\t// The JIT Recompilation options alter the default settings for recompiling methods at given optimization levels\n\t\t\t// Generally speaking: the more recompilation the JIT is doing, the more likely it is that something goes wrong\n\t\t\t// The default sample thresholds as of Dec 2013 are:\n\t\t\t// \tveryHotSampleThreshold=480\n\t\t\t// \tscorchingSampleThreshold=240\n\t\t\tif (newOption.equals(\"jitRecompilationOptions\")) {\n\t\t\t\tnewOption = jitRecompilationOptions();\n\t\t\t}\n\t\t\tif (newOption.equals(\"optLevel\")) {\n\t\t\t\tint optLevelIndex = rnd.nextInt(optLevels.length);\n\t\t\t\tnewOption += \"=\" + optLevels[optLevelIndex];\n\t\t\t}\n\t\t\tif (newOption.equals(\"sampleInterval\")) {\n\t\t\t\tnewOption += \"=\" + rnd.nextInt(16);\n\t\t\t}\n\t\t\tif (newOption.equals(\"scorchingSampleThreshold\")) {\n\t\t\t\tnewOption += \"=\" + rnd.nextInt(25565);\n\t\t\t}\n\t\t\tif (newOption.equals(\"randomGen\")) {\n\t\t\t\tnewOption = \"randomGen,randomSeed=\" + this.seed;\n\t\t\t}\n\t\t\t\n\t\t\tif (selected.length() != 0) {\n\t\t\t\tselected.append(\",\");\n\t\t\t}\n\t\t\tselected.append(newOption);\n\t\t}\n\n\t\treturn \"-Xjit:\" + selected.toString();\n\t}",
        "start_line": 143,
        "end_line": 226,
        "chunk_index": 2,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 902,
        "node_type": null,
        "file_sha": "28429a68640de554e409fa04fa8aa1ad437f22cf",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.076366"
      },
      "text": "// Functions for choosing a JIT option(s), eg randomGen,disableMergeStackMaps,optLevel=hot,count=0, etc\n\t// TODO when randomGen is selected, need to add randomSeed=x, where x is an integer I believe,\n\t// but need to select appropriate values.\n\tprivate String[] getJitOptions() {\n\t\tString[] jitOptions = {\n\t\t\t\t\"randomGen\", \n\t\t\t\t\"disableMergeStackMaps\", \n\t\t\t\t\"noJitUntilMain\", \n\t\t\t\t\"optLevel\", \n\t\t\t\t\"count\", \n\t\t\t\t\"gcOnResolve\",\n\t\t\t\t\"jitCodeCacheOptions\",\n\t\t\t\t\"jitDataCacheOptions\",\t\t\t\t  \n\t\t\t\t\"jitRecompilationOptions\",\n\t\t\t\t\"rtResolve\",\n\t\t\t\t\"quickProfile\", \n\t\t\t\t\"reserveAllLocks\",\n\t\t\t\t\"sampleInterval\"\n\t\t};\n\t\treturn jitOptions;\n\t}\n\n\tprivate String[] optLevels = { \"noOpt\", \"cold\", \"warm\", \"hot\", \"veryHot\", \"scorching\" };\n\n\t\n\tprivate String getJITOptions() {\n\t\tArrayList<String> optionsCopy = new ArrayList<String>(Arrays.asList(getJitOptions()));\n\t\tint optionCount = rnd.nextInt(optionsCopy.size()) + 1;  // make sure there is always one\n\t\tStringBuilder selected = new StringBuilder();\n\t\tfor (int listIndex=0; listIndex<optionCount; listIndex++) {\n\t\t\tint optionIndex = rnd.nextInt(optionsCopy.size());\n\t\t\tString newOption = optionsCopy.get(optionIndex);\n\t\t\toptionsCopy.remove(optionIndex);\n\t\t\t\n\t\t\tif (newOption.equals(\"count\")) {\n\t\t\t\tnewOption = newOption + \"=\" + rnd.nextInt(5);\n\t\t\t}\n\t\t\t// The JIT Code Cache options alter the default settings for the JIT code cache\n\t\t\t// The code cache is where code compiled by the JIT is stored for re-use\n\t\t\t// The default code cache options as of Dec 2012 are (in MB):\n\t\t\t//  code=2048 (1024 on 32bit Windows, 512 on 32bit Linux x86)\n\t\t\t//  numCodeCachesOnStartup=1\n\t\t\t//  codeTotal=128000 (64000 on 31/32 bit)\n\t\t\tif (newOption.equals(\"jitCodeCacheOptions\")) {\n\t\t\t\tnewOption = jitCodeCacheOptions();\n\t\t\t}\n\t\t\t// The JIT Data Cache options alter the default settings for the JIT data cache.\n\t\t\t// The data cache contains \"meta data\" for compiled methods. \n\t\t\t// Compiled code goes in the code cache, which is separate from the data cache.\n\t\t\tif (newOption.equals(\"jitDataCacheOptions\")) {\n\t\t\t\tnewOption = \"dataCacheMinQuanta=\" + (rnd.nextInt(16) + 1);\n\t\t\t\tnewOption += \",dataCacheQuantumSize=\" + (rnd.nextInt(64) + 1);\n\t\t\t\tnewOption += \",paintDataCacheOnFree,data=\" + (rnd.nextInt(4096) + 1);\n\t\t\t}\n\t\t\t// The JIT Recompilation options alter the default settings for recompiling methods at given optimization levels\n\t\t\t// Generally speaking: the more recompilation the JIT is doing, the more likely it is that something goes wrong\n\t\t\t// The default sample thresholds as of Dec 2013 are:\n\t\t\t// \tveryHotSampleThreshold=480\n\t\t\t// \tscorchingSampleThreshold=240\n\t\t\tif (newOption.equals(\"jitRecompilationOptions\")) {\n\t\t\t\tnewOption = jitRecompilationOptions();\n\t\t\t}\n\t\t\tif (newOption.equals(\"optLevel\")) {\n\t\t\t\tint optLevelIndex = rnd.nextInt(optLevels.length);\n\t\t\t\tnewOption += \"=\" + optLevels[optLevelIndex];\n\t\t\t}\n\t\t\tif (newOption.equals(\"sampleInterval\")) {\n\t\t\t\tnewOption += \"=\" + rnd.nextInt(16);\n\t\t\t}\n\t\t\tif (newOption.equals(\"scorchingSampleThreshold\")) {\n\t\t\t\tnewOption += \"=\" + rnd.nextInt(25565);\n\t\t\t}\n\t\t\tif (newOption.equals(\"randomGen\")) {\n\t\t\t\tnewOption = \"randomGen,randomSeed=\" + this.seed;\n\t\t\t}\n\t\t\t\n\t\t\tif (selected.length() != 0) {\n\t\t\t\tselected.append(\",\");\n\t\t\t}\n\t\t\tselected.append(newOption);\n\t\t}\n\n\t\treturn \"-Xjit:\" + selected.toString();\n\t}"
    },
    "222": {
      "metadata": {
        "chunk_id": "9e2312f80c4dbfa87506c7a574dbf154b70a8066c6ad89bf90fc8db4526b6938",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/RandomModesGenerator.java",
        "content": "// Randomly build JVM options\n\tprivate ArrayList<String> getJVMOptions() {\n\t\tString[] jvmOptions = {\n\t\t\t\"-Xfastresolve\" + rnd.nextInt(256), \n\t\t\t\"-Xfuture\",\n\t\t\t\"-Xiss\" + rnd.nextInt(16)+\"K\",\n\t\t\t\"-Xssi\" + rnd.nextInt(32)+\"K\",\n\t\t\t\"-Xthr:minimizeUserCPU\",\n\t\t\t\"-Xjni:arrayCacheMax=\" + rnd.nextInt(8096),\n\t\t\t\"-Xargencoding\" };\n\t\t\n\t\treturn randomlyPickSubset(jvmOptions);\n\t}\n\n\n\tprivate String getCompressedReferencesOption() {\n\t\t// Default is for compressed references to be disabled\n\t\tString crOption = \"-Xnocompressedrefs\";\n\t\t\n\t\t// If we are running on a 64 bit system, we want to enable compressed references half of the time\n\t\tif (bitSize == 64) {\n\t\t\tint option = rnd.nextInt(2) + 1;\n\t\t\tif (option == 1) {\n\t\t\t\tcrOption = \"\";\n\t\t\t\t//System.out.println(\"OPTIONS GENERATOR: This job is using compressed references, unless the heap size is bigger than 28gb (limit accurate for linux, and varies per platform)\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn crOption;\n\t}\n\t\n\t\n\t// Randomly pick some elements from the supplied array\n\tprivate ArrayList<String> randomlyPickSubset(String[] options) {\n\t\tint numberOfOptions = rnd.nextInt(options.length) + 1 ;\n\t\treturn randomlyPick(options, numberOfOptions);\n\t}\n\n\t// Pick the specified number of elements from the supplied array of Strings\n\tprivate ArrayList<String> randomlyPick(String[] options, int count) {\n\t\tArrayList<String> localOptions = new ArrayList<String>(Arrays.asList(options));\n\t\t\n\t\tArrayList<String> optionsSelected = new ArrayList<String>();\n\t\t// Loop for choosing which options to use\n\t\tfor (int i=0; i<count; i++) {\n\t\t\t// Random number to select which array entry to take an option from\n\t\t\tint rand = rnd.nextInt(localOptions.size());\n\t\t\t// put the selection option into the optionsSelected array\n\t\t\toptionsSelected.add(localOptions.get(rand));\n\t\t\t// Remove the used entry\n\t\t    localOptions.remove(rand);\n\t\t}\n\t\t\n\t\treturn optionsSelected;\n\t}\n\n\n\t// Pick a single value from the supplied array of Strings\n\tprivate String randomlyPickFrom(String[] strings) {\n\t\tint selectedIndex = rnd.nextInt(strings.length);\n\t\treturn strings[selectedIndex];\n\t}\n\n\n\t/**\n\t * @return long containing the actual seed which the random number generator has been set to.\n\t */\n\tpublic long getSeed() {\n\t\treturn seed;\n\t}\n}",
        "start_line": 227,
        "end_line": 297,
        "chunk_index": 3,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 549,
        "node_type": null,
        "file_sha": "28429a68640de554e409fa04fa8aa1ad437f22cf",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.076369"
      },
      "text": "// Randomly build JVM options\n\tprivate ArrayList<String> getJVMOptions() {\n\t\tString[] jvmOptions = {\n\t\t\t\"-Xfastresolve\" + rnd.nextInt(256), \n\t\t\t\"-Xfuture\",\n\t\t\t\"-Xiss\" + rnd.nextInt(16)+\"K\",\n\t\t\t\"-Xssi\" + rnd.nextInt(32)+\"K\",\n\t\t\t\"-Xthr:minimizeUserCPU\",\n\t\t\t\"-Xjni:arrayCacheMax=\" + rnd.nextInt(8096),\n\t\t\t\"-Xargencoding\" };\n\t\t\n\t\treturn randomlyPickSubset(jvmOptions);\n\t}\n\n\n\tprivate String getCompressedReferencesOption() {\n\t\t// Default is for compressed references to be disabled\n\t\tString crOption = \"-Xnocompressedrefs\";\n\t\t\n\t\t// If we are running on a 64 bit system, we want to enable compressed references half of the time\n\t\tif (bitSize == 64) {\n\t\t\tint option = rnd.nextInt(2) + 1;\n\t\t\tif (option == 1) {\n\t\t\t\tcrOption = \"\";\n\t\t\t\t//System.out.println(\"OPTIONS GENERATOR: This job is using compressed references, unless the heap size is bigger than 28gb (limit accurate for linux, and varies per platform)\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn crOption;\n\t}\n\t\n\t\n\t// Randomly pick some elements from the supplied array\n\tprivate ArrayList<String> randomlyPickSubset(String[] options) {\n\t\tint numberOfOptions = rnd.nextInt(options.length) + 1 ;\n\t\treturn randomlyPick(options, numberOfOptions);\n\t}\n\n\t// Pick the specified number of elements from the supplied array of Strings\n\tprivate ArrayList<String> randomlyPick(String[] options, int count) {\n\t\tArrayList<String> localOptions = new ArrayList<String>(Arrays.asList(options));\n\t\t\n\t\tArrayList<String> optionsSelected = new ArrayList<String>();\n\t\t// Loop for choosing which options to use\n\t\tfor (int i=0; i<count; i++) {\n\t\t\t// Random number to select which array entry to take an option from\n\t\t\tint rand = rnd.nextInt(localOptions.size());\n\t\t\t// put the selection option into the optionsSelected array\n\t\t\toptionsSelected.add(localOptions.get(rand));\n\t\t\t// Remove the used entry\n\t\t    localOptions.remove(rand);\n\t\t}\n\t\t\n\t\treturn optionsSelected;\n\t}\n\n\n\t// Pick a single value from the supplied array of Strings\n\tprivate String randomlyPickFrom(String[] strings) {\n\t\tint selectedIndex = rnd.nextInt(strings.length);\n\t\treturn strings[selectedIndex];\n\t}\n\n\n\t/**\n\t * @return long containing the actual seed which the random number generator has been set to.\n\t */\n\tpublic long getSeed() {\n\t\treturn seed;\n\t}\n}"
    },
    "223": {
      "metadata": {
        "chunk_id": "6982413cdfac84534dfea3cb87206d7751049143f1d110302c15013e6642f28e",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/VariationsFileReader.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.io.File;\nimport java.io.StringReader;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class reads a variations.xml or testplan.xml file to find the java-args \n * values for a specified variation name.\n * \n * It basically extracts the java-args from xml such as:\n *    <variations>\n *       <variation name=\"jit-count30\">\n *          <java-args>-Xjit:count=30</java-args>\n *          <generation-constraints>\n *          ...\n */\npublic class VariationsFileReader {\n    private static final Logger logger = LogManager.getLogger(VariationsFileReader.class.getName());\n\n\n    /**\n\t * Reads a variations xml file to find the java-args for the named variation \n\t * @param variationsFile is the file to be read.\n\t * @param variationName is the name of the java-args variation being used. \n\t * @return ArrayList of all matching java-arg definitions.\n\t * @throws StfException if we failed to read the xml file.\n\t */\t\n\tpublic static ArrayList<JvmArgDetails> decodeVariationName(File variationsFile, String variationName) throws StfException {\n\t\tlogger.debug(\"Searching variations file: \" + variationsFile.getAbsolutePath());\n\t\t\n\t\ttry {\n\t\t\t// Read the contents of the variations xml file\n\t\t\tDocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tdb.setEntityResolver(new EntityResolver() {\n\t\t\t\t@Override\n\t\t\t\tpublic InputSource resolveEntity(String publicId, String systemId) {\n\t\t\t\t\t// it might be a good idea to insert a trace logging here that you are ignoring publicId/systemId\n\t\t\t\t\treturn new InputSource(new StringReader(\"\")); // Returns a valid dummy source\n\t\t\t\t}\n\t\t\t});\n\t\t\tDocument doc = db.parse(variationsFile);\n\t\t\t\t\n\t\t\t// Find the 'java-args' node for the named variation\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression expr = xpath.compile(\"//variations/variation[@name=\\\"\" + variationName + \"\\\"]/java-args/text()\");\n\t\t\tNodeList nl = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);\n\n\t\t\t// Extract all found 'java-args' values\n\t\t\tArrayList<JvmArgDetails> javaArgs = new ArrayList<JvmArgDetails>();\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tString argsSpec = nl.item(0).getNodeValue();\n\t\t\t\tJvmArgDetails argDetails = new JvmArgDetails(variationsFile, argsSpec);\n\t\t\t\tjavaArgs.add(argDetails);\n\t\t\t\tlogger.trace(\"Found java-args value: \" + argsSpec);\n\t\t\t}\n\t\t\t\n\t\t\treturn javaArgs;\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to read variation '\" + variationName + \"' from variation file: \" + variationsFile.getAbsolutePath(), e);\n\t\t}\n\t}\n}",
        "start_line": 0,
        "end_line": 94,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 830,
        "node_type": null,
        "file_sha": "e627901101a5b8393202f5d9eff7eca161e4d078",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.088433"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.io.File;\nimport java.io.StringReader;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class reads a variations.xml or testplan.xml file to find the java-args \n * values for a specified variation name.\n * \n * It basically extracts the java-args from xml such as:\n *    <variations>\n *       <variation name=\"jit-count30\">\n *          <java-args>-Xjit:count=30</java-args>\n *          <generation-constraints>\n *          ...\n */\npublic class VariationsFileReader {\n    private static final Logger logger = LogManager.getLogger(VariationsFileReader.class.getName());\n\n\n    /**\n\t * Reads a variations xml file to find the java-args for the named variation \n\t * @param variationsFile is the file to be read.\n\t * @param variationName is the name of the java-args variation being used. \n\t * @return ArrayList of all matching java-arg definitions.\n\t * @throws StfException if we failed to read the xml file.\n\t */\t\n\tpublic static ArrayList<JvmArgDetails> decodeVariationName(File variationsFile, String variationName) throws StfException {\n\t\tlogger.debug(\"Searching variations file: \" + variationsFile.getAbsolutePath());\n\t\t\n\t\ttry {\n\t\t\t// Read the contents of the variations xml file\n\t\t\tDocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tdb.setEntityResolver(new EntityResolver() {\n\t\t\t\t@Override\n\t\t\t\tpublic InputSource resolveEntity(String publicId, String systemId) {\n\t\t\t\t\t// it might be a good idea to insert a trace logging here that you are ignoring publicId/systemId\n\t\t\t\t\treturn new InputSource(new StringReader(\"\")); // Returns a valid dummy source\n\t\t\t\t}\n\t\t\t});\n\t\t\tDocument doc = db.parse(variationsFile);\n\t\t\t\t\n\t\t\t// Find the 'java-args' node for the named variation\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression expr = xpath.compile(\"//variations/variation[@name=\\\"\" + variationName + \"\\\"]/java-args/text()\");\n\t\t\tNodeList nl = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);\n\n\t\t\t// Extract all found 'java-args' values\n\t\t\tArrayList<JvmArgDetails> javaArgs = new ArrayList<JvmArgDetails>();\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tString argsSpec = nl.item(0).getNodeValue();\n\t\t\t\tJvmArgDetails argDetails = new JvmArgDetails(variationsFile, argsSpec);\n\t\t\t\tjavaArgs.add(argDetails);\n\t\t\t\tlogger.trace(\"Found java-args value: \" + argsSpec);\n\t\t\t}\n\t\t\t\n\t\t\treturn javaArgs;\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to read variation '\" + variationName + \"' from variation file: \" + variationsFile.getAbsolutePath(), e);\n\t\t}\n\t}\n}"
    },
    "224": {
      "metadata": {
        "chunk_id": "abdfeaf8bc780782ad93d6135849ecce2503444ba424c3a192969a4f7f1da886",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/VariationsSearcher.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\n\n/**\n * This class finds all java-args definitions for a single variation name. \n * It searches for these in:\n *   1) variations.xml file\n *   2) all testplan.xml files\n */",
        "start_line": 0,
        "end_line": 31,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 245,
        "node_type": null,
        "file_sha": "77a35cb791f18b0a55dcfc505e7f1729141ae3a1",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.100658"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.modes;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\n\n/**\n * This class finds all java-args definitions for a single variation name. \n * It searches for these in:\n *   1) variations.xml file\n *   2) all testplan.xml files\n */"
    },
    "225": {
      "metadata": {
        "chunk_id": "1493c959eed5a6534ff3ab8e5b3cb8a8392d16d402f0256e2be11d3f3acb8057",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/modes/VariationsSearcher.java",
        "content": "public class VariationsSearcher {\n\tprivate static final Logger logger = LogManager.getLogger(VariationsFileReader.class.getName());\n\t\n\tprivate static final String VARIATIONS_FILE = \"tools.testExecution/config/variations.xml\";\n\tprivate static final String TESTPLANS_DIRECTORY = \"testplans\";\n\tprivate static final String TESTPLAN_FILENAME = \"testplan.xml\";\n\n\n\t/**\n\t * Reads variations.xml and testplan.xml files to find the java-args for the named variation.\n\t * @param environmentCore \n\t * @param variationName is variation that has been set through the STF '-mode' argument. \n\t * @return ArrayList containing all matching java-arg definitions.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic ArrayList<JvmArgDetails> findMode(StfEnvironmentCore environmentCore, String variationName) throws StfException {\n\t\tArrayList<JvmArgDetails> javaArgDefinitions = new ArrayList<JvmArgDetails>();\n\t\t\n\t\t// Find any and all variation definitions from the main variations file\n\t\tFile variationsFile = environmentCore.findTestFile(VARIATIONS_FILE).asJavaFile();\n\t\tArrayList<JvmArgDetails> variationsFileDefinitions = VariationsFileReader.decodeVariationName(variationsFile, variationName);\n\t\tjavaArgDefinitions.addAll(variationsFileDefinitions);\n\t\t\n\t\t// Search all testplan.xml files for definitions of this variation\n\t\tArrayList<File> testplans = findTestplans(environmentCore.getTestRoots()); \n\t\tfor (File testplan : testplans) {\n\t\t\tArrayList<JvmArgDetails> testplanDefinions = VariationsFileReader.decodeVariationName(testplan, variationName);\n\t\t\tjavaArgDefinitions.addAll(testplanDefinions);\n\t\t}\n\t\t\n\t\treturn javaArgDefinitions;\n\t}\n\n\t\n\t/**\n\t * Search the test roots for all testplan.xml files. \n\t * These are assumed to live below the 'testplans' directory of each project.\n\t * @param testRoots are the directories to search below.\n\t * @return an ArrayList containing references to all found testplan.xml files.\n\t * @throws StfException if there is an internal error.\n\t */\n\tprivate ArrayList<File> findTestplans(ArrayList<DirectoryRef> testRoots) throws StfException {\n\t\tArrayList<File> foundTestplans = new ArrayList<File>();\n\t\tfor (DirectoryRef testRoot : testRoots) {\n\t\t\tlogger.debug(\"Searching for testplans below: \" + testRoot);\n\t\t\t\n\t\t\t// Search all projects which have a top level 'testplans' directory\n\t\t\tfor (File project : testRoot.asJavaFile().listFiles()) {\n\t\t\t\tFile testplansDir = new File(project, TESTPLANS_DIRECTORY);\n\t\t\t\tif (testplansDir.exists() && testplansDir.isDirectory()) {\n\t\t\t\t\tsearchDirForTestplans(testplansDir, foundTestplans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn foundTestplans;\n\t}\n\n\n\t// Recursively search a directory for testplan.xml files\n\tprivate void searchDirForTestplans(File dir, ArrayList<File> foundTestplans) {\n\t\tfor (File f : dir.listFiles()) {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tsearchDirForTestplans(f, foundTestplans);\n\t\t\t} else if (f.isFile() && f.getName().equals(TESTPLAN_FILENAME)) {\n\t\t\t\tfoundTestplans.add(f);\n\t\t\t}\n\t\t}\n\t}\n}",
        "start_line": 32,
        "end_line": 101,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 690,
        "node_type": null,
        "file_sha": "77a35cb791f18b0a55dcfc505e7f1729141ae3a1",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.100665"
      },
      "text": "public class VariationsSearcher {\n\tprivate static final Logger logger = LogManager.getLogger(VariationsFileReader.class.getName());\n\t\n\tprivate static final String VARIATIONS_FILE = \"tools.testExecution/config/variations.xml\";\n\tprivate static final String TESTPLANS_DIRECTORY = \"testplans\";\n\tprivate static final String TESTPLAN_FILENAME = \"testplan.xml\";\n\n\n\t/**\n\t * Reads variations.xml and testplan.xml files to find the java-args for the named variation.\n\t * @param environmentCore \n\t * @param variationName is variation that has been set through the STF '-mode' argument. \n\t * @return ArrayList containing all matching java-arg definitions.\n\t * @throws StfException if there is an internal error.\n\t */\n\tpublic ArrayList<JvmArgDetails> findMode(StfEnvironmentCore environmentCore, String variationName) throws StfException {\n\t\tArrayList<JvmArgDetails> javaArgDefinitions = new ArrayList<JvmArgDetails>();\n\t\t\n\t\t// Find any and all variation definitions from the main variations file\n\t\tFile variationsFile = environmentCore.findTestFile(VARIATIONS_FILE).asJavaFile();\n\t\tArrayList<JvmArgDetails> variationsFileDefinitions = VariationsFileReader.decodeVariationName(variationsFile, variationName);\n\t\tjavaArgDefinitions.addAll(variationsFileDefinitions);\n\t\t\n\t\t// Search all testplan.xml files for definitions of this variation\n\t\tArrayList<File> testplans = findTestplans(environmentCore.getTestRoots()); \n\t\tfor (File testplan : testplans) {\n\t\t\tArrayList<JvmArgDetails> testplanDefinions = VariationsFileReader.decodeVariationName(testplan, variationName);\n\t\t\tjavaArgDefinitions.addAll(testplanDefinions);\n\t\t}\n\t\t\n\t\treturn javaArgDefinitions;\n\t}\n\n\t\n\t/**\n\t * Search the test roots for all testplan.xml files. \n\t * These are assumed to live below the 'testplans' directory of each project.\n\t * @param testRoots are the directories to search below.\n\t * @return an ArrayList containing references to all found testplan.xml files.\n\t * @throws StfException if there is an internal error.\n\t */\n\tprivate ArrayList<File> findTestplans(ArrayList<DirectoryRef> testRoots) throws StfException {\n\t\tArrayList<File> foundTestplans = new ArrayList<File>();\n\t\tfor (DirectoryRef testRoot : testRoots) {\n\t\t\tlogger.debug(\"Searching for testplans below: \" + testRoot);\n\t\t\t\n\t\t\t// Search all projects which have a top level 'testplans' directory\n\t\t\tfor (File project : testRoot.asJavaFile().listFiles()) {\n\t\t\t\tFile testplansDir = new File(project, TESTPLANS_DIRECTORY);\n\t\t\t\tif (testplansDir.exists() && testplansDir.isDirectory()) {\n\t\t\t\t\tsearchDirForTestplans(testplansDir, foundTestplans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn foundTestplans;\n\t}\n\n\n\t// Recursively search a directory for testplan.xml files\n\tprivate void searchDirForTestplans(File dir, ArrayList<File> foundTestplans) {\n\t\tfor (File f : dir.listFiles()) {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tsearchDirForTestplans(f, foundTestplans);\n\t\t\t} else if (f.isFile() && f.getName().equals(TESTPLAN_FILENAME)) {\n\t\t\t\tfoundTestplans.add(f);\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "226": {
      "metadata": {
        "chunk_id": "c396960f56e534cd9ed6d752cd0c3e347efc56241feb243baac8a4badadb6c07",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/plugin/interfaces/StfPluginInterface.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.plugin.interfaces;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/** \n * An interface to provide the simplest possible interface for test plugins.\n * \n * This can be used by plugins which don't need to make use of any extensions \n * beyond 'StfCore'.\n */\npublic interface StfPluginInterface extends StfPluginRootInterface {\n\n\tpublic void help(HelpTextGenerator help) throws Exception;\n\t\n\tpublic void pluginInit(StfCoreExtension svt) throws Exception;\n\n\tpublic void setUp(StfCoreExtension svt) throws Exception;\n\t\n\tpublic void tearDown(StfCoreExtension svt) throws Exception;\n}",
        "start_line": 0,
        "end_line": 35,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 277,
        "node_type": null,
        "file_sha": "e7f8a52e926f12dec847a00af82311ea4fc8641a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.114986"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.plugin.interfaces;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/** \n * An interface to provide the simplest possible interface for test plugins.\n * \n * This can be used by plugins which don't need to make use of any extensions \n * beyond 'StfCore'.\n */\npublic interface StfPluginInterface extends StfPluginRootInterface {\n\n\tpublic void help(HelpTextGenerator help) throws Exception;\n\t\n\tpublic void pluginInit(StfCoreExtension svt) throws Exception;\n\n\tpublic void setUp(StfCoreExtension svt) throws Exception;\n\t\n\tpublic void tearDown(StfCoreExtension svt) throws Exception;\n}"
    },
    "227": {
      "metadata": {
        "chunk_id": "50ba878e65cfd6d737477cac59564459f1ecef5fd52d80ab63a83f07644f9bbf",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/plugin/interfaces/StfPluginRootInterface.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.plugin.interfaces;\n\n/**\n * All test plugins must ultimately implement this interface.\n * \n * It is expected that another interface will sit between the test plugin\n * class and this interface. The intermediate interface will define the 4 \n * essential methods: \n *   - help() for test specific help\n *   - pluginInit()\n *   - setUp()\n *   - excute*() - NB. Required but not in the interface\n *   - tearDown()\n * In the typical usage the test plugin implements the project specific \n * intermediate interface which in turn implements this marker interface.\n * \n * This interface is not able to define the pluginInit/setup/etc methods as the \n * 4 lifecycle methods all take a currently unknown list of Extension \n * objects. \n */\npublic interface StfPluginRootInterface {\n\n}",
        "start_line": 0,
        "end_line": 36,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 294,
        "node_type": null,
        "file_sha": "65869c420e1f9901aac57e9f320e6a84dd715223",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.130088"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.plugin.interfaces;\n\n/**\n * All test plugins must ultimately implement this interface.\n * \n * It is expected that another interface will sit between the test plugin\n * class and this interface. The intermediate interface will define the 4 \n * essential methods: \n *   - help() for test specific help\n *   - pluginInit()\n *   - setUp()\n *   - excute*() - NB. Required but not in the interface\n *   - tearDown()\n * In the typical usage the test plugin implements the project specific \n * intermediate interface which in turn implements this marker interface.\n * \n * This interface is not able to define the pluginInit/setup/etc methods as the \n * 4 lifecycle methods all take a currently unknown list of Extension \n * objects. \n */\npublic interface StfPluginRootInterface {\n\n}"
    },
    "228": {
      "metadata": {
        "chunk_id": "0c5d1a79008acb0fdda26593db4e82ff99ab68951812812cabbd5cb7b4eea974",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/ExpectedOutcome.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.StfExitCodes;\nimport net.adoptopenjdk.stf.util.StfDuration;\nimport net.adoptopenjdk.stf.util.TimeParser;\n\n\n/**\n * This class holds the expected outcome of running a process. \n * \n * The test run is deemed successful if the process behaves as expected. \n * i.e. if a process is expected to crash, and it does then crash, then the test \n * run is a success. However, if the process were to complete with an exit \n * code of '0' then it has not met its expectations and would be treated as a \n * failure.\n * \n */",
        "start_line": 0,
        "end_line": 31,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 280,
        "node_type": null,
        "file_sha": "ef715f75828c2d860b9415eaf9b172bb03c63a59",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.145143"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.StfExitCodes;\nimport net.adoptopenjdk.stf.util.StfDuration;\nimport net.adoptopenjdk.stf.util.TimeParser;\n\n\n/**\n * This class holds the expected outcome of running a process. \n * \n * The test run is deemed successful if the process behaves as expected. \n * i.e. if a process is expected to crash, and it does then crash, then the test \n * run is a success. However, if the process were to complete with an exit \n * code of '0' then it has not met its expectations and would be treated as a \n * failure.\n * \n */"
    },
    "229": {
      "metadata": {
        "chunk_id": "83d97809ec37de95b52239aec3b7bf8920ecbaf3d8bf2cbbbc7a3d01069bdc4b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/ExpectedOutcome.java",
        "content": "public class ExpectedOutcome {\n\tpublic enum OutcomeType {\n\t\tCLEAN_RUN,\n\t\tNON_ZERO_EXIT,\n\t\tNEVER,\n\t\tCRASHES\n\t};\n\t\n\tprivate final OutcomeType expectedOutcome;\n\tprivate final StfExitCodes expectedExitValue;\n\tprivate final StfDuration durationLimit;\n\t\n\t\n\t// Private to force the use of the static methods.\n\tprivate ExpectedOutcome(OutcomeType expectedOutcome, StfExitCodes expectedExitValue, StfDuration duration) {\n\t\tthis.expectedOutcome = expectedOutcome;\n\t\tthis.expectedExitValue = expectedExitValue;\n\t\tthis.durationLimit = duration;\n\t}\n\n\t\n\t/**\n\t * @return An ExcepectedOutcome object for the case in which the process is expected \n\t * to finish successfully with an exit value of '0'.\n\t */\n\tpublic static ExpectedOutcome cleanRun() {\n\t\treturn new ExpectedOutcome(OutcomeType.CLEAN_RUN, StfExitCodes.expected(0), null);\n\t}\n\t\n\t\n\t/**\n\t * Creates an ExpectedOutcome object for the case in which the process exits with \n\t * a non-zero value.  \n\t * @param expectedExitValue is the value which the process will be using on exit.\n\t * This is normally a single value but in some circumstances more a process may exit \n\t * with another value. \n\t */\n\tpublic static ExpectedOutcome exitValue(Integer... expectedExitValue) {\n\t\treturn new ExpectedOutcome(OutcomeType.NON_ZERO_EXIT, StfExitCodes.expected(expectedExitValue), null);\n\t}\n\n\t\n\t/**\n\t * @return an ExpectedOutcome object for a process which runs indefinitely, and should \n\t * neither exit or crash.\n\t */\n\tpublic static ExpectedOutcome neverCompletes() {\n\t\treturn new ExpectedOutcome(OutcomeType.NEVER, StfExitCodes.expected(-1), StfDuration.ofDays(2));\n\t}\n\n\t\n\t/**\n\t * @return an ExpectedOutcome object for a process which is going to crash.\n\t */\n\tpublic static ExpectedOutcome crashes() {\n\t\treturn new ExpectedOutcome(OutcomeType.CRASHES, StfExitCodes.expected(-1), null);\n\t}\n\n\n\t/**\n\t * Allows the setting of the maximum run time for a process.\n\t * If the process has not completed within the specified time then it will \n\t * be killed and the test run will have failed.\n\t * @param timeSpecification is a string containing the hours, minutes and seconds\n\t * time limit. eg, '1h30m' or '15s'. \n\t * @return an ExpectedOutcome object which has the maximum run time \n\t * @throws StfException if the timeSpecification string is not in the expected format.\n\t */\n\tpublic ExpectedOutcome within(String timeSpecification) throws StfException {\n\t\t// Build duration of the specified value\n\t\tStfDuration duration = TimeParser.parseTimeSpecification(timeSpecification);\n\t\treturn new ExpectedOutcome(expectedOutcome, expectedExitValue, duration);\n\t}\n\n\t\n\tpublic OutcomeType getExpectedOutcome() {\n\t\treturn expectedOutcome;\n\t}\n\t\n\t\n\t/**\n\t * @return a String containing the expected exit values for a child process.\n\t * eg, '0' for successful run, or '2,3,4' if multiple values are allowed.\n\t */\n\tpublic String getExpectedExitValue() {\n\t\tStringBuilder exitCodeSpec = new StringBuilder();\n\t\tfor (int exitCode : expectedExitValue.getAllowableExitCodes()) { \n\t\t\tif (exitCodeSpec.length() > 0) {\n\t\t\t\texitCodeSpec.append(\",\");\n\t\t\t}\n\t\t\texitCodeSpec.append(exitCode);\n\t\t}\n\t\t\n\t\treturn exitCodeSpec.toString();\n\t}\n\t\n\t\t\n\tpublic StfDuration getDurationLimit() {\n\t\treturn durationLimit;\n\t}\n\t\n\t\n\tpublic String toString() { \n\t\tStringBuilder buff = new StringBuilder();\n\t\t\n\t\tbuff.append(expectedOutcome.toString());\n\t\t\n\t\tif (expectedOutcome == OutcomeType.NON_ZERO_EXIT) {\n\t\t\tbuff.append(\" \" + expectedExitValue);\n\t\t}\n\t\t\n\t\tif (durationLimit != null && expectedOutcome != OutcomeType.NEVER) { \n\t\t\tbuff.append(\" within \" + durationLimit);\n\t\t}\n\t\t\n\t\treturn buff.toString();\n\t}\n}",
        "start_line": 32,
        "end_line": 149,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 845,
        "node_type": null,
        "file_sha": "ef715f75828c2d860b9415eaf9b172bb03c63a59",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.145153"
      },
      "text": "public class ExpectedOutcome {\n\tpublic enum OutcomeType {\n\t\tCLEAN_RUN,\n\t\tNON_ZERO_EXIT,\n\t\tNEVER,\n\t\tCRASHES\n\t};\n\t\n\tprivate final OutcomeType expectedOutcome;\n\tprivate final StfExitCodes expectedExitValue;\n\tprivate final StfDuration durationLimit;\n\t\n\t\n\t// Private to force the use of the static methods.\n\tprivate ExpectedOutcome(OutcomeType expectedOutcome, StfExitCodes expectedExitValue, StfDuration duration) {\n\t\tthis.expectedOutcome = expectedOutcome;\n\t\tthis.expectedExitValue = expectedExitValue;\n\t\tthis.durationLimit = duration;\n\t}\n\n\t\n\t/**\n\t * @return An ExcepectedOutcome object for the case in which the process is expected \n\t * to finish successfully with an exit value of '0'.\n\t */\n\tpublic static ExpectedOutcome cleanRun() {\n\t\treturn new ExpectedOutcome(OutcomeType.CLEAN_RUN, StfExitCodes.expected(0), null);\n\t}\n\t\n\t\n\t/**\n\t * Creates an ExpectedOutcome object for the case in which the process exits with \n\t * a non-zero value.  \n\t * @param expectedExitValue is the value which the process will be using on exit.\n\t * This is normally a single value but in some circumstances more a process may exit \n\t * with another value. \n\t */\n\tpublic static ExpectedOutcome exitValue(Integer... expectedExitValue) {\n\t\treturn new ExpectedOutcome(OutcomeType.NON_ZERO_EXIT, StfExitCodes.expected(expectedExitValue), null);\n\t}\n\n\t\n\t/**\n\t * @return an ExpectedOutcome object for a process which runs indefinitely, and should \n\t * neither exit or crash.\n\t */\n\tpublic static ExpectedOutcome neverCompletes() {\n\t\treturn new ExpectedOutcome(OutcomeType.NEVER, StfExitCodes.expected(-1), StfDuration.ofDays(2));\n\t}\n\n\t\n\t/**\n\t * @return an ExpectedOutcome object for a process which is going to crash.\n\t */\n\tpublic static ExpectedOutcome crashes() {\n\t\treturn new ExpectedOutcome(OutcomeType.CRASHES, StfExitCodes.expected(-1), null);\n\t}\n\n\n\t/**\n\t * Allows the setting of the maximum run time for a process.\n\t * If the process has not completed within the specified time then it will \n\t * be killed and the test run will have failed.\n\t * @param timeSpecification is a string containing the hours, minutes and seconds\n\t * time limit. eg, '1h30m' or '15s'. \n\t * @return an ExpectedOutcome object which has the maximum run time \n\t * @throws StfException if the timeSpecification string is not in the expected format.\n\t */\n\tpublic ExpectedOutcome within(String timeSpecification) throws StfException {\n\t\t// Build duration of the specified value\n\t\tStfDuration duration = TimeParser.parseTimeSpecification(timeSpecification);\n\t\treturn new ExpectedOutcome(expectedOutcome, expectedExitValue, duration);\n\t}\n\n\t\n\tpublic OutcomeType getExpectedOutcome() {\n\t\treturn expectedOutcome;\n\t}\n\t\n\t\n\t/**\n\t * @return a String containing the expected exit values for a child process.\n\t * eg, '0' for successful run, or '2,3,4' if multiple values are allowed.\n\t */\n\tpublic String getExpectedExitValue() {\n\t\tStringBuilder exitCodeSpec = new StringBuilder();\n\t\tfor (int exitCode : expectedExitValue.getAllowableExitCodes()) { \n\t\t\tif (exitCodeSpec.length() > 0) {\n\t\t\t\texitCodeSpec.append(\",\");\n\t\t\t}\n\t\t\texitCodeSpec.append(exitCode);\n\t\t}\n\t\t\n\t\treturn exitCodeSpec.toString();\n\t}\n\t\n\t\t\n\tpublic StfDuration getDurationLimit() {\n\t\treturn durationLimit;\n\t}\n\t\n\t\n\tpublic String toString() { \n\t\tStringBuilder buff = new StringBuilder();\n\t\t\n\t\tbuff.append(expectedOutcome.toString());\n\t\t\n\t\tif (expectedOutcome == OutcomeType.NON_ZERO_EXIT) {\n\t\t\tbuff.append(\" \" + expectedExitValue);\n\t\t}\n\t\t\n\t\tif (durationLimit != null && expectedOutcome != OutcomeType.NEVER) { \n\t\t\tbuff.append(\" within \" + durationLimit);\n\t\t}\n\t\t\n\t\treturn buff.toString();\n\t}\n}"
    },
    "230": {
      "metadata": {
        "chunk_id": "ecf6ad97a9a0ff2d65200f9c99092f4582a3de19bfa9201b67112dfa4b7cf172",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/StfProcess.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.FileRef;\n\n\n/** \n * This class holds information about a process which will be controlled by \n * the perl process management layer.\n */\npublic class StfProcess {\n\t// Holds the mnemonic name of the process, as used by the test case\n\tprivate String mnemonic;\n\t\n\t// Holds the variable name used by the perl code to refer to this process\n\tprivate String perlProcessVariable;\n\t\n\t// Contains the test cases expectation for the process. Also holds its maximum runtime.\n\tprivate ExpectedOutcome expectedOutcome;\n\t\n\t// Track the currently known process state. \n\t// Used for error checking at code generation time, to spot problems with automation code.\n\tprivate enum ProcessState { RUNNING, COMPLETED, KILLED };\n\tprivate ProcessState knownState;\n\t\n\tprivate FileRef stderr;\n\tprivate FileRef stdout;\n\t\n\t\n\tpublic StfProcess(String mnemonic, String perlProcessVariable, ExpectedOutcome expectedOutcome, FileRef stderr, FileRef stdout) throws StfException {\n\t\tthis.mnemonic = mnemonic;\n\t\tthis.perlProcessVariable = perlProcessVariable;\n\t\tthis.expectedOutcome = expectedOutcome;\n\t\tthis.knownState = ProcessState.RUNNING;\n\t\t\n\t\tthis.stderr = stderr;\n\t\tthis.stdout = stdout;\n\t}\n\n\t\n\tpublic String getPerlProcessVariable() { \n\t\treturn perlProcessVariable;\n\t}\n\t\n\tpublic FileRef getStderrFileRef(){\n\t\treturn stderr;\n\t}\n\t\n\t\n\tpublic FileRef getStdoutFileRef(){\n\t\treturn stdout;\n\t}\n\n\tpublic String getMnemonic() {\n\t\treturn mnemonic;\n\t}\n\n\tpublic void updateStateToCompleted() {\n\t\tthis.knownState = ProcessState.COMPLETED;\n\t}\n\n\tpublic void updateStateToKilled() {\n\t\tthis.knownState = ProcessState.KILLED;\n\t}\n\n\tpublic boolean isRunning() {\n\t\treturn knownState == ProcessState.RUNNING;\n\t}\n\n\tpublic boolean processHasCompleted() {\n\t\treturn knownState == ProcessState.COMPLETED;\n\t}\n\n\tpublic boolean processHasBeenKilled() {\n\t\treturn knownState == ProcessState.KILLED;\n\t}\n\n\tpublic ExpectedOutcome getExpectedCompletion() {\n\t\treturn expectedOutcome;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn mnemonic;\n\t}\n}",
        "start_line": 0,
        "end_line": 98,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 589,
        "node_type": null,
        "file_sha": "83a1864e1f56c6623159376aab91a67f644beabf",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.162491"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.FileRef;\n\n\n/** \n * This class holds information about a process which will be controlled by \n * the perl process management layer.\n */\npublic class StfProcess {\n\t// Holds the mnemonic name of the process, as used by the test case\n\tprivate String mnemonic;\n\t\n\t// Holds the variable name used by the perl code to refer to this process\n\tprivate String perlProcessVariable;\n\t\n\t// Contains the test cases expectation for the process. Also holds its maximum runtime.\n\tprivate ExpectedOutcome expectedOutcome;\n\t\n\t// Track the currently known process state. \n\t// Used for error checking at code generation time, to spot problems with automation code.\n\tprivate enum ProcessState { RUNNING, COMPLETED, KILLED };\n\tprivate ProcessState knownState;\n\t\n\tprivate FileRef stderr;\n\tprivate FileRef stdout;\n\t\n\t\n\tpublic StfProcess(String mnemonic, String perlProcessVariable, ExpectedOutcome expectedOutcome, FileRef stderr, FileRef stdout) throws StfException {\n\t\tthis.mnemonic = mnemonic;\n\t\tthis.perlProcessVariable = perlProcessVariable;\n\t\tthis.expectedOutcome = expectedOutcome;\n\t\tthis.knownState = ProcessState.RUNNING;\n\t\t\n\t\tthis.stderr = stderr;\n\t\tthis.stdout = stdout;\n\t}\n\n\t\n\tpublic String getPerlProcessVariable() { \n\t\treturn perlProcessVariable;\n\t}\n\t\n\tpublic FileRef getStderrFileRef(){\n\t\treturn stderr;\n\t}\n\t\n\t\n\tpublic FileRef getStdoutFileRef(){\n\t\treturn stdout;\n\t}\n\n\tpublic String getMnemonic() {\n\t\treturn mnemonic;\n\t}\n\n\tpublic void updateStateToCompleted() {\n\t\tthis.knownState = ProcessState.COMPLETED;\n\t}\n\n\tpublic void updateStateToKilled() {\n\t\tthis.knownState = ProcessState.KILLED;\n\t}\n\n\tpublic boolean isRunning() {\n\t\treturn knownState == ProcessState.RUNNING;\n\t}\n\n\tpublic boolean processHasCompleted() {\n\t\treturn knownState == ProcessState.COMPLETED;\n\t}\n\n\tpublic boolean processHasBeenKilled() {\n\t\treturn knownState == ProcessState.KILLED;\n\t}\n\n\tpublic ExpectedOutcome getExpectedCompletion() {\n\t\treturn expectedOutcome;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn mnemonic;\n\t}\n}"
    },
    "231": {
      "metadata": {
        "chunk_id": "94dccd9d720833a53d191fb1840d67982221e396a97e480f72ecad6df1861ff7",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JDKToolProcessDefinition.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.processes.StfProcess;\n\n\n/**\n * This object captures the information needed to start a JDK tool or utility.\n * \n * See SampleRunJDKTool.java for a runnable example.\n */",
        "start_line": 0,
        "end_line": 30,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 241,
        "node_type": null,
        "file_sha": "eae8cca295aeaf2a3c52d2e6d153c71b36d515fd",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.176789"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.processes.StfProcess;\n\n\n/**\n * This object captures the information needed to start a JDK tool or utility.\n * \n * See SampleRunJDKTool.java for a runnable example.\n */"
    },
    "232": {
      "metadata": {
        "chunk_id": "0d6c4d3b982b989c8b69505d4d58cc31521a399fde17fa8d2c21400576413683",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JDKToolProcessDefinition.java",
        "content": "public class JDKToolProcessDefinition implements ProcessDefinition {\n\tprivate StfEnvironmentCore environmentCore;\n\tprivate String toolOrUtilityName; \n\t\n\tprivate ArrayList<String> args = new ArrayList<String>();\n\n\n\tpublic JDKToolProcessDefinition(StfEnvironmentCore environmentCore) {\n\t\tthis.environmentCore = environmentCore;\n\t}\n\t\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param toolOrUtilityName sets the name of the JDK tool or utility to execute.\n\t */\n\tpublic JDKToolProcessDefinition setJDKToolOrUtility(String toolOrUtilityName) {\n\t\tthis.toolOrUtilityName = toolOrUtilityName;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a argument value to the tool's invocation.\n\t * @param arg is an argument to be passed to the JDK tool.\n\t * @return the updated JDKToolProcessDefinition.\n\t */\n\tpublic JDKToolProcessDefinition addArg(String arg) {\n\t\tthis.args.add(arg);\t\t\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adds multiple argument values to the tool's invocation.\n\t * @param arg is one or more arguments to be passed to the JDK tool.\n\t * @return the updated JDKToolProcessDefinition.\n\t */\n\tpublic JDKToolProcessDefinition addArg(String... args) {\n\t\tfor (String arg : args) { \n\t\t\taddArg(arg);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * Convenience method for adding a FileRef object as an argument\n\t * @param fileRef is the object to add as an argument.\n\t * @return the updated JDKToolProcessDefinition\n\t */\n\tpublic JDKToolProcessDefinition addArg(FileRef fileRef) {\n\t\treturn addArg(fileRef.getSpec());\n\t}\n\n\n\t/**\n\t * @return the name of the JDK tool or utility to execute.\n\t * @throws StfException \n\t */\n\tpublic String getCommand() throws StfException {\n\t\t// Create the command using the full path to Java or the JDK tool\n\t\treturn environmentCore.getJavaHome().childFile(\"bin/\" + toolOrUtilityName).getSpec();\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\t\n\t\n\t/**\n\t * Returns all of the arguments needed to run the JDK tool or utility.\n\t * @return an array list of Strings containing the arguments.\n\t * @throws StfException if the JDK tool/utility has not been specified.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\tArrayList<String> allArgs = new ArrayList<String>();\n\t\t\n\t\tif (toolOrUtilityName == null) {\n\t\t\tthrow new StfException(\"Can't run as Java class has not been specified (method setJDKToolOrUtility() needs to be called\");\n\t\t}\n\t\t\n\t\tallArgs.addAll(args);\n\t\t\n\t\treturn allArgs;\n\t}\n\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) {\n\t}\n}",
        "start_line": 31,
        "end_line": 145,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 785,
        "node_type": null,
        "file_sha": "eae8cca295aeaf2a3c52d2e6d153c71b36d515fd",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.176797"
      },
      "text": "public class JDKToolProcessDefinition implements ProcessDefinition {\n\tprivate StfEnvironmentCore environmentCore;\n\tprivate String toolOrUtilityName; \n\t\n\tprivate ArrayList<String> args = new ArrayList<String>();\n\n\n\tpublic JDKToolProcessDefinition(StfEnvironmentCore environmentCore) {\n\t\tthis.environmentCore = environmentCore;\n\t}\n\t\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param toolOrUtilityName sets the name of the JDK tool or utility to execute.\n\t */\n\tpublic JDKToolProcessDefinition setJDKToolOrUtility(String toolOrUtilityName) {\n\t\tthis.toolOrUtilityName = toolOrUtilityName;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a argument value to the tool's invocation.\n\t * @param arg is an argument to be passed to the JDK tool.\n\t * @return the updated JDKToolProcessDefinition.\n\t */\n\tpublic JDKToolProcessDefinition addArg(String arg) {\n\t\tthis.args.add(arg);\t\t\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adds multiple argument values to the tool's invocation.\n\t * @param arg is one or more arguments to be passed to the JDK tool.\n\t * @return the updated JDKToolProcessDefinition.\n\t */\n\tpublic JDKToolProcessDefinition addArg(String... args) {\n\t\tfor (String arg : args) { \n\t\t\taddArg(arg);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * Convenience method for adding a FileRef object as an argument\n\t * @param fileRef is the object to add as an argument.\n\t * @return the updated JDKToolProcessDefinition\n\t */\n\tpublic JDKToolProcessDefinition addArg(FileRef fileRef) {\n\t\treturn addArg(fileRef.getSpec());\n\t}\n\n\n\t/**\n\t * @return the name of the JDK tool or utility to execute.\n\t * @throws StfException \n\t */\n\tpublic String getCommand() throws StfException {\n\t\t// Create the command using the full path to Java or the JDK tool\n\t\treturn environmentCore.getJavaHome().childFile(\"bin/\" + toolOrUtilityName).getSpec();\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\t\n\t\n\t/**\n\t * Returns all of the arguments needed to run the JDK tool or utility.\n\t * @return an array list of Strings containing the arguments.\n\t * @throws StfException if the JDK tool/utility has not been specified.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\tArrayList<String> allArgs = new ArrayList<String>();\n\t\t\n\t\tif (toolOrUtilityName == null) {\n\t\t\tthrow new StfException(\"Can't run as Java class has not been specified (method setJDKToolOrUtility() needs to be called\");\n\t\t}\n\t\t\n\t\tallArgs.addAll(args);\n\t\t\n\t\treturn allArgs;\n\t}\n\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) {\n\t}\n}"
    },
    "233": {
      "metadata": {
        "chunk_id": "d0af59361e2ac61d0a2064bec8da45c36e55e824f52bc4591e9f49ff21a1306a",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport net.adoptopenjdk.stf.StfConstants;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.processes.StfProcess;\n\n/**\n * This object captures the information needed to start a Java process.\n * \n * Running a Java process can require numerous setup values, so rather than \n * giving this class a very complex constructor it uses the builder pattern, to \n * provide a fluent style interface for automation code.\n * \n * An example of typical usage is:\n *    test.createJavaProcessDefinition()\n *        .addJvmOption(\"-Xmx500M\")\n *\t      .addProjectToClasspath(\"openjdk.test.load\")\n *\t\t  .addProjectToClasspath(\"stf.core\")\n *\t\t  .addProjectToClasspath(\"stf.load\")\n *\t\t  .addArg(suiteName)    \t\t\t\n *\t\t  .addArg(resultsDir.getSpec()));\n *\n * This class throws an exception if the Java process information is not built  \n * in the same order in which it will be used.\n * Callers should build the java process information in the following order:\n *   - jvm arguments\n *   - module --add-reads\n *   - module-path\n *   - upgrade-module-path\n *   - module add-modules\n *   - module limit-modules\n *   - module to run\n *   - classpath setup\n *   - class to execute \n *   - application arguments\n *\n * See SampleClientServer.java for a runnable example.\n */",
        "start_line": 0,
        "end_line": 64,
        "chunk_index": 0,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 554,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197792"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport net.adoptopenjdk.stf.StfConstants;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.processes.StfProcess;\n\n/**\n * This object captures the information needed to start a Java process.\n * \n * Running a Java process can require numerous setup values, so rather than \n * giving this class a very complex constructor it uses the builder pattern, to \n * provide a fluent style interface for automation code.\n * \n * An example of typical usage is:\n *    test.createJavaProcessDefinition()\n *        .addJvmOption(\"-Xmx500M\")\n *\t      .addProjectToClasspath(\"openjdk.test.load\")\n *\t\t  .addProjectToClasspath(\"stf.core\")\n *\t\t  .addProjectToClasspath(\"stf.load\")\n *\t\t  .addArg(suiteName)    \t\t\t\n *\t\t  .addArg(resultsDir.getSpec()));\n *\n * This class throws an exception if the Java process information is not built  \n * in the same order in which it will be used.\n * Callers should build the java process information in the following order:\n *   - jvm arguments\n *   - module --add-reads\n *   - module-path\n *   - upgrade-module-path\n *   - module add-modules\n *   - module limit-modules\n *   - module to run\n *   - classpath setup\n *   - class to execute \n *   - application arguments\n *\n * See SampleClientServer.java for a runnable example.\n */"
    },
    "234": {
      "metadata": {
        "chunk_id": "a1595615610172c15e3913933a7329de23ec977a197a3b116b7a13705773b152",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "public class JavaProcessDefinition implements ProcessDefinition {\n\tprivate StfEnvironmentCore environmentCore;\n\t\n\tprivate JavaVersion jvm;\n\t\n\t// To accommodate the buildup invocation arguments\n\tprivate ArrayList<String> jvmOptions = new ArrayList<String>();\n\tprivate ArrayList<String> classpathEntries = new ArrayList<String>();\n\tprivate String executableJar = null;\n\tprivate String javaClassName = null;\n\tprivate ArrayList<String> javaArgs = new ArrayList<String>();\n\tprivate HashMap<String,StfProcess> relatedProcesses = new HashMap<String,StfProcess>();\n\tprivate HashMap<String,Integer> relatedProcessesData = new HashMap<String,Integer>();\n\t\n\t// Module related data\n\tprivate DirectoryRef runtimeImage = null;\n\tprivate String moduleAddReadsDefinition = null;\n\tprivate ArrayList<String> modulepathEntries = new ArrayList<String>();\n\tprivate ArrayList<String> upgradeModulepathEntries = new ArrayList<String>();\n\tprivate ArrayList<String> rootModules = new ArrayList<String>();\n\tprivate ArrayList<String> limitModules = new ArrayList<String>();\n\tprivate String initialModuleName = null;\n\tprivate Class<?> initialModuleMainClass = null;\n\t// For --add-exports\n\tprivate String addExportsModule = null;\n\tprivate String addExportsPackage = null;\n\tprivate ArrayList<String> addExportsOtherModules = null;\n\t\n\t// for --patch-module\n\tprivate static class PatchModuleData {\n\t\tString moduleName;\n\t\tArrayList<String> patchDetails;\n\t}\n\tprivate boolean disablePatchModuleAmalgamation;\n\tArrayList<PatchModuleData> patchModules = new ArrayList<PatchModuleData>();  \n\t\n\t// To enforce correct buildup of invocation arguments, all the addition \n\t// methods fall into one of these categories.\n\tprivate enum Stage {\n\t\t//                level min VM version\n\t\tIMAGE(              1,  9),\n\t\tJVM_ARGS(           2,  1),\n\t\tMODULE_ADD_READS(   3,  9),\n\t\tMODULE_PATH(        3,  9),\n\t\tMODULE_UPGRADE_PATH(3,  9),\n\t\tMODULE_ADDMODS(     3,  9),\n\t\tMODULE_LIMITMODS(   3,  9),\n\t\tMODULE_ADD_EXPORTS( 3,  9),\n\t\tMODULE_PATCH_MODS(  3,  9),\n\t\tMODULE(             3,  9),\n\t\tCLASSPATH(          4,  1),\n\t\tCLASS(              5,  1),\n\t\tAPPLICATION_ARGS(   6,  1);\n\t\t\n\t\tprivate int level;\n\t\tprivate int minimumJVM;\n\t\tStage(int level, int minimumJVM) { \n\t\t\tthis.level = level;\n\t\t\tthis.minimumJVM = minimumJVM;\n\t\t}\n\t}\n\n\t// Holds the category of addition method last used\n\tprivate Stage oldStage = Stage.IMAGE;\n\t\n\t\n\tpublic JavaProcessDefinition(StfEnvironmentCore environmentCore, JavaVersion jvm) {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.jvm = jvm;\n\t}\n\n\tpublic JavaProcessDefinition(StfEnvironmentCore environmentCore) throws StfException {\n\t\tthis(environmentCore, environmentCore.primaryJvm());\n\t}\n\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\t\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn jvm;\n\t}\n\t\n\tpublic JavaProcessDefinition addRunImage(DirectoryRef runtimeImage) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.IMAGE);\n\t\t\n\t\tthis.runtimeImage = runtimeImage;\n\t\treturn this;\n\t}",
        "start_line": 65,
        "end_line": 153,
        "chunk_index": 1,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 711,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197800"
      },
      "text": "public class JavaProcessDefinition implements ProcessDefinition {\n\tprivate StfEnvironmentCore environmentCore;\n\t\n\tprivate JavaVersion jvm;\n\t\n\t// To accommodate the buildup invocation arguments\n\tprivate ArrayList<String> jvmOptions = new ArrayList<String>();\n\tprivate ArrayList<String> classpathEntries = new ArrayList<String>();\n\tprivate String executableJar = null;\n\tprivate String javaClassName = null;\n\tprivate ArrayList<String> javaArgs = new ArrayList<String>();\n\tprivate HashMap<String,StfProcess> relatedProcesses = new HashMap<String,StfProcess>();\n\tprivate HashMap<String,Integer> relatedProcessesData = new HashMap<String,Integer>();\n\t\n\t// Module related data\n\tprivate DirectoryRef runtimeImage = null;\n\tprivate String moduleAddReadsDefinition = null;\n\tprivate ArrayList<String> modulepathEntries = new ArrayList<String>();\n\tprivate ArrayList<String> upgradeModulepathEntries = new ArrayList<String>();\n\tprivate ArrayList<String> rootModules = new ArrayList<String>();\n\tprivate ArrayList<String> limitModules = new ArrayList<String>();\n\tprivate String initialModuleName = null;\n\tprivate Class<?> initialModuleMainClass = null;\n\t// For --add-exports\n\tprivate String addExportsModule = null;\n\tprivate String addExportsPackage = null;\n\tprivate ArrayList<String> addExportsOtherModules = null;\n\t\n\t// for --patch-module\n\tprivate static class PatchModuleData {\n\t\tString moduleName;\n\t\tArrayList<String> patchDetails;\n\t}\n\tprivate boolean disablePatchModuleAmalgamation;\n\tArrayList<PatchModuleData> patchModules = new ArrayList<PatchModuleData>();  \n\t\n\t// To enforce correct buildup of invocation arguments, all the addition \n\t// methods fall into one of these categories.\n\tprivate enum Stage {\n\t\t//                level min VM version\n\t\tIMAGE(              1,  9),\n\t\tJVM_ARGS(           2,  1),\n\t\tMODULE_ADD_READS(   3,  9),\n\t\tMODULE_PATH(        3,  9),\n\t\tMODULE_UPGRADE_PATH(3,  9),\n\t\tMODULE_ADDMODS(     3,  9),\n\t\tMODULE_LIMITMODS(   3,  9),\n\t\tMODULE_ADD_EXPORTS( 3,  9),\n\t\tMODULE_PATCH_MODS(  3,  9),\n\t\tMODULE(             3,  9),\n\t\tCLASSPATH(          4,  1),\n\t\tCLASS(              5,  1),\n\t\tAPPLICATION_ARGS(   6,  1);\n\t\t\n\t\tprivate int level;\n\t\tprivate int minimumJVM;\n\t\tStage(int level, int minimumJVM) { \n\t\t\tthis.level = level;\n\t\t\tthis.minimumJVM = minimumJVM;\n\t\t}\n\t}\n\n\t// Holds the category of addition method last used\n\tprivate Stage oldStage = Stage.IMAGE;\n\t\n\t\n\tpublic JavaProcessDefinition(StfEnvironmentCore environmentCore, JavaVersion jvm) {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.jvm = jvm;\n\t}\n\n\tpublic JavaProcessDefinition(StfEnvironmentCore environmentCore) throws StfException {\n\t\tthis(environmentCore, environmentCore.primaryJvm());\n\t}\n\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\t\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn jvm;\n\t}\n\t\n\tpublic JavaProcessDefinition addRunImage(DirectoryRef runtimeImage) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.IMAGE);\n\t\t\n\t\tthis.runtimeImage = runtimeImage;\n\t\treturn this;\n\t}"
    },
    "235": {
      "metadata": {
        "chunk_id": "88d7864e94234c8f425ae0ae7c240e44031bd35b431dd30ed842cc7fad6cf7f9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "// Holds the category of addition method last used\n\tprivate Stage oldStage = Stage.IMAGE;\n\t\n\t\n\tpublic JavaProcessDefinition(StfEnvironmentCore environmentCore, JavaVersion jvm) {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.jvm = jvm;\n\t}\n\n\tpublic JavaProcessDefinition(StfEnvironmentCore environmentCore) throws StfException {\n\t\tthis(environmentCore, environmentCore.primaryJvm());\n\t}\n\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\t\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn jvm;\n\t}\n\t\n\tpublic JavaProcessDefinition addRunImage(DirectoryRef runtimeImage) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.IMAGE);\n\t\t\n\t\tthis.runtimeImage = runtimeImage;\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Adds a value to be used as a Jvm option. eg, '-Xmx100M'\n\t * It is usual to provide a single option on each call, but if options\n\t * are related then it makes sense to supply several at the same time, as\n\t * this helps to allow a logical layout in the test code.  \n\t * @param jvmOptions one or more values to be used as JVM options\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addJvmOption(String... jvmOptions) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.JVM_ARGS);\n\t\t\n\t\tif (jvmOptions != null) {\n\t\t\tfor (String option : jvmOptions) {\n\t\t\t\tif (option != null) {\n\t\t\t\t\tthis.jvmOptions.add(option);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a value to be used as a Jvm option. eg, '-Xmx100M', only if \n\t * we are using an IBM JVM.  \n\t * \n\t * @param jvmOptions one or more values to be used as JVM options\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addJvmOptionIfIBMJava(String... jvmOptions) throws StfException {\n\t\tif (environmentCore.isUsingIBMJava()) {\n\t\t\treturn addJvmOption(jvmOptions);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Adds a value for the --add-reads argument for Java9 modularity.\n\t * Supply a value for add-reads, eg \"com.test=ALL-UNNAMED\"\n\t * @param moduleAddReadsDefinition, which should be in the form '<module>=<other-module>(,<other-module>)*' \n\t * <other-module> may be ALL-UNNAMED to require the unnamed module.\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addModuleAddReads(String moduleAddReadsDefinition) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_ADD_READS);\n\n\t\tthis.moduleAddReadsDefinition = moduleAddReadsDefinition;\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adds a directory to the --module-path argument for Java9 modularity.\n\t * @param directoryReference is the directory of modules to add as the next modulepath entry.\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addDirectoryToModulepath(DirectoryRef directoryReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_PATH);\n\t\t\n\t\tvalidateDirectoryExists(directoryReference, \"Can't add directory to modulepath\");\n\t\tmodulepathEntries.add(directoryReference.getSpec());\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a workspace directory to the --module-path argument for Java9 modularity. \n\t * @param moduleRef is the path to a module within the workspace, eg, \"test.modularity/bin/common-mods\"\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addModuleToModulepath(String moduleRef) throws StfException {\n\t\tDirectoryRef moduleDir = environmentCore.findTestDirectory(moduleRef);\n\t\treturn addDirectoryToModulepath(moduleDir);\n\t}",
        "start_line": 154,
        "end_line": 266,
        "chunk_index": 2,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 901,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197803"
      },
      "text": "// Holds the category of addition method last used\n\tprivate Stage oldStage = Stage.IMAGE;\n\t\n\t\n\tpublic JavaProcessDefinition(StfEnvironmentCore environmentCore, JavaVersion jvm) {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.jvm = jvm;\n\t}\n\n\tpublic JavaProcessDefinition(StfEnvironmentCore environmentCore) throws StfException {\n\t\tthis(environmentCore, environmentCore.primaryJvm());\n\t}\n\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\t\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn jvm;\n\t}\n\t\n\tpublic JavaProcessDefinition addRunImage(DirectoryRef runtimeImage) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.IMAGE);\n\t\t\n\t\tthis.runtimeImage = runtimeImage;\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Adds a value to be used as a Jvm option. eg, '-Xmx100M'\n\t * It is usual to provide a single option on each call, but if options\n\t * are related then it makes sense to supply several at the same time, as\n\t * this helps to allow a logical layout in the test code.  \n\t * @param jvmOptions one or more values to be used as JVM options\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addJvmOption(String... jvmOptions) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.JVM_ARGS);\n\t\t\n\t\tif (jvmOptions != null) {\n\t\t\tfor (String option : jvmOptions) {\n\t\t\t\tif (option != null) {\n\t\t\t\t\tthis.jvmOptions.add(option);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a value to be used as a Jvm option. eg, '-Xmx100M', only if \n\t * we are using an IBM JVM.  \n\t * \n\t * @param jvmOptions one or more values to be used as JVM options\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addJvmOptionIfIBMJava(String... jvmOptions) throws StfException {\n\t\tif (environmentCore.isUsingIBMJava()) {\n\t\t\treturn addJvmOption(jvmOptions);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Adds a value for the --add-reads argument for Java9 modularity.\n\t * Supply a value for add-reads, eg \"com.test=ALL-UNNAMED\"\n\t * @param moduleAddReadsDefinition, which should be in the form '<module>=<other-module>(,<other-module>)*' \n\t * <other-module> may be ALL-UNNAMED to require the unnamed module.\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addModuleAddReads(String moduleAddReadsDefinition) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_ADD_READS);\n\n\t\tthis.moduleAddReadsDefinition = moduleAddReadsDefinition;\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adds a directory to the --module-path argument for Java9 modularity.\n\t * @param directoryReference is the directory of modules to add as the next modulepath entry.\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addDirectoryToModulepath(DirectoryRef directoryReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_PATH);\n\t\t\n\t\tvalidateDirectoryExists(directoryReference, \"Can't add directory to modulepath\");\n\t\tmodulepathEntries.add(directoryReference.getSpec());\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a workspace directory to the --module-path argument for Java9 modularity. \n\t * @param moduleRef is the path to a module within the workspace, eg, \"test.modularity/bin/common-mods\"\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addModuleToModulepath(String moduleRef) throws StfException {\n\t\tDirectoryRef moduleDir = environmentCore.findTestDirectory(moduleRef);\n\t\treturn addDirectoryToModulepath(moduleDir);\n\t}"
    },
    "236": {
      "metadata": {
        "chunk_id": "183005aa2d21846c1f6d538fcdba7e31154afcf70a6f7507b74095c0cbcabc3d",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "/**\n\t * Adds a jar file to the --module-path argument for Java9 modularity. \n\t * @param moduleRef points to the jar file.\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addModuleToModulepath(ModuleRef moduleRef) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_PATH);\n\t\t\n\t\tmodulepathEntries.add(moduleRef.getJarFileRef().getSpec());\n\t\t\n\t\treturn this;\n\t}\n    \n\n\t/**\n\t * Adds a jar file to the --module-path argument for Java9 modularity. \n\t * @param jarRef points to the jar file.\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addJarToModulepath(FileRef jarRef) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_PATH);\n\t\t\n\t\tmodulepathEntries.add(jarRef.getSpec());\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a known systemtest-prereq jar to the modulepath.\n\t * These are jar files held in one of the systemtest-prereq locations, and are referenced by the JarId enumeration. \n\t * See stf.core.properties for the default values. \n\t * @param jarId refers to the jar to be added.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the jar file does not exist.\n\t */\n\tpublic JavaProcessDefinition addPrereqJarToModulePath(JarId jarId) throws StfException {\n\t\t// Find out where the jar file lives\n\t\tString relativeJarLocation = environmentCore.getProperty(jarId.getArgument()).replace(\"/systemtest-prereqs/\", \"\");\n\t\tFileRef jarFileRef = environmentCore.findPrereqFile(relativeJarLocation);\n\t\t\n\t\tif (!jarFileRef.asJavaFile().exists()) {\n\t\t\tthrow new StfException(\"Jar file does not exist: \" + jarFileRef.getSpec());\n\t\t}\n\t\t\n\t\treturn addJarToModulepath(jarFileRef);\n\t}\t\n  \n\n\t/**\n\t * Adds a directory to the --upgrade-module-path argument for Java9 modularity.\n\t * @param directoryReference is the directory of modules to add as the next modulepath entry.\n\t * @return an updated Java process definition.\n\t * @throws StfException if the directory does not exist.\n\t */\n\tpublic JavaProcessDefinition addDirectoryToUpgradeModulepath(DirectoryRef directoryReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_UPGRADE_PATH);\n\t\t\n\t\tvalidateDirectoryExists(directoryReference, \"Can't add directory to modulepath\");\n\t\tupgradeModulepathEntries.add(directoryReference.getSpec());\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a workspace directory to the --upgrade-module-path argument for Java9 modularity. \n\t * @param moduleRef is the path to a module within the workspace, eg, \"test.modularity/bin/common-mods\"\n\t * @return an updated Java process definition.\n\t * @throws StfException if the module directory doesn't exist.\n\t */\n\tpublic JavaProcessDefinition addModuleToUpgradeModulepath(String moduleRef) throws StfException {\n\t\tDirectoryRef upgradeModuleDir = environmentCore.findTestDirectory(moduleRef);\n\t\treturn addDirectoryToUpgradeModulepath(upgradeModuleDir);\n\t}\n\n\t\n\t/**\n\t * Adds a jar or jmod file to the --upgrade-module-path argument for Java9 modularity. \n\t * @param fileRef points to the file to add. This is expected to be a jar or jmod file.\n\t * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addFileToUpgradeModulepath(FileRef fileRef) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_UPGRADE_PATH);\n\t\t\n\t\tupgradeModulepathEntries.add(fileRef.getSpec());\n\t\t\n\t\treturn this;\n\t}",
        "start_line": 267,
        "end_line": 357,
        "chunk_index": 3,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 816,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197805"
      },
      "text": "/**\n\t * Adds a jar file to the --module-path argument for Java9 modularity. \n\t * @param moduleRef points to the jar file.\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addModuleToModulepath(ModuleRef moduleRef) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_PATH);\n\t\t\n\t\tmodulepathEntries.add(moduleRef.getJarFileRef().getSpec());\n\t\t\n\t\treturn this;\n\t}\n    \n\n\t/**\n\t * Adds a jar file to the --module-path argument for Java9 modularity. \n\t * @param jarRef points to the jar file.\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addJarToModulepath(FileRef jarRef) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_PATH);\n\t\t\n\t\tmodulepathEntries.add(jarRef.getSpec());\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a known systemtest-prereq jar to the modulepath.\n\t * These are jar files held in one of the systemtest-prereq locations, and are referenced by the JarId enumeration. \n\t * See stf.core.properties for the default values. \n\t * @param jarId refers to the jar to be added.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the jar file does not exist.\n\t */\n\tpublic JavaProcessDefinition addPrereqJarToModulePath(JarId jarId) throws StfException {\n\t\t// Find out where the jar file lives\n\t\tString relativeJarLocation = environmentCore.getProperty(jarId.getArgument()).replace(\"/systemtest-prereqs/\", \"\");\n\t\tFileRef jarFileRef = environmentCore.findPrereqFile(relativeJarLocation);\n\t\t\n\t\tif (!jarFileRef.asJavaFile().exists()) {\n\t\t\tthrow new StfException(\"Jar file does not exist: \" + jarFileRef.getSpec());\n\t\t}\n\t\t\n\t\treturn addJarToModulepath(jarFileRef);\n\t}\t\n  \n\n\t/**\n\t * Adds a directory to the --upgrade-module-path argument for Java9 modularity.\n\t * @param directoryReference is the directory of modules to add as the next modulepath entry.\n\t * @return an updated Java process definition.\n\t * @throws StfException if the directory does not exist.\n\t */\n\tpublic JavaProcessDefinition addDirectoryToUpgradeModulepath(DirectoryRef directoryReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_UPGRADE_PATH);\n\t\t\n\t\tvalidateDirectoryExists(directoryReference, \"Can't add directory to modulepath\");\n\t\tupgradeModulepathEntries.add(directoryReference.getSpec());\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a workspace directory to the --upgrade-module-path argument for Java9 modularity. \n\t * @param moduleRef is the path to a module within the workspace, eg, \"test.modularity/bin/common-mods\"\n\t * @return an updated Java process definition.\n\t * @throws StfException if the module directory doesn't exist.\n\t */\n\tpublic JavaProcessDefinition addModuleToUpgradeModulepath(String moduleRef) throws StfException {\n\t\tDirectoryRef upgradeModuleDir = environmentCore.findTestDirectory(moduleRef);\n\t\treturn addDirectoryToUpgradeModulepath(upgradeModuleDir);\n\t}\n\n\t\n\t/**\n\t * Adds a jar or jmod file to the --upgrade-module-path argument for Java9 modularity. \n\t * @param fileRef points to the file to add. This is expected to be a jar or jmod file.\n\t * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addFileToUpgradeModulepath(FileRef fileRef) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_UPGRADE_PATH);\n\t\t\n\t\tupgradeModulepathEntries.add(fileRef.getSpec());\n\t\t\n\t\treturn this;\n\t}"
    },
    "237": {
      "metadata": {
        "chunk_id": "98bcae23c7f36789f235a53bcf4633cb7d3429a4882ce452aca5b268d93e1984",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "/**\n\t * Adds a jar or jmod file to the --upgrade-module-path argument for Java9 modularity. \n\t * @param fileRef points to the file to add. This is expected to be a jar or jmod file.\n\t * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addFileToUpgradeModulepath(FileRef fileRef) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_UPGRADE_PATH);\n\t\t\n\t\tupgradeModulepathEntries.add(fileRef.getSpec());\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/** \n\t * Define a module to be used as part of the --add-modules argument for Java9 modularity.\n\t * @param rootModuleName is the name of a root module, eg, \"com.test\"\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addRootModule(String rootModuleName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_ADDMODS);\n\t\t\n\t\trootModules.add(rootModuleName);\n\t\treturn this;\n\t}\n\t\n\t\n\t/** \n\t * Define a module to be used as part of the --limit-modules argument for Java9 modularity.\n\t * @param limitModuleName is the name of a module for the limitmods argument. eg, \"com.test\"\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addLimitModule(String limitModuleName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_LIMITMODS);\n\t\t\n\t\tlimitModules.add(limitModuleName);\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Allows setting of optional values for --add-exports.\n\t * Generates a Java argument in the form:\n\t *   --add-exports <module>/<package>=<other-module>(,<other-module>)\n\t *   \n\t * @param addExportsModule\n\t * @param addExportsPackage\n\t * @param addExportsOtherModules is one or more module names. Currently string to allow almost anything to be passed in.\n\t * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addAddExports(String addExportsModule, String addExportsPackage, String... addExportsOtherModules)  throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_ADD_EXPORTS);\n\n\t\tthis.addExportsModule = addExportsModule;\n\t\tthis.addExportsPackage = addExportsPackage;\n\t\tthis.addExportsOtherModules = new ArrayList<String>(Arrays.asList(addExportsOtherModules));\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t\n\t/**\n\t * By default module data for --patch-module arguments are combined into arguments \n\t * with the same module name.\n\t * This method disables the amalgamation. Every call to .addPatchModule will then \n\t * result in the generation of a new --patch-module argument.\n     * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition disablePatchModuleAmalgamation() {\n\t\tdisablePatchModuleAmalgamation = true;\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Allows setting of optional values for --patch-module.\n\t * Generates a Java argument in the form:\n\t *   --patch-module <module>=<file>(:<file>)\n\t * If used this method is expected to be invoked only once. \n\t * @param moduleName contains the name of the module.\n\t * @param patchDirs are 1 or more directories to be used to patch the module.\n     * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addPatchModule(String moduleName, DirectoryRef... patchDirs) throws StfException {\n\t\tArrayList<String> patchStrings = new ArrayList<String>();\t\n\t\tfor (DirectoryRef patchDir : patchDirs) {\n\t\t\tpatchStrings.add(patchDir.getSpec());\n\t\t}\n\t\t\n\t\taddPatchModule(moduleName, patchStrings);\n\t\t\n\t\treturn this;\n\t}",
        "start_line": 358,
        "end_line": 453,
        "chunk_index": 4,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 800,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197807"
      },
      "text": "/**\n\t * Adds a jar or jmod file to the --upgrade-module-path argument for Java9 modularity. \n\t * @param fileRef points to the file to add. This is expected to be a jar or jmod file.\n\t * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addFileToUpgradeModulepath(FileRef fileRef) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_UPGRADE_PATH);\n\t\t\n\t\tupgradeModulepathEntries.add(fileRef.getSpec());\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/** \n\t * Define a module to be used as part of the --add-modules argument for Java9 modularity.\n\t * @param rootModuleName is the name of a root module, eg, \"com.test\"\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addRootModule(String rootModuleName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_ADDMODS);\n\t\t\n\t\trootModules.add(rootModuleName);\n\t\treturn this;\n\t}\n\t\n\t\n\t/** \n\t * Define a module to be used as part of the --limit-modules argument for Java9 modularity.\n\t * @param limitModuleName is the name of a module for the limitmods argument. eg, \"com.test\"\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addLimitModule(String limitModuleName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_LIMITMODS);\n\t\t\n\t\tlimitModules.add(limitModuleName);\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Allows setting of optional values for --add-exports.\n\t * Generates a Java argument in the form:\n\t *   --add-exports <module>/<package>=<other-module>(,<other-module>)\n\t *   \n\t * @param addExportsModule\n\t * @param addExportsPackage\n\t * @param addExportsOtherModules is one or more module names. Currently string to allow almost anything to be passed in.\n\t * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addAddExports(String addExportsModule, String addExportsPackage, String... addExportsOtherModules)  throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_ADD_EXPORTS);\n\n\t\tthis.addExportsModule = addExportsModule;\n\t\tthis.addExportsPackage = addExportsPackage;\n\t\tthis.addExportsOtherModules = new ArrayList<String>(Arrays.asList(addExportsOtherModules));\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t\n\t/**\n\t * By default module data for --patch-module arguments are combined into arguments \n\t * with the same module name.\n\t * This method disables the amalgamation. Every call to .addPatchModule will then \n\t * result in the generation of a new --patch-module argument.\n     * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition disablePatchModuleAmalgamation() {\n\t\tdisablePatchModuleAmalgamation = true;\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Allows setting of optional values for --patch-module.\n\t * Generates a Java argument in the form:\n\t *   --patch-module <module>=<file>(:<file>)\n\t * If used this method is expected to be invoked only once. \n\t * @param moduleName contains the name of the module.\n\t * @param patchDirs are 1 or more directories to be used to patch the module.\n     * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addPatchModule(String moduleName, DirectoryRef... patchDirs) throws StfException {\n\t\tArrayList<String> patchStrings = new ArrayList<String>();\t\n\t\tfor (DirectoryRef patchDir : patchDirs) {\n\t\t\tpatchStrings.add(patchDir.getSpec());\n\t\t}\n\t\t\n\t\taddPatchModule(moduleName, patchStrings);\n\t\t\n\t\treturn this;\n\t}"
    },
    "238": {
      "metadata": {
        "chunk_id": "61ed77bb73799271eb34f39fdbfa31f21965667771c50e67b422d34de38ad3ab",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "/**\n\t * Allows setting of optional values for --patch-module.\n\t * Generates a Java argument in the form:\n\t *   --patch-module <module>=<file>(:<file>)\n\t * If used this method is expected to be invoked only once. \n\t * @param moduleName contains the name of the module.\n\t * @param patchDirs are 1 or more directories to be used to patch the module.\n     * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addPatchModule(String moduleName, DirectoryRef... patchDirs) throws StfException {\n\t\tArrayList<String> patchStrings = new ArrayList<String>();\t\n\t\tfor (DirectoryRef patchDir : patchDirs) {\n\t\t\tpatchStrings.add(patchDir.getSpec());\n\t\t}\n\t\t\n\t\taddPatchModule(moduleName, patchStrings);\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * Allows setting of optional values for --patch-module.\n\t * Generates a Java argument in the form:\n\t *   --patch-module <module>=<file>(:<file>)\n\t * If used this method is expected to be invoked only once. \n\t * @param moduleName contains the name of the module.\n\t * @param patches contains 1 or more modules to be used.\n     * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addPatchModule(String moduleName, ModuleRef... patches) throws StfException {\n\t\tArrayList<String> patchStrings = new ArrayList<String>();\n\t\tfor (ModuleRef patch : patches) {\n\t\t\tpatchStrings.add(patch.getJarFileRef().getSpec());\n\t\t}\n\t\t\n\t\taddPatchModule(moduleName, patchStrings);\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\tprivate JavaProcessDefinition addPatchModule(String moduleName, ArrayList<String> patches) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_PATCH_MODS);\n\t\t\n\t\t// Attempt to find existing patch module data for the named module\n\t\tPatchModuleData patchModule = null;\n\t\tif (!disablePatchModuleAmalgamation) {\n\t\t\tfor (PatchModuleData p : patchModules) {\n\t\t\t\tif (p.moduleName.equals(moduleName)) {\n\t\t\t\t\tpatchModule = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Create a new patchModule object if we cannot add to an existing patchModule entry\n\t\tif (patchModule == null) {\n\t\t\tpatchModule = new PatchModuleData();\n\t\t\tpatchModule.moduleName = moduleName;\n\t\t\tpatchModule.patchDetails = new ArrayList<String>();\n\t\t\tthis.patchModules.add(patchModule);\n\t\t}\n\t\t\n\t\t// Store patch details for the current addPatchModule method call\n\t\tfor (String patchArg : patches) {\n\t\t\tpatchModule.patchDetails.add(patchArg);\n\t\t}\n\t\t\n\t\treturn this;\n\t}",
        "start_line": 454,
        "end_line": 524,
        "chunk_index": 5,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 572,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197810"
      },
      "text": "/**\n\t * Allows setting of optional values for --patch-module.\n\t * Generates a Java argument in the form:\n\t *   --patch-module <module>=<file>(:<file>)\n\t * If used this method is expected to be invoked only once. \n\t * @param moduleName contains the name of the module.\n\t * @param patchDirs are 1 or more directories to be used to patch the module.\n     * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addPatchModule(String moduleName, DirectoryRef... patchDirs) throws StfException {\n\t\tArrayList<String> patchStrings = new ArrayList<String>();\t\n\t\tfor (DirectoryRef patchDir : patchDirs) {\n\t\t\tpatchStrings.add(patchDir.getSpec());\n\t\t}\n\t\t\n\t\taddPatchModule(moduleName, patchStrings);\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * Allows setting of optional values for --patch-module.\n\t * Generates a Java argument in the form:\n\t *   --patch-module <module>=<file>(:<file>)\n\t * If used this method is expected to be invoked only once. \n\t * @param moduleName contains the name of the module.\n\t * @param patches contains 1 or more modules to be used.\n     * @return an updated Java process definition.\n\t */\n\tpublic JavaProcessDefinition addPatchModule(String moduleName, ModuleRef... patches) throws StfException {\n\t\tArrayList<String> patchStrings = new ArrayList<String>();\n\t\tfor (ModuleRef patch : patches) {\n\t\t\tpatchStrings.add(patch.getJarFileRef().getSpec());\n\t\t}\n\t\t\n\t\taddPatchModule(moduleName, patchStrings);\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\tprivate JavaProcessDefinition addPatchModule(String moduleName, ArrayList<String> patches) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE_PATCH_MODS);\n\t\t\n\t\t// Attempt to find existing patch module data for the named module\n\t\tPatchModuleData patchModule = null;\n\t\tif (!disablePatchModuleAmalgamation) {\n\t\t\tfor (PatchModuleData p : patchModules) {\n\t\t\t\tif (p.moduleName.equals(moduleName)) {\n\t\t\t\t\tpatchModule = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Create a new patchModule object if we cannot add to an existing patchModule entry\n\t\tif (patchModule == null) {\n\t\t\tpatchModule = new PatchModuleData();\n\t\t\tpatchModule.moduleName = moduleName;\n\t\t\tpatchModule.patchDetails = new ArrayList<String>();\n\t\t\tthis.patchModules.add(patchModule);\n\t\t}\n\t\t\n\t\t// Store patch details for the current addPatchModule method call\n\t\tfor (String patchArg : patches) {\n\t\t\tpatchModule.patchDetails.add(patchArg);\n\t\t}\n\t\t\n\t\treturn this;\n\t}"
    },
    "239": {
      "metadata": {
        "chunk_id": "35a3263263e3c8155d4fe5b70c01beff0e225a157b39593275f774cf5a3c55cb",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "/** \n\t * Define the initial module to be used for the optional -m argument for Java9 modularity.\n\t * @param initialModuleName is the name of the initial module, eg, \"com.test\"\n\t * @param initialModuleMainClass is the main class to execute if not specified in the module. \n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addInitialModule(String initialModuleName, Class<?> initialModuleMainClass)  throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE);\n\t\t\n\t\tthis.initialModuleName = initialModuleName;\n\t\tthis.initialModuleMainClass = initialModuleMainClass;\n\t\treturn this;\n\t}\n\t\n\t\n\t/** \n\t * Variant of addInitialModule for cases in which no initial module main class is supplied.\n\t * Supplied values are used to build java's '-m' argument. \n\t * @param initialModuleName is the name of the initial module, eg, \"com.test\"\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addInitialModule(String initialModuleName)  throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE);\n\t\t\n\t\tthis.initialModuleName = initialModuleName;\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds the bin directory of a project to the classpath.\n\t * The project is searched for in the test-root locations.\n\t * @param projectName is the name of the project to be added, or null if there is no project to add.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the bin directory of the named project does not exist\n\t * or if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addProjectToClasspath(String projectName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tif (projectName != null) {\n\t\t\tDirectoryRef projectBinDir = environmentCore.findTestDirectory((projectName + \"/bin\"));\n\t\t\tclasspathEntries.add(projectBinDir.getSpec());\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * This enumeration lists the known jar files which can be added to the classpath.\n\t * We remove \"/systemtest-prereqs\" from the start of each argument so we can search\n\t * each prereq location for these jars later.\n\t */\n\tpublic enum JarId {\n\t\tJUNIT(StfCoreExtension.ARG_JUNIT_JAR),\n\t\tHAMCREST(StfCoreExtension.ARG_HAMCREST_CORE_JAR),\n\t\tLOG4J_API(StfCoreExtension.ARG_LOG4J_API_JAR),\n\t\tLOG4J_CORE(StfCoreExtension.ARG_LOG4J_CORE_JAR),\n\t\tASM(StfCoreExtension.ARG_ASM_JAR),\n\t\tASM_COMMONS(StfCoreExtension.ARG_ASM_COMMONS_JAR);\n\t\t\n\t\tprivate Argument jarLocation;\n\t\tprivate JarId(Argument jarLocation) { this.jarLocation = jarLocation; }\n\t\tpublic Argument getArgument() { return jarLocation; }\n\t}\n\t\n\t\n\t/**\n\t * Adds a known systemtest-prereq jar to the classpath.\n\t * These are jar files held in one of the systemtest-prereqs locations, and are referenced by the JarId enumeration. \n\t * See stf.core.properties for the default values. \n\t * @param jarId refers to the jar to be added.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the jar file does not exist.\n\t */\n\tpublic JavaProcessDefinition addPrereqJarToClasspath(JarId jarId) throws StfException {\n\t\t// Find out where the jar file lives.\n\t\tString relativeJarLocation = environmentCore.getProperty(jarId.getArgument()).replace(\"/systemtest-prereqs/\", \"\");\n\t\tFileRef jarFileRef = environmentCore.findPrereqFile(relativeJarLocation);\n\t\t\n\t\tif (!jarFileRef.asJavaFile().exists()) {\n\t\t\tthrow new StfException(\"Jar file does not exist: \" + jarFileRef.getSpec());\n\t\t}\n\t\t\n\t\treturn addJarToClasspath(jarFileRef);\n\t}\n\n\t\n\t/**\n\t * Adds a jar file to the classpath.\n\t * The jar file is not checked to make sure it exists, as it may not be \n\t * available until run time.\n\t * @param jarReference is a FileReference pointing at the jar file to add to the classpath.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addJarToClasspath(FileRef jarReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);",
        "start_line": 525,
        "end_line": 625,
        "chunk_index": 6,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 995,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197812"
      },
      "text": "/** \n\t * Define the initial module to be used for the optional -m argument for Java9 modularity.\n\t * @param initialModuleName is the name of the initial module, eg, \"com.test\"\n\t * @param initialModuleMainClass is the main class to execute if not specified in the module. \n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addInitialModule(String initialModuleName, Class<?> initialModuleMainClass)  throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE);\n\t\t\n\t\tthis.initialModuleName = initialModuleName;\n\t\tthis.initialModuleMainClass = initialModuleMainClass;\n\t\treturn this;\n\t}\n\t\n\t\n\t/** \n\t * Variant of addInitialModule for cases in which no initial module main class is supplied.\n\t * Supplied values are used to build java's '-m' argument. \n\t * @param initialModuleName is the name of the initial module, eg, \"com.test\"\n\t * @return an updated Java process definition.\n\t * @throws StfException\n\t */\n\tpublic JavaProcessDefinition addInitialModule(String initialModuleName)  throws StfException {\n\t\tcheckAndUpdateLevel(Stage.MODULE);\n\t\t\n\t\tthis.initialModuleName = initialModuleName;\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds the bin directory of a project to the classpath.\n\t * The project is searched for in the test-root locations.\n\t * @param projectName is the name of the project to be added, or null if there is no project to add.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the bin directory of the named project does not exist\n\t * or if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addProjectToClasspath(String projectName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tif (projectName != null) {\n\t\t\tDirectoryRef projectBinDir = environmentCore.findTestDirectory((projectName + \"/bin\"));\n\t\t\tclasspathEntries.add(projectBinDir.getSpec());\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * This enumeration lists the known jar files which can be added to the classpath.\n\t * We remove \"/systemtest-prereqs\" from the start of each argument so we can search\n\t * each prereq location for these jars later.\n\t */\n\tpublic enum JarId {\n\t\tJUNIT(StfCoreExtension.ARG_JUNIT_JAR),\n\t\tHAMCREST(StfCoreExtension.ARG_HAMCREST_CORE_JAR),\n\t\tLOG4J_API(StfCoreExtension.ARG_LOG4J_API_JAR),\n\t\tLOG4J_CORE(StfCoreExtension.ARG_LOG4J_CORE_JAR),\n\t\tASM(StfCoreExtension.ARG_ASM_JAR),\n\t\tASM_COMMONS(StfCoreExtension.ARG_ASM_COMMONS_JAR);\n\t\t\n\t\tprivate Argument jarLocation;\n\t\tprivate JarId(Argument jarLocation) { this.jarLocation = jarLocation; }\n\t\tpublic Argument getArgument() { return jarLocation; }\n\t}\n\t\n\t\n\t/**\n\t * Adds a known systemtest-prereq jar to the classpath.\n\t * These are jar files held in one of the systemtest-prereqs locations, and are referenced by the JarId enumeration. \n\t * See stf.core.properties for the default values. \n\t * @param jarId refers to the jar to be added.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the jar file does not exist.\n\t */\n\tpublic JavaProcessDefinition addPrereqJarToClasspath(JarId jarId) throws StfException {\n\t\t// Find out where the jar file lives.\n\t\tString relativeJarLocation = environmentCore.getProperty(jarId.getArgument()).replace(\"/systemtest-prereqs/\", \"\");\n\t\tFileRef jarFileRef = environmentCore.findPrereqFile(relativeJarLocation);\n\t\t\n\t\tif (!jarFileRef.asJavaFile().exists()) {\n\t\t\tthrow new StfException(\"Jar file does not exist: \" + jarFileRef.getSpec());\n\t\t}\n\t\t\n\t\treturn addJarToClasspath(jarFileRef);\n\t}\n\n\t\n\t/**\n\t * Adds a jar file to the classpath.\n\t * The jar file is not checked to make sure it exists, as it may not be \n\t * available until run time.\n\t * @param jarReference is a FileReference pointing at the jar file to add to the classpath.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addJarToClasspath(FileRef jarReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);"
    },
    "240": {
      "metadata": {
        "chunk_id": "45efc7eface62aabe40573b030527564d5675d5cc5ec6387e3856738dfe66460",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "/**\n\t * Adds a jar file to the classpath.\n\t * The jar file is not checked to make sure it exists, as it may not be \n\t * available until run time.\n\t * @param jarReference is a FileReference pointing at the jar file to add to the classpath.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addJarToClasspath(FileRef jarReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\n\t\tclasspathEntries.add(jarReference.getSpec());\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a directory to the classpath.\n\t * @param directoryReference is a DirectoryRef pointing at the directory to add to the classpath.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the directory does not exist or if this method \n\t * is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addDirectoryToClasspath(DirectoryRef directoryReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tclasspathEntries.add(directoryReference.getSpec());\n\t\treturn this;\n\t}\n\n\tprivate void validateDirectoryExists(DirectoryRef directory, String failureMessage) throws StfException {\n\t\tif (!directory.asJavaFile().exists()) {\n\t\t\tthrow new StfException(failureMessage + \". Directory does not exist: \" + directory.getSpec());\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Specifies the name of an executable jar file.\n\t * Results in the Java process being executed with a '-jar <jarname.jar>' argument.\n\t * If an executable jar is specified then 'runClass' cannot be called.\n\t *  \n\t * @param executableJar is a reference to the excutable jar file.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the executable jar has already been set or if an application\n\t * argument has already been set.\n\t */\n\tpublic JavaProcessDefinition setExecutableJar(FileRef executableJar) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASS);\n\t\t\n\t\tif (this.executableJar != null) {\n\t\t\tthrow new StfException(\"Can't set executable jar to '\" + executableJar +\"', as already set to '\" + this.executableJar +\"'\");\n\t\t}\n\n\t\tthis.executableJar = executableJar.getSpec();\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Declares the class to be run for this java process. \n\t * @param javaClass is the class object that needs to be executed.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the class has already been set or an application \n\t * argument has already been set.\n\t */\n\tpublic JavaProcessDefinition runClass(Class<?> javaClass) throws StfException {\n\t\treturn runClass(javaClass.getName());\n\t}\n\n\t\n\t/**\n\t * Declares the class to be run for this java process.\n\t * This variant should only be used in cases in which the java class is not\n\t * known at compile time. If at all possible the runClass(Class<?>) method should used.  \n\t * @param javaClass is the class object that needs to be executed.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the class has already been set or if an application argument \n\t * has already been set.\n\t */\n\tpublic JavaProcessDefinition runClass(String javaClassName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASS);\n\n\t\tif (this.javaClassName != null) {\n\t\t\tthrow new StfException(\"Can't set java class to '\" + javaClassName +\"', as already set to '\" + this.javaClassName +\"'\");\n\t\t}\n\t\t\n\t\tthis.javaClassName = javaClassName;\n\t\t\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Adds a argument value to the Java invocation.\n\t * Arguments are normally added singly, but where a set of related arguments need \n\t * to be passed then they can all be supplied in a single addArg() call.\n\t * @param args is one or more arguments to be passed to the java class.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addArg(String... args) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.APPLICATION_ARGS);",
        "start_line": 626,
        "end_line": 728,
        "chunk_index": 7,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 921,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197814"
      },
      "text": "/**\n\t * Adds a jar file to the classpath.\n\t * The jar file is not checked to make sure it exists, as it may not be \n\t * available until run time.\n\t * @param jarReference is a FileReference pointing at the jar file to add to the classpath.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addJarToClasspath(FileRef jarReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\n\t\tclasspathEntries.add(jarReference.getSpec());\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds a directory to the classpath.\n\t * @param directoryReference is a DirectoryRef pointing at the directory to add to the classpath.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the directory does not exist or if this method \n\t * is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addDirectoryToClasspath(DirectoryRef directoryReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tclasspathEntries.add(directoryReference.getSpec());\n\t\treturn this;\n\t}\n\n\tprivate void validateDirectoryExists(DirectoryRef directory, String failureMessage) throws StfException {\n\t\tif (!directory.asJavaFile().exists()) {\n\t\t\tthrow new StfException(failureMessage + \". Directory does not exist: \" + directory.getSpec());\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Specifies the name of an executable jar file.\n\t * Results in the Java process being executed with a '-jar <jarname.jar>' argument.\n\t * If an executable jar is specified then 'runClass' cannot be called.\n\t *  \n\t * @param executableJar is a reference to the excutable jar file.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the executable jar has already been set or if an application\n\t * argument has already been set.\n\t */\n\tpublic JavaProcessDefinition setExecutableJar(FileRef executableJar) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASS);\n\t\t\n\t\tif (this.executableJar != null) {\n\t\t\tthrow new StfException(\"Can't set executable jar to '\" + executableJar +\"', as already set to '\" + this.executableJar +\"'\");\n\t\t}\n\n\t\tthis.executableJar = executableJar.getSpec();\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Declares the class to be run for this java process. \n\t * @param javaClass is the class object that needs to be executed.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the class has already been set or an application \n\t * argument has already been set.\n\t */\n\tpublic JavaProcessDefinition runClass(Class<?> javaClass) throws StfException {\n\t\treturn runClass(javaClass.getName());\n\t}\n\n\t\n\t/**\n\t * Declares the class to be run for this java process.\n\t * This variant should only be used in cases in which the java class is not\n\t * known at compile time. If at all possible the runClass(Class<?>) method should used.  \n\t * @param javaClass is the class object that needs to be executed.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if the class has already been set or if an application argument \n\t * has already been set.\n\t */\n\tpublic JavaProcessDefinition runClass(String javaClassName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASS);\n\n\t\tif (this.javaClassName != null) {\n\t\t\tthrow new StfException(\"Can't set java class to '\" + javaClassName +\"', as already set to '\" + this.javaClassName +\"'\");\n\t\t}\n\t\t\n\t\tthis.javaClassName = javaClassName;\n\t\t\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Adds a argument value to the Java invocation.\n\t * Arguments are normally added singly, but where a set of related arguments need \n\t * to be passed then they can all be supplied in a single addArg() call.\n\t * @param args is one or more arguments to be passed to the java class.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addArg(String... args) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.APPLICATION_ARGS);"
    },
    "241": {
      "metadata": {
        "chunk_id": "c5c97952bdaf989b340e5b2b8a9935e8db98f6ed34d85597bc75794044ba3a82",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "if (this.javaClassName != null) {\n\t\t\tthrow new StfException(\"Can't set java class to '\" + javaClassName +\"', as already set to '\" + this.javaClassName +\"'\");\n\t\t}\n\t\t\n\t\tthis.javaClassName = javaClassName;\n\t\t\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Adds a argument value to the Java invocation.\n\t * Arguments are normally added singly, but where a set of related arguments need \n\t * to be passed then they can all be supplied in a single addArg() call.\n\t * @param args is one or more arguments to be passed to the java class.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addArg(String... args) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.APPLICATION_ARGS);\n\n\t\tfor (String arg : args) {\n\t\t\tif (!arg.isEmpty()) {\n\t\t\t\tthis.javaArgs.add(arg);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Convenience method which adds one or more FileRef objects as an argument.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addArg(FileRef... files) throws StfException {\n\t\tfor (FileRef file : files) {\n\t\t\taddArg(file.getSpec());\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Adds another process' perl variable to the Java invocation as an argument value, plus a suffix that tells it to return data we want.\n\t * @param process is the StfProcess object whose data we want.\n\t * @param perlProcessDataIndex is the number of the Perl process variable add-on that returns the data we want. \n\t *                             e.g. Passing 1 would result in \"$processVariableName->{pid}\", which would tell the \n\t *                             perl variable representing a process to return the process id.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence, or if that perlProcessDataKey doesn't exist inside \n\t * \t\t\t\t\t\tthe PERL_PROCESS_DATA constant HashMap.\n\t */\n\tpublic JavaProcessDefinition addPerlProcessData(StfProcess process, Integer perlProcessDataKey) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.APPLICATION_ARGS);\n\n\t\tif (process != null) {\n\t\t\t//First we check to see if this a\n\t\t\tif (!StfConstants.PERL_PROCESS_DATA.containsKey(perlProcessDataKey)) {\n\t\t\t\tthrow new StfException(\"PERL_PROCESS_DATA does not contain key \" + perlProcessDataKey);\n\t\t\t}\n\t\t\t//Then we add this process to the list of processes.\n\t\t\tString processKey = \"Nonconstant_Placeholder_For_Perl_Code_That_Retrieves_Process_Data\" + this.relatedProcesses.size() + \";\";\n\t\t\tthis.relatedProcesses.put(processKey,process); \n\t\t\tthis.relatedProcessesData.put(processKey, perlProcessDataKey);\n\t\t\t//Then we add a placeholder to the list of arguments, to retain the correct argument order.\n\t\t\taddArg(processKey);\n\t\t}\n\t\t\n\t\treturn this;\n\t}",
        "start_line": 729,
        "end_line": 800,
        "chunk_index": 8,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 674,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197816"
      },
      "text": "if (this.javaClassName != null) {\n\t\t\tthrow new StfException(\"Can't set java class to '\" + javaClassName +\"', as already set to '\" + this.javaClassName +\"'\");\n\t\t}\n\t\t\n\t\tthis.javaClassName = javaClassName;\n\t\t\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Adds a argument value to the Java invocation.\n\t * Arguments are normally added singly, but where a set of related arguments need \n\t * to be passed then they can all be supplied in a single addArg() call.\n\t * @param args is one or more arguments to be passed to the java class.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addArg(String... args) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.APPLICATION_ARGS);\n\n\t\tfor (String arg : args) {\n\t\t\tif (!arg.isEmpty()) {\n\t\t\t\tthis.javaArgs.add(arg);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Convenience method which adds one or more FileRef objects as an argument.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence.\n\t */\n\tpublic JavaProcessDefinition addArg(FileRef... files) throws StfException {\n\t\tfor (FileRef file : files) {\n\t\t\taddArg(file.getSpec());\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Adds another process' perl variable to the Java invocation as an argument value, plus a suffix that tells it to return data we want.\n\t * @param process is the StfProcess object whose data we want.\n\t * @param perlProcessDataIndex is the number of the Perl process variable add-on that returns the data we want. \n\t *                             e.g. Passing 1 would result in \"$processVariableName->{pid}\", which would tell the \n\t *                             perl variable representing a process to return the process id.\n\t * @return the updated JavaProcessDefinition.\n\t * @throws StfException if this method is called out of sequence, or if that perlProcessDataKey doesn't exist inside \n\t * \t\t\t\t\t\tthe PERL_PROCESS_DATA constant HashMap.\n\t */\n\tpublic JavaProcessDefinition addPerlProcessData(StfProcess process, Integer perlProcessDataKey) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.APPLICATION_ARGS);\n\n\t\tif (process != null) {\n\t\t\t//First we check to see if this a\n\t\t\tif (!StfConstants.PERL_PROCESS_DATA.containsKey(perlProcessDataKey)) {\n\t\t\t\tthrow new StfException(\"PERL_PROCESS_DATA does not contain key \" + perlProcessDataKey);\n\t\t\t}\n\t\t\t//Then we add this process to the list of processes.\n\t\t\tString processKey = \"Nonconstant_Placeholder_For_Perl_Code_That_Retrieves_Process_Data\" + this.relatedProcesses.size() + \";\";\n\t\t\tthis.relatedProcesses.put(processKey,process); \n\t\t\tthis.relatedProcessesData.put(processKey, perlProcessDataKey);\n\t\t\t//Then we add a placeholder to the list of arguments, to retain the correct argument order.\n\t\t\taddArg(processKey);\n\t\t}\n\t\t\n\t\treturn this;\n\t}"
    },
    "242": {
      "metadata": {
        "chunk_id": "77dac460f06ac122688325af605dee3124ef04cc3427c7acf8d581bd39fb0e68",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "if (process != null) {\n\t\t\t//First we check to see if this a\n\t\t\tif (!StfConstants.PERL_PROCESS_DATA.containsKey(perlProcessDataKey)) {\n\t\t\t\tthrow new StfException(\"PERL_PROCESS_DATA does not contain key \" + perlProcessDataKey);\n\t\t\t}\n\t\t\t//Then we add this process to the list of processes.\n\t\t\tString processKey = \"Nonconstant_Placeholder_For_Perl_Code_That_Retrieves_Process_Data\" + this.relatedProcesses.size() + \";\";\n\t\t\tthis.relatedProcesses.put(processKey,process); \n\t\t\tthis.relatedProcessesData.put(processKey, perlProcessDataKey);\n\t\t\t//Then we add a placeholder to the list of arguments, to retain the correct argument order.\n\t\t\taddArg(processKey);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return the full path to java, as this process definition class can only run java.\n\t * This may use the standard JAVA_HOME or a custom runtime image.\n\t * @throws StfException \n\t */\n\tpublic String getCommand() throws StfException {\n\t\tDirectoryRef javaHome;\n\t\tif (this.runtimeImage == null) {\n\t\t\tjavaHome = environmentCore.createDirectoryRef(jvm.getJavaHome());\n\t\t} else {\n\t\t\tjavaHome = runtimeImage;  // use a jlink image\n\t\t}\n\t\t\n\t\t// Create the command using the full path to Java\n\t\treturn javaHome.childFile(\"bin/java\").getSpec();\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn this.relatedProcesses;\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn this.relatedProcessesData;\n\t}\n\n\t\n\t/**\n\t * Call this when all options, jars, arguments, etc have been added and it \n\t * will build all lines of the java command with the logically correct ordering.\n\t * @return an array list of Strings with the values needed to run java.\n\t * @throws StfException if the java class to run hasn't been specified.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\t// Sanity check jar/classpath type settings\n\t\tif (javaClassName != null && executableJar != null) {\n\t\t\tthrow new StfException(\"Can't run as both Java class and executable jar have been specified\");\n\t\t} else if (executableJar != null && classpathEntries.size() > 0) {\n\t\t\tthrow new StfException(\"Running an excutable jar, therefore classpath entries cannot be specified (JVM ignores them)\");\n\t\t}\n\t\n\t\t// Add JVM arguments\n\t\tArrayList<String> allArgs = new ArrayList<String>();\n\t\tallArgs.addAll(jvmOptions);\n\n\t\t// --add-reads\n\t\t// Emit optional addReads option, for classpath/modulepath compatibilty\n\t\tif (moduleAddReadsDefinition != null) {\n\t\t\tallArgs.add(\"--add-reads \" + moduleAddReadsDefinition);\n\t\t}\n\n\t\t// --module-path\n\t\tString modulepath = concatenateStrings(modulepathEntries, File.pathSeparatorChar);\n\t\tif (!modulepath.isEmpty()) {\n\t\t\tallArgs.add(\"--module-path\");\n\t\t\tallArgs.add(modulepath);\n\t\t}\n\t\t\n\t\t// --upgrade-module-path\n\t\t// To upgrade modules in the runtime image\n\t\tString upgradeModulepath = concatenateStrings(upgradeModulepathEntries, File.pathSeparatorChar);\n\t\tif (!upgradeModulepath.isEmpty()) {\n\t\t\tallArgs.add(\"--upgrade-module-path\");\n\t\t\tallArgs.add(upgradeModulepath);\n\t\t}\n\t\t\n\t\t// --add-modules\n\t\t// To specify root modules\n\t\tString rootModuleSpec = concatenateStrings(rootModules, ',');\n\t\tif (!rootModuleSpec.isEmpty()) {\n\t\t\tallArgs.add(\"--add-modules=\" + rootModuleSpec);\n\t\t}",
        "start_line": 801,
        "end_line": 898,
        "chunk_index": 9,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 924,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197818"
      },
      "text": "if (process != null) {\n\t\t\t//First we check to see if this a\n\t\t\tif (!StfConstants.PERL_PROCESS_DATA.containsKey(perlProcessDataKey)) {\n\t\t\t\tthrow new StfException(\"PERL_PROCESS_DATA does not contain key \" + perlProcessDataKey);\n\t\t\t}\n\t\t\t//Then we add this process to the list of processes.\n\t\t\tString processKey = \"Nonconstant_Placeholder_For_Perl_Code_That_Retrieves_Process_Data\" + this.relatedProcesses.size() + \";\";\n\t\t\tthis.relatedProcesses.put(processKey,process); \n\t\t\tthis.relatedProcessesData.put(processKey, perlProcessDataKey);\n\t\t\t//Then we add a placeholder to the list of arguments, to retain the correct argument order.\n\t\t\taddArg(processKey);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return the full path to java, as this process definition class can only run java.\n\t * This may use the standard JAVA_HOME or a custom runtime image.\n\t * @throws StfException \n\t */\n\tpublic String getCommand() throws StfException {\n\t\tDirectoryRef javaHome;\n\t\tif (this.runtimeImage == null) {\n\t\t\tjavaHome = environmentCore.createDirectoryRef(jvm.getJavaHome());\n\t\t} else {\n\t\t\tjavaHome = runtimeImage;  // use a jlink image\n\t\t}\n\t\t\n\t\t// Create the command using the full path to Java\n\t\treturn javaHome.childFile(\"bin/java\").getSpec();\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn this.relatedProcesses;\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn this.relatedProcessesData;\n\t}\n\n\t\n\t/**\n\t * Call this when all options, jars, arguments, etc have been added and it \n\t * will build all lines of the java command with the logically correct ordering.\n\t * @return an array list of Strings with the values needed to run java.\n\t * @throws StfException if the java class to run hasn't been specified.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\t// Sanity check jar/classpath type settings\n\t\tif (javaClassName != null && executableJar != null) {\n\t\t\tthrow new StfException(\"Can't run as both Java class and executable jar have been specified\");\n\t\t} else if (executableJar != null && classpathEntries.size() > 0) {\n\t\t\tthrow new StfException(\"Running an excutable jar, therefore classpath entries cannot be specified (JVM ignores them)\");\n\t\t}\n\t\n\t\t// Add JVM arguments\n\t\tArrayList<String> allArgs = new ArrayList<String>();\n\t\tallArgs.addAll(jvmOptions);\n\n\t\t// --add-reads\n\t\t// Emit optional addReads option, for classpath/modulepath compatibilty\n\t\tif (moduleAddReadsDefinition != null) {\n\t\t\tallArgs.add(\"--add-reads \" + moduleAddReadsDefinition);\n\t\t}\n\n\t\t// --module-path\n\t\tString modulepath = concatenateStrings(modulepathEntries, File.pathSeparatorChar);\n\t\tif (!modulepath.isEmpty()) {\n\t\t\tallArgs.add(\"--module-path\");\n\t\t\tallArgs.add(modulepath);\n\t\t}\n\t\t\n\t\t// --upgrade-module-path\n\t\t// To upgrade modules in the runtime image\n\t\tString upgradeModulepath = concatenateStrings(upgradeModulepathEntries, File.pathSeparatorChar);\n\t\tif (!upgradeModulepath.isEmpty()) {\n\t\t\tallArgs.add(\"--upgrade-module-path\");\n\t\t\tallArgs.add(upgradeModulepath);\n\t\t}\n\t\t\n\t\t// --add-modules\n\t\t// To specify root modules\n\t\tString rootModuleSpec = concatenateStrings(rootModules, ',');\n\t\tif (!rootModuleSpec.isEmpty()) {\n\t\t\tallArgs.add(\"--add-modules=\" + rootModuleSpec);\n\t\t}"
    },
    "243": {
      "metadata": {
        "chunk_id": "97066920e9d2aa3b17e882bb550e0be7eb83ce60e934f01803f7187560d9d37e",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "// --module-path\n\t\tString modulepath = concatenateStrings(modulepathEntries, File.pathSeparatorChar);\n\t\tif (!modulepath.isEmpty()) {\n\t\t\tallArgs.add(\"--module-path\");\n\t\t\tallArgs.add(modulepath);\n\t\t}\n\t\t\n\t\t// --upgrade-module-path\n\t\t// To upgrade modules in the runtime image\n\t\tString upgradeModulepath = concatenateStrings(upgradeModulepathEntries, File.pathSeparatorChar);\n\t\tif (!upgradeModulepath.isEmpty()) {\n\t\t\tallArgs.add(\"--upgrade-module-path\");\n\t\t\tallArgs.add(upgradeModulepath);\n\t\t}\n\t\t\n\t\t// --add-modules\n\t\t// To specify root modules\n\t\tString rootModuleSpec = concatenateStrings(rootModules, ',');\n\t\tif (!rootModuleSpec.isEmpty()) {\n\t\t\tallArgs.add(\"--add-modules=\" + rootModuleSpec);\n\t\t}\n\n\t\t// --limit-modules\n\t\t// To specify root modules\n\t\tString limitModuleSpec = concatenateStrings(limitModules, ',');\n\t\tif (!limitModuleSpec.isEmpty()) {\n\t\t\tallArgs.add(\"--limit-modules\");\n\t\t\tallArgs.add(limitModuleSpec);\n\t\t}\n\t\t\n\t\t// --add-exports <module>/<package>=<other-module>(,<other-module>)\n\t\tif (addExportsModule != null) {\n\t\t\tStringBuilder addExports = new StringBuilder();\n\t\t\taddExports.append(\"--add-exports \" + addExportsModule + \"/\" + addExportsPackage + \"=\");\n\t\t\taddExports.append(concatenateStrings(addExportsOtherModules, ','));\n\t\t\tallArgs.add(addExports.toString());\n\t\t}\n\t\t\t\t\t\n\t\t// --patch-module <module>=<file>(:<file>)\n\t\tfor (PatchModuleData patchModuleData : patchModules) {\n\t\t\tStringBuilder patchModule = new StringBuilder();\n\t\t\tpatchModule.append(\"--patch-module \" + patchModuleData.moduleName + \"=\");\n\t\t\tpatchModule.append(concatenateStrings(patchModuleData.patchDetails, File.pathSeparatorChar));\n\t\t\tallArgs.add(patchModule.toString());\n\t\t}\n\n\t\t// -m for initial module\n\t\tif (initialModuleName != null) {\n\t\t\tallArgs.add(\"-m\");\n\t\t\tif (initialModuleMainClass == null) {\n\t\t\t\tallArgs.add(initialModuleName);\n\t\t\t} else {\n\t\t\t\tallArgs.add(initialModuleName + \"/\" + initialModuleMainClass.getName());\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t// Add in the classpath\n\t\tString classpath = concatenateStrings(classpathEntries, File.pathSeparatorChar);\n\t\tif (!classpath.isEmpty()) {\n\t\t\tallArgs.add(\"-classpath\");\n\t\t\tallArgs.add(classpath);\n\t\t}\n\t\t\n\t\t// Add the class to run \n\t\tif (javaClassName != null && !javaClassName.isEmpty()) {\n\t\t\tallArgs.add(javaClassName);\n\t\t}\n\n\t\t// Optionally, specify the executable jar\n\t\tif (executableJar != null) {\n\t\t\tallArgs.add(\"-jar\");\n\t\t\tallArgs.add(executableJar);\n\t\t}\n\t\t\n\t\t// Finally, JVM arguments\n\t\tallArgs.addAll(javaArgs);\n\t\t\n\t\treturn allArgs;\n\t}\n\n\n\t// Joins multiple strings together to form classpath, etc\n\tprivate String concatenateStrings(ArrayList<String> classpathEntries, char separator) {\n\t\tStringBuilder formattedClasspath = new StringBuilder();\n\t\t\n\t\tfor (String entry : classpathEntries) {\n\t\t\tif (formattedClasspath.length() > 0) {\n\t\t\t\tformattedClasspath.append(separator);\n\t\t\t}\n\t\t\tformattedClasspath.append(entry);\n\t\t}\n\t\t\n\t\treturn formattedClasspath.toString();\n\t}\n\t\n\t\n\t/**\n\t * Not for normal use. \n\t * This method resets the internal state which tracks the last method used.\n\t * Prevents callers from building process invocations in an illogical order.\n\t * Only to be used by extensions which pre-populate a bare bones process definition.\n\t */\n\tpublic void resetStageChecking() { \n\t\toldStage = Stage.IMAGE;\n\t}",
        "start_line": 899,
        "end_line": 1004,
        "chunk_index": 10,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 786,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197820"
      },
      "text": "// --module-path\n\t\tString modulepath = concatenateStrings(modulepathEntries, File.pathSeparatorChar);\n\t\tif (!modulepath.isEmpty()) {\n\t\t\tallArgs.add(\"--module-path\");\n\t\t\tallArgs.add(modulepath);\n\t\t}\n\t\t\n\t\t// --upgrade-module-path\n\t\t// To upgrade modules in the runtime image\n\t\tString upgradeModulepath = concatenateStrings(upgradeModulepathEntries, File.pathSeparatorChar);\n\t\tif (!upgradeModulepath.isEmpty()) {\n\t\t\tallArgs.add(\"--upgrade-module-path\");\n\t\t\tallArgs.add(upgradeModulepath);\n\t\t}\n\t\t\n\t\t// --add-modules\n\t\t// To specify root modules\n\t\tString rootModuleSpec = concatenateStrings(rootModules, ',');\n\t\tif (!rootModuleSpec.isEmpty()) {\n\t\t\tallArgs.add(\"--add-modules=\" + rootModuleSpec);\n\t\t}\n\n\t\t// --limit-modules\n\t\t// To specify root modules\n\t\tString limitModuleSpec = concatenateStrings(limitModules, ',');\n\t\tif (!limitModuleSpec.isEmpty()) {\n\t\t\tallArgs.add(\"--limit-modules\");\n\t\t\tallArgs.add(limitModuleSpec);\n\t\t}\n\t\t\n\t\t// --add-exports <module>/<package>=<other-module>(,<other-module>)\n\t\tif (addExportsModule != null) {\n\t\t\tStringBuilder addExports = new StringBuilder();\n\t\t\taddExports.append(\"--add-exports \" + addExportsModule + \"/\" + addExportsPackage + \"=\");\n\t\t\taddExports.append(concatenateStrings(addExportsOtherModules, ','));\n\t\t\tallArgs.add(addExports.toString());\n\t\t}\n\t\t\t\t\t\n\t\t// --patch-module <module>=<file>(:<file>)\n\t\tfor (PatchModuleData patchModuleData : patchModules) {\n\t\t\tStringBuilder patchModule = new StringBuilder();\n\t\t\tpatchModule.append(\"--patch-module \" + patchModuleData.moduleName + \"=\");\n\t\t\tpatchModule.append(concatenateStrings(patchModuleData.patchDetails, File.pathSeparatorChar));\n\t\t\tallArgs.add(patchModule.toString());\n\t\t}\n\n\t\t// -m for initial module\n\t\tif (initialModuleName != null) {\n\t\t\tallArgs.add(\"-m\");\n\t\t\tif (initialModuleMainClass == null) {\n\t\t\t\tallArgs.add(initialModuleName);\n\t\t\t} else {\n\t\t\t\tallArgs.add(initialModuleName + \"/\" + initialModuleMainClass.getName());\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t// Add in the classpath\n\t\tString classpath = concatenateStrings(classpathEntries, File.pathSeparatorChar);\n\t\tif (!classpath.isEmpty()) {\n\t\t\tallArgs.add(\"-classpath\");\n\t\t\tallArgs.add(classpath);\n\t\t}\n\t\t\n\t\t// Add the class to run \n\t\tif (javaClassName != null && !javaClassName.isEmpty()) {\n\t\t\tallArgs.add(javaClassName);\n\t\t}\n\n\t\t// Optionally, specify the executable jar\n\t\tif (executableJar != null) {\n\t\t\tallArgs.add(\"-jar\");\n\t\t\tallArgs.add(executableJar);\n\t\t}\n\t\t\n\t\t// Finally, JVM arguments\n\t\tallArgs.addAll(javaArgs);\n\t\t\n\t\treturn allArgs;\n\t}\n\n\n\t// Joins multiple strings together to form classpath, etc\n\tprivate String concatenateStrings(ArrayList<String> classpathEntries, char separator) {\n\t\tStringBuilder formattedClasspath = new StringBuilder();\n\t\t\n\t\tfor (String entry : classpathEntries) {\n\t\t\tif (formattedClasspath.length() > 0) {\n\t\t\t\tformattedClasspath.append(separator);\n\t\t\t}\n\t\t\tformattedClasspath.append(entry);\n\t\t}\n\t\t\n\t\treturn formattedClasspath.toString();\n\t}\n\t\n\t\n\t/**\n\t * Not for normal use. \n\t * This method resets the internal state which tracks the last method used.\n\t * Prevents callers from building process invocations in an illogical order.\n\t * Only to be used by extensions which pre-populate a bare bones process definition.\n\t */\n\tpublic void resetStageChecking() { \n\t\toldStage = Stage.IMAGE;\n\t}"
    },
    "244": {
      "metadata": {
        "chunk_id": "e3d6a301478d71b94c4cb36c238dcf79af99a1e5439242ee42519cf972edfa49",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JavaProcessDefinition.java",
        "content": "// Joins multiple strings together to form classpath, etc\n\tprivate String concatenateStrings(ArrayList<String> classpathEntries, char separator) {\n\t\tStringBuilder formattedClasspath = new StringBuilder();\n\t\t\n\t\tfor (String entry : classpathEntries) {\n\t\t\tif (formattedClasspath.length() > 0) {\n\t\t\t\tformattedClasspath.append(separator);\n\t\t\t}\n\t\t\tformattedClasspath.append(entry);\n\t\t}\n\t\t\n\t\treturn formattedClasspath.toString();\n\t}\n\t\n\t\n\t/**\n\t * Not for normal use. \n\t * This method resets the internal state which tracks the last method used.\n\t * Prevents callers from building process invocations in an illogical order.\n\t * Only to be used by extensions which pre-populate a bare bones process definition.\n\t */\n\tpublic void resetStageChecking() { \n\t\toldStage = Stage.IMAGE;\n\t}\n\n\n\t// Verifies that the addition method is not being called at the wrong time.\n\t// eg. throws exception if attempting to add to the classpath if the last\n\t// call was adding an application argument.\n\tprivate void checkAndUpdateLevel(Stage newStage) throws StfException {\n\t\t// Make sure calls not made out of sequence\n\t\tif (newStage.level < oldStage.level) { \n\t\t\tthrow new StfException(\"Java invocation built out of sequence. \" + newStage + \" cannot be set after \" + oldStage);\n\t\t}\n\t\t\n\t\t// Make sure the JVM supports the feature that is being specified\n\t\tint javaVersion = environmentCore.getJavaVersion();\n\t\tint requiredJavaVersion = newStage.minimumJVM;\n\t\tif (javaVersion < requiredJavaVersion) {\n\t\t\tthrow new StfException(\"Target JVM too old. \"\n\t\t\t\t\t+ \"Java module arguments are only available from java 9 onwards. \"\n\t\t\t\t\t+ \"Current JVM version: \" + javaVersion + \", but need minimum of version: \" + requiredJavaVersion + \" for: \" + newStage);\n\t\t}\n\t\t\n\t\toldStage = newStage;\n\t}\n\n\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) {\n\t}\n}",
        "start_line": 1005,
        "end_line": 1056,
        "chunk_index": 11,
        "total_chunks": 12,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 437,
        "node_type": null,
        "file_sha": "759e0cc361309f0a4b452ff44a2a91fb6ef7d33f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.197823"
      },
      "text": "// Joins multiple strings together to form classpath, etc\n\tprivate String concatenateStrings(ArrayList<String> classpathEntries, char separator) {\n\t\tStringBuilder formattedClasspath = new StringBuilder();\n\t\t\n\t\tfor (String entry : classpathEntries) {\n\t\t\tif (formattedClasspath.length() > 0) {\n\t\t\t\tformattedClasspath.append(separator);\n\t\t\t}\n\t\t\tformattedClasspath.append(entry);\n\t\t}\n\t\t\n\t\treturn formattedClasspath.toString();\n\t}\n\t\n\t\n\t/**\n\t * Not for normal use. \n\t * This method resets the internal state which tracks the last method used.\n\t * Prevents callers from building process invocations in an illogical order.\n\t * Only to be used by extensions which pre-populate a bare bones process definition.\n\t */\n\tpublic void resetStageChecking() { \n\t\toldStage = Stage.IMAGE;\n\t}\n\n\n\t// Verifies that the addition method is not being called at the wrong time.\n\t// eg. throws exception if attempting to add to the classpath if the last\n\t// call was adding an application argument.\n\tprivate void checkAndUpdateLevel(Stage newStage) throws StfException {\n\t\t// Make sure calls not made out of sequence\n\t\tif (newStage.level < oldStage.level) { \n\t\t\tthrow new StfException(\"Java invocation built out of sequence. \" + newStage + \" cannot be set after \" + oldStage);\n\t\t}\n\t\t\n\t\t// Make sure the JVM supports the feature that is being specified\n\t\tint javaVersion = environmentCore.getJavaVersion();\n\t\tint requiredJavaVersion = newStage.minimumJVM;\n\t\tif (javaVersion < requiredJavaVersion) {\n\t\t\tthrow new StfException(\"Target JVM too old. \"\n\t\t\t\t\t+ \"Java module arguments are only available from java 9 onwards. \"\n\t\t\t\t\t+ \"Current JVM version: \" + javaVersion + \", but need minimum of version: \" + requiredJavaVersion + \" for: \" + newStage);\n\t\t}\n\t\t\n\t\toldStage = newStage;\n\t}\n\n\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) {\n\t}\n}"
    },
    "245": {
      "metadata": {
        "chunk_id": "2dddfa03598e96127d15f9a200217bb2044e88d8062dfe7504cb60e87f041862",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport static net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.REQUIREMENT.OPTIONAL;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArgCollection;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.ARG_TYPE;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArgCollection.Stage;\n\n\n/**\n * This class helps to build jlink commands for the following version of jlink:\n * \n *   $ jlink --help\n *   Usage: jlink <options> --module-path <modulepath> --add-modules <mods> --output <path>\n *   Possible options include:\n *     --help                            Print this help message\n *     --module-path <modulepath>         Module path\n *     --limit-modules <mod>[,<mod>...]      Limit the universe of observable modules\n *     --add-modules <mod>[,<mod>...]        Root modules to resolve\n *     --output <path>                   Location of output path\n *     --endian <little|big>             Byte order of generated jimage (default:native)\n *     --version                         Version information\n *     --save-opts <filename>             Save jlink options in the given file\n *     -G, --strip-debug                 Strip debug information\n *     -c, --compress=2                  Enable compression of resources (level 2)\n *     --plugin-module-path <modulepath> Custom plugins module path\n *     --list-plugins                    List available plugins\n *     @<filename>                       Read options from file\n *     \n *  There also some options described by '--list-plugins'.\n *  I've no idea why they do not appear under help but the don't.\n *  Option lines listed by 'list-plugins' follows:\n *  $ jlink --list-plugins\n *     --class-for-name\n *     --compress=<0|1|2>[:filter=<pattern>]\n *     --copy-files=<List of <file path>=<image target> to copy to the image>.\n *     --exclude-files=<files to exclude | files of excluded files>\n *     --exclude-resources=<resources to exclude | file of excluded resources>\n *     --include-locales=<langtag>[,<langtag>]*\n *     --installed-modules\n *     --order-resources=<pattern-list> of paths in priority order\n *     --strip-debug\n *     --strip-native-commands\n *     --vm=<client|server|minimal|all>\n *     \n *     --release-info=<file>|add:<key1>=<value1>:<key2>=<value2>:...|del:<key list>\n */",
        "start_line": 0,
        "end_line": 72,
        "chunk_index": 0,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 818,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213254"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport static net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.REQUIREMENT.OPTIONAL;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArgCollection;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.ARG_TYPE;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArgCollection.Stage;\n\n\n/**\n * This class helps to build jlink commands for the following version of jlink:\n * \n *   $ jlink --help\n *   Usage: jlink <options> --module-path <modulepath> --add-modules <mods> --output <path>\n *   Possible options include:\n *     --help                            Print this help message\n *     --module-path <modulepath>         Module path\n *     --limit-modules <mod>[,<mod>...]      Limit the universe of observable modules\n *     --add-modules <mod>[,<mod>...]        Root modules to resolve\n *     --output <path>                   Location of output path\n *     --endian <little|big>             Byte order of generated jimage (default:native)\n *     --version                         Version information\n *     --save-opts <filename>             Save jlink options in the given file\n *     -G, --strip-debug                 Strip debug information\n *     -c, --compress=2                  Enable compression of resources (level 2)\n *     --plugin-module-path <modulepath> Custom plugins module path\n *     --list-plugins                    List available plugins\n *     @<filename>                       Read options from file\n *     \n *  There also some options described by '--list-plugins'.\n *  I've no idea why they do not appear under help but the don't.\n *  Option lines listed by 'list-plugins' follows:\n *  $ jlink --list-plugins\n *     --class-for-name\n *     --compress=<0|1|2>[:filter=<pattern>]\n *     --copy-files=<List of <file path>=<image target> to copy to the image>.\n *     --exclude-files=<files to exclude | files of excluded files>\n *     --exclude-resources=<resources to exclude | file of excluded resources>\n *     --include-locales=<langtag>[,<langtag>]*\n *     --installed-modules\n *     --order-resources=<pattern-list> of paths in priority order\n *     --strip-debug\n *     --strip-native-commands\n *     --vm=<client|server|minimal|all>\n *     \n *     --release-info=<file>|add:<key1>=<value1>:<key2>=<value2>:...|del:<key list>\n */"
    },
    "246": {
      "metadata": {
        "chunk_id": "87deb954dcca7a5751747141af652884a14e7e24f1c3140f2efad90edbe85a8e",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "public class JlinkDefinition implements ProcessDefinition {\n\tprivate static StfEnvironmentCore environmentCore;\n\n\t// All arguments are in a single stage. Java 9 and beyond is required\n\tprivate Stage argStage = new ProcessArgCollection.Stage(\"jlinkArguments\", 1, 9);",
        "start_line": 73,
        "end_line": 77,
        "chunk_index": 1,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 57,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213265"
      },
      "text": "public class JlinkDefinition implements ProcessDefinition {\n\tprivate static StfEnvironmentCore environmentCore;\n\n\t// All arguments are in a single stage. Java 9 and beyond is required\n\tprivate Stage argStage = new ProcessArgCollection.Stage(\"jlinkArguments\", 1, 9);"
    },
    "247": {
      "metadata": {
        "chunk_id": "a324db6c25fd5cf4fd00f331bf1b0cba4d120722343548a352f598c1c9184456",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "// All arguments are in a single stage. Java 9 and beyond is required\n\tprivate Stage argStage = new ProcessArgCollection.Stage(\"jlinkArguments\", 1, 9);\n\n\t// Define the arguments which jlink commands accept\n\tProcessArg helpArg                = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"help\",                  \"--help\");\n\tProcessArg modulepathArg          = new ProcessArg(ARG_TYPE.PATH,       \" \",          \"\",  OPTIONAL,  \"modulepath\",            \"--module-path\");\n\tProcessArg limitmodsArg           = new ProcessArg(ARG_TYPE.MULTI_VAL,  \" \",          \",\", OPTIONAL,  \"limitmods\",             \"--limit-modules\");\n\tProcessArg addmodsArg             = new ProcessArg(ARG_TYPE.MULTI_VAL,  \" \",          \",\", OPTIONAL,  \"addmods\",               \"--add-modules\");\n\tProcessArg outputArg              = new ProcessArg(ARG_TYPE.DIR,        \" \",          \"\",  OPTIONAL,  \"output\",                \"--output\");\n\tProcessArg endianArg              = new ProcessArg(ARG_TYPE.STRING,     \" \",          \"\",  OPTIONAL,  \"endian\",                \"--endian\");\n\tProcessArg versionArg             = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"version\",               \"--version\");\n\tProcessArg saveoptsArg            = new ProcessArg(ARG_TYPE.STRING,     \" \",          \"\",  OPTIONAL,  \"saveopts\",              \"--save-opts\");\n\tProcessArg stripDebugArg          = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"strip-debug\",           \"--strip-debug\");\n\tProcessArg stripNativeCommandsArg = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"strip-native-commands\", \"--strip-native-commands\");\n\tProcessArg compressArg            = new ProcessArg(ARG_TYPE.STRING,     \"=\",          \"\",  OPTIONAL,  \"compress\",              \"--compress\");\n\tProcessArg pluginModulePathArg    = new ProcessArg(ARG_TYPE.PATH,       \" \",          \"\",  OPTIONAL,  \"plugin-module-path\",    \"--plugin-module-path\");\n\tProcessArg listPluginsArg         = new ProcessArg(ARG_TYPE.FLAG,       \" \",          \"\",  OPTIONAL,  \"list-plugins\",          \"--list-plugins\");\n\tProcessArg classForNameArg        = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"class-for-name\",        \"--class-for-name\");\n\tProcessArg copyFilesArg           = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"copy-files\",            \"--copy-files\");\n\tProcessArg excludeFilesArg        = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"exclude-files\",         \"--exclude-files\");\n\tProcessArg excludeResourcesArg    = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"exclude-resources\",     \"--exclude-resources\");\n\tProcessArg includeLocalesArg      = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"include-locales\",       \"--include-locales\");\n\tProcessArg installedModulesArg    = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"installed-modules\",     \"--installed-modules\");\n\tProcessArg orderResourcesArg      = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"order-resources\",       \"--order-resources\");\n\tProcessArg vmArg                  = new ProcessArg(ARG_TYPE.STRING,     \"=\",          \"\",  OPTIONAL,  \"vm\",                    \"--vm\");\n\tProcessArg releaseInfoFileArg     = new ProcessArg(ARG_TYPE.REPEAT_ARG, \"=\",          \"\",  OPTIONAL,  \"release-info\",          \"--release-info\");\n\tProcessArg releaseInfoAddArg      = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=add:\",      \":\", OPTIONAL,  \"release-info\",          \"--release-info\");\n\tProcessArg releaseInfoDelArg      = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=del:keys=\", \",\", OPTIONAL,  \"release-info\",          \"--release-info\");\n\t\n\tProcessArgCollection argCollection;\n\t\n\tString imageName;\n\tDirectoryRef imageDir;  // For cases in which the test decides on the output directory\n\tprivate int commandSerialNum;",
        "start_line": 78,
        "end_line": 111,
        "chunk_index": 2,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 882,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213270"
      },
      "text": "// All arguments are in a single stage. Java 9 and beyond is required\n\tprivate Stage argStage = new ProcessArgCollection.Stage(\"jlinkArguments\", 1, 9);\n\n\t// Define the arguments which jlink commands accept\n\tProcessArg helpArg                = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"help\",                  \"--help\");\n\tProcessArg modulepathArg          = new ProcessArg(ARG_TYPE.PATH,       \" \",          \"\",  OPTIONAL,  \"modulepath\",            \"--module-path\");\n\tProcessArg limitmodsArg           = new ProcessArg(ARG_TYPE.MULTI_VAL,  \" \",          \",\", OPTIONAL,  \"limitmods\",             \"--limit-modules\");\n\tProcessArg addmodsArg             = new ProcessArg(ARG_TYPE.MULTI_VAL,  \" \",          \",\", OPTIONAL,  \"addmods\",               \"--add-modules\");\n\tProcessArg outputArg              = new ProcessArg(ARG_TYPE.DIR,        \" \",          \"\",  OPTIONAL,  \"output\",                \"--output\");\n\tProcessArg endianArg              = new ProcessArg(ARG_TYPE.STRING,     \" \",          \"\",  OPTIONAL,  \"endian\",                \"--endian\");\n\tProcessArg versionArg             = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"version\",               \"--version\");\n\tProcessArg saveoptsArg            = new ProcessArg(ARG_TYPE.STRING,     \" \",          \"\",  OPTIONAL,  \"saveopts\",              \"--save-opts\");\n\tProcessArg stripDebugArg          = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"strip-debug\",           \"--strip-debug\");\n\tProcessArg stripNativeCommandsArg = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"strip-native-commands\", \"--strip-native-commands\");\n\tProcessArg compressArg            = new ProcessArg(ARG_TYPE.STRING,     \"=\",          \"\",  OPTIONAL,  \"compress\",              \"--compress\");\n\tProcessArg pluginModulePathArg    = new ProcessArg(ARG_TYPE.PATH,       \" \",          \"\",  OPTIONAL,  \"plugin-module-path\",    \"--plugin-module-path\");\n\tProcessArg listPluginsArg         = new ProcessArg(ARG_TYPE.FLAG,       \" \",          \"\",  OPTIONAL,  \"list-plugins\",          \"--list-plugins\");\n\tProcessArg classForNameArg        = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"class-for-name\",        \"--class-for-name\");\n\tProcessArg copyFilesArg           = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"copy-files\",            \"--copy-files\");\n\tProcessArg excludeFilesArg        = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"exclude-files\",         \"--exclude-files\");\n\tProcessArg excludeResourcesArg    = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"exclude-resources\",     \"--exclude-resources\");\n\tProcessArg includeLocalesArg      = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"include-locales\",       \"--include-locales\");\n\tProcessArg installedModulesArg    = new ProcessArg(ARG_TYPE.FLAG,       \"\",           \"\",  OPTIONAL,  \"installed-modules\",     \"--installed-modules\");\n\tProcessArg orderResourcesArg      = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=\",          \",\", OPTIONAL,  \"order-resources\",       \"--order-resources\");\n\tProcessArg vmArg                  = new ProcessArg(ARG_TYPE.STRING,     \"=\",          \"\",  OPTIONAL,  \"vm\",                    \"--vm\");\n\tProcessArg releaseInfoFileArg     = new ProcessArg(ARG_TYPE.REPEAT_ARG, \"=\",          \"\",  OPTIONAL,  \"release-info\",          \"--release-info\");\n\tProcessArg releaseInfoAddArg      = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=add:\",      \":\", OPTIONAL,  \"release-info\",          \"--release-info\");\n\tProcessArg releaseInfoDelArg      = new ProcessArg(ARG_TYPE.MULTI_VAL,  \"=del:keys=\", \",\", OPTIONAL,  \"release-info\",          \"--release-info\");\n\t\n\tProcessArgCollection argCollection;\n\t\n\tString imageName;\n\tDirectoryRef imageDir;  // For cases in which the test decides on the output directory\n\tprivate int commandSerialNum;"
    },
    "248": {
      "metadata": {
        "chunk_id": "7eff323b38dd528696beca846f7875e4316f23bbfab688b4a055917c06a1fc9c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "public JlinkDefinition() {\n\t\tthis.argCollection = new ProcessArgCollection(environmentCore, argStage,\n\t\t\t\thelpArg,            \n\t\t\t\tmodulepathArg,      \n\t\t\t\tlimitmodsArg,       \n\t\t\t\taddmodsArg,         \n\t\t\t\toutputArg,          \n\t\t\t\tendianArg,          \n\t\t\t\tversionArg,\n\t\t\t\tsaveoptsArg,        \n\t\t\t\tstripDebugArg,      \n\t\t\t\tstripNativeCommandsArg,\n\t\t\t\tcompressArg,        \n\t\t\t\tpluginModulePathArg,\n\t\t\t\tlistPluginsArg,\n\t\t\t\tclassForNameArg,\n\t\t\t\tcopyFilesArg,\n\t\t\t\texcludeFilesArg,\n\t\t\t\texcludeResourcesArg,\n\t\t\t\tincludeLocalesArg, \n\t\t\t\tinstalledModulesArg,\n\t\t\t\torderResourcesArg,\n\t\t\t\tvmArg,\n\t\t\t\treleaseInfoFileArg,\n\t\t\t\treleaseInfoAddArg,\n\t\t\t\treleaseInfoDelArg);\n\t}\n\n\t\n\t///////////////////////////  --help  ///////////////////////////\n\n\t/**\n\t * For '--help' argument.\n\t * Calling this method enables the inclusion of '--help' into the jlink command.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableHelp() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\thelpArg.setFlag(true);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --module-path <modulepath>  ///////////////////////////\n\t\n\t/**\n\t * For '--module-path <modulepath>' argument.\n\t * @param dir is 1 or more directories to add to the modulepath. \n\t * $JAVA_HOME/jmods is also added to the module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addDirectoryToModulePath(DirectoryRef... dirs) throws StfException {\n\t\tfor (DirectoryRef dir : dirs) {\n\t\t\taddToModulePath(dir.getSpec());\n\t\t}\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * For '--module-path <modulepath>' argument.\n\t * @param modularJar is a reference to 1 or more modular jar files.\n\t * $JAVA_HOME/jmods is also added to the module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModularJarToModulePath(FileRef... modularJars) throws StfException {\n\t\tfor (FileRef modularJar : modularJars) {\n\t\t\taddToModulePath(modularJar.getSpec());\n\t\t}\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * For '--module-path <modulepath>' argument.\n\t * @param module is 1 or more references to an existing module. The test may have created the module\n\t * by running doCreateJmod() or by creating a ModuleRef object for a pre-existing module.\n \t * $JAVA_HOME/jmods is also added to the module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToModulePath(ModuleRef... modules) throws StfException {\n\t\tfor (ModuleRef module : modules) {\n\t\t\tDirectoryRef parentDir = module.getJarFileRef().parent();\n\t\t\taddToModulePath(parentDir.getSpec());\n\t\t}\n\t\treturn this;\n\t}\n\n\t\n\tprivate void addToModulePath(String modulePathEntry) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.add(modulePathEntry);\n\t}\n\t    \n\n\t///////////////////////////  --limit-modules <mod>[,<mod>...]  ///////////////////////////\n\n\t/**\n\t * For '--limit-modules <mod>[,<mod>...]' argument.\n\t * @param module is a module to to be appended to the limitmods list.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToLimitmods(ModuleRef module) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tlimitmodsArg.add(module.getBaseName());\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --add-modules <mod>[,<mod>...]  ///////////////////////////\n\n\t/**\n\t * For '--add-modules <mod>[,<mod>...]' argument.\n\t * @param modules is 1 or more modules to to be appended to the addmods list.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToAddmods(ModuleRef... modules) throws StfException {\n\t\tfor (ModuleRef module : modules) {\n\t\t\targCollection.checkAndUpdateLevel(argStage);\n\t\t\taddmodsArg.add(module.getBaseName());\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --output <path>  ///////////////////////////",
        "start_line": 112,
        "end_line": 237,
        "chunk_index": 3,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 928,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213274"
      },
      "text": "public JlinkDefinition() {\n\t\tthis.argCollection = new ProcessArgCollection(environmentCore, argStage,\n\t\t\t\thelpArg,            \n\t\t\t\tmodulepathArg,      \n\t\t\t\tlimitmodsArg,       \n\t\t\t\taddmodsArg,         \n\t\t\t\toutputArg,          \n\t\t\t\tendianArg,          \n\t\t\t\tversionArg,\n\t\t\t\tsaveoptsArg,        \n\t\t\t\tstripDebugArg,      \n\t\t\t\tstripNativeCommandsArg,\n\t\t\t\tcompressArg,        \n\t\t\t\tpluginModulePathArg,\n\t\t\t\tlistPluginsArg,\n\t\t\t\tclassForNameArg,\n\t\t\t\tcopyFilesArg,\n\t\t\t\texcludeFilesArg,\n\t\t\t\texcludeResourcesArg,\n\t\t\t\tincludeLocalesArg, \n\t\t\t\tinstalledModulesArg,\n\t\t\t\torderResourcesArg,\n\t\t\t\tvmArg,\n\t\t\t\treleaseInfoFileArg,\n\t\t\t\treleaseInfoAddArg,\n\t\t\t\treleaseInfoDelArg);\n\t}\n\n\t\n\t///////////////////////////  --help  ///////////////////////////\n\n\t/**\n\t * For '--help' argument.\n\t * Calling this method enables the inclusion of '--help' into the jlink command.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableHelp() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\thelpArg.setFlag(true);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --module-path <modulepath>  ///////////////////////////\n\t\n\t/**\n\t * For '--module-path <modulepath>' argument.\n\t * @param dir is 1 or more directories to add to the modulepath. \n\t * $JAVA_HOME/jmods is also added to the module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addDirectoryToModulePath(DirectoryRef... dirs) throws StfException {\n\t\tfor (DirectoryRef dir : dirs) {\n\t\t\taddToModulePath(dir.getSpec());\n\t\t}\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * For '--module-path <modulepath>' argument.\n\t * @param modularJar is a reference to 1 or more modular jar files.\n\t * $JAVA_HOME/jmods is also added to the module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModularJarToModulePath(FileRef... modularJars) throws StfException {\n\t\tfor (FileRef modularJar : modularJars) {\n\t\t\taddToModulePath(modularJar.getSpec());\n\t\t}\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * For '--module-path <modulepath>' argument.\n\t * @param module is 1 or more references to an existing module. The test may have created the module\n\t * by running doCreateJmod() or by creating a ModuleRef object for a pre-existing module.\n \t * $JAVA_HOME/jmods is also added to the module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToModulePath(ModuleRef... modules) throws StfException {\n\t\tfor (ModuleRef module : modules) {\n\t\t\tDirectoryRef parentDir = module.getJarFileRef().parent();\n\t\t\taddToModulePath(parentDir.getSpec());\n\t\t}\n\t\treturn this;\n\t}\n\n\t\n\tprivate void addToModulePath(String modulePathEntry) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.add(modulePathEntry);\n\t}\n\t    \n\n\t///////////////////////////  --limit-modules <mod>[,<mod>...]  ///////////////////////////\n\n\t/**\n\t * For '--limit-modules <mod>[,<mod>...]' argument.\n\t * @param module is a module to to be appended to the limitmods list.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToLimitmods(ModuleRef module) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tlimitmodsArg.add(module.getBaseName());\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --add-modules <mod>[,<mod>...]  ///////////////////////////\n\n\t/**\n\t * For '--add-modules <mod>[,<mod>...]' argument.\n\t * @param modules is 1 or more modules to to be appended to the addmods list.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToAddmods(ModuleRef... modules) throws StfException {\n\t\tfor (ModuleRef module : modules) {\n\t\t\targCollection.checkAndUpdateLevel(argStage);\n\t\t\taddmodsArg.add(module.getBaseName());\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --output <path>  ///////////////////////////"
    },
    "249": {
      "metadata": {
        "chunk_id": "197046f8f27c03f170d8fd533c735aeda6bbdf543414b01035403254bf8cbd66",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "///////////////////////////  --add-modules <mod>[,<mod>...]  ///////////////////////////\n\n\t/**\n\t * For '--add-modules <mod>[,<mod>...]' argument.\n\t * @param modules is 1 or more modules to to be appended to the addmods list.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToAddmods(ModuleRef... modules) throws StfException {\n\t\tfor (ModuleRef module : modules) {\n\t\t\targCollection.checkAndUpdateLevel(argStage);\n\t\t\taddmodsArg.add(module.getBaseName());\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --output <path>  ///////////////////////////\n\n\t/**\n\t * For '--output <path>' argument.\n\t * @param imageName is a unique name for this image.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setOutput(String imageName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\t\n\t\tthis.imageName = imageName;\n\t\tString fullImageName = StfConstants.PLACEHOLDER_STF_COMMAND_NUMBER + \".\" + imageName;\n\t\tDirectoryRef imageDir = environmentCore.getTmpDir().childDirectory(fullImageName);\n\t\toutputArg.add(imageDir);\n\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * For '--output <path>' argument.\n\t * Allows the test to specify the output directory in which to create the image.\n\t * This method should only be used in cases in which the test really _must_ \n\t * have control over the output location. \n\t * In most cases it is best to let STF decide where to put the image. \n\t * @param dirName is a platform specific directory name where the image is to be created.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setOutputDirectory(String dirName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\t\n\t\tthis.imageName = dirName;\n\t\tthis.imageDir = environmentCore.createDirectoryRef(dirName);\n\t\toutputArg.add(imageDir);\n\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * @return a String containing the image name, as supplied to JlinkDefinition.setOutput()\n\t */\n\tpublic String getOutputImageName() {\n\t\treturn imageName;\n\t}\n\n\t\n\t/**\n\t * @return the directory in which STF has created the jlinked image.\n\t * @throws StfException \n\t */\n\tpublic DirectoryRef getOutputImageDir() throws StfException {\n\t\tif (imageDir != null) {\n\t\t\t// Special case for explicitly set output directory\n\t\t\treturn imageDir;\n\t\t}\n\n\t\tString actualImageName = Integer.toString(commandSerialNum) + \".\" + imageName;\n\t\treturn environmentCore.getTmpDir().childDirectory(actualImageName);\n\t}\n\n\n\t/**\n\t * @returns true if this JlinkDefinition has been told to create it's image at\n\t * a particular location. \n\t */\n\tpublic boolean usingCustomOuputImageDir() {\n\t\treturn imageDir != null;\n\t}\n\n\t\n\t///////////////////////////  --endian <little|big>  ///////////////////////////\n\n\t/**\n\t * For '--endian <little|big>' argument.\n\t * Calling this method forces output to little endian.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setEndianToLittle() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tendianArg.add(\"little\");\n\t\treturn this;\n\t}\n\n\t/**\n\t * For '--endian <little|big>' argument.\n\t * Calling this method forces output to big endian.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setEndianToBig() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tendianArg.add(\"big\");\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --version  ///////////////////////////\n\n\t/**\n\t * For '--version' argument.\n\t * Calling this method enables the inclusion of '--version' into the jlink command.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableVersion() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tversionArg.setFlag(true);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --save-opts <filename>  ///////////////////////////",
        "start_line": 238,
        "end_line": 364,
        "chunk_index": 4,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 887,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213278"
      },
      "text": "///////////////////////////  --add-modules <mod>[,<mod>...]  ///////////////////////////\n\n\t/**\n\t * For '--add-modules <mod>[,<mod>...]' argument.\n\t * @param modules is 1 or more modules to to be appended to the addmods list.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToAddmods(ModuleRef... modules) throws StfException {\n\t\tfor (ModuleRef module : modules) {\n\t\t\targCollection.checkAndUpdateLevel(argStage);\n\t\t\taddmodsArg.add(module.getBaseName());\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --output <path>  ///////////////////////////\n\n\t/**\n\t * For '--output <path>' argument.\n\t * @param imageName is a unique name for this image.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setOutput(String imageName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\t\n\t\tthis.imageName = imageName;\n\t\tString fullImageName = StfConstants.PLACEHOLDER_STF_COMMAND_NUMBER + \".\" + imageName;\n\t\tDirectoryRef imageDir = environmentCore.getTmpDir().childDirectory(fullImageName);\n\t\toutputArg.add(imageDir);\n\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * For '--output <path>' argument.\n\t * Allows the test to specify the output directory in which to create the image.\n\t * This method should only be used in cases in which the test really _must_ \n\t * have control over the output location. \n\t * In most cases it is best to let STF decide where to put the image. \n\t * @param dirName is a platform specific directory name where the image is to be created.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setOutputDirectory(String dirName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\t\n\t\tthis.imageName = dirName;\n\t\tthis.imageDir = environmentCore.createDirectoryRef(dirName);\n\t\toutputArg.add(imageDir);\n\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * @return a String containing the image name, as supplied to JlinkDefinition.setOutput()\n\t */\n\tpublic String getOutputImageName() {\n\t\treturn imageName;\n\t}\n\n\t\n\t/**\n\t * @return the directory in which STF has created the jlinked image.\n\t * @throws StfException \n\t */\n\tpublic DirectoryRef getOutputImageDir() throws StfException {\n\t\tif (imageDir != null) {\n\t\t\t// Special case for explicitly set output directory\n\t\t\treturn imageDir;\n\t\t}\n\n\t\tString actualImageName = Integer.toString(commandSerialNum) + \".\" + imageName;\n\t\treturn environmentCore.getTmpDir().childDirectory(actualImageName);\n\t}\n\n\n\t/**\n\t * @returns true if this JlinkDefinition has been told to create it's image at\n\t * a particular location. \n\t */\n\tpublic boolean usingCustomOuputImageDir() {\n\t\treturn imageDir != null;\n\t}\n\n\t\n\t///////////////////////////  --endian <little|big>  ///////////////////////////\n\n\t/**\n\t * For '--endian <little|big>' argument.\n\t * Calling this method forces output to little endian.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setEndianToLittle() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tendianArg.add(\"little\");\n\t\treturn this;\n\t}\n\n\t/**\n\t * For '--endian <little|big>' argument.\n\t * Calling this method forces output to big endian.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setEndianToBig() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tendianArg.add(\"big\");\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --version  ///////////////////////////\n\n\t/**\n\t * For '--version' argument.\n\t * Calling this method enables the inclusion of '--version' into the jlink command.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableVersion() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tversionArg.setFlag(true);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --save-opts <filename>  ///////////////////////////"
    },
    "250": {
      "metadata": {
        "chunk_id": "11301274a6e4464db5de0b84cd54dd88b993a8e1509fc91515e61390f3a7bfb9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "/**\n\t * For '--endian <little|big>' argument.\n\t * Calling this method forces output to big endian.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setEndianToBig() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tendianArg.add(\"big\");\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --version  ///////////////////////////\n\n\t/**\n\t * For '--version' argument.\n\t * Calling this method enables the inclusion of '--version' into the jlink command.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableVersion() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tversionArg.setFlag(true);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --save-opts <filename>  ///////////////////////////\n\n\t/**\n\t * For '--save-opts <filename>' argument.\n\t * Calling this method tells jlink to save the jlink options to the referenced file.\n\t * @param saveoptsFile points to a file to save the options to.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setSaveopts(FileRef saveoptsFile) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tsaveoptsArg.add(saveoptsFile);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --strip-debug  ///////////////////////////\n\t\n\t/**\n\t * For '--strip-debug' argument.\n\t * Call this method to tell jlink to string debug information.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableStripDebug() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tstripDebugArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --strip-native-commands  ///////////////////////////\n\t\n\t/**\n\t * For '--strip-native-commands' argument.\n\t * Call this method to tell jlink to remove commands (such as java and keytool)\n\t * from the created image.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableStripNativeCommands() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tstripNativeCommandsArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --compress=n  ///////////////////////////\n\t\n\t/**\n\t * For '--compress=n' argument.\n\t * @param compressLevel describes which resources to compress:\n\t *   Level 0: constant string sharing\n\t *   Level 1: ZIP\n\t *   Level 2: both.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setCompress(int compressLevel) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcompressArg.add(compressLevel);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * For '--compress=n[:filter=<pattern>]' argument, with a filter specification.\n\t * @param compressLevel as with previous setCompress method.\n\t * @param filterPattern 'java --list-plugins' describes this as:\n\t *   \"An optional filter can be specified to list the pattern of files to be filtered.\n\t *   Use ^ for negation. e.g.: *Exception.class,*Error.class,^/java.base/java/lang/*\"\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setCompress(int compressLevel, String filterPattern) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcompressArg.add(compressLevel + \":filter=\" + filterPattern);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --plugin-module-path <modulepath>  ///////////////////////////\n\n\t/**\n\t * For '--plugin-module-path <modulepath>' argument.\n\t * Calling this method adds a module to the plugin module path.\n\t * @param pluginModuleDir is the directory to add to the plugin module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addDirectoryToPluginModulePath(DirectoryRef dir) throws StfException {\n\t\treturn addToPluginModulePath(dir.getSpec());\n\t}",
        "start_line": 365,
        "end_line": 476,
        "chunk_index": 5,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 855,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213282"
      },
      "text": "/**\n\t * For '--endian <little|big>' argument.\n\t * Calling this method forces output to big endian.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setEndianToBig() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tendianArg.add(\"big\");\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --version  ///////////////////////////\n\n\t/**\n\t * For '--version' argument.\n\t * Calling this method enables the inclusion of '--version' into the jlink command.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableVersion() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tversionArg.setFlag(true);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --save-opts <filename>  ///////////////////////////\n\n\t/**\n\t * For '--save-opts <filename>' argument.\n\t * Calling this method tells jlink to save the jlink options to the referenced file.\n\t * @param saveoptsFile points to a file to save the options to.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setSaveopts(FileRef saveoptsFile) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tsaveoptsArg.add(saveoptsFile);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --strip-debug  ///////////////////////////\n\t\n\t/**\n\t * For '--strip-debug' argument.\n\t * Call this method to tell jlink to string debug information.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableStripDebug() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tstripDebugArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --strip-native-commands  ///////////////////////////\n\t\n\t/**\n\t * For '--strip-native-commands' argument.\n\t * Call this method to tell jlink to remove commands (such as java and keytool)\n\t * from the created image.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableStripNativeCommands() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tstripNativeCommandsArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --compress=n  ///////////////////////////\n\t\n\t/**\n\t * For '--compress=n' argument.\n\t * @param compressLevel describes which resources to compress:\n\t *   Level 0: constant string sharing\n\t *   Level 1: ZIP\n\t *   Level 2: both.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setCompress(int compressLevel) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcompressArg.add(compressLevel);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * For '--compress=n[:filter=<pattern>]' argument, with a filter specification.\n\t * @param compressLevel as with previous setCompress method.\n\t * @param filterPattern 'java --list-plugins' describes this as:\n\t *   \"An optional filter can be specified to list the pattern of files to be filtered.\n\t *   Use ^ for negation. e.g.: *Exception.class,*Error.class,^/java.base/java/lang/*\"\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setCompress(int compressLevel, String filterPattern) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcompressArg.add(compressLevel + \":filter=\" + filterPattern);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --plugin-module-path <modulepath>  ///////////////////////////\n\n\t/**\n\t * For '--plugin-module-path <modulepath>' argument.\n\t * Calling this method adds a module to the plugin module path.\n\t * @param pluginModuleDir is the directory to add to the plugin module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addDirectoryToPluginModulePath(DirectoryRef dir) throws StfException {\n\t\treturn addToPluginModulePath(dir.getSpec());\n\t}"
    },
    "251": {
      "metadata": {
        "chunk_id": "fb947a0f84caca57d9565b3ca890b6d34585ef79679efa3310818615abbe2872",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "/**\n\t * For '--plugin-module-path <modulepath>' argument.\n\t * Calling this method adds a module to the plugin module path.\n\t * @param pluginModuleDir is the directory to add to the plugin module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addDirectoryToPluginModulePath(DirectoryRef dir) throws StfException {\n\t\treturn addToPluginModulePath(dir.getSpec());\n\t}\n\n\t\n\t/**\n\t * For '--plugin-module-path <modulepath>' argument.\n\t * @param modularJar is a reference to a modular jar to be added to the plugin module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModularJarToPluginModulePath(FileRef modularJar) throws StfException {\n\t\treturn addToPluginModulePath(modularJar.getSpec());\n\t}\n\n\t\n\t/**\n\t * For '--plugin-module-path <modulepath>' argument.\n\t * @param module is a reference to an existing module. The test may have created the module\n\t * by running doCreateJmod() or by creating a ModuleRef object for a pre-existing module.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToPluginModulePath(ModuleRef module) throws StfException {\n\t\tDirectoryRef parentDir = module.getJarFileRef().parent();\n\t\treturn addToPluginModulePath(parentDir.getSpec());\n\t}\n\n\t\n\tprivate JlinkDefinition addToPluginModulePath(String pluginModulePathEntry) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tpluginModulePathArg.add(pluginModulePathEntry);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --list-plugins  ///////////////////////////\n\t\n\t/**\n\t * For '--list-plugins' argument.\n\t * Enables the jlink argument to list plugins.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableListPlugins() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tlistPluginsArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\n\t///////////////////////////  --class-for-name  ///////////////////////////\n\t\n\t/**\n\t * For '--class-for-name' argument.\n\t * Call this method to enable the output of this flag, which is a class optimisation\n\t * that 'converts Class.forName calls to constant loads'. \n\t * @return Updated jlink definition\n\t */\n\tpublic JlinkDefinition enableClassForName() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tclassForNameArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\n\t///////////////////////////  --copy-files  ///////////////////////////\n\t\n\t/**\n\t * For the '--copy-files=<List of <file path>=<image target> to copy to the image>' \n\t * argument, which copies files or directories into a jlinked image.\n\t * This method is for cases in which you only want to specify the source file.\n\t * @param source is a file or directory to be copied to the jlink image output.\n\t * If not an absolute file/directory then it is assumed to be relative to the \n\t * root of the JVM for the execute stage. \n\t * The file or directory will be copied into the jlink image with the same name.\n\t * Note: Value is currently a string. This may need to change to a FileRef or \n\t * DirectoryRef object to preserve platform independence.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addToCopyFiles(String source) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcopyFilesArg.add(source);\n\t\treturn this;\n\t}",
        "start_line": 477,
        "end_line": 564,
        "chunk_index": 6,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 754,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213286"
      },
      "text": "/**\n\t * For '--plugin-module-path <modulepath>' argument.\n\t * Calling this method adds a module to the plugin module path.\n\t * @param pluginModuleDir is the directory to add to the plugin module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addDirectoryToPluginModulePath(DirectoryRef dir) throws StfException {\n\t\treturn addToPluginModulePath(dir.getSpec());\n\t}\n\n\t\n\t/**\n\t * For '--plugin-module-path <modulepath>' argument.\n\t * @param modularJar is a reference to a modular jar to be added to the plugin module path.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModularJarToPluginModulePath(FileRef modularJar) throws StfException {\n\t\treturn addToPluginModulePath(modularJar.getSpec());\n\t}\n\n\t\n\t/**\n\t * For '--plugin-module-path <modulepath>' argument.\n\t * @param module is a reference to an existing module. The test may have created the module\n\t * by running doCreateJmod() or by creating a ModuleRef object for a pre-existing module.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addModuleToPluginModulePath(ModuleRef module) throws StfException {\n\t\tDirectoryRef parentDir = module.getJarFileRef().parent();\n\t\treturn addToPluginModulePath(parentDir.getSpec());\n\t}\n\n\t\n\tprivate JlinkDefinition addToPluginModulePath(String pluginModulePathEntry) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tpluginModulePathArg.add(pluginModulePathEntry);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --list-plugins  ///////////////////////////\n\t\n\t/**\n\t * For '--list-plugins' argument.\n\t * Enables the jlink argument to list plugins.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableListPlugins() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tlistPluginsArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\n\t///////////////////////////  --class-for-name  ///////////////////////////\n\t\n\t/**\n\t * For '--class-for-name' argument.\n\t * Call this method to enable the output of this flag, which is a class optimisation\n\t * that 'converts Class.forName calls to constant loads'. \n\t * @return Updated jlink definition\n\t */\n\tpublic JlinkDefinition enableClassForName() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tclassForNameArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\n\t///////////////////////////  --copy-files  ///////////////////////////\n\t\n\t/**\n\t * For the '--copy-files=<List of <file path>=<image target> to copy to the image>' \n\t * argument, which copies files or directories into a jlinked image.\n\t * This method is for cases in which you only want to specify the source file.\n\t * @param source is a file or directory to be copied to the jlink image output.\n\t * If not an absolute file/directory then it is assumed to be relative to the \n\t * root of the JVM for the execute stage. \n\t * The file or directory will be copied into the jlink image with the same name.\n\t * Note: Value is currently a string. This may need to change to a FileRef or \n\t * DirectoryRef object to preserve platform independence.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addToCopyFiles(String source) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcopyFilesArg.add(source);\n\t\treturn this;\n\t}"
    },
    "252": {
      "metadata": {
        "chunk_id": "ab5c33cfb4dde18b92467435b057af968c7af77d426f7b5ba3646df861d52309",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "/**\n\t * For the '--copy-files=<List of <file path>=<image target> to copy to the image>'\n\t * argument, which copies files or directories into a specific location within a \n\t * jlinked image.\n\t * This method is for cases in which you want to specify a source file/dir and \n\t * also it's destination. \n\t * At the time of writing there is little Oracle documentation on copy-files but it\n\t * appears to work in the way that you would expect a unix style copy to operate.\n\t * @param source is a file or directory to be copied to the jlink image output.\n\t * If not an absolute file/directory then it is assumed to be relative to the \n\t * root of the JVM for the execute stage. \n\t * @param dest is the file or directory to copy the source to.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addToCopyFiles(String source, String dest) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcopyFilesArg.add(source + \"=\" + dest);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --exclude-files  ///////////////////////////\n\n\t/**\n\t * For the '--exclude-files=<files to exclude | files of excluded files>' argument.\n\t * @param excludeFileName desribes which files to exclude, eg '*.diz' or '/java.base/native/client/*' \n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addToExcludeFiles(String excludeFileName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\texcludeFilesArg.add(excludeFileName);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --exclude-resources  ///////////////////////////\n\n\t/**\n\t * For the '--exclude-resources=<resources to exclude | file of excluded resources>'\n\t * argument.\n\t * @param excludeResourceName describes the resource to exclude. eg, '*.jcov' or 'META-INF'\n\t * @return Updated jlink definition\n\t */\n\tpublic JlinkDefinition addToExcludeResources(String excludeResourceName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\texcludeResourcesArg.add(excludeResourceName);\n\t\treturn this;\n\t}\n\t\t\n\t///////////////////////////  --include-locales  ///////////////////////////\n\t\n\t/**\n\t * For the '--include-locales=<langtag>[,<langtag>]*' argument.\n\t * @param localeName is the name of a locale to include, 'es' or 'th'\n\t * @return Updated jlink definition\n\t */\n\tpublic JlinkDefinition addToIncludeLocales(String localeName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tincludeLocalesArg.add(localeName);\n\t\treturn this;\n\t}\n\t\t\n\t\n\t///////////////////////////  --installed-modules  ///////////////////////////\n\t\n\t/**\n\t * For '--installed-modules' argument.\n\t * Call this method to tell enable the '--installed-modules' option.\n\t * This option appears to be aimed at improving the startup time of the JVM\n\t * if it doesn't use lambdas.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableInstalledModules() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tinstalledModulesArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --order-resources  ///////////////////////////\n\t\n\t/**\n\t * For the '--order-resources=<pattern-list> of paths in priority order'\n\t * argument.\n\t * @param resourceSpec is a name to be added to the order resources argument values.\n\t * @return Updated jlink definition\n\t */\n\tpublic JlinkDefinition addToOrderResources(String resourceSpec) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\torderResourcesArg.add(resourceSpec);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --vm  ///////////////////////////",
        "start_line": 565,
        "end_line": 659,
        "chunk_index": 7,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 805,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213289"
      },
      "text": "/**\n\t * For the '--copy-files=<List of <file path>=<image target> to copy to the image>'\n\t * argument, which copies files or directories into a specific location within a \n\t * jlinked image.\n\t * This method is for cases in which you want to specify a source file/dir and \n\t * also it's destination. \n\t * At the time of writing there is little Oracle documentation on copy-files but it\n\t * appears to work in the way that you would expect a unix style copy to operate.\n\t * @param source is a file or directory to be copied to the jlink image output.\n\t * If not an absolute file/directory then it is assumed to be relative to the \n\t * root of the JVM for the execute stage. \n\t * @param dest is the file or directory to copy the source to.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addToCopyFiles(String source, String dest) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcopyFilesArg.add(source + \"=\" + dest);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --exclude-files  ///////////////////////////\n\n\t/**\n\t * For the '--exclude-files=<files to exclude | files of excluded files>' argument.\n\t * @param excludeFileName desribes which files to exclude, eg '*.diz' or '/java.base/native/client/*' \n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition addToExcludeFiles(String excludeFileName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\texcludeFilesArg.add(excludeFileName);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --exclude-resources  ///////////////////////////\n\n\t/**\n\t * For the '--exclude-resources=<resources to exclude | file of excluded resources>'\n\t * argument.\n\t * @param excludeResourceName describes the resource to exclude. eg, '*.jcov' or 'META-INF'\n\t * @return Updated jlink definition\n\t */\n\tpublic JlinkDefinition addToExcludeResources(String excludeResourceName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\texcludeResourcesArg.add(excludeResourceName);\n\t\treturn this;\n\t}\n\t\t\n\t///////////////////////////  --include-locales  ///////////////////////////\n\t\n\t/**\n\t * For the '--include-locales=<langtag>[,<langtag>]*' argument.\n\t * @param localeName is the name of a locale to include, 'es' or 'th'\n\t * @return Updated jlink definition\n\t */\n\tpublic JlinkDefinition addToIncludeLocales(String localeName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tincludeLocalesArg.add(localeName);\n\t\treturn this;\n\t}\n\t\t\n\t\n\t///////////////////////////  --installed-modules  ///////////////////////////\n\t\n\t/**\n\t * For '--installed-modules' argument.\n\t * Call this method to tell enable the '--installed-modules' option.\n\t * This option appears to be aimed at improving the startup time of the JVM\n\t * if it doesn't use lambdas.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition enableInstalledModules() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tinstalledModulesArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --order-resources  ///////////////////////////\n\t\n\t/**\n\t * For the '--order-resources=<pattern-list> of paths in priority order'\n\t * argument.\n\t * @param resourceSpec is a name to be added to the order resources argument values.\n\t * @return Updated jlink definition\n\t */\n\tpublic JlinkDefinition addToOrderResources(String resourceSpec) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\torderResourcesArg.add(resourceSpec);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --vm  ///////////////////////////"
    },
    "253": {
      "metadata": {
        "chunk_id": "d4cdf03ce9a45519574f890eeded5cde6f123fbd1bdb2edfb972948284f1cc4d",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JlinkDefinition.java",
        "content": "public enum VmType {CLIENT, SERVER, MINIMAL, ALL};\n\t\n\t/**\n\t * For the '--vm=<client|server|minimal|all>' argument. \n\t * @param vmType describes the type of JVM to create.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setVm(VmType vmType) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tvmArg.add(vmType.name().toLowerCase());\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --release-info  ///////////////////////////\n\t\n\tpublic JlinkDefinition setReleaseInfoFile(String filename) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\treleaseInfoFileArg.add(filename);\n\t\treturn this;\n\t}\n\t\n\t\n\tpublic JlinkDefinition addReleaseInfoProperty(String key, String value) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\treleaseInfoAddArg.add(key + \"=\" + value);\n\t\treturn this;\n\t}\n\t\n\tpublic JlinkDefinition deleteReleaseInfoProperty(String key) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\treleaseInfoDelArg.add(key);\n\t\treturn this;\n\t}\n\t\n\t \n\t// ------------------------------------------------------------------------\n\t\n\t// For STF internal use\n\tpublic static void setEnvironmentCore(StfEnvironmentCore environmentCore) {\n\t\tJlinkDefinition.environmentCore = environmentCore;\n\t}\n\t\n\t\n\t@Override\n\tpublic String getCommand() throws StfException {\n\t\t// Build the command to run, with the full path to jlink\n\t\treturn environmentCore.getJavaHome().childFile(\"bin/jlink\").getSpec();\n\t}\n\t\n\t@Override\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t@Override\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\n\t@Override\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\treturn argCollection.asArgsArray();\n\t}\n\n\t@Override\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) throws StfException {\n\t\tthis.commandSerialNum = commandSerialNum;\n\t}\n}",
        "start_line": 660,
        "end_line": 739,
        "chunk_index": 8,
        "total_chunks": 9,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 490,
        "node_type": null,
        "file_sha": "4c7ba13b8cbf154f6e9403047b57236e4a6ba40d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.213292"
      },
      "text": "public enum VmType {CLIENT, SERVER, MINIMAL, ALL};\n\t\n\t/**\n\t * For the '--vm=<client|server|minimal|all>' argument. \n\t * @param vmType describes the type of JVM to create.\n\t * @return Updated jlink definition.\n\t */\n\tpublic JlinkDefinition setVm(VmType vmType) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tvmArg.add(vmType.name().toLowerCase());\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --release-info  ///////////////////////////\n\t\n\tpublic JlinkDefinition setReleaseInfoFile(String filename) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\treleaseInfoFileArg.add(filename);\n\t\treturn this;\n\t}\n\t\n\t\n\tpublic JlinkDefinition addReleaseInfoProperty(String key, String value) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\treleaseInfoAddArg.add(key + \"=\" + value);\n\t\treturn this;\n\t}\n\t\n\tpublic JlinkDefinition deleteReleaseInfoProperty(String key) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\treleaseInfoDelArg.add(key);\n\t\treturn this;\n\t}\n\t\n\t \n\t// ------------------------------------------------------------------------\n\t\n\t// For STF internal use\n\tpublic static void setEnvironmentCore(StfEnvironmentCore environmentCore) {\n\t\tJlinkDefinition.environmentCore = environmentCore;\n\t}\n\t\n\t\n\t@Override\n\tpublic String getCommand() throws StfException {\n\t\t// Build the command to run, with the full path to jlink\n\t\treturn environmentCore.getJavaHome().childFile(\"bin/jlink\").getSpec();\n\t}\n\t\n\t@Override\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t@Override\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\n\t@Override\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\treturn argCollection.asArgsArray();\n\t}\n\n\t@Override\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) throws StfException {\n\t\tthis.commandSerialNum = commandSerialNum;\n\t}\n}"
    },
    "254": {
      "metadata": {
        "chunk_id": "274373acf8f851d3b04744eb61cc6d1c61776051d206192732e702f12a5abe87",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JmodDefinition.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport static net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.REQUIREMENT.MANDATORY;\nimport static net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.REQUIREMENT.OPTIONAL;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArgCollection;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.ARG_TYPE;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArgCollection.Stage;\n\n\n/**\n * This class builds jmod commands for the following version of jmod:\n * \n *   $ jmod --help\n *   Usage: jmod (create|list|describe) <OPTIONS> <jmod-file>\n *   \n *    Main operation modes:\n *     create    - Creates a new jmod archive\n *     list      - Prints the names of all the entries\n *     describe  - Prints the module details\n *   \n *    Option                             Description                           \n *    ------                             -----------                           \n *     --class-path <path>                Application jar files|dir containing  \n *                                          classes                             \n *     --cmds <path>                      Location of native commands           \n *     --config <path>                    Location of user-editable config files\n *     --exclude <pattern>                Exclude files, given as a PATTERN     \n *     --hash-modules <pattern>           Compute and record hashes of          \n *                                          dependencies matched by the pattern \n *     --help                             Print this usage message              \n *     --libs <path>                      Location of native libraries          \n *     --main-class <class-name>          Main class                            \n *     --module-version <module-version>  Module version                        \n *     --module-path, --mp <path>         Module path                           \n *     --os-arch <os-arch>                Operating system architecture         \n *     --os-name <os-name>                Operating system name                 \n *     --os-version <os-version>          Operating system version              \n *     --version                          Version information                   \n *     @<filename>                        Read options from the specified file  \n */",
        "start_line": 0,
        "end_line": 65,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 673,
        "node_type": null,
        "file_sha": "7ada8c9ac541d7dd4d5c1b1201231b02b6cadb5c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.241244"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport static net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.REQUIREMENT.MANDATORY;\nimport static net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.REQUIREMENT.OPTIONAL;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArgCollection;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArg.ARG_TYPE;\nimport net.adoptopenjdk.stf.processes.definitions.generic.ProcessArgCollection.Stage;\n\n\n/**\n * This class builds jmod commands for the following version of jmod:\n * \n *   $ jmod --help\n *   Usage: jmod (create|list|describe) <OPTIONS> <jmod-file>\n *   \n *    Main operation modes:\n *     create    - Creates a new jmod archive\n *     list      - Prints the names of all the entries\n *     describe  - Prints the module details\n *   \n *    Option                             Description                           \n *    ------                             -----------                           \n *     --class-path <path>                Application jar files|dir containing  \n *                                          classes                             \n *     --cmds <path>                      Location of native commands           \n *     --config <path>                    Location of user-editable config files\n *     --exclude <pattern>                Exclude files, given as a PATTERN     \n *     --hash-modules <pattern>           Compute and record hashes of          \n *                                          dependencies matched by the pattern \n *     --help                             Print this usage message              \n *     --libs <path>                      Location of native libraries          \n *     --main-class <class-name>          Main class                            \n *     --module-version <module-version>  Module version                        \n *     --module-path, --mp <path>         Module path                           \n *     --os-arch <os-arch>                Operating system architecture         \n *     --os-name <os-name>                Operating system name                 \n *     --os-version <os-version>          Operating system version              \n *     --version                          Version information                   \n *     @<filename>                        Read options from the specified file  \n */"
    },
    "255": {
      "metadata": {
        "chunk_id": "70c60679580dde35b39015372c1f5755fb42fb1a05f7f22ccc3d5d18a25a88cb",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JmodDefinition.java",
        "content": "public class JmodDefinition implements ProcessDefinition {\n\tprivate static StfEnvironmentCore environmentCore;\n\n\t// Define stages. To ensure that the operation type (create/list/describe) is\n\t// set before any/all the arguments.\n\t// All stages require a minimum of Java 9\n\tprivate Stage operationStage = new ProcessArgCollection.Stage(\"jmodOperation\", 1, 9);\n\tprivate Stage argStage       = new ProcessArgCollection.Stage(\"jmodArguments\", 2, 9);\n\n\t// Define the arguments which jmod commands accept\n\tProcessArg operationArg        = new ProcessArg(ARG_TYPE.STRING, MANDATORY, \"operation\",        null);\n\tProcessArg classPathArg        = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"class-path\",       \"--class-path\");\n\tProcessArg cmdsArg             = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"cmds\",             \"--cmds\");\n\tProcessArg configArg           = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"config\",           \"--config\");\n\tProcessArg excludeArg          = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"exclude\",          \"--exclude\");\n\tProcessArg hashModulesArg      = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"hashModules\",      \"--hash-modules\");\n\tProcessArg helpArg             = new ProcessArg(ARG_TYPE.FLAG,   OPTIONAL,  \"help\",             \"--help\");\n\tProcessArg libsArg             = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"libs\",             \"--libs\");\n\tProcessArg mainClassArg        = new ProcessArg(ARG_TYPE.CLASS,  OPTIONAL,  \"mainClass\",        \"--main-class\");\n\tProcessArg moduleVersionArg    = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"moduleVersion\",    \"--module-version\");\n\tProcessArg modulepathArg       = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"modulepath\",       \"--module-path\");\n\tProcessArg osArchArg           = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"osArch\",           \"--os-arch\");\n\tProcessArg osNameArg           = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"osName\",           \"--os-name\");\n\tProcessArg osVersionArg        = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"osVersion\",        \"--os-version\");\n\tProcessArg versionArg          = new ProcessArg(ARG_TYPE.FLAG,   OPTIONAL,  \"version\",          \"--version\");\n\tProcessArg jmodFileArg         = new ProcessArg(ARG_TYPE.FILE,   OPTIONAL,  \"jmodFile\",         null);\n\n\tProcessArgCollection argCollection;\n\n\n\tpublic JmodDefinition() {\n\t\tthis.argCollection = new ProcessArgCollection(environmentCore, operationStage,\n\t\t\t\t\t\t\t\t\toperationArg,\n\t\t\t\t\t\t\t\t\tclassPathArg,\n\t\t\t\t\t\t\t\t\tcmdsArg,\n\t\t\t\t\t\t\t\t\tconfigArg,\n\t\t\t\t\t\t\t\t\texcludeArg,\n\t\t\t\t\t\t\t\t\thashModulesArg,\n\t\t\t\t\t\t\t\t\thelpArg,\n\t\t\t\t\t\t\t\t\tlibsArg,\n\t\t\t\t\t\t\t\t\tmainClassArg,\n\t\t\t\t\t\t\t\t\tmoduleVersionArg,\n\t\t\t\t\t\t\t\t\tmodulepathArg,\n\t\t\t\t\t\t\t\t\tosArchArg,\n\t\t\t\t\t\t\t\t\tosNameArg,\n\t\t\t\t\t\t\t\t\tosVersionArg,\n\t\t\t\t\t\t\t\t\tversionArg,\n\t\t\t\t\t\t\t\t\tjmodFileArg);\n\t}\n\n\n\t// For STF internal use\n\tpublic static void setEnvironmentCore(StfEnvironmentCore environmentCore) {\n\t\tJmodDefinition.environmentCore = environmentCore;\n\t}",
        "start_line": 66,
        "end_line": 120,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 682,
        "node_type": null,
        "file_sha": "7ada8c9ac541d7dd4d5c1b1201231b02b6cadb5c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.241255"
      },
      "text": "public class JmodDefinition implements ProcessDefinition {\n\tprivate static StfEnvironmentCore environmentCore;\n\n\t// Define stages. To ensure that the operation type (create/list/describe) is\n\t// set before any/all the arguments.\n\t// All stages require a minimum of Java 9\n\tprivate Stage operationStage = new ProcessArgCollection.Stage(\"jmodOperation\", 1, 9);\n\tprivate Stage argStage       = new ProcessArgCollection.Stage(\"jmodArguments\", 2, 9);\n\n\t// Define the arguments which jmod commands accept\n\tProcessArg operationArg        = new ProcessArg(ARG_TYPE.STRING, MANDATORY, \"operation\",        null);\n\tProcessArg classPathArg        = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"class-path\",       \"--class-path\");\n\tProcessArg cmdsArg             = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"cmds\",             \"--cmds\");\n\tProcessArg configArg           = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"config\",           \"--config\");\n\tProcessArg excludeArg          = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"exclude\",          \"--exclude\");\n\tProcessArg hashModulesArg      = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"hashModules\",      \"--hash-modules\");\n\tProcessArg helpArg             = new ProcessArg(ARG_TYPE.FLAG,   OPTIONAL,  \"help\",             \"--help\");\n\tProcessArg libsArg             = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"libs\",             \"--libs\");\n\tProcessArg mainClassArg        = new ProcessArg(ARG_TYPE.CLASS,  OPTIONAL,  \"mainClass\",        \"--main-class\");\n\tProcessArg moduleVersionArg    = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"moduleVersion\",    \"--module-version\");\n\tProcessArg modulepathArg       = new ProcessArg(ARG_TYPE.PATH,   OPTIONAL,  \"modulepath\",       \"--module-path\");\n\tProcessArg osArchArg           = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"osArch\",           \"--os-arch\");\n\tProcessArg osNameArg           = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"osName\",           \"--os-name\");\n\tProcessArg osVersionArg        = new ProcessArg(ARG_TYPE.STRING, OPTIONAL,  \"osVersion\",        \"--os-version\");\n\tProcessArg versionArg          = new ProcessArg(ARG_TYPE.FLAG,   OPTIONAL,  \"version\",          \"--version\");\n\tProcessArg jmodFileArg         = new ProcessArg(ARG_TYPE.FILE,   OPTIONAL,  \"jmodFile\",         null);\n\n\tProcessArgCollection argCollection;\n\n\n\tpublic JmodDefinition() {\n\t\tthis.argCollection = new ProcessArgCollection(environmentCore, operationStage,\n\t\t\t\t\t\t\t\t\toperationArg,\n\t\t\t\t\t\t\t\t\tclassPathArg,\n\t\t\t\t\t\t\t\t\tcmdsArg,\n\t\t\t\t\t\t\t\t\tconfigArg,\n\t\t\t\t\t\t\t\t\texcludeArg,\n\t\t\t\t\t\t\t\t\thashModulesArg,\n\t\t\t\t\t\t\t\t\thelpArg,\n\t\t\t\t\t\t\t\t\tlibsArg,\n\t\t\t\t\t\t\t\t\tmainClassArg,\n\t\t\t\t\t\t\t\t\tmoduleVersionArg,\n\t\t\t\t\t\t\t\t\tmodulepathArg,\n\t\t\t\t\t\t\t\t\tosArchArg,\n\t\t\t\t\t\t\t\t\tosNameArg,\n\t\t\t\t\t\t\t\t\tosVersionArg,\n\t\t\t\t\t\t\t\t\tversionArg,\n\t\t\t\t\t\t\t\t\tjmodFileArg);\n\t}\n\n\n\t// For STF internal use\n\tpublic static void setEnvironmentCore(StfEnvironmentCore environmentCore) {\n\t\tJmodDefinition.environmentCore = environmentCore;\n\t}"
    },
    "256": {
      "metadata": {
        "chunk_id": "2f47e4a55dac0d9d4235e26ebae4699ffa212690a838e67542c43ac6d4215504",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JmodDefinition.java",
        "content": "ProcessArgCollection argCollection;\n\n\n\tpublic JmodDefinition() {\n\t\tthis.argCollection = new ProcessArgCollection(environmentCore, operationStage,\n\t\t\t\t\t\t\t\t\toperationArg,\n\t\t\t\t\t\t\t\t\tclassPathArg,\n\t\t\t\t\t\t\t\t\tcmdsArg,\n\t\t\t\t\t\t\t\t\tconfigArg,\n\t\t\t\t\t\t\t\t\texcludeArg,\n\t\t\t\t\t\t\t\t\thashModulesArg,\n\t\t\t\t\t\t\t\t\thelpArg,\n\t\t\t\t\t\t\t\t\tlibsArg,\n\t\t\t\t\t\t\t\t\tmainClassArg,\n\t\t\t\t\t\t\t\t\tmoduleVersionArg,\n\t\t\t\t\t\t\t\t\tmodulepathArg,\n\t\t\t\t\t\t\t\t\tosArchArg,\n\t\t\t\t\t\t\t\t\tosNameArg,\n\t\t\t\t\t\t\t\t\tosVersionArg,\n\t\t\t\t\t\t\t\t\tversionArg,\n\t\t\t\t\t\t\t\t\tjmodFileArg);\n\t}\n\n\n\t// For STF internal use\n\tpublic static void setEnvironmentCore(StfEnvironmentCore environmentCore) {\n\t\tJmodDefinition.environmentCore = environmentCore;\n\t}\n\n\n\t///////////////////////////  Jmod operation modes  ///////////////////////////\n\t\n\t/**\n\t * Sets the jmod operation to 'create'.\n\t * @param jmodName is the name of the jmod file to create. \n\t * It will be created in the stf temp directory.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition doJmodCreate(String jmodName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(operationStage);\n\t\toperationArg.add(\"create\");\n\t\tjmodFileArg.setFile(environmentCore.getTmpDir().childFile(jmodName));\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * If this jmod definition represents a create operation then this \n\t * method returns a reference for the created file.\n\t * @return a ModuleRef object for the jmod file that will be created.\n\t */\n\tpublic ModuleRef getJmodModuleRef() throws StfException {\n\t\tFileRef jmodFile = jmodFileArg.getFileValue();\n\t\treturn new ModuleRef(jmodFile.getName(), jmodFile);\n\t}\n\t\n\t\n\t/**\n\t * Sets the jmod operation to 'list'.\n\t * @param jmod is the jmod which you want to list.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition doJmodList(ModuleRef jmod) throws StfException {\n\t\targCollection.checkAndUpdateLevel(operationStage);\n\t\toperationArg.add(\"list\");\n\t\tjmodFileArg.setFile(jmod.getJarFileRef());\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Sets the jmod operation to 'describe'.\n\t * @param jmod is the jmod which you want to describe.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition doJmodDescribe(ModuleRef jmod) throws StfException {\n\t\targCollection.checkAndUpdateLevel(operationStage);\n\t\toperationArg.add(\"describe\");\n\t\tjmodFileArg.setFile(jmod.getJarFileRef());\n\t\treturn this;\n\t}\n\t\n\n\t///////////////////////////  --class-path <path>  ///////////////////////////\n\n\t/**\n\t * For '--class-path <path>' argument.\n\t * @param dir is a directory to add to the classpath.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToClassPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tclassPathArg.addToPath(dir);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * For '--class-path <path>' argument.\n\t * @param jar is an application jar to add to the classpath.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addJarToClassPath(FileRef jar) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tclassPathArg.add(jar);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --cmds <path>  ///////////////////////////\n\n\t/**\n\t * For '--cmds <path>' argument.\n\t * @param dir is a directory to add to the path for native commands.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToCmdsPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcmdsArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --config <path>  ///////////////////////////\n\n\t/**\n\t * For '--config <path>' argument.\n\t * @param dir is a directory to add to the path for user-editable config files.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToConfigPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tconfigArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --exclude <pattern>  ///////////////////////////",
        "start_line": 121,
        "end_line": 257,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 945,
        "node_type": null,
        "file_sha": "7ada8c9ac541d7dd4d5c1b1201231b02b6cadb5c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.241259"
      },
      "text": "ProcessArgCollection argCollection;\n\n\n\tpublic JmodDefinition() {\n\t\tthis.argCollection = new ProcessArgCollection(environmentCore, operationStage,\n\t\t\t\t\t\t\t\t\toperationArg,\n\t\t\t\t\t\t\t\t\tclassPathArg,\n\t\t\t\t\t\t\t\t\tcmdsArg,\n\t\t\t\t\t\t\t\t\tconfigArg,\n\t\t\t\t\t\t\t\t\texcludeArg,\n\t\t\t\t\t\t\t\t\thashModulesArg,\n\t\t\t\t\t\t\t\t\thelpArg,\n\t\t\t\t\t\t\t\t\tlibsArg,\n\t\t\t\t\t\t\t\t\tmainClassArg,\n\t\t\t\t\t\t\t\t\tmoduleVersionArg,\n\t\t\t\t\t\t\t\t\tmodulepathArg,\n\t\t\t\t\t\t\t\t\tosArchArg,\n\t\t\t\t\t\t\t\t\tosNameArg,\n\t\t\t\t\t\t\t\t\tosVersionArg,\n\t\t\t\t\t\t\t\t\tversionArg,\n\t\t\t\t\t\t\t\t\tjmodFileArg);\n\t}\n\n\n\t// For STF internal use\n\tpublic static void setEnvironmentCore(StfEnvironmentCore environmentCore) {\n\t\tJmodDefinition.environmentCore = environmentCore;\n\t}\n\n\n\t///////////////////////////  Jmod operation modes  ///////////////////////////\n\t\n\t/**\n\t * Sets the jmod operation to 'create'.\n\t * @param jmodName is the name of the jmod file to create. \n\t * It will be created in the stf temp directory.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition doJmodCreate(String jmodName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(operationStage);\n\t\toperationArg.add(\"create\");\n\t\tjmodFileArg.setFile(environmentCore.getTmpDir().childFile(jmodName));\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * If this jmod definition represents a create operation then this \n\t * method returns a reference for the created file.\n\t * @return a ModuleRef object for the jmod file that will be created.\n\t */\n\tpublic ModuleRef getJmodModuleRef() throws StfException {\n\t\tFileRef jmodFile = jmodFileArg.getFileValue();\n\t\treturn new ModuleRef(jmodFile.getName(), jmodFile);\n\t}\n\t\n\t\n\t/**\n\t * Sets the jmod operation to 'list'.\n\t * @param jmod is the jmod which you want to list.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition doJmodList(ModuleRef jmod) throws StfException {\n\t\targCollection.checkAndUpdateLevel(operationStage);\n\t\toperationArg.add(\"list\");\n\t\tjmodFileArg.setFile(jmod.getJarFileRef());\n\t\treturn this;\n\t}\n\t\n\n\t/**\n\t * Sets the jmod operation to 'describe'.\n\t * @param jmod is the jmod which you want to describe.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition doJmodDescribe(ModuleRef jmod) throws StfException {\n\t\targCollection.checkAndUpdateLevel(operationStage);\n\t\toperationArg.add(\"describe\");\n\t\tjmodFileArg.setFile(jmod.getJarFileRef());\n\t\treturn this;\n\t}\n\t\n\n\t///////////////////////////  --class-path <path>  ///////////////////////////\n\n\t/**\n\t * For '--class-path <path>' argument.\n\t * @param dir is a directory to add to the classpath.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToClassPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tclassPathArg.addToPath(dir);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * For '--class-path <path>' argument.\n\t * @param jar is an application jar to add to the classpath.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addJarToClassPath(FileRef jar) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tclassPathArg.add(jar);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --cmds <path>  ///////////////////////////\n\n\t/**\n\t * For '--cmds <path>' argument.\n\t * @param dir is a directory to add to the path for native commands.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToCmdsPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tcmdsArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --config <path>  ///////////////////////////\n\n\t/**\n\t * For '--config <path>' argument.\n\t * @param dir is a directory to add to the path for user-editable config files.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToConfigPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tconfigArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --exclude <pattern>  ///////////////////////////"
    },
    "257": {
      "metadata": {
        "chunk_id": "0772dd08bf416bdc7dc13d838baac868ef7fb80b1b7fb8706e4540c8678a6303",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JmodDefinition.java",
        "content": "///////////////////////////  --config <path>  ///////////////////////////\n\n\t/**\n\t * For '--config <path>' argument.\n\t * @param dir is a directory to add to the path for user-editable config files.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToConfigPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tconfigArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --exclude <pattern>  ///////////////////////////\n\n\t/**\n\t * For '--exclude <pattern>' argument.\n\t * @param excludePattern is the value to use as the module version.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setExcludePattern(String excludePattern) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\texcludeArg.add(excludePattern);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --hash-modules <pattern>  ///////////////////////////\n\n\t/**\n\t * For '--hash-modules <pattern>' argument.\n\t * @param hashModulesPattern is the value to use as the module version.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setHashModulesPattern(String hashModulesPattern) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\thashModulesArg.add(hashModulesPattern);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --help  ///////////////////////////\n\n\t/**\n\t * For '--help' argument.\n\t * Calling this method enables the inclusion of '--help' into the jmod command.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition enableHelp() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\thelpArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\n\t///////////////////////////  --libs <path>  ///////////////////////////\n\n\t/**\n\t * For '--libs <path>' argument.\n\t * @param dir is a directory to add to the libs path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToLibsPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tlibsArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --main-class <class-name>  ///////////////////////////\n\n\t/**\n\t * For '--main-class <class-name>' argument.\n\t * @param clazz is the class to use for the the main class.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setMainClass(Class<?> clazz) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmainClassArg.setClass(clazz);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --module-version <module-version>  ///////////////////////////\n\n\t/**\n\t * For '--module-version <module-version>' argument.\n\t * @param moduleVersionStr is the value to use as the module version.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setModuleVersion(String moduleVersion) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmoduleVersionArg.add(moduleVersion);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --module-path <path>  ///////////////////////////\n\n\t/**\n\t * For '--module-path <path>' argument.\n\t * @param dir is a directory to add to the modulepath path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToModulepath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\t/**\n\t * For '--module-path <path>' argument.\n\t * @param jar is an application jar to add to the modulepath path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addJarToModulPath(FileRef jar) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.add(jar);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --os-arch <os-arch>  ///////////////////////////",
        "start_line": 258,
        "end_line": 381,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 862,
        "node_type": null,
        "file_sha": "7ada8c9ac541d7dd4d5c1b1201231b02b6cadb5c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.241263"
      },
      "text": "///////////////////////////  --config <path>  ///////////////////////////\n\n\t/**\n\t * For '--config <path>' argument.\n\t * @param dir is a directory to add to the path for user-editable config files.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToConfigPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tconfigArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --exclude <pattern>  ///////////////////////////\n\n\t/**\n\t * For '--exclude <pattern>' argument.\n\t * @param excludePattern is the value to use as the module version.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setExcludePattern(String excludePattern) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\texcludeArg.add(excludePattern);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --hash-modules <pattern>  ///////////////////////////\n\n\t/**\n\t * For '--hash-modules <pattern>' argument.\n\t * @param hashModulesPattern is the value to use as the module version.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setHashModulesPattern(String hashModulesPattern) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\thashModulesArg.add(hashModulesPattern);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --help  ///////////////////////////\n\n\t/**\n\t * For '--help' argument.\n\t * Calling this method enables the inclusion of '--help' into the jmod command.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition enableHelp() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\thelpArg.setFlag(true);\n\t\treturn this;\n\t}\n\t\n\n\t///////////////////////////  --libs <path>  ///////////////////////////\n\n\t/**\n\t * For '--libs <path>' argument.\n\t * @param dir is a directory to add to the libs path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToLibsPath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tlibsArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --main-class <class-name>  ///////////////////////////\n\n\t/**\n\t * For '--main-class <class-name>' argument.\n\t * @param clazz is the class to use for the the main class.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setMainClass(Class<?> clazz) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmainClassArg.setClass(clazz);\n\t\treturn this;\n\t}\n\n\t\n\t///////////////////////////  --module-version <module-version>  ///////////////////////////\n\n\t/**\n\t * For '--module-version <module-version>' argument.\n\t * @param moduleVersionStr is the value to use as the module version.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setModuleVersion(String moduleVersion) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmoduleVersionArg.add(moduleVersion);\n\t\treturn this;\n\t}\n\n\n\t///////////////////////////  --module-path <path>  ///////////////////////////\n\n\t/**\n\t * For '--module-path <path>' argument.\n\t * @param dir is a directory to add to the modulepath path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToModulepath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\t/**\n\t * For '--module-path <path>' argument.\n\t * @param jar is an application jar to add to the modulepath path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addJarToModulPath(FileRef jar) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.add(jar);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --os-arch <os-arch>  ///////////////////////////"
    },
    "258": {
      "metadata": {
        "chunk_id": "dc2505eb7027bdebb535942a3a219d68d605992f2026589003e594fa875ddd53",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/JmodDefinition.java",
        "content": "/**\n\t * For '--module-path <path>' argument.\n\t * @param dir is a directory to add to the modulepath path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToModulepath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\t/**\n\t * For '--module-path <path>' argument.\n\t * @param jar is an application jar to add to the modulepath path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addJarToModulPath(FileRef jar) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.add(jar);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --os-arch <os-arch>  ///////////////////////////\n\n\t/**\n\t * For '--os-arch <os-arch>' argument.\n\t * @param osArch is the value to supply for the argument.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsArch(String osArch) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tosArchArg.add(osArch);\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * For '--os-arch <os-arch>' argument.\n\t * Sets the os-arch to the value of the current platform. \n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsArchToCurrentPlatform() throws StfException {\n\t\treturn setOsArch(System.getProperty(\"os.arch\"));\n\t}\n\n\n\t///////////////////////////  --os-name <os-name>  ///////////////////////////\n\n\t/**\n\t * For '--os-name <os-name>' argument.\n\t * @param osName is the value to supply for the argument.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsName(String osName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tosNameArg.add(osName);\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * For '--os-name <os-name>' argument.\n\t * Sets the os-name to the value of the current platform. \n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsNameToCurrentPlatform() throws StfException {\n\t\treturn setOsName(System.getProperty(\"os.name\"));\n\t}\n\n\t\n\t///////////////////////////  --os-version <os-version>  ///////////////////////////\n\n\t/**\n\t * For '--os-version <os-version>' argument.\n\t * @param osVersion is the value to supply for the argument.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsVersion(String osVersion) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tosVersionArg.add(osVersion);\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * For '--os-version <os-version>' argument.\n\t * Sets the os-version to the value of the current platform. \n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsVersionToCurrentPlatform() throws StfException {\n\t\treturn setOsVersion(System.getProperty(\"os.version\"));\n\t}\n\n\t\n\t///////////////////////////  -version  ///////////////////////////\n\n\t/**\n\t * For '--version' argument.\n\t * Calling this method enables the inclusion of '--version' into the jmod command.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition enableVersion() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tversionArg.setFlag(true);\n\t\treturn this;\n\t}\n\n\t\n\t// ------------------------------------------------------------------------\n\t\n\t@Override\n\tpublic String getCommand() throws StfException {\n\t\t// Build the command to run, with the full path to jmod\n\t\treturn environmentCore.getJavaHome().childFile(\"bin/jmod\").getSpec();\n\t}\n\t\n\t@Override\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t@Override\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\n\t@Override\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\treturn argCollection.asArgsArray();\n\t}\n\n\t@Override\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) throws StfException {\n\t}\n}",
        "start_line": 382,
        "end_line": 527,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 949,
        "node_type": null,
        "file_sha": "7ada8c9ac541d7dd4d5c1b1201231b02b6cadb5c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.241267"
      },
      "text": "/**\n\t * For '--module-path <path>' argument.\n\t * @param dir is a directory to add to the modulepath path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addDirectoryToModulepath(DirectoryRef dir) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.addToPath(dir);\n\t\treturn this;\n\t}\n\n\t/**\n\t * For '--module-path <path>' argument.\n\t * @param jar is an application jar to add to the modulepath path.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition addJarToModulPath(FileRef jar) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tmodulepathArg.add(jar);\n\t\treturn this;\n\t}\n\t\n\t\n\t///////////////////////////  --os-arch <os-arch>  ///////////////////////////\n\n\t/**\n\t * For '--os-arch <os-arch>' argument.\n\t * @param osArch is the value to supply for the argument.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsArch(String osArch) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tosArchArg.add(osArch);\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * For '--os-arch <os-arch>' argument.\n\t * Sets the os-arch to the value of the current platform. \n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsArchToCurrentPlatform() throws StfException {\n\t\treturn setOsArch(System.getProperty(\"os.arch\"));\n\t}\n\n\n\t///////////////////////////  --os-name <os-name>  ///////////////////////////\n\n\t/**\n\t * For '--os-name <os-name>' argument.\n\t * @param osName is the value to supply for the argument.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsName(String osName) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tosNameArg.add(osName);\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * For '--os-name <os-name>' argument.\n\t * Sets the os-name to the value of the current platform. \n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsNameToCurrentPlatform() throws StfException {\n\t\treturn setOsName(System.getProperty(\"os.name\"));\n\t}\n\n\t\n\t///////////////////////////  --os-version <os-version>  ///////////////////////////\n\n\t/**\n\t * For '--os-version <os-version>' argument.\n\t * @param osVersion is the value to supply for the argument.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsVersion(String osVersion) throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tosVersionArg.add(osVersion);\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * For '--os-version <os-version>' argument.\n\t * Sets the os-version to the value of the current platform. \n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition setOsVersionToCurrentPlatform() throws StfException {\n\t\treturn setOsVersion(System.getProperty(\"os.version\"));\n\t}\n\n\t\n\t///////////////////////////  -version  ///////////////////////////\n\n\t/**\n\t * For '--version' argument.\n\t * Calling this method enables the inclusion of '--version' into the jmod command.\n\t * @return Updated jmod definition.\n\t */\n\tpublic JmodDefinition enableVersion() throws StfException {\n\t\targCollection.checkAndUpdateLevel(argStage);\n\t\tversionArg.setFlag(true);\n\t\treturn this;\n\t}\n\n\t\n\t// ------------------------------------------------------------------------\n\t\n\t@Override\n\tpublic String getCommand() throws StfException {\n\t\t// Build the command to run, with the full path to jmod\n\t\treturn environmentCore.getJavaHome().childFile(\"bin/jmod\").getSpec();\n\t}\n\t\n\t@Override\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t@Override\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\n\t@Override\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\treturn argCollection.asArgsArray();\n\t}\n\n\t@Override\n\tpublic boolean isJdkProgram() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) throws StfException {\n\t}\n}"
    },
    "259": {
      "metadata": {
        "chunk_id": "519a5780072041e869e3d464f3e1bfe475f158f3a2e0838ed05579f2c359db63",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_COMMAND_MNEMONIC;\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_COMMAND_NUMBER;\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_PROCESS_INSTANCE;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Scanner;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.util.FileOperations;\n\n\n/**\n * This object captures the information needed to start a LoadTest process.\n * \n * Parameters to control one or more suites are supplied following each call\n * to addSuite(). \n * \n * This class throws an exception if the Java process information is not built  \n * in the same order in which it will be used.\n * Callers should build the java process information in the following order:\n *   - Results directory\n *   - Time limit\n *   - suite arguments\n *   \n * Configuration of the load test is split into 2 parts:\n * 1) Values for the load test tool itself, eg, classpath, optional time limit.\n * 2) Workload definition. This consists of 1 or more suites. Each suite describes some tests to \n * run and their configuration, eg, number of worker threads, test selection\n * mode (random or sequential), etc.\n *   \n * Load tests should generally run a fixed work load, as this means that at the \n * end of test run it is possible to state that a exactly what has been run and\n * the result of that run.\n * If a test is run for a specific time period that there is no such certainty\n * over what has really been done due to variations in both machine and JVM performance.\n * The number of tests to run for each suite is configured by using the setSuiteNumTests(int)\n * method.\n * \n * Some tests run a load test as a means of getting the machine to do some work.\n * Typically running it to represent an application that does some work, so that\n * another application can do some sort of monitoring. A total run time can be \n * set by using the setTimeLimit() method. Tests are started until the time limit \n * is reached. The total runtime is going to depend on how long the final test takes. \n *\n * If a load test is started with both a fixed workload and an overall time limit\n * then the load test runs until the first limit is reached.\n *\n * See SampleLoadTest.java for a runnable example.\n */",
        "start_line": 0,
        "end_line": 82,
        "chunk_index": 0,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 805,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257913"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_COMMAND_MNEMONIC;\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_COMMAND_NUMBER;\nimport static net.adoptopenjdk.stf.StfConstants.PLACEHOLDER_STF_PROCESS_INSTANCE;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Scanner;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.util.FileOperations;\n\n\n/**\n * This object captures the information needed to start a LoadTest process.\n * \n * Parameters to control one or more suites are supplied following each call\n * to addSuite(). \n * \n * This class throws an exception if the Java process information is not built  \n * in the same order in which it will be used.\n * Callers should build the java process information in the following order:\n *   - Results directory\n *   - Time limit\n *   - suite arguments\n *   \n * Configuration of the load test is split into 2 parts:\n * 1) Values for the load test tool itself, eg, classpath, optional time limit.\n * 2) Workload definition. This consists of 1 or more suites. Each suite describes some tests to \n * run and their configuration, eg, number of worker threads, test selection\n * mode (random or sequential), etc.\n *   \n * Load tests should generally run a fixed work load, as this means that at the \n * end of test run it is possible to state that a exactly what has been run and\n * the result of that run.\n * If a test is run for a specific time period that there is no such certainty\n * over what has really been done due to variations in both machine and JVM performance.\n * The number of tests to run for each suite is configured by using the setSuiteNumTests(int)\n * method.\n * \n * Some tests run a load test as a means of getting the machine to do some work.\n * Typically running it to represent an application that does some work, so that\n * another application can do some sort of monitoring. A total run time can be \n * set by using the setTimeLimit() method. Tests are started until the time limit \n * is reached. The total runtime is going to depend on how long the final test takes. \n *\n * If a load test is started with both a fixed workload and an overall time limit\n * then the load test runs until the first limit is reached.\n *\n * See SampleLoadTest.java for a runnable example.\n */"
    },
    "260": {
      "metadata": {
        "chunk_id": "7334143e3f5cd4d8657b8b9621deeb4294fa3ccc002e65f30bb41e32dd09d0e2",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "public class LoadTestProcessDefinition implements ProcessDefinition {\n    private static final Logger logger = LogManager.getLogger(LoadTestProcessDefinition.class.getName());\n\n  \t// Load test runs Java so this class is really provides a program \n\t// specific interface to the LoadTest class\n\tprivate JavaProcessDefinition javaProcessDefinition;\n\t\n\tprivate StfEnvironmentCore environmentCore;\n\t\n\tprivate String currentSuiteName = null;\n\tprivate boolean haveThreadCount   = false;\n\tprivate boolean haveSeed          = false;\n\tprivate boolean haveInventoryFile = false;\n\tprivate boolean haveRepeatCount   = false;\n\tprivate boolean haveSelectionMode = false;\n\tprivate boolean haveThinkingTime  = false;\n\t\n\t// Keeps track of suite names that have already been used.\n\tprivate HashSet<String> knownSuites = new HashSet<String>();\n\t\n\t// To enforce correct buildup of invocation arguments, all the addition \n\t// methods fall into one of these categories.\n\tprivate enum Stage {\n\t\tJVM_ARGS(1),\n\t\tCLASSPATH(2),\n\t\tCLASS(3),\n\t\tLOAD_TEST_ARGS(4),\n\t\tSUITE(5);\n\t\t\n\t\tprivate int level;\n\t\tStage(int level) { this.level = level; }\n\t}\n\n\t// Holds the category of addition method last used\n\tprivate Stage previousStage = Stage.JVM_ARGS;\n\t\n\t// Keep track of relocated inventory files. \n\t// They are copied from a workspace to the results directory\n\tprivate LinkedHashSet<String> relocatedInventoryFiles = new LinkedHashSet<String>();\n\n\t// Error reporting and abort on failure control\n\tprivate static int DEFAULT_REPORT_FAILURE_LIMIT = 1;\n\tprivate static int DEFAULT_ABORT_AT_FAILURE_LIMIT = 10;\n\tprivate boolean haveReportFailureLimit = false;\n\tprivate boolean haveAbortAtFailureLimit = false;\n\t\n\t// Disk space limits for execution logs\n\tprivate static String DEFAULT_MAX_TOTAL_LOG_FILE_SPACE = \"200M\";\n\tprivate static String DEFAULT_MAX_SINGLE_LOG_SIZE = \"1/25\";\n\tprivate boolean haveMaxTotalLogFileSpace = false;\n\tprivate boolean haveMaxSingleLogSize = false;\n\t\n\t\n\tpublic LoadTestProcessDefinition(StfEnvironmentCore environmentCore, JavaVersion jvm) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tjavaProcessDefinition = new JavaProcessDefinition(environmentCore, jvm);\n\t}\n\n\n\tpublic boolean isJdkProgram() {\n\t\treturn javaProcessDefinition.isJdkProgram();\n\t}\n\t\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn javaProcessDefinition.getJavaVersion();\n\t}\n\t\n\t/**\n\t * Adds a value to be used as a Jvm option. eg, '-Xmx100M'\n\t * @see JavaProcessDefinition.addJvmOption\n\t */\n\tpublic LoadTestProcessDefinition addJvmOption(String... jvmOptions) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.JVM_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addJvmOption(jvmOptions);\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Defines the modules to add to '--add-modules'.\n\t * @param rootModuleName contains a comma separated list of modules. Empty string values are ignored.\n\t */\n\tpublic LoadTestProcessDefinition addModules(String rootModuleName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tif (rootModuleName != null && !rootModuleName.isEmpty()) {\n\t\t\tjavaProcessDefinition.addRootModule(rootModuleName);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds the bin directory of a workspaces project to the classpath.\n\t * @see JavaProcessDefinition.addJvmOption\n\t */\n\tpublic LoadTestProcessDefinition addProjectToClasspath(String projectName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\n\t\tlogger.debug(\"Adding \\\" + projectName + \\\" to classpath\");\n\t\tjavaProcessDefinition.addProjectToClasspath(projectName);\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a known systemtest-prereq jar to the classpath.\n\t */\n\tpublic LoadTestProcessDefinition addPrereqJarToClasspath(JavaProcessDefinition.JarId jarId) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);",
        "start_line": 83,
        "end_line": 195,
        "chunk_index": 1,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 829,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257921"
      },
      "text": "public class LoadTestProcessDefinition implements ProcessDefinition {\n    private static final Logger logger = LogManager.getLogger(LoadTestProcessDefinition.class.getName());\n\n  \t// Load test runs Java so this class is really provides a program \n\t// specific interface to the LoadTest class\n\tprivate JavaProcessDefinition javaProcessDefinition;\n\t\n\tprivate StfEnvironmentCore environmentCore;\n\t\n\tprivate String currentSuiteName = null;\n\tprivate boolean haveThreadCount   = false;\n\tprivate boolean haveSeed          = false;\n\tprivate boolean haveInventoryFile = false;\n\tprivate boolean haveRepeatCount   = false;\n\tprivate boolean haveSelectionMode = false;\n\tprivate boolean haveThinkingTime  = false;\n\t\n\t// Keeps track of suite names that have already been used.\n\tprivate HashSet<String> knownSuites = new HashSet<String>();\n\t\n\t// To enforce correct buildup of invocation arguments, all the addition \n\t// methods fall into one of these categories.\n\tprivate enum Stage {\n\t\tJVM_ARGS(1),\n\t\tCLASSPATH(2),\n\t\tCLASS(3),\n\t\tLOAD_TEST_ARGS(4),\n\t\tSUITE(5);\n\t\t\n\t\tprivate int level;\n\t\tStage(int level) { this.level = level; }\n\t}\n\n\t// Holds the category of addition method last used\n\tprivate Stage previousStage = Stage.JVM_ARGS;\n\t\n\t// Keep track of relocated inventory files. \n\t// They are copied from a workspace to the results directory\n\tprivate LinkedHashSet<String> relocatedInventoryFiles = new LinkedHashSet<String>();\n\n\t// Error reporting and abort on failure control\n\tprivate static int DEFAULT_REPORT_FAILURE_LIMIT = 1;\n\tprivate static int DEFAULT_ABORT_AT_FAILURE_LIMIT = 10;\n\tprivate boolean haveReportFailureLimit = false;\n\tprivate boolean haveAbortAtFailureLimit = false;\n\t\n\t// Disk space limits for execution logs\n\tprivate static String DEFAULT_MAX_TOTAL_LOG_FILE_SPACE = \"200M\";\n\tprivate static String DEFAULT_MAX_SINGLE_LOG_SIZE = \"1/25\";\n\tprivate boolean haveMaxTotalLogFileSpace = false;\n\tprivate boolean haveMaxSingleLogSize = false;\n\t\n\t\n\tpublic LoadTestProcessDefinition(StfEnvironmentCore environmentCore, JavaVersion jvm) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tjavaProcessDefinition = new JavaProcessDefinition(environmentCore, jvm);\n\t}\n\n\n\tpublic boolean isJdkProgram() {\n\t\treturn javaProcessDefinition.isJdkProgram();\n\t}\n\t\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn javaProcessDefinition.getJavaVersion();\n\t}\n\t\n\t/**\n\t * Adds a value to be used as a Jvm option. eg, '-Xmx100M'\n\t * @see JavaProcessDefinition.addJvmOption\n\t */\n\tpublic LoadTestProcessDefinition addJvmOption(String... jvmOptions) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.JVM_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addJvmOption(jvmOptions);\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Defines the modules to add to '--add-modules'.\n\t * @param rootModuleName contains a comma separated list of modules. Empty string values are ignored.\n\t */\n\tpublic LoadTestProcessDefinition addModules(String rootModuleName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tif (rootModuleName != null && !rootModuleName.isEmpty()) {\n\t\t\tjavaProcessDefinition.addRootModule(rootModuleName);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds the bin directory of a workspaces project to the classpath.\n\t * @see JavaProcessDefinition.addJvmOption\n\t */\n\tpublic LoadTestProcessDefinition addProjectToClasspath(String projectName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\n\t\tlogger.debug(\"Adding \\\" + projectName + \\\" to classpath\");\n\t\tjavaProcessDefinition.addProjectToClasspath(projectName);\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a known systemtest-prereq jar to the classpath.\n\t */\n\tpublic LoadTestProcessDefinition addPrereqJarToClasspath(JavaProcessDefinition.JarId jarId) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);"
    },
    "261": {
      "metadata": {
        "chunk_id": "313ae412aca0a8ac95d61bcb83fccda1457546820abd7c7b318b3f38077b7c23",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "logger.debug(\"Adding \\\" + projectName + \\\" to classpath\");\n\t\tjavaProcessDefinition.addProjectToClasspath(projectName);\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a known systemtest-prereq jar to the classpath.\n\t */\n\tpublic LoadTestProcessDefinition addPrereqJarToClasspath(JavaProcessDefinition.JarId jarId) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\n\t\tjavaProcessDefinition.addPrereqJarToClasspath(jarId);\n\t\t\n\t\treturn this;\n\t}\n\t\t\n\t/**\n\t * Adds a jar file to the classpath.\n\t */\n\tpublic LoadTestProcessDefinition addJarToClasspath(FileRef jarReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tjavaProcessDefinition.addJarToClasspath(jarReference);\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds 1 or more directories to the classpath.\n\t */\n\tpublic LoadTestProcessDefinition addDirectoryToClasspath(DirectoryRef... directoryReferences) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tfor (DirectoryRef dirRef : directoryReferences)\n\t\tjavaProcessDefinition.addDirectoryToClasspath(dirRef);\n\n\t\treturn this;\n\t}\n\n\t\n\n\t/**\n\t * Declares the class to be run for this java process.\n\t */\n\tpublic LoadTestProcessDefinition runClass(String javaClassName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASS);\n\n\t\tjavaProcessDefinition.runClass(javaClassName);\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Sets the results directory which load test can write results to.\n\t */\n\tpublic LoadTestProcessDefinition setResultsDir(DirectoryRef resultsDir) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\n\t\t// Use placeholder values to make sure a different output file is created for each execution. Eg '2.SCL1.'\n\t\tString resultsPrefix = PLACEHOLDER_STF_COMMAND_NUMBER + \".\" + PLACEHOLDER_STF_COMMAND_MNEMONIC + PLACEHOLDER_STF_PROCESS_INSTANCE + \".\";\n\n\t\tjavaProcessDefinition.addArg(\"-resultsDir\", resultsDir.getSpec());\n\t\tjavaProcessDefinition.addArg(\"-resultsPrefix\", resultsPrefix);\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Optional method which sets a maximum runtime for the load test.\n\t * If set, then no more tests will be started once the time limit is reached.\n\t * Most test scenarios are best run with a fixed workload (using setSuiteNumTests()), but\n\t * this method can be useful if you need some load to run for a fixed period of time.\n\t * @param limitSpec a String describing the limit. Supports h,m,s units. eg, '45s' or '5m30s' or '1h30m', etc\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setTimeLimit(String limitSpec) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-timeLimit\", limitSpec);\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method which sets a maximum acceptable duration of inactivity \n\t * other than the default which is 15 minutes.\n\t * If set, test will fail after it remains inactive for more than the given limit.\n\t * @param limitSpec a String describing the limit. Supports h,m,s units. eg, '45s' or '5m30s' or '1h30m', etc\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setInactivityLimit(String limitSpec) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-inactivityLimit\", limitSpec);\n\t\t\n\t\treturn this;\n\t}",
        "start_line": 196,
        "end_line": 295,
        "chunk_index": 2,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 787,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257923"
      },
      "text": "logger.debug(\"Adding \\\" + projectName + \\\" to classpath\");\n\t\tjavaProcessDefinition.addProjectToClasspath(projectName);\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a known systemtest-prereq jar to the classpath.\n\t */\n\tpublic LoadTestProcessDefinition addPrereqJarToClasspath(JavaProcessDefinition.JarId jarId) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\n\t\tjavaProcessDefinition.addPrereqJarToClasspath(jarId);\n\t\t\n\t\treturn this;\n\t}\n\t\t\n\t/**\n\t * Adds a jar file to the classpath.\n\t */\n\tpublic LoadTestProcessDefinition addJarToClasspath(FileRef jarReference) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tjavaProcessDefinition.addJarToClasspath(jarReference);\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Adds 1 or more directories to the classpath.\n\t */\n\tpublic LoadTestProcessDefinition addDirectoryToClasspath(DirectoryRef... directoryReferences) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASSPATH);\n\t\t\n\t\tfor (DirectoryRef dirRef : directoryReferences)\n\t\tjavaProcessDefinition.addDirectoryToClasspath(dirRef);\n\n\t\treturn this;\n\t}\n\n\t\n\n\t/**\n\t * Declares the class to be run for this java process.\n\t */\n\tpublic LoadTestProcessDefinition runClass(String javaClassName) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.CLASS);\n\n\t\tjavaProcessDefinition.runClass(javaClassName);\n\t\t\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t * Sets the results directory which load test can write results to.\n\t */\n\tpublic LoadTestProcessDefinition setResultsDir(DirectoryRef resultsDir) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\n\t\t// Use placeholder values to make sure a different output file is created for each execution. Eg '2.SCL1.'\n\t\tString resultsPrefix = PLACEHOLDER_STF_COMMAND_NUMBER + \".\" + PLACEHOLDER_STF_COMMAND_MNEMONIC + PLACEHOLDER_STF_PROCESS_INSTANCE + \".\";\n\n\t\tjavaProcessDefinition.addArg(\"-resultsDir\", resultsDir.getSpec());\n\t\tjavaProcessDefinition.addArg(\"-resultsPrefix\", resultsPrefix);\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Optional method which sets a maximum runtime for the load test.\n\t * If set, then no more tests will be started once the time limit is reached.\n\t * Most test scenarios are best run with a fixed workload (using setSuiteNumTests()), but\n\t * this method can be useful if you need some load to run for a fixed period of time.\n\t * @param limitSpec a String describing the limit. Supports h,m,s units. eg, '45s' or '5m30s' or '1h30m', etc\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setTimeLimit(String limitSpec) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-timeLimit\", limitSpec);\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method which sets a maximum acceptable duration of inactivity \n\t * other than the default which is 15 minutes.\n\t * If set, test will fail after it remains inactive for more than the given limit.\n\t * @param limitSpec a String describing the limit. Supports h,m,s units. eg, '45s' or '5m30s' or '1h30m', etc\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setInactivityLimit(String limitSpec) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-inactivityLimit\", limitSpec);\n\t\t\n\t\treturn this;\n\t}"
    },
    "262": {
      "metadata": {
        "chunk_id": "30d01dea2358625957ea177e14704d2a1d2fbc7fef9868ad42197cf6c5101cf4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "/**\n\t * Optional method which sets the policy when an OutOfMemoryError is detected.\n\t * @param abortIfOOM can be set to true (the default) to abort all worker threads \n\t * as soon as possible after detecting an OutOfMemoryError. The threads will complete \n\t * their current test before exiting.\n\t * It set to false then the LoadTest will not abort on OOM. ie, it will do its best to \n\t * continue until the workload is complete.\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setAbortIfOutOfMemory(boolean abortIfOOM) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-abortIfOutOfMemory\", Boolean.toString(abortIfOOM));\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method which sets the flag to trigger core dumps to be generated after first failure\n\t * is detected in a load test run.\n\t * @param dumpRequested can be set to true (default is false) to trigger dump generation \n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition generateCoreDumpAtFirstLoadTestFailure(boolean dumpRequested) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-dumpRequested\", Boolean.toString(dumpRequested));\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method which controls how many test failures are reported in detail, with \n\t * a description of the failing test case and a stack trace, etc.\n\t * Once the reporting limit is reached load test prints out a single line to say that a failure\n\t * has been detected but doesn't provide any further information. \n\t * \n\t * @param reportFailureLimit is the number of failures to be reported in detail. Defaults to 1. \n\t * Set to '-1' to disable, causing all test failures to be reported in detail.\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setReportFailureLimit(int reportFailureLimit) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-reportFailureLimit\", Integer.toString(reportFailureLimit));\n\t\thaveReportFailureLimit = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Optional method which sets the number of test failures which load test \n\t * allows before aborting a test run. \n\t * \n\t * @param abortAtFailureLimit is the maximum number of failures before load test \n\t * will abort a run. Set to '-1' to disable, so that load test never aborts a run.\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setAbortAtFailureLimit(int abortAtFailureLimit) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-abortAtFailureLimit\", Integer.toString(abortAtFailureLimit));\n\t\thaveAbortAtFailureLimit = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method to specify amount of disk space allocated to load test \n\t * execution logs (to record start+end of each test invocation)\n\t * @param size is a string in the form '<size>[g|G|m|M|k|K]', eg '250M' or '1G'\n\t * @return Update load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setMaxTotalLogFileSpace(String size) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\n\t\tjavaProcessDefinition.addArg(\"-maxTotalLogFileSpace\", size);\n\t\thaveMaxTotalLogFileSpace = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method to specify maximum amount of disk space used for a\n\t * single execution logs.\n\t * @param size is a string in the form '<size>[g|G|m|M|k|K] | 1/<number>', \n\t * eg '250M' or '1G' for a fixed size,\n\t * or '1/50' to divide the maxTotalLogFileSpace into 50 parts. \n\t * @return Update load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setMaxSingleLogSize(String size) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);",
        "start_line": 296,
        "end_line": 387,
        "chunk_index": 3,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 917,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257925"
      },
      "text": "/**\n\t * Optional method which sets the policy when an OutOfMemoryError is detected.\n\t * @param abortIfOOM can be set to true (the default) to abort all worker threads \n\t * as soon as possible after detecting an OutOfMemoryError. The threads will complete \n\t * their current test before exiting.\n\t * It set to false then the LoadTest will not abort on OOM. ie, it will do its best to \n\t * continue until the workload is complete.\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setAbortIfOutOfMemory(boolean abortIfOOM) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-abortIfOutOfMemory\", Boolean.toString(abortIfOOM));\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method which sets the flag to trigger core dumps to be generated after first failure\n\t * is detected in a load test run.\n\t * @param dumpRequested can be set to true (default is false) to trigger dump generation \n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition generateCoreDumpAtFirstLoadTestFailure(boolean dumpRequested) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-dumpRequested\", Boolean.toString(dumpRequested));\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method which controls how many test failures are reported in detail, with \n\t * a description of the failing test case and a stack trace, etc.\n\t * Once the reporting limit is reached load test prints out a single line to say that a failure\n\t * has been detected but doesn't provide any further information. \n\t * \n\t * @param reportFailureLimit is the number of failures to be reported in detail. Defaults to 1. \n\t * Set to '-1' to disable, causing all test failures to be reported in detail.\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setReportFailureLimit(int reportFailureLimit) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-reportFailureLimit\", Integer.toString(reportFailureLimit));\n\t\thaveReportFailureLimit = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Optional method which sets the number of test failures which load test \n\t * allows before aborting a test run. \n\t * \n\t * @param abortAtFailureLimit is the maximum number of failures before load test \n\t * will abort a run. Set to '-1' to disable, so that load test never aborts a run.\n\t * @return Updated load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setAbortAtFailureLimit(int abortAtFailureLimit) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\t\t\n\t\tjavaProcessDefinition.addArg(\"-abortAtFailureLimit\", Integer.toString(abortAtFailureLimit));\n\t\thaveAbortAtFailureLimit = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method to specify amount of disk space allocated to load test \n\t * execution logs (to record start+end of each test invocation)\n\t * @param size is a string in the form '<size>[g|G|m|M|k|K]', eg '250M' or '1G'\n\t * @return Update load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setMaxTotalLogFileSpace(String size) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\n\t\tjavaProcessDefinition.addArg(\"-maxTotalLogFileSpace\", size);\n\t\thaveMaxTotalLogFileSpace = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method to specify maximum amount of disk space used for a\n\t * single execution logs.\n\t * @param size is a string in the form '<size>[g|G|m|M|k|K] | 1/<number>', \n\t * eg '250M' or '1G' for a fixed size,\n\t * or '1/50' to divide the maxTotalLogFileSpace into 50 parts. \n\t * @return Update load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setMaxSingleLogSize(String size) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);"
    },
    "263": {
      "metadata": {
        "chunk_id": "298167e7f0dc3812d0593f7fdf3313f8535dbe03568cd2f69c9aa398c5e6b315",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "javaProcessDefinition.addArg(\"-maxTotalLogFileSpace\", size);\n\t\thaveMaxTotalLogFileSpace = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method to specify maximum amount of disk space used for a\n\t * single execution logs.\n\t * @param size is a string in the form '<size>[g|G|m|M|k|K] | 1/<number>', \n\t * eg '250M' or '1G' for a fixed size,\n\t * or '1/50' to divide the maxTotalLogFileSpace into 50 parts. \n\t * @return Update load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setMaxSingleLogSize(String size) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\n\t\tjavaProcessDefinition.addArg(\"-maxSingleLogSize\", size);\n\t\thaveMaxSingleLogSize = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Tell the load test process definition that you want supply arguments for the numbered suite.\n\t * Suite numbers start at 0 and must be sequential. \n\t */\n\tpublic LoadTestProcessDefinition addSuite(String suiteName) throws StfException {\n\t\t// Supply defaults for error handling\n\t\tif (!haveReportFailureLimit) {\n\t\t\tsetReportFailureLimit(DEFAULT_REPORT_FAILURE_LIMIT);\n\t\t}\n\t\tif (!haveAbortAtFailureLimit) {\n\t\t\tsetAbortAtFailureLimit(DEFAULT_ABORT_AT_FAILURE_LIMIT);\n\t\t}\n\t\t\n\t\t// Supply log space defaults if not already set\n\t\tif (!haveMaxTotalLogFileSpace) {\n\t\t\tsetMaxTotalLogFileSpace(DEFAULT_MAX_TOTAL_LOG_FILE_SPACE);\n\t\t}\n\t\tif (!haveMaxSingleLogSize) {\n\t\t\tsetMaxSingleLogSize(DEFAULT_MAX_SINGLE_LOG_SIZE);\n\t\t}\n\t\t\n\t\tcheckAndUpdateLevel(Stage.SUITE);\n\n\t\t// Make sure the suite name doesn't have any characters that would break perl\n\t\tScanner suiteScanner = new Scanner(suiteName);        \n\t    String validationResult = suiteScanner.findInLine(\"[ \\t\\r\\n\\\\\\\"'.,]\");\n\t    suiteScanner.close();\n\t    if (validationResult != null) {\n\t        throw new StfException(\"Invalid suite name: '\" + suiteName + \"'. It cannot contain white space, slash or quote characters\");\n\t    }\n\t    \n\t    if (!knownSuites.isEmpty()) {\n\t\t\tvalidateSuiteArgs();  // validate the arguments of previous suite\n\t\t}\n\t\tif (knownSuites.contains(suiteName)) {\n\t\t\tthrow new StfException(\"Suite name not unique: \" + suiteName);\n\t\t}\n\t\tknownSuites.add(suiteName);\n\t\tthis.currentSuiteName = suiteName;\n\t\t\n\t\thaveThreadCount   = false;\n\t\thaveSeed          = false;\n\t\thaveInventoryFile = false;\n\t\thaveRepeatCount   = false;\n\t\thaveSelectionMode = false;\n\t\thaveThinkingTime  = false;\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Mandatory method which sets the number of threads for the current suite.\n\t * @param threadCount is the number of threads to use.\n\t * @return Updated process definition.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteThreadCount(int threadCount) throws StfException {\n\t\toutputSuiteArg(\"threadCount\", Integer.toString(threadCount));\n\t\thaveThreadCount = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Convenience method which sets the thread count but won't allow it below a minimum value.\n\t * @param threadCount is a calculated value for the number of threads.\n\t * @param minThreadCount is the minimum number of threads that will be used.\n\t * @return Updated process definition.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteThreadCount(int threadCount, int minThreadCount) throws StfException {\n\t\tint actualThreadCount = Math.max(threadCount, minThreadCount);\n\t\treturn setSuiteThreadCount(actualThreadCount);\n\t}",
        "start_line": 388,
        "end_line": 483,
        "chunk_index": 4,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 807,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257928"
      },
      "text": "javaProcessDefinition.addArg(\"-maxTotalLogFileSpace\", size);\n\t\thaveMaxTotalLogFileSpace = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method to specify maximum amount of disk space used for a\n\t * single execution logs.\n\t * @param size is a string in the form '<size>[g|G|m|M|k|K] | 1/<number>', \n\t * eg '250M' or '1G' for a fixed size,\n\t * or '1/50' to divide the maxTotalLogFileSpace into 50 parts. \n\t * @return Update load test process definition.\n\t */\n\tpublic LoadTestProcessDefinition setMaxSingleLogSize(String size) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.LOAD_TEST_ARGS);\n\n\t\tjavaProcessDefinition.addArg(\"-maxSingleLogSize\", size);\n\t\thaveMaxSingleLogSize = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Tell the load test process definition that you want supply arguments for the numbered suite.\n\t * Suite numbers start at 0 and must be sequential. \n\t */\n\tpublic LoadTestProcessDefinition addSuite(String suiteName) throws StfException {\n\t\t// Supply defaults for error handling\n\t\tif (!haveReportFailureLimit) {\n\t\t\tsetReportFailureLimit(DEFAULT_REPORT_FAILURE_LIMIT);\n\t\t}\n\t\tif (!haveAbortAtFailureLimit) {\n\t\t\tsetAbortAtFailureLimit(DEFAULT_ABORT_AT_FAILURE_LIMIT);\n\t\t}\n\t\t\n\t\t// Supply log space defaults if not already set\n\t\tif (!haveMaxTotalLogFileSpace) {\n\t\t\tsetMaxTotalLogFileSpace(DEFAULT_MAX_TOTAL_LOG_FILE_SPACE);\n\t\t}\n\t\tif (!haveMaxSingleLogSize) {\n\t\t\tsetMaxSingleLogSize(DEFAULT_MAX_SINGLE_LOG_SIZE);\n\t\t}\n\t\t\n\t\tcheckAndUpdateLevel(Stage.SUITE);\n\n\t\t// Make sure the suite name doesn't have any characters that would break perl\n\t\tScanner suiteScanner = new Scanner(suiteName);        \n\t    String validationResult = suiteScanner.findInLine(\"[ \\t\\r\\n\\\\\\\"'.,]\");\n\t    suiteScanner.close();\n\t    if (validationResult != null) {\n\t        throw new StfException(\"Invalid suite name: '\" + suiteName + \"'. It cannot contain white space, slash or quote characters\");\n\t    }\n\t    \n\t    if (!knownSuites.isEmpty()) {\n\t\t\tvalidateSuiteArgs();  // validate the arguments of previous suite\n\t\t}\n\t\tif (knownSuites.contains(suiteName)) {\n\t\t\tthrow new StfException(\"Suite name not unique: \" + suiteName);\n\t\t}\n\t\tknownSuites.add(suiteName);\n\t\tthis.currentSuiteName = suiteName;\n\t\t\n\t\thaveThreadCount   = false;\n\t\thaveSeed          = false;\n\t\thaveInventoryFile = false;\n\t\thaveRepeatCount   = false;\n\t\thaveSelectionMode = false;\n\t\thaveThinkingTime  = false;\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Mandatory method which sets the number of threads for the current suite.\n\t * @param threadCount is the number of threads to use.\n\t * @return Updated process definition.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteThreadCount(int threadCount) throws StfException {\n\t\toutputSuiteArg(\"threadCount\", Integer.toString(threadCount));\n\t\thaveThreadCount = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Convenience method which sets the thread count but won't allow it below a minimum value.\n\t * @param threadCount is a calculated value for the number of threads.\n\t * @param minThreadCount is the minimum number of threads that will be used.\n\t * @return Updated process definition.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteThreadCount(int threadCount, int minThreadCount) throws StfException {\n\t\tint actualThreadCount = Math.max(threadCount, minThreadCount);\n\t\treturn setSuiteThreadCount(actualThreadCount);\n\t}"
    },
    "264": {
      "metadata": {
        "chunk_id": "d7698badeb258ed67f08d33d12a9daca8c826c48ea15398cabdcabe5d260d370",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "/**\n\t * Convenience method which sets the thread count but won't allow it below a minimum value.\n\t * @param threadCount is a calculated value for the number of threads.\n\t * @param minThreadCount is the minimum number of threads that will be used.\n\t * @return Updated process definition.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteThreadCount(int threadCount, int minThreadCount) throws StfException {\n\t\tint actualThreadCount = Math.max(threadCount, minThreadCount);\n\t\treturn setSuiteThreadCount(actualThreadCount);\n\t}\n\n\t/**\n\t * Convenience method for setting thread count within min and max limits.\n\t * @param threadCount is expected to be the number of available cores minus 1 or 2\n\t * to account for the JIT/GC or more suites.\n\t * @param minThreadCount is the minimum number of threads that will be used.\n\t * @param maxThreadCount is the maximum number of threads that will be used.\n\t * @return Updated process definition.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteThreadCount(int threadCount, int minThreadCount, int maxThreadCount) throws StfException {\n\t\tint actualThreadCount = threadCount;\n\t\tif (threadCount < minThreadCount) {\n\t\t\tactualThreadCount = minThreadCount;\n\t\t} else if (threadCount > maxThreadCount) {\n\t\t\tactualThreadCount = maxThreadCount;\n\t\t}\n\n\t\treturn setSuiteThreadCount(actualThreadCount);\n\t}\n\n\t\n\t/**\n\t * Optional method to set the seed for the suites random number generator.\n\t * If not called then a new seed will be used for the run.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteSeed(long seed) throws StfException {\n\t\toutputSuiteArg(\"seed\", Long.toString(seed));\n\t\thaveSeed = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * Mandatory method which specifies a file listing the tests to be used.\n\t * @param inventoryFileRef points to an inventory file to use for the load test.\n\t * The reference of the inventory file is relative to one of the test-roots.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteInventory(String inventoryFileRef) throws StfException {\n\t\tArrayList<DirectoryRef> testRoots = environmentCore.getTestRoots();\n\t\tif (!inventoryFileRef.startsWith(\"/\")) {\n\t\t\tthrow new StfException(\"inventory file name must start with a '/' to indicate a file below the root directory. Inventory=\" + inventoryFileRef);\n\t\t}\n\t\t\n\t\t// We want the generated command to use an inventory file in the results\n\t\t// directory (to allow easy hacking at runtime).\n\t\t// The implications of this are:\n\t\t//   1) The generated command needs to reference a file in the results dir.\n\t\t//   2) We need to copy the inventory file to the results dir (done in generationComplete() \n\t\t//      once we know the command number and mnemonic)\n\t\tFileRef newInventoryFile = calculateRelocatedInventoryFile(inventoryFileRef);\n\t\toutputSuiteArg(\"inventoryFile\", newInventoryFile.getSpec());\n\n\t\t// Build a list of all inventory files which are going to be used.\n\t\tArrayList<String> allInventoryFiles = new ArrayList<String>();\n\t\tfindAllInventoryFiles(allInventoryFiles, testRoots, inventoryFileRef);\n\t\t\n\t\trelocatedInventoryFiles.addAll(allInventoryFiles);\n\t\thaveInventoryFile = true;\n\t\t\n\t\t// Find the full set of exclusion files\n\t\tArrayList<String> allExcludeFiles = new ArrayList<String>();\n\t\tfor (String inv : allInventoryFiles) {\n\t\t\t// See if the current inventoryFile has any exclude files\n\t\t\tArrayList<String> excludeFiles = LoadTestProcessDefinition.findExclusionFiles(testRoots, inv);\n\t\t\tallExcludeFiles.addAll(excludeFiles);\n\t\t}\n\n\t\t// Output load test argument to describe the exclude files for the current suite\n\t\tif (!allExcludeFiles.isEmpty()) {\n\t\t\tfor (String excludeFileRef : allExcludeFiles) {\n\t\t\t\tFileRef relocatedExcludeFile = calculateRelocatedInventoryFile(excludeFileRef);\n\t\t\t\toutputSuiteArg(\"inventoryExcludeFile\", relocatedExcludeFile.getSpec());\n\t\t\t}\n\t\t} else {\n\t\t\toutputSuiteArg(\"inventoryExcludeFile\", \"none\");\n\t\t}\n\t\t\n\t\t// Make sure all the exclude files get copied to the results dir\n\t\trelocatedInventoryFiles.addAll(allExcludeFiles);",
        "start_line": 484,
        "end_line": 573,
        "chunk_index": 5,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 917,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257930"
      },
      "text": "/**\n\t * Convenience method which sets the thread count but won't allow it below a minimum value.\n\t * @param threadCount is a calculated value for the number of threads.\n\t * @param minThreadCount is the minimum number of threads that will be used.\n\t * @return Updated process definition.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteThreadCount(int threadCount, int minThreadCount) throws StfException {\n\t\tint actualThreadCount = Math.max(threadCount, minThreadCount);\n\t\treturn setSuiteThreadCount(actualThreadCount);\n\t}\n\n\t/**\n\t * Convenience method for setting thread count within min and max limits.\n\t * @param threadCount is expected to be the number of available cores minus 1 or 2\n\t * to account for the JIT/GC or more suites.\n\t * @param minThreadCount is the minimum number of threads that will be used.\n\t * @param maxThreadCount is the maximum number of threads that will be used.\n\t * @return Updated process definition.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteThreadCount(int threadCount, int minThreadCount, int maxThreadCount) throws StfException {\n\t\tint actualThreadCount = threadCount;\n\t\tif (threadCount < minThreadCount) {\n\t\t\tactualThreadCount = minThreadCount;\n\t\t} else if (threadCount > maxThreadCount) {\n\t\t\tactualThreadCount = maxThreadCount;\n\t\t}\n\n\t\treturn setSuiteThreadCount(actualThreadCount);\n\t}\n\n\t\n\t/**\n\t * Optional method to set the seed for the suites random number generator.\n\t * If not called then a new seed will be used for the run.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteSeed(long seed) throws StfException {\n\t\toutputSuiteArg(\"seed\", Long.toString(seed));\n\t\thaveSeed = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * Mandatory method which specifies a file listing the tests to be used.\n\t * @param inventoryFileRef points to an inventory file to use for the load test.\n\t * The reference of the inventory file is relative to one of the test-roots.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteInventory(String inventoryFileRef) throws StfException {\n\t\tArrayList<DirectoryRef> testRoots = environmentCore.getTestRoots();\n\t\tif (!inventoryFileRef.startsWith(\"/\")) {\n\t\t\tthrow new StfException(\"inventory file name must start with a '/' to indicate a file below the root directory. Inventory=\" + inventoryFileRef);\n\t\t}\n\t\t\n\t\t// We want the generated command to use an inventory file in the results\n\t\t// directory (to allow easy hacking at runtime).\n\t\t// The implications of this are:\n\t\t//   1) The generated command needs to reference a file in the results dir.\n\t\t//   2) We need to copy the inventory file to the results dir (done in generationComplete() \n\t\t//      once we know the command number and mnemonic)\n\t\tFileRef newInventoryFile = calculateRelocatedInventoryFile(inventoryFileRef);\n\t\toutputSuiteArg(\"inventoryFile\", newInventoryFile.getSpec());\n\n\t\t// Build a list of all inventory files which are going to be used.\n\t\tArrayList<String> allInventoryFiles = new ArrayList<String>();\n\t\tfindAllInventoryFiles(allInventoryFiles, testRoots, inventoryFileRef);\n\t\t\n\t\trelocatedInventoryFiles.addAll(allInventoryFiles);\n\t\thaveInventoryFile = true;\n\t\t\n\t\t// Find the full set of exclusion files\n\t\tArrayList<String> allExcludeFiles = new ArrayList<String>();\n\t\tfor (String inv : allInventoryFiles) {\n\t\t\t// See if the current inventoryFile has any exclude files\n\t\t\tArrayList<String> excludeFiles = LoadTestProcessDefinition.findExclusionFiles(testRoots, inv);\n\t\t\tallExcludeFiles.addAll(excludeFiles);\n\t\t}\n\n\t\t// Output load test argument to describe the exclude files for the current suite\n\t\tif (!allExcludeFiles.isEmpty()) {\n\t\t\tfor (String excludeFileRef : allExcludeFiles) {\n\t\t\t\tFileRef relocatedExcludeFile = calculateRelocatedInventoryFile(excludeFileRef);\n\t\t\t\toutputSuiteArg(\"inventoryExcludeFile\", relocatedExcludeFile.getSpec());\n\t\t\t}\n\t\t} else {\n\t\t\toutputSuiteArg(\"inventoryExcludeFile\", \"none\");\n\t\t}\n\t\t\n\t\t// Make sure all the exclude files get copied to the results dir\n\t\trelocatedInventoryFiles.addAll(allExcludeFiles);"
    },
    "265": {
      "metadata": {
        "chunk_id": "a98fc01809cec8af13d0605c4f2cce01232428806b3f6acec0158efa590d8350",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "// Output load test argument to describe the exclude files for the current suite\n\t\tif (!allExcludeFiles.isEmpty()) {\n\t\t\tfor (String excludeFileRef : allExcludeFiles) {\n\t\t\t\tFileRef relocatedExcludeFile = calculateRelocatedInventoryFile(excludeFileRef);\n\t\t\t\toutputSuiteArg(\"inventoryExcludeFile\", relocatedExcludeFile.getSpec());\n\t\t\t}\n\t\t} else {\n\t\t\toutputSuiteArg(\"inventoryExcludeFile\", \"none\");\n\t\t}\n\t\t\n\t\t// Make sure all the exclude files get copied to the results dir\n\t\trelocatedInventoryFiles.addAll(allExcludeFiles);\n\n\t\tlogger.debug(\"Inventory files to copy:\");\n\t\tfor (String relFile : relocatedInventoryFiles) {\n\t\t\tlogger.debug(\"  \" + relFile);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\t// This method recursively finds all inventory files. \n\t// It starts with an initial inventory file and follows all 'include references'.\n\t// It uses a bare bones parser to skim the file and follow the includes. InventoryData.java does the real parsing.\n\t// @param allInventoryFiles is the discovered list of all used inventory files.\n\t// @param testRoots is the list of tests root directories which may contain inventory file references.\n\t// @param inventoryFileRef is the location of an inventoryFile below one of the testRoots.\n\tprivate void findAllInventoryFiles(ArrayList<String> allInventoryFiles, ArrayList<DirectoryRef> testRoots, String inventoryFileRef) throws StfException {\n\t\tallInventoryFiles.add(inventoryFileRef);\n\t\t\n\t\t// Find and validate inventory file.\n\t\tFile inventoryFile = FileRef.findFile(inventoryFileRef,testRoots).asJavaFile();\n\t\t\n\t\t// Open inventory file as xml document\n\t\tDocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n\t\tDocument doc;\n\t\ttry {\n\t\t\tdoc = dbFactory.newDocumentBuilder().parse(inventoryFile);\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to parse file:\" + inventoryFile.getAbsolutePath(), e);\n\t\t}\n\t\t\n\t\t// Process every top level 'inventory' node\n\t\tfor (int i = 0; i < doc.getChildNodes().getLength(); i++) {\n\t\t\tNode inventoryNode = doc.getChildNodes().item(i);\n\t\t\tif (!inventoryNode.getNodeName().equals(\"inventory\") && !inventoryNode.getNodeName().equals(\"#comment\")) {\n\t\t\t\tthrow new IllegalStateException(\"Expected 'inventory' node but was '\" + inventoryNode.getNodeName());\n\t\t\t}\n\n\t\t\t// Parse inventory content. Expecting a list of tests\n\t\t\tNodeList testNodes = inventoryNode.getChildNodes();\n\t\t\tfor (int j=0; j<testNodes.getLength(); j++) {\n\t\t\t\tNode testNode = testNodes.item(j);\n\t\t\t\tif (testNode.getNodeType() == Node.TEXT_NODE || testNode.getNodeType() == Node.COMMENT_NODE) {\n\t\t\t\t\tcontinue;  // Ignore text and comment nodes\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (testNode.getNodeName().equals(\"include\")) {\n\t\t\t\t\tNode includeInventoryNode = testNode.getAttributes().getNamedItem(\"inventory\");\n\t\t\t\t\tif (includeInventoryNode == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Failed to find mandatory 'inventory' attribute for include node. Child index: \" + j + \" in file: \" + inventoryFileRef);\n\t\t\t\t\t}\n\t\t\t\t\tString includeFileName = includeInventoryNode.getNodeValue();\n\t\t\t\t\tif (!includeFileName.startsWith(\"/\")) {\n\t\t\t\t\t\tthrow new StfException(\"Included inventory file must start with a '/' to indicate a file below the root directory. Inventory: \" + inventoryFile + \" is attempting to include: \" + includeFileName);\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFileRef.findFile(includeFileName,testRoots).asJavaFile();\n\t\t\t\t\t} catch (StfException e) {\t\n\t\t\t\t\t\tthrow new StfException(\"Inventory file '\" + inventoryFile + \"' is attempting to include file '\" + includeFileName + \"', but failed. This attempt resulted in this error: \" + e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\tfindAllInventoryFiles(allInventoryFiles, testRoots, includeFileName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 574,
        "end_line": 650,
        "chunk_index": 6,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 844,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257932"
      },
      "text": "// Output load test argument to describe the exclude files for the current suite\n\t\tif (!allExcludeFiles.isEmpty()) {\n\t\t\tfor (String excludeFileRef : allExcludeFiles) {\n\t\t\t\tFileRef relocatedExcludeFile = calculateRelocatedInventoryFile(excludeFileRef);\n\t\t\t\toutputSuiteArg(\"inventoryExcludeFile\", relocatedExcludeFile.getSpec());\n\t\t\t}\n\t\t} else {\n\t\t\toutputSuiteArg(\"inventoryExcludeFile\", \"none\");\n\t\t}\n\t\t\n\t\t// Make sure all the exclude files get copied to the results dir\n\t\trelocatedInventoryFiles.addAll(allExcludeFiles);\n\n\t\tlogger.debug(\"Inventory files to copy:\");\n\t\tfor (String relFile : relocatedInventoryFiles) {\n\t\t\tlogger.debug(\"  \" + relFile);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\t// This method recursively finds all inventory files. \n\t// It starts with an initial inventory file and follows all 'include references'.\n\t// It uses a bare bones parser to skim the file and follow the includes. InventoryData.java does the real parsing.\n\t// @param allInventoryFiles is the discovered list of all used inventory files.\n\t// @param testRoots is the list of tests root directories which may contain inventory file references.\n\t// @param inventoryFileRef is the location of an inventoryFile below one of the testRoots.\n\tprivate void findAllInventoryFiles(ArrayList<String> allInventoryFiles, ArrayList<DirectoryRef> testRoots, String inventoryFileRef) throws StfException {\n\t\tallInventoryFiles.add(inventoryFileRef);\n\t\t\n\t\t// Find and validate inventory file.\n\t\tFile inventoryFile = FileRef.findFile(inventoryFileRef,testRoots).asJavaFile();\n\t\t\n\t\t// Open inventory file as xml document\n\t\tDocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n\t\tDocument doc;\n\t\ttry {\n\t\t\tdoc = dbFactory.newDocumentBuilder().parse(inventoryFile);\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to parse file:\" + inventoryFile.getAbsolutePath(), e);\n\t\t}\n\t\t\n\t\t// Process every top level 'inventory' node\n\t\tfor (int i = 0; i < doc.getChildNodes().getLength(); i++) {\n\t\t\tNode inventoryNode = doc.getChildNodes().item(i);\n\t\t\tif (!inventoryNode.getNodeName().equals(\"inventory\") && !inventoryNode.getNodeName().equals(\"#comment\")) {\n\t\t\t\tthrow new IllegalStateException(\"Expected 'inventory' node but was '\" + inventoryNode.getNodeName());\n\t\t\t}\n\n\t\t\t// Parse inventory content. Expecting a list of tests\n\t\t\tNodeList testNodes = inventoryNode.getChildNodes();\n\t\t\tfor (int j=0; j<testNodes.getLength(); j++) {\n\t\t\t\tNode testNode = testNodes.item(j);\n\t\t\t\tif (testNode.getNodeType() == Node.TEXT_NODE || testNode.getNodeType() == Node.COMMENT_NODE) {\n\t\t\t\t\tcontinue;  // Ignore text and comment nodes\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (testNode.getNodeName().equals(\"include\")) {\n\t\t\t\t\tNode includeInventoryNode = testNode.getAttributes().getNamedItem(\"inventory\");\n\t\t\t\t\tif (includeInventoryNode == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Failed to find mandatory 'inventory' attribute for include node. Child index: \" + j + \" in file: \" + inventoryFileRef);\n\t\t\t\t\t}\n\t\t\t\t\tString includeFileName = includeInventoryNode.getNodeValue();\n\t\t\t\t\tif (!includeFileName.startsWith(\"/\")) {\n\t\t\t\t\t\tthrow new StfException(\"Included inventory file must start with a '/' to indicate a file below the root directory. Inventory: \" + inventoryFile + \" is attempting to include: \" + includeFileName);\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFileRef.findFile(includeFileName,testRoots).asJavaFile();\n\t\t\t\t\t} catch (StfException e) {\t\n\t\t\t\t\t\tthrow new StfException(\"Inventory file '\" + inventoryFile + \"' is attempting to include file '\" + includeFileName + \"', but failed. This attempt resulted in this error: \" + e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\tfindAllInventoryFiles(allInventoryFiles, testRoots, includeFileName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
    },
    "266": {
      "metadata": {
        "chunk_id": "fd843ffa9ed7dd5548a5d80ce54d79107fda6636df71916cf7ea801d907f997b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "// Work out where the given inventory file will be once it has been copied to the results directory\n\tprivate FileRef calculateRelocatedInventoryFile(String inventoryFileRef) throws StfException {\n\t\t// Create the name of the directory to copy inventory files to, eg, 1.LT.inventory\n\t\tString inventoryDirName = PLACEHOLDER_STF_COMMAND_NUMBER + \".\" + PLACEHOLDER_STF_COMMAND_MNEMONIC + \".\" + StfConstants.INVENTORY_DIR_SUFFIX; \n\t\tFileRef newInventoryFile = environmentCore.getResultsDir().childDirectory(inventoryDirName).childFile(inventoryFileRef);\n\t\treturn newInventoryFile;\n\t}\n\n\t/**\n\t * Optional method which controls how many tests are to be run for this suite.\n\t * Worker threads will run tests until the supplied number of tests have been started.\n\t * If this value is not specified then the load test runs until the time limit\n\t * specified by setTimeLimit().\n\t * \n\t * For example, if the inventory file contains tests A,B,C,D,E. \n\t * Then randomly executing 4 tests may run B,E,A,E or A,C,B,B.\n\t * Sequentially executing 4 tests will always run A,B,C,D \n\t * Sequentially executing 7 tests would run A,B,C,D,E,A,B\n\t * If the repetition count is to 2 then sequentially executing 7 tests would run A,A,B,B,C,C,D\n\t */\n\tpublic LoadTestProcessDefinition setSuiteNumTests(int numTests) throws StfException {\n\t\toutputSuiteArg(\"totalNumberTests\", Integer.toString(numTests));\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method which sets how many times each test will be run before the selection \n\t * of the the next text.\n\t * If not supplied then the default of '1' is used. ie. run a test once before \n\t * picking the next test.\n\t * There is no interaction of this value with the setSuiteNumTests value. For example,\n\t * if we are running 9 randomly selected tests with a repeat count of 4, then we may \n\t * execute test numbers: C,C,C,C,A,A,A,A,D \n\t */\n\tpublic LoadTestProcessDefinition setSuiteTestRepeatCount(int repeatCount) throws StfException {\n\t\toutputSuiteArg(\"repeatCount\", Integer.toString(repeatCount));\n\t\thaveRepeatCount = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the amount of time which each load test thread should wait between executing \n\t * successive tests of the current suite. \n\t * Each load test thread has it's own random number generator which picks a pause \n\t * time between the specified min and max times. \n\t * The min and max can be set to the same value for a fixed delay.\n\t * If not set then min and max default to zero, which means that the load test thread \n\t * will not sleep between tests.  \n\t * @param minThinkingTime The minimum sleep time. Supported time units are 'h', 'm', 's' and 'ms'. eg, '100ms1\n\t * @param maxThinkingTime The maximum sleep time. eg, '2s'.\n\t * @throws StfException \n\t */\n\tpublic LoadTestProcessDefinition setSuiteThinkingTime(String minThinkingTime, String maxThinkingTime) throws StfException {\n\t\tString thinkTimeSpec = minThinkingTime + \"..\" + maxThinkingTime;\n\t\toutputSuiteArg(\"thinkingTime\", thinkTimeSpec);\n\t\thaveThinkingTime = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Tests to run will be selected sequentially, A,B,C,D,E,F,G,...\n\t * If the final test in the inventory list has been executed then the next test \n\t * will be the first in the list.\n\t * This method or the setSuiteRandomSelection() method must be called for each suite.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteSequentialSelection() throws StfException {\n\t\toutputSuiteArg(\"selection\", \"sequential\");\n\t\thaveSelectionMode = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Tests to run will be selected randomly.\n\t * There is no weighting at present.\n\t * This method or the setSuiteSequentialSelection() method must be called for each suite.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteRandomSelection() throws StfException {\n\t\toutputSuiteArg(\"selection\", \"random\");\n\t\thaveSelectionMode = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\tprivate void outputSuiteArg(String suiteFieldName, String value) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.SUITE);",
        "start_line": 651,
        "end_line": 740,
        "chunk_index": 7,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 961,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257934"
      },
      "text": "// Work out where the given inventory file will be once it has been copied to the results directory\n\tprivate FileRef calculateRelocatedInventoryFile(String inventoryFileRef) throws StfException {\n\t\t// Create the name of the directory to copy inventory files to, eg, 1.LT.inventory\n\t\tString inventoryDirName = PLACEHOLDER_STF_COMMAND_NUMBER + \".\" + PLACEHOLDER_STF_COMMAND_MNEMONIC + \".\" + StfConstants.INVENTORY_DIR_SUFFIX; \n\t\tFileRef newInventoryFile = environmentCore.getResultsDir().childDirectory(inventoryDirName).childFile(inventoryFileRef);\n\t\treturn newInventoryFile;\n\t}\n\n\t/**\n\t * Optional method which controls how many tests are to be run for this suite.\n\t * Worker threads will run tests until the supplied number of tests have been started.\n\t * If this value is not specified then the load test runs until the time limit\n\t * specified by setTimeLimit().\n\t * \n\t * For example, if the inventory file contains tests A,B,C,D,E. \n\t * Then randomly executing 4 tests may run B,E,A,E or A,C,B,B.\n\t * Sequentially executing 4 tests will always run A,B,C,D \n\t * Sequentially executing 7 tests would run A,B,C,D,E,A,B\n\t * If the repetition count is to 2 then sequentially executing 7 tests would run A,A,B,B,C,C,D\n\t */\n\tpublic LoadTestProcessDefinition setSuiteNumTests(int numTests) throws StfException {\n\t\toutputSuiteArg(\"totalNumberTests\", Integer.toString(numTests));\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Optional method which sets how many times each test will be run before the selection \n\t * of the the next text.\n\t * If not supplied then the default of '1' is used. ie. run a test once before \n\t * picking the next test.\n\t * There is no interaction of this value with the setSuiteNumTests value. For example,\n\t * if we are running 9 randomly selected tests with a repeat count of 4, then we may \n\t * execute test numbers: C,C,C,C,A,A,A,A,D \n\t */\n\tpublic LoadTestProcessDefinition setSuiteTestRepeatCount(int repeatCount) throws StfException {\n\t\toutputSuiteArg(\"repeatCount\", Integer.toString(repeatCount));\n\t\thaveRepeatCount = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the amount of time which each load test thread should wait between executing \n\t * successive tests of the current suite. \n\t * Each load test thread has it's own random number generator which picks a pause \n\t * time between the specified min and max times. \n\t * The min and max can be set to the same value for a fixed delay.\n\t * If not set then min and max default to zero, which means that the load test thread \n\t * will not sleep between tests.  \n\t * @param minThinkingTime The minimum sleep time. Supported time units are 'h', 'm', 's' and 'ms'. eg, '100ms1\n\t * @param maxThinkingTime The maximum sleep time. eg, '2s'.\n\t * @throws StfException \n\t */\n\tpublic LoadTestProcessDefinition setSuiteThinkingTime(String minThinkingTime, String maxThinkingTime) throws StfException {\n\t\tString thinkTimeSpec = minThinkingTime + \"..\" + maxThinkingTime;\n\t\toutputSuiteArg(\"thinkingTime\", thinkTimeSpec);\n\t\thaveThinkingTime = true;\n\t\t\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Tests to run will be selected sequentially, A,B,C,D,E,F,G,...\n\t * If the final test in the inventory list has been executed then the next test \n\t * will be the first in the list.\n\t * This method or the setSuiteRandomSelection() method must be called for each suite.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteSequentialSelection() throws StfException {\n\t\toutputSuiteArg(\"selection\", \"sequential\");\n\t\thaveSelectionMode = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Tests to run will be selected randomly.\n\t * There is no weighting at present.\n\t * This method or the setSuiteSequentialSelection() method must be called for each suite.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteRandomSelection() throws StfException {\n\t\toutputSuiteArg(\"selection\", \"random\");\n\t\thaveSelectionMode = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\tprivate void outputSuiteArg(String suiteFieldName, String value) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.SUITE);"
    },
    "267": {
      "metadata": {
        "chunk_id": "dc7ceabb5c1920f2cf33130aa2888bb84ce0623e25c8dbe1b63d948418d81341",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "/**\n\t * Tests to run will be selected randomly.\n\t * There is no weighting at present.\n\t * This method or the setSuiteSequentialSelection() method must be called for each suite.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteRandomSelection() throws StfException {\n\t\toutputSuiteArg(\"selection\", \"random\");\n\t\thaveSelectionMode = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\tprivate void outputSuiteArg(String suiteFieldName, String value) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.SUITE);\n\n\t\tjavaProcessDefinition.addArg(\"-suite.\" + currentSuiteName + \".\" + suiteFieldName);\n\t\tjavaProcessDefinition.addArg(value);\n\t}\n\n\t\n\t// Validate the values for the current suite.\n\t// Make sure that all mandatory values have been supplied.\n\tprivate void validateSuiteArgs() throws StfException {\n\t\tif (currentSuiteName == null) {\n\t\t\tthrow new IllegalStateException(\"No suite data supplied for first suite. Call 'LoadTestProcessDefinition.addSuite(\\\"name\\\")'\");\n\t\t}\n\t\t\n\t\t// Verify that mandatory suite values have been set\n\t\tboolean mandatoryArgsAllSet = haveThreadCount && haveInventoryFile && haveSelectionMode;\n\t\tif (!mandatoryArgsAllSet) {\n\t\t\tthrow new IllegalStateException(\"Incomplete suite data. Values must be supplied for threadCount, inventoryFile and the selection mode\");\n\t\t}\n\t\t\n\t\t// Make sure that defaults are set for optional values\n\t\tif (!haveSeed) {\n\t\t\tsetSuiteSeed(-1);\n\t\t}\n\t\tif (!haveRepeatCount) {\n\t\t\tsetSuiteTestRepeatCount(1);\n\t\t}\n\t\tif (!haveThinkingTime) {\n\t\t\tsetSuiteThinkingTime(\"0ms\", \"0ms\");\n\t\t}\n\t}\n\n\t\n\t/**\n\t * @return \"java\" as this process definition class can only run java.\n\t * @throws StfException \n\t */\n\t@Override \n\tpublic String getCommand() throws StfException {\n\t\treturn javaProcessDefinition.getCommand();\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\n\t\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t\n\t/**\n\t * Creates strings for running the command.\n\t * @throws StfException if validation of the suites arguments fails.\n\t */\n\t@Override\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\tvalidateSuiteArgs();\n\t\treturn javaProcessDefinition.asArgsArray();\n\t}\n\n\n\t/**\n\t * Not for normal use. \n\t * This method resets the internal state which tracks the last method used.\n\t * Only to be used by extensions which pre-populate a bare bones process definition.\n\t */\n\tpublic void resetStageChecking() {\n\t\tjavaProcessDefinition.resetStageChecking();\n\t\tpreviousStage = Stage.JVM_ARGS;\n\t}",
        "start_line": 741,
        "end_line": 836,
        "chunk_index": 8,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 717,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257936"
      },
      "text": "/**\n\t * Tests to run will be selected randomly.\n\t * There is no weighting at present.\n\t * This method or the setSuiteSequentialSelection() method must be called for each suite.\n\t */\n\tpublic LoadTestProcessDefinition setSuiteRandomSelection() throws StfException {\n\t\toutputSuiteArg(\"selection\", \"random\");\n\t\thaveSelectionMode = true;\n\t\t\n\t\treturn this;\n\t}\n\n\t\n\tprivate void outputSuiteArg(String suiteFieldName, String value) throws StfException {\n\t\tcheckAndUpdateLevel(Stage.SUITE);\n\n\t\tjavaProcessDefinition.addArg(\"-suite.\" + currentSuiteName + \".\" + suiteFieldName);\n\t\tjavaProcessDefinition.addArg(value);\n\t}\n\n\t\n\t// Validate the values for the current suite.\n\t// Make sure that all mandatory values have been supplied.\n\tprivate void validateSuiteArgs() throws StfException {\n\t\tif (currentSuiteName == null) {\n\t\t\tthrow new IllegalStateException(\"No suite data supplied for first suite. Call 'LoadTestProcessDefinition.addSuite(\\\"name\\\")'\");\n\t\t}\n\t\t\n\t\t// Verify that mandatory suite values have been set\n\t\tboolean mandatoryArgsAllSet = haveThreadCount && haveInventoryFile && haveSelectionMode;\n\t\tif (!mandatoryArgsAllSet) {\n\t\t\tthrow new IllegalStateException(\"Incomplete suite data. Values must be supplied for threadCount, inventoryFile and the selection mode\");\n\t\t}\n\t\t\n\t\t// Make sure that defaults are set for optional values\n\t\tif (!haveSeed) {\n\t\t\tsetSuiteSeed(-1);\n\t\t}\n\t\tif (!haveRepeatCount) {\n\t\t\tsetSuiteTestRepeatCount(1);\n\t\t}\n\t\tif (!haveThinkingTime) {\n\t\t\tsetSuiteThinkingTime(\"0ms\", \"0ms\");\n\t\t}\n\t}\n\n\t\n\t/**\n\t * @return \"java\" as this process definition class can only run java.\n\t * @throws StfException \n\t */\n\t@Override \n\tpublic String getCommand() throws StfException {\n\t\treturn javaProcessDefinition.getCommand();\n\t}\n\t\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\n\t\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t\n\t/**\n\t * Creates strings for running the command.\n\t * @throws StfException if validation of the suites arguments fails.\n\t */\n\t@Override\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\tvalidateSuiteArgs();\n\t\treturn javaProcessDefinition.asArgsArray();\n\t}\n\n\n\t/**\n\t * Not for normal use. \n\t * This method resets the internal state which tracks the last method used.\n\t * Only to be used by extensions which pre-populate a bare bones process definition.\n\t */\n\tpublic void resetStageChecking() {\n\t\tjavaProcessDefinition.resetStageChecking();\n\t\tpreviousStage = Stage.JVM_ARGS;\n\t}"
    },
    "268": {
      "metadata": {
        "chunk_id": "afa3a423ef9558844d181bfefa0d7fb4d726446c7bd238a950212a8c30f65f8f",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/LoadTestProcessDefinition.java",
        "content": "/**\n\t * Not for normal use. \n\t * This method resets the internal state which tracks the last method used.\n\t * Only to be used by extensions which pre-populate a bare bones process definition.\n\t */\n\tpublic void resetStageChecking() {\n\t\tjavaProcessDefinition.resetStageChecking();\n\t\tpreviousStage = Stage.JVM_ARGS;\n\t}\n\n\n\t// Verifies that the addition method is not being called at the wrong time.\n\t// eg. throws exception if attempting to add to the classpath if the last\n\t// call was adding an application argument.\n\tprivate void checkAndUpdateLevel(Stage newStage) throws StfException {\n\t\tif (newStage.level < previousStage.level) { \n\t\t\tthrow new StfException(\"Java invocation built out of sequence. \" + newStage + \" cannot be set after \" + previousStage);\n\t\t}\n\t\t\n\t\tpreviousStage = newStage;\n\t}\n\t\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) throws StfException {\n\t\t// Copy all inventory files from a workspace to the results directory. \n\t\t// This allows for easy modification of the inventory, followed by manual re-execution.\n\t\t// Inventory files may be under a testRoot\n\t\tfor (String sourceFileName : relocatedInventoryFiles) {\n\t\t\tFile sourceFile = environmentCore.findTestFile(sourceFileName).asJavaFile();\n\t\t\tString destDirName = commandSerialNum + \".\" + processMnemonic + \".inventory\";\n\t\t\tFileRef destFile = environmentCore.getResultsDir().childDirectory(destDirName).childFile(sourceFileName);\n\t\t\tlogger.debug(\"Copying inventory file. Source=\" + sourceFile.getAbsolutePath() + \" Destination=\" + destFile);\n\t\t\tFileOperations.copyFile(sourceFile, destFile.asJavaFile());\n\t\t}\n\t}\n\t\n\t\n\t/**\t\n\t * Finds the exclusion files for the specified inventory file.\n\t *\n\t * @param inventoryFile points to the inventory file.\n\t * @return an arrayList containing a File object for each exclusion file. \n\t * If there are no exclusion files then the list is empty. \n\t * @throws StfException \n\t */\n\tpublic static ArrayList<String> findExclusionFiles(ArrayList<DirectoryRef> testRoots, String inventoryFileRef) throws StfException {\n\t\tFile inventoryFile = FileRef.findFile(inventoryFileRef,testRoots).asJavaFile();\n\n\t\t// Work out the exclusion file name to look for. eg for 'mauvePt1.xml' it would be 'mauvePt1_exclude*'\n\t\tint extensionAt = inventoryFile.getName().lastIndexOf(\".\");\n\t\tString baseFileName = inventoryFile.getName().substring(0, extensionAt);\n\t\tString searchPrefix = baseFileName + \"_exclude\";\n\t\t\n\t\t// Work out the directory holding the inventory file\n\t\tint finalSlash = inventoryFileRef.lastIndexOf('/');\n\t\tString inventoryDir = inventoryFileRef.substring(0, finalSlash);\n\t\t\n\t\t// Find all of the exclusion files in the same directory as the inventory files\n\t\tArrayList<String> exclusionFiles = new ArrayList<String>();\n\t\tfor (File ef : inventoryFile.getParentFile().listFiles()) {\n\t\t\tif (ef.getName().startsWith(searchPrefix)) {\n\t\t\t\tString excludeFileRef = inventoryDir + \"/\" + ef.getName();\n\t\t\t\tlogger.debug(\"Saving inventory exclusion file: \" + excludeFileRef);\n\t\t\t\texclusionFiles.add(excludeFileRef);\n\t\t\t}\n\t\t}\n\t\n\t\treturn exclusionFiles;\n\t}\n}",
        "start_line": 837,
        "end_line": 907,
        "chunk_index": 9,
        "total_chunks": 10,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 709,
        "node_type": null,
        "file_sha": "76f687f0491e2e7b23333c803eeacb59f66527b5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.257939"
      },
      "text": "/**\n\t * Not for normal use. \n\t * This method resets the internal state which tracks the last method used.\n\t * Only to be used by extensions which pre-populate a bare bones process definition.\n\t */\n\tpublic void resetStageChecking() {\n\t\tjavaProcessDefinition.resetStageChecking();\n\t\tpreviousStage = Stage.JVM_ARGS;\n\t}\n\n\n\t// Verifies that the addition method is not being called at the wrong time.\n\t// eg. throws exception if attempting to add to the classpath if the last\n\t// call was adding an application argument.\n\tprivate void checkAndUpdateLevel(Stage newStage) throws StfException {\n\t\tif (newStage.level < previousStage.level) { \n\t\t\tthrow new StfException(\"Java invocation built out of sequence. \" + newStage + \" cannot be set after \" + previousStage);\n\t\t}\n\t\t\n\t\tpreviousStage = newStage;\n\t}\n\t\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) throws StfException {\n\t\t// Copy all inventory files from a workspace to the results directory. \n\t\t// This allows for easy modification of the inventory, followed by manual re-execution.\n\t\t// Inventory files may be under a testRoot\n\t\tfor (String sourceFileName : relocatedInventoryFiles) {\n\t\t\tFile sourceFile = environmentCore.findTestFile(sourceFileName).asJavaFile();\n\t\t\tString destDirName = commandSerialNum + \".\" + processMnemonic + \".inventory\";\n\t\t\tFileRef destFile = environmentCore.getResultsDir().childDirectory(destDirName).childFile(sourceFileName);\n\t\t\tlogger.debug(\"Copying inventory file. Source=\" + sourceFile.getAbsolutePath() + \" Destination=\" + destFile);\n\t\t\tFileOperations.copyFile(sourceFile, destFile.asJavaFile());\n\t\t}\n\t}\n\t\n\t\n\t/**\t\n\t * Finds the exclusion files for the specified inventory file.\n\t *\n\t * @param inventoryFile points to the inventory file.\n\t * @return an arrayList containing a File object for each exclusion file. \n\t * If there are no exclusion files then the list is empty. \n\t * @throws StfException \n\t */\n\tpublic static ArrayList<String> findExclusionFiles(ArrayList<DirectoryRef> testRoots, String inventoryFileRef) throws StfException {\n\t\tFile inventoryFile = FileRef.findFile(inventoryFileRef,testRoots).asJavaFile();\n\n\t\t// Work out the exclusion file name to look for. eg for 'mauvePt1.xml' it would be 'mauvePt1_exclude*'\n\t\tint extensionAt = inventoryFile.getName().lastIndexOf(\".\");\n\t\tString baseFileName = inventoryFile.getName().substring(0, extensionAt);\n\t\tString searchPrefix = baseFileName + \"_exclude\";\n\t\t\n\t\t// Work out the directory holding the inventory file\n\t\tint finalSlash = inventoryFileRef.lastIndexOf('/');\n\t\tString inventoryDir = inventoryFileRef.substring(0, finalSlash);\n\t\t\n\t\t// Find all of the exclusion files in the same directory as the inventory files\n\t\tArrayList<String> exclusionFiles = new ArrayList<String>();\n\t\tfor (File ef : inventoryFile.getParentFile().listFiles()) {\n\t\t\tif (ef.getName().startsWith(searchPrefix)) {\n\t\t\t\tString excludeFileRef = inventoryDir + \"/\" + ef.getName();\n\t\t\t\tlogger.debug(\"Saving inventory exclusion file: \" + excludeFileRef);\n\t\t\t\texclusionFiles.add(excludeFileRef);\n\t\t\t}\n\t\t}\n\t\n\t\treturn exclusionFiles;\n\t}\n}"
    },
    "269": {
      "metadata": {
        "chunk_id": "40316112bd37be1f7651285323ff4d899c6b51e0ac0bbc1d96a04a25e5c063dd",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/ProcessDefinition.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.processes.StfProcess;\n\npublic interface ProcessDefinition {\n\t/**\n\t * @return the full path and name of the program to be executed. eg, '/opt/java/bin/java' or '/opt/java/bin/keytool', etc.\n\t * @throws StfException \n\t */\n\tpublic String getCommand() throws StfException;\n\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses();\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData();\n\t\n\t/**\n\t * When STF needs to run a process this method is called to produce\n\t * the list of arguments needed to run the process.\n\t * @return an array list of Strings with the values needed to run the process.\n\t * @throws StfException if the implementation detects an error.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException;\n\n\t/** \n\t * @return true if the specified program lives in the current jdk bin directory.\n\t */\n\tpublic boolean isJdkProgram();\n\t\n\t/**\n\t * If the process definition is going to be running Java then this method gets\n\t * an object to represent the JVM to run.\n\t * @return jvm details or null if the process is not running Java.\n\t */\n\tpublic JavaVersion getJavaVersion();\n\n\t/**\n\t * Called when code generation has completed.\n\t * Allows the process definition object to do any necessary house keeping.\n\t * @param commandSerialNum is the number assigned to the newly generated step.\n\t * @param processMnemonic is the mnemonic used for the current invocation.\n\t * @throws StfException \n\t */\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) throws StfException;\n}",
        "start_line": 0,
        "end_line": 71,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 649,
        "node_type": null,
        "file_sha": "4849f24e9a19b582a8956b9b43c9a6f673f627dc",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.274023"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.processes.StfProcess;\n\npublic interface ProcessDefinition {\n\t/**\n\t * @return the full path and name of the program to be executed. eg, '/opt/java/bin/java' or '/opt/java/bin/keytool', etc.\n\t * @throws StfException \n\t */\n\tpublic String getCommand() throws StfException;\n\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses();\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData();\n\t\n\t/**\n\t * When STF needs to run a process this method is called to produce\n\t * the list of arguments needed to run the process.\n\t * @return an array list of Strings with the values needed to run the process.\n\t * @throws StfException if the implementation detects an error.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException;\n\n\t/** \n\t * @return true if the specified program lives in the current jdk bin directory.\n\t */\n\tpublic boolean isJdkProgram();\n\t\n\t/**\n\t * If the process definition is going to be running Java then this method gets\n\t * an object to represent the JVM to run.\n\t * @return jvm details or null if the process is not running Java.\n\t */\n\tpublic JavaVersion getJavaVersion();\n\n\t/**\n\t * Called when code generation has completed.\n\t * Allows the process definition object to do any necessary house keeping.\n\t * @param commandSerialNum is the number assigned to the newly generated step.\n\t * @param processMnemonic is the mnemonic used for the current invocation.\n\t * @throws StfException \n\t */\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) throws StfException;\n}"
    },
    "270": {
      "metadata": {
        "chunk_id": "d258149fffd85612a4cd8d6b07bbeb90d7cda04e5d7a2ac6308c02d9c724fc82",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/SystemProcessDefinition.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.processes.StfProcess;\n\n\n/**\n * This object captures the information needed to start a system process.\n * \n * This is a powerful command which has potential to produce fragile \n * tests which are system dependent.\n * Use only after consideration about other options. \n */\npublic class SystemProcessDefinition implements ProcessDefinition {\n\tprivate String command; \n\t\n\tprivate ArrayList<String> args = new ArrayList<String>();\n\n\n\tpublic static SystemProcessDefinition create() {\n\t\treturn new SystemProcessDefinition();\n\t}\n\t\n\tpublic boolean isJdkProgram() {\n\t\treturn false;  // The command is on the system path \n \t}\n\n\t@Override\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param command sets the name of the program to execute.\n\t */\n\tpublic SystemProcessDefinition setProcessName(String command) {\n\t\tthis.command = command;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a argument value to the programs invocation.\n\t * @param arg is an argument to be passed to the program.\n\t * @return the updated SystemProcessDefinition.\n\t */\n\tpublic SystemProcessDefinition addArg(String arg) {\n\t\tthis.args.add(arg);\t\t\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adds multiple argument values to the programs invocation.\n\t * @param arg is one or more arguments to be passed to the program.\n\t * @return the updated SystemProcessDefinition.\n\t */\n\tpublic SystemProcessDefinition addArg(String... args) {\n\t\tfor (String arg : args) { \n\t\t\taddArg(arg);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * @return the name of the program to execute.\n\t */\n\tpublic String getCommand() {\n\t\treturn command;\n\t}\n\t\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\t\n\t/**\n\t * Returns all of the arguments needed to run the program.\n\t * @return an array list of Strings containing the arguments.\n\t * @throws StfException if the program name has not been specified.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\tArrayList<String> allArgs = new ArrayList<String>();\n\t\t\n\t\tif (command == null) {\n\t\t\tthrow new StfException(\"Can't run as program name has not been specified\");\n\t\t}\n\t\t\n\t\tallArgs.addAll(args);\n\t\t\n\t\treturn allArgs;\n\t}\n\t\n\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) {\n\t}\n}",
        "start_line": 0,
        "end_line": 130,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 841,
        "node_type": null,
        "file_sha": "02629055d083ddccd663bc5496cc7ab012ff6029",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.288876"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.processes.StfProcess;\n\n\n/**\n * This object captures the information needed to start a system process.\n * \n * This is a powerful command which has potential to produce fragile \n * tests which are system dependent.\n * Use only after consideration about other options. \n */\npublic class SystemProcessDefinition implements ProcessDefinition {\n\tprivate String command; \n\t\n\tprivate ArrayList<String> args = new ArrayList<String>();\n\n\n\tpublic static SystemProcessDefinition create() {\n\t\treturn new SystemProcessDefinition();\n\t}\n\t\n\tpublic boolean isJdkProgram() {\n\t\treturn false;  // The command is on the system path \n \t}\n\n\t@Override\n\tpublic JavaVersion getJavaVersion() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param command sets the name of the program to execute.\n\t */\n\tpublic SystemProcessDefinition setProcessName(String command) {\n\t\tthis.command = command;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a argument value to the programs invocation.\n\t * @param arg is an argument to be passed to the program.\n\t * @return the updated SystemProcessDefinition.\n\t */\n\tpublic SystemProcessDefinition addArg(String arg) {\n\t\tthis.args.add(arg);\t\t\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Adds multiple argument values to the programs invocation.\n\t * @param arg is one or more arguments to be passed to the program.\n\t * @return the updated SystemProcessDefinition.\n\t */\n\tpublic SystemProcessDefinition addArg(String... args) {\n\t\tfor (String arg : args) { \n\t\t\taddArg(arg);\n\t\t}\n\t\t\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * @return the name of the program to execute.\n\t */\n\tpublic String getCommand() {\n\t\treturn command;\n\t}\n\t\n\t/**\n\t * Returns a HashMap containing links to all processes that have been identified as related to this process.\n\t * @return A HashMap where each key is a unique String, and each StfProcess is a process related to this process.\n\t */\n\tpublic HashMap<String, StfProcess> getRelatedProcesses() {\n\t\treturn new HashMap<String, StfProcess>();\t\t\n\t}\n\t\n\t/**\n\t * Returns a HashMap containing a list of data that we want to get from all processes in the relatedProcesses HashMap.\n\t * @return A HashMap where each key is a unique String, and each Integer is a PERL_PROCESS_DATA key linked to a specific \n\t * \t\t   operation that can be performed after appending the perl variable representing a specific process.\n\t */\n\tpublic HashMap<String, Integer> getRelatedProcessesData() {\n\t\treturn new HashMap<String, Integer>();\n\t}\n\t\n\t/**\n\t * Returns all of the arguments needed to run the program.\n\t * @return an array list of Strings containing the arguments.\n\t * @throws StfException if the program name has not been specified.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\tArrayList<String> allArgs = new ArrayList<String>();\n\t\t\n\t\tif (command == null) {\n\t\t\tthrow new StfException(\"Can't run as program name has not been specified\");\n\t\t}\n\t\t\n\t\tallArgs.addAll(args);\n\t\t\n\t\treturn allArgs;\n\t}\n\t\n\n\t\n\t@Override\n\tpublic void generationCompleted(int commandSerialNum, String processMnemonic) {\n\t}\n}"
    },
    "271": {
      "metadata": {
        "chunk_id": "9b754b4156df7bbc02fa262cfebca2602245ffaf4db8dd6a97f55874d44c3fda",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/generic/ProcessArg.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions.generic;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\n\n\n/**\n * This class represents a single argument for an external process.\n * \n * It aims to reduce the work needed by each process definition object. \n * There are quite a lot of different process definitions so their repetitive\n * code, such as building a classpath, can all be contained within this class. \n */",
        "start_line": 0,
        "end_line": 32,
        "chunk_index": 0,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 257,
        "node_type": null,
        "file_sha": "a338b42ca019fc03129a69f1a3492ccf69c41dee",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.303682"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions.generic;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\n\n\n/**\n * This class represents a single argument for an external process.\n * \n * It aims to reduce the work needed by each process definition object. \n * There are quite a lot of different process definitions so their repetitive\n * code, such as building a classpath, can all be contained within this class. \n */"
    },
    "272": {
      "metadata": {
        "chunk_id": "927395f4ae076f28b03e4034a76ccb46b5862d9607303ba73f4093a61ff3b39e",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/generic/ProcessArg.java",
        "content": "public class ProcessArg {\n\tpublic enum ARG_TYPE {\n\t\tSTRING(false),    // For pure string values. Argument value output as-is, with no processing. eg, '--endian little'\n\t\tMULTI_VAL(true),  // For arguments with multiple values. Frequently comma separated. eg, '--add-modules mod1,mod2,mod3'\n\t\tREPEAT_ARG(true), // For multiple values arguments where the argument name is repeated, '--release-info=file1 --release-info=file2'\n\t\tCLASS(false),     // For output of the full name of a class. Contains name of package and enclosing class. eg, '--main-class net.adoptopenjdk.hello'\n\t\tFLAG(false),      // Toggle for an argument which doesn't have any argument values. eg, '--version'\n\t\tPATH(true),       // For specification of path with 1 or more directories. eg, '--class-path dir1:dir2:dir3'\n\t\tDIR(false),       // For an argument whose value must be a directory. eg, '-output /tmp/dir2' \n\t\tFILE(false);      // For an argument whose value must be a file. eg, '-log /tmp/process.log' \n\t\t\n\t\tboolean allowMultipleValues;\n\t\t\n\t\tARG_TYPE(boolean allowMultipleValues) {\n\t\t\tthis.allowMultipleValues = allowMultipleValues;\n\t\t}\n\t}\n\t\n\tpublic enum REQUIREMENT { MANDATORY, OPTIONAL };\n\t\n\t// Metadata about the argument\n\tprivate ARG_TYPE argType;\n\tprivate String nameValueSeparator;\n\tprivate String argSeparator;\n\tprivate REQUIREMENT argRule;\n\tprivate String argId;\n\tprivate String argName;\n\n\t// Data for STRING, COMMA_SEP, CLASS, PATH, and DIR arguments\n\tprivate LinkedHashSet<String> argValues;\n\t\n\t// Data for FLAG arguments\n\tprivate Boolean argEnabled;\n\t\n\t// Data for FILE arguments\n\tprivate FileRef argFile;\n\t\n\t\n\t/**\n\t * Define a process argument.\n\t * @param argType is the type of argument\n\t * @param nameValueSeparator is a string used between the argument and its value. Typically \" \", or \"=\".\n\t * @param argSeparator is the string to be used between multiple argument values. eg ',' for '-addmods=mimimod,bigmod'\n\t * @param argRule specifies if the argument is mandatory or optional.\n\t * @param argId is a ID name for the argument. Only used for error messages.\n\t * @param argName contains the text used to invoke the argument. \n\t * Use 'null' for arguments which don't have an argument name and only specify a value.\n\t */\n\tpublic ProcessArg(ARG_TYPE argType, String nameValueSeparator, String argSeparator, REQUIREMENT argRule, String argId, String argName) {\n\t\tthis.argType = argType;\n\t\tthis.nameValueSeparator = nameValueSeparator;\n\t\tthis.argSeparator = argSeparator;\n\t\tthis.argRule = argRule;\n\t\tthis.argId   = argId;\n\t\tthis.argName = argName;\n\t\t\n\t\t// Set system specific separator for paths\n\t\tif (argType == ARG_TYPE.PATH) { \n\t\t\tthis.argSeparator = File.pathSeparator;\n\t\t}\n\t\t\n\t\tthis.argValues = new LinkedHashSet<String>();\n\t}\n\t\n\n\t/**\n\t * Define a process argument.\n\t * This is simple constructor for non MULTI_VAL arguments that will be using\n\t * a name/value separator of space, eg, '--output /tmp/log.txt'\n\t */\n\tpublic ProcessArg(ARG_TYPE argType, REQUIREMENT argRule, String argId, String argName) {\n\t\tthis(argType, \" \", \"\", argRule, argId, argName);\n\n\t\tif (argType == ARG_TYPE.MULTI_VAL) {\n\t\t\tthrow new IllegalStateException(\"Separator characters must be specified for multi-value arguements. Use other constructor\");\n\t\t}\n\t}\n\t\n\n\tpublic void add(String newStringValue) throws StfException {\n\t\tif (!argType.allowMultipleValues) {\n\t\t\tverifyNotAlreadySet(argValues, newStringValue);\n\t\t}\n\t\tverifyArgTypeIs(ARG_TYPE.STRING, ARG_TYPE.MULTI_VAL, ARG_TYPE.REPEAT_ARG, ARG_TYPE.CLASS, ARG_TYPE.PATH, ARG_TYPE.DIR, ARG_TYPE.FILE);\n\t\targValues.add(newStringValue);\n\t}\n\n\n\tpublic void add(DirectoryRef dir) throws StfException {\n\t\tadd(dir.getSpec());\n\t}\n\t\n\n\tpublic void add(int n) throws StfException {\n\t\ttry {\n\t\t\tadd(Integer.toString(n));\n\t\t} catch (StfException e) {\n\t\t\tthrow new StfException(\"Failed to convert integer to string. Value:\" + n);\n\t\t}\t\t\n\t}\n\t\n\t\n\tpublic void setClass(Class<?> clazz) throws StfException {\n\t\tadd(clazz.getCanonicalName());\n\t}",
        "start_line": 33,
        "end_line": 137,
        "chunk_index": 1,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 978,
        "node_type": null,
        "file_sha": "a338b42ca019fc03129a69f1a3492ccf69c41dee",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.303719"
      },
      "text": "public class ProcessArg {\n\tpublic enum ARG_TYPE {\n\t\tSTRING(false),    // For pure string values. Argument value output as-is, with no processing. eg, '--endian little'\n\t\tMULTI_VAL(true),  // For arguments with multiple values. Frequently comma separated. eg, '--add-modules mod1,mod2,mod3'\n\t\tREPEAT_ARG(true), // For multiple values arguments where the argument name is repeated, '--release-info=file1 --release-info=file2'\n\t\tCLASS(false),     // For output of the full name of a class. Contains name of package and enclosing class. eg, '--main-class net.adoptopenjdk.hello'\n\t\tFLAG(false),      // Toggle for an argument which doesn't have any argument values. eg, '--version'\n\t\tPATH(true),       // For specification of path with 1 or more directories. eg, '--class-path dir1:dir2:dir3'\n\t\tDIR(false),       // For an argument whose value must be a directory. eg, '-output /tmp/dir2' \n\t\tFILE(false);      // For an argument whose value must be a file. eg, '-log /tmp/process.log' \n\t\t\n\t\tboolean allowMultipleValues;\n\t\t\n\t\tARG_TYPE(boolean allowMultipleValues) {\n\t\t\tthis.allowMultipleValues = allowMultipleValues;\n\t\t}\n\t}\n\t\n\tpublic enum REQUIREMENT { MANDATORY, OPTIONAL };\n\t\n\t// Metadata about the argument\n\tprivate ARG_TYPE argType;\n\tprivate String nameValueSeparator;\n\tprivate String argSeparator;\n\tprivate REQUIREMENT argRule;\n\tprivate String argId;\n\tprivate String argName;\n\n\t// Data for STRING, COMMA_SEP, CLASS, PATH, and DIR arguments\n\tprivate LinkedHashSet<String> argValues;\n\t\n\t// Data for FLAG arguments\n\tprivate Boolean argEnabled;\n\t\n\t// Data for FILE arguments\n\tprivate FileRef argFile;\n\t\n\t\n\t/**\n\t * Define a process argument.\n\t * @param argType is the type of argument\n\t * @param nameValueSeparator is a string used between the argument and its value. Typically \" \", or \"=\".\n\t * @param argSeparator is the string to be used between multiple argument values. eg ',' for '-addmods=mimimod,bigmod'\n\t * @param argRule specifies if the argument is mandatory or optional.\n\t * @param argId is a ID name for the argument. Only used for error messages.\n\t * @param argName contains the text used to invoke the argument. \n\t * Use 'null' for arguments which don't have an argument name and only specify a value.\n\t */\n\tpublic ProcessArg(ARG_TYPE argType, String nameValueSeparator, String argSeparator, REQUIREMENT argRule, String argId, String argName) {\n\t\tthis.argType = argType;\n\t\tthis.nameValueSeparator = nameValueSeparator;\n\t\tthis.argSeparator = argSeparator;\n\t\tthis.argRule = argRule;\n\t\tthis.argId   = argId;\n\t\tthis.argName = argName;\n\t\t\n\t\t// Set system specific separator for paths\n\t\tif (argType == ARG_TYPE.PATH) { \n\t\t\tthis.argSeparator = File.pathSeparator;\n\t\t}\n\t\t\n\t\tthis.argValues = new LinkedHashSet<String>();\n\t}\n\t\n\n\t/**\n\t * Define a process argument.\n\t * This is simple constructor for non MULTI_VAL arguments that will be using\n\t * a name/value separator of space, eg, '--output /tmp/log.txt'\n\t */\n\tpublic ProcessArg(ARG_TYPE argType, REQUIREMENT argRule, String argId, String argName) {\n\t\tthis(argType, \" \", \"\", argRule, argId, argName);\n\n\t\tif (argType == ARG_TYPE.MULTI_VAL) {\n\t\t\tthrow new IllegalStateException(\"Separator characters must be specified for multi-value arguements. Use other constructor\");\n\t\t}\n\t}\n\t\n\n\tpublic void add(String newStringValue) throws StfException {\n\t\tif (!argType.allowMultipleValues) {\n\t\t\tverifyNotAlreadySet(argValues, newStringValue);\n\t\t}\n\t\tverifyArgTypeIs(ARG_TYPE.STRING, ARG_TYPE.MULTI_VAL, ARG_TYPE.REPEAT_ARG, ARG_TYPE.CLASS, ARG_TYPE.PATH, ARG_TYPE.DIR, ARG_TYPE.FILE);\n\t\targValues.add(newStringValue);\n\t}\n\n\n\tpublic void add(DirectoryRef dir) throws StfException {\n\t\tadd(dir.getSpec());\n\t}\n\t\n\n\tpublic void add(int n) throws StfException {\n\t\ttry {\n\t\t\tadd(Integer.toString(n));\n\t\t} catch (StfException e) {\n\t\t\tthrow new StfException(\"Failed to convert integer to string. Value:\" + n);\n\t\t}\t\t\n\t}\n\t\n\t\n\tpublic void setClass(Class<?> clazz) throws StfException {\n\t\tadd(clazz.getCanonicalName());\n\t}"
    },
    "273": {
      "metadata": {
        "chunk_id": "52ca2c306db4f95c264e19fb7d091bf706eac82d8f529d565b419a9fc830cb07",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/generic/ProcessArg.java",
        "content": "public void add(String newStringValue) throws StfException {\n\t\tif (!argType.allowMultipleValues) {\n\t\t\tverifyNotAlreadySet(argValues, newStringValue);\n\t\t}\n\t\tverifyArgTypeIs(ARG_TYPE.STRING, ARG_TYPE.MULTI_VAL, ARG_TYPE.REPEAT_ARG, ARG_TYPE.CLASS, ARG_TYPE.PATH, ARG_TYPE.DIR, ARG_TYPE.FILE);\n\t\targValues.add(newStringValue);\n\t}\n\n\n\tpublic void add(DirectoryRef dir) throws StfException {\n\t\tadd(dir.getSpec());\n\t}\n\t\n\n\tpublic void add(int n) throws StfException {\n\t\ttry {\n\t\t\tadd(Integer.toString(n));\n\t\t} catch (StfException e) {\n\t\t\tthrow new StfException(\"Failed to convert integer to string. Value:\" + n);\n\t\t}\t\t\n\t}\n\t\n\t\n\tpublic void setClass(Class<?> clazz) throws StfException {\n\t\tadd(clazz.getCanonicalName());\n\t}\n\n\n\tpublic void addToPath(DirectoryRef dir) throws StfException {\n\t\tverifyArgTypeIs(ARG_TYPE.PATH);\n\t\tadd(dir.getSpec());\n\t}\n\n\t\n\tpublic void add(FileRef file) throws StfException {\n\t\tverifyArgTypeIs(ARG_TYPE.STRING, ARG_TYPE.PATH);\n\t\tadd(file.getSpec());\n\t}\n\n\t\n\tpublic void setFlag(Boolean newValue) throws StfException {\n\t\tverifyNotAlreadySet(argEnabled, newValue);\n\t\tverifyArgTypeIs(ARG_TYPE.FLAG);\n\t\t\n\t\tthis.argEnabled = newValue;\n\t}\n\t\n\t\n\tpublic void setFile(FileRef fileRef) throws StfException {\n\t\tverifyNotAlreadySet(argFile, fileRef);\n\t\tverifyArgTypeIs(ARG_TYPE.FILE);\n\t\t\n\t\tthis.argFile = fileRef;\n\t}\n\n\t\n\tpublic FileRef getFileValue() throws StfException {\n\t\tverifyArgTypeIs(ARG_TYPE.FILE);\n\t\treturn argFile;\n\t}\n\t\n\t\n\tprivate void verifyNotAlreadySet(Object currentValue, Object newValue) throws StfException {\n\t\tif (currentValue != null) {\n\t\t\tthrow new StfException(\"Argument value already set for the '\" + argId + \"' argument. \"\n\t\t\t\t\t+ \"Current value of '\" + currentValue + \"' \"\n\t\t\t\t\t+ \"cannot be replaced with new value of '\" + newValue + \"'\");\n\t\t}\n\t}\n\n\n\tprivate void verifyNotAlreadySet(LinkedHashSet<String> currentValues, String newValue) throws StfException {\n\t\tif (!currentValues.isEmpty()) {\n\t\t\tthrow new StfException(\"Argument value already set for the '\" + argId + \"' argument. \"\n\t\t\t\t\t+ \"Current value of '\" + currentValues + \"' \"\n\t\t\t\t\t+ \"cannot be replaced with new value of '\" + newValue + \"'\");\n\t\t}\n\t}\n\n\n\t// Throw exception if current argument is not of correct type.\n\tprivate void verifyArgTypeIs(ARG_TYPE... expectedArgTypes) throws StfException {\n\t\tfor (ARG_TYPE expectedArgType : expectedArgTypes) {\n\t\t\tif (argType == expectedArgType) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new StfException(\"Invalid argument type for this operation. Current argument '\" + argId + \"' is of type '\" + argType + \"' but must be of type '\" + Arrays.toString(expectedArgTypes) + \"'\");\n\t}\n\n\n\tpublic ArrayList<String> asString() throws StfException {\n\t\tArrayList<String> allArgAsStrings = new ArrayList<String>();",
        "start_line": 138,
        "end_line": 231,
        "chunk_index": 2,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 676,
        "node_type": null,
        "file_sha": "a338b42ca019fc03129a69f1a3492ccf69c41dee",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.303725"
      },
      "text": "public void add(String newStringValue) throws StfException {\n\t\tif (!argType.allowMultipleValues) {\n\t\t\tverifyNotAlreadySet(argValues, newStringValue);\n\t\t}\n\t\tverifyArgTypeIs(ARG_TYPE.STRING, ARG_TYPE.MULTI_VAL, ARG_TYPE.REPEAT_ARG, ARG_TYPE.CLASS, ARG_TYPE.PATH, ARG_TYPE.DIR, ARG_TYPE.FILE);\n\t\targValues.add(newStringValue);\n\t}\n\n\n\tpublic void add(DirectoryRef dir) throws StfException {\n\t\tadd(dir.getSpec());\n\t}\n\t\n\n\tpublic void add(int n) throws StfException {\n\t\ttry {\n\t\t\tadd(Integer.toString(n));\n\t\t} catch (StfException e) {\n\t\t\tthrow new StfException(\"Failed to convert integer to string. Value:\" + n);\n\t\t}\t\t\n\t}\n\t\n\t\n\tpublic void setClass(Class<?> clazz) throws StfException {\n\t\tadd(clazz.getCanonicalName());\n\t}\n\n\n\tpublic void addToPath(DirectoryRef dir) throws StfException {\n\t\tverifyArgTypeIs(ARG_TYPE.PATH);\n\t\tadd(dir.getSpec());\n\t}\n\n\t\n\tpublic void add(FileRef file) throws StfException {\n\t\tverifyArgTypeIs(ARG_TYPE.STRING, ARG_TYPE.PATH);\n\t\tadd(file.getSpec());\n\t}\n\n\t\n\tpublic void setFlag(Boolean newValue) throws StfException {\n\t\tverifyNotAlreadySet(argEnabled, newValue);\n\t\tverifyArgTypeIs(ARG_TYPE.FLAG);\n\t\t\n\t\tthis.argEnabled = newValue;\n\t}\n\t\n\t\n\tpublic void setFile(FileRef fileRef) throws StfException {\n\t\tverifyNotAlreadySet(argFile, fileRef);\n\t\tverifyArgTypeIs(ARG_TYPE.FILE);\n\t\t\n\t\tthis.argFile = fileRef;\n\t}\n\n\t\n\tpublic FileRef getFileValue() throws StfException {\n\t\tverifyArgTypeIs(ARG_TYPE.FILE);\n\t\treturn argFile;\n\t}\n\t\n\t\n\tprivate void verifyNotAlreadySet(Object currentValue, Object newValue) throws StfException {\n\t\tif (currentValue != null) {\n\t\t\tthrow new StfException(\"Argument value already set for the '\" + argId + \"' argument. \"\n\t\t\t\t\t+ \"Current value of '\" + currentValue + \"' \"\n\t\t\t\t\t+ \"cannot be replaced with new value of '\" + newValue + \"'\");\n\t\t}\n\t}\n\n\n\tprivate void verifyNotAlreadySet(LinkedHashSet<String> currentValues, String newValue) throws StfException {\n\t\tif (!currentValues.isEmpty()) {\n\t\t\tthrow new StfException(\"Argument value already set for the '\" + argId + \"' argument. \"\n\t\t\t\t\t+ \"Current value of '\" + currentValues + \"' \"\n\t\t\t\t\t+ \"cannot be replaced with new value of '\" + newValue + \"'\");\n\t\t}\n\t}\n\n\n\t// Throw exception if current argument is not of correct type.\n\tprivate void verifyArgTypeIs(ARG_TYPE... expectedArgTypes) throws StfException {\n\t\tfor (ARG_TYPE expectedArgType : expectedArgTypes) {\n\t\t\tif (argType == expectedArgType) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new StfException(\"Invalid argument type for this operation. Current argument '\" + argId + \"' is of type '\" + argType + \"' but must be of type '\" + Arrays.toString(expectedArgTypes) + \"'\");\n\t}\n\n\n\tpublic ArrayList<String> asString() throws StfException {\n\t\tArrayList<String> allArgAsStrings = new ArrayList<String>();"
    },
    "274": {
      "metadata": {
        "chunk_id": "e76ab3fc5897d0f28096314efd7909e1d0662368849461dec84c139bd4426d7e",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/generic/ProcessArg.java",
        "content": "// Throw exception if current argument is not of correct type.\n\tprivate void verifyArgTypeIs(ARG_TYPE... expectedArgTypes) throws StfException {\n\t\tfor (ARG_TYPE expectedArgType : expectedArgTypes) {\n\t\t\tif (argType == expectedArgType) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new StfException(\"Invalid argument type for this operation. Current argument '\" + argId + \"' is of type '\" + argType + \"' but must be of type '\" + Arrays.toString(expectedArgTypes) + \"'\");\n\t}\n\n\n\tpublic ArrayList<String> asString() throws StfException {\n\t\tArrayList<String> allArgAsStrings = new ArrayList<String>();\n\n\t\tswitch (argType) {\n\t\tcase STRING:\n\t\tcase CLASS:\n\t\tcase DIR:\n\t\t\t// Output argument name and a single parameter\n\t\t\tif (!argValues.isEmpty()) {\n\t\t\t\tString argAsString;\n\t\t\t\tif (argName == null) {\n\t\t\t\t\targAsString = formatArgumentValue(argValues.iterator().next());\n\t\t\t\t} else {\n\t\t\t\t\targAsString = argName + nameValueSeparator + formatArgumentValue(argValues.iterator().next());\n\t\t\t\t}\n\t\t\t\tallArgAsStrings.add(argAsString);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase MULTI_VAL:\n\t\tcase PATH:\n\t\t\t// Create path argument by concatenating together all directory references\n\t\t\tif (!argValues.isEmpty()) {\n\t\t\t\tStringBuilder pathArg = new StringBuilder();\n\t\t\t\tif (argName != null) { \n\t\t\t\t\tpathArg.append(argName + nameValueSeparator);\n\t\t\t\t}\n\t\t\t\tboolean doneFirst = false;\n\t\t\t\tfor (String arg : argValues) {\n\t\t\t\t\tif (doneFirst) {\n\t\t\t\t\t\tpathArg.append(argSeparator);\n\t\t\t\t\t}\n\t\t\t\t\tpathArg.append(arg);\n\t\t\t\t\tdoneFirst = true;\n\t\t\t\t}\n\t\t\t\tallArgAsStrings.add(pathArg.toString());\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase REPEAT_ARG:\n\t\t\tfor (String arg : argValues) {\n\t\t\t\tString argText = argName + nameValueSeparator + arg;\n\t\t\t\tallArgAsStrings.add(argText);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FLAG:\n\t\t\tif (argEnabled != null && argEnabled) {\n\t\t\t\t// Flag has been enabled. Output correct value to turn it on.\n\t\t\t\tallArgAsStrings.add(argName);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FILE:\n\t\t\tif (argFile != null) {\n\t\t\t\t// File has been set. Output value.\n\t\t\t\tallArgAsStrings.add(argFile.getSpec());\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault: \n\t\t\tthrow new StfException(\"Internal error: toString() not supported for argument '\" + argId + \"' of type '\" + argType + \"'\");\n\t\t}\n\t\t\n\t\t// Fail if mandatory argument has not been set\n\t\tif (argRule == REQUIREMENT.MANDATORY  && allArgAsStrings.isEmpty()) {\n\t\t\tthrow new StfException(\"No value supplied for mandatory argument '\" + argId + \"'\");\n\t\t}\n\t\t\n\t\treturn allArgAsStrings;\n\t}\n\t\n\t\n\tprivate String formatArgumentValue(String arg) { \n       if (arg.contains(\" \")) {\n          return \"\\\"\" + arg + \"\\\"\";\n       }\n       return arg;\n    }\n\t\n}",
        "start_line": 232,
        "end_line": 324,
        "chunk_index": 3,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 650,
        "node_type": null,
        "file_sha": "a338b42ca019fc03129a69f1a3492ccf69c41dee",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.303729"
      },
      "text": "// Throw exception if current argument is not of correct type.\n\tprivate void verifyArgTypeIs(ARG_TYPE... expectedArgTypes) throws StfException {\n\t\tfor (ARG_TYPE expectedArgType : expectedArgTypes) {\n\t\t\tif (argType == expectedArgType) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow new StfException(\"Invalid argument type for this operation. Current argument '\" + argId + \"' is of type '\" + argType + \"' but must be of type '\" + Arrays.toString(expectedArgTypes) + \"'\");\n\t}\n\n\n\tpublic ArrayList<String> asString() throws StfException {\n\t\tArrayList<String> allArgAsStrings = new ArrayList<String>();\n\n\t\tswitch (argType) {\n\t\tcase STRING:\n\t\tcase CLASS:\n\t\tcase DIR:\n\t\t\t// Output argument name and a single parameter\n\t\t\tif (!argValues.isEmpty()) {\n\t\t\t\tString argAsString;\n\t\t\t\tif (argName == null) {\n\t\t\t\t\targAsString = formatArgumentValue(argValues.iterator().next());\n\t\t\t\t} else {\n\t\t\t\t\targAsString = argName + nameValueSeparator + formatArgumentValue(argValues.iterator().next());\n\t\t\t\t}\n\t\t\t\tallArgAsStrings.add(argAsString);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase MULTI_VAL:\n\t\tcase PATH:\n\t\t\t// Create path argument by concatenating together all directory references\n\t\t\tif (!argValues.isEmpty()) {\n\t\t\t\tStringBuilder pathArg = new StringBuilder();\n\t\t\t\tif (argName != null) { \n\t\t\t\t\tpathArg.append(argName + nameValueSeparator);\n\t\t\t\t}\n\t\t\t\tboolean doneFirst = false;\n\t\t\t\tfor (String arg : argValues) {\n\t\t\t\t\tif (doneFirst) {\n\t\t\t\t\t\tpathArg.append(argSeparator);\n\t\t\t\t\t}\n\t\t\t\t\tpathArg.append(arg);\n\t\t\t\t\tdoneFirst = true;\n\t\t\t\t}\n\t\t\t\tallArgAsStrings.add(pathArg.toString());\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase REPEAT_ARG:\n\t\t\tfor (String arg : argValues) {\n\t\t\t\tString argText = argName + nameValueSeparator + arg;\n\t\t\t\tallArgAsStrings.add(argText);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FLAG:\n\t\t\tif (argEnabled != null && argEnabled) {\n\t\t\t\t// Flag has been enabled. Output correct value to turn it on.\n\t\t\t\tallArgAsStrings.add(argName);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FILE:\n\t\t\tif (argFile != null) {\n\t\t\t\t// File has been set. Output value.\n\t\t\t\tallArgAsStrings.add(argFile.getSpec());\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault: \n\t\t\tthrow new StfException(\"Internal error: toString() not supported for argument '\" + argId + \"' of type '\" + argType + \"'\");\n\t\t}\n\t\t\n\t\t// Fail if mandatory argument has not been set\n\t\tif (argRule == REQUIREMENT.MANDATORY  && allArgAsStrings.isEmpty()) {\n\t\t\tthrow new StfException(\"No value supplied for mandatory argument '\" + argId + \"'\");\n\t\t}\n\t\t\n\t\treturn allArgAsStrings;\n\t}\n\t\n\t\n\tprivate String formatArgumentValue(String arg) { \n       if (arg.contains(\" \")) {\n          return \"\\\"\" + arg + \"\\\"\";\n       }\n       return arg;\n    }\n\t\n}"
    },
    "275": {
      "metadata": {
        "chunk_id": "ca0f5d0719dbe5276932a68edabb8ec726fa7ea5af0ac10af11241be5b98d725",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/generic/ProcessArgCollection.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions.generic;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\n\n\n/**\n * This class manages a collection of 1 or more ProcessArg objects.\n * \n * It aims to hold functionality which is common to process definition objects:\n *   - Enforcing the ordering in which process definition arguments can be specified.\n *   - Building an ArrayList of strings needed to run the process. \n */",
        "start_line": 0,
        "end_line": 29,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 236,
        "node_type": null,
        "file_sha": "72ad749e990131c9984942d62e1e9da8bee07afd",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.323004"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processes.definitions.generic;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\n\n\n/**\n * This class manages a collection of 1 or more ProcessArg objects.\n * \n * It aims to hold functionality which is common to process definition objects:\n *   - Enforcing the ordering in which process definition arguments can be specified.\n *   - Building an ArrayList of strings needed to run the process. \n */"
    },
    "276": {
      "metadata": {
        "chunk_id": "986d587202445b2ab39b5403772eadb39b39cc1eeae852a0bb3b64c57277dd77",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/processes/definitions/generic/ProcessArgCollection.java",
        "content": "public class ProcessArgCollection {\n\t// To enforce correct buildup of invocation arguments, all the addition \n\t// methods fall into one of these categories.\n\tpublic static class Stage {\n\t\tString name;\n\t\tint level;\n\t\tint minimumJVM;\n\t\tpublic Stage(String stageName, int level, int minimumJVM) {\n\t\t\tthis.name = stageName;\n\t\t\tthis.level = level;\n\t\t\tthis.minimumJVM = minimumJVM;\n\t\t}\n\t}\n\n\t\n\tprivate StfEnvironmentCore environmentCore;\n\n\t// Holds information about the last argument which has been set.\n\t// Allows for the detection of out of order setting.\n\tprivate Stage oldStage;\n\n\t// Contains the arguments for the process.\n\t// Held in the order in which they will be used.\n\tprivate ArrayList<ProcessArg> args;\n\t\n\t\n\t/**\n\t * Create a ProcessArgCollection\n\t * @param environmentCore references StfEnvironmentCore.\n\t * @param initialStage initialises the stage ordering.\n\t * @param args contains all of the arguments which can be used by the current process.\n\t */\n\tpublic ProcessArgCollection(StfEnvironmentCore environmentCore, Stage initialStage, ProcessArg... args) {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.oldStage = initialStage;\n\t\tthis.args = new ArrayList<ProcessArg>(Arrays.asList(args));\n\t}\n\n\t\n\t// Verifies that the addition method is not being called at the wrong time.\n\t// eg. throws exception if attempting to add to the classpath if the last\n\t// call was adding an application argument.\n\tpublic void checkAndUpdateLevel(Stage newStage) throws StfException {\n\t\t// Make sure calls not made out of sequence\n\t\tif (newStage.level < oldStage.level) {\n\t\t\tthrow new StfException(\"Java invocation built out of sequence. \"\n\t\t\t\t\t+ \"Arguments for stage '\" + newStage.name + \"' cannot be set after stage '\" + oldStage.name + \"'\");\n\t\t}\n\t\t\n\t\t// Make sure the JVM supports the feature that is being specified\n\t\tint javaVersion = environmentCore.getJavaVersion();\n\t\tint requiredJavaVersion = newStage.minimumJVM;\n\t\tif (javaVersion < requiredJavaVersion) {\n\t\t\tthrow new StfException(\"Target JVM too old. \"\n\t\t\t\t\t+ \"Java module arguments are only available from java 9 onwards. \"\n\t\t\t\t\t+ \"Current JVM version: \" + javaVersion + \", but need minimum of version: \" + requiredJavaVersion + \" for: \" + newStage);\n\t\t}\n\t\t\n\t\toldStage = newStage;\n\t}\n\n\n\t/**\n\t * Convert the current argument objects into strings which can be used to invoke the process.\n\t * @return ArrayList of Strings containing the arguments for the process.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\tArrayList<String> argStrings = new ArrayList<String>();\n\t\t\n\t\tfor (ProcessArg arg : args) {\n\t\t\tArrayList<String> argAsString = arg.asString();\n\t\t\t// Add in all created arguments (argAsString may be empty, but that is ok)\n\t\t\targStrings.addAll(argAsString);\n\t\t}\n\t\t\n\t\treturn argStrings;\n\t}\n}",
        "start_line": 30,
        "end_line": 107,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 648,
        "node_type": null,
        "file_sha": "72ad749e990131c9984942d62e1e9da8bee07afd",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.323014"
      },
      "text": "public class ProcessArgCollection {\n\t// To enforce correct buildup of invocation arguments, all the addition \n\t// methods fall into one of these categories.\n\tpublic static class Stage {\n\t\tString name;\n\t\tint level;\n\t\tint minimumJVM;\n\t\tpublic Stage(String stageName, int level, int minimumJVM) {\n\t\t\tthis.name = stageName;\n\t\t\tthis.level = level;\n\t\t\tthis.minimumJVM = minimumJVM;\n\t\t}\n\t}\n\n\t\n\tprivate StfEnvironmentCore environmentCore;\n\n\t// Holds information about the last argument which has been set.\n\t// Allows for the detection of out of order setting.\n\tprivate Stage oldStage;\n\n\t// Contains the arguments for the process.\n\t// Held in the order in which they will be used.\n\tprivate ArrayList<ProcessArg> args;\n\t\n\t\n\t/**\n\t * Create a ProcessArgCollection\n\t * @param environmentCore references StfEnvironmentCore.\n\t * @param initialStage initialises the stage ordering.\n\t * @param args contains all of the arguments which can be used by the current process.\n\t */\n\tpublic ProcessArgCollection(StfEnvironmentCore environmentCore, Stage initialStage, ProcessArg... args) {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.oldStage = initialStage;\n\t\tthis.args = new ArrayList<ProcessArg>(Arrays.asList(args));\n\t}\n\n\t\n\t// Verifies that the addition method is not being called at the wrong time.\n\t// eg. throws exception if attempting to add to the classpath if the last\n\t// call was adding an application argument.\n\tpublic void checkAndUpdateLevel(Stage newStage) throws StfException {\n\t\t// Make sure calls not made out of sequence\n\t\tif (newStage.level < oldStage.level) {\n\t\t\tthrow new StfException(\"Java invocation built out of sequence. \"\n\t\t\t\t\t+ \"Arguments for stage '\" + newStage.name + \"' cannot be set after stage '\" + oldStage.name + \"'\");\n\t\t}\n\t\t\n\t\t// Make sure the JVM supports the feature that is being specified\n\t\tint javaVersion = environmentCore.getJavaVersion();\n\t\tint requiredJavaVersion = newStage.minimumJVM;\n\t\tif (javaVersion < requiredJavaVersion) {\n\t\t\tthrow new StfException(\"Target JVM too old. \"\n\t\t\t\t\t+ \"Java module arguments are only available from java 9 onwards. \"\n\t\t\t\t\t+ \"Current JVM version: \" + javaVersion + \", but need minimum of version: \" + requiredJavaVersion + \" for: \" + newStage);\n\t\t}\n\t\t\n\t\toldStage = newStage;\n\t}\n\n\n\t/**\n\t * Convert the current argument objects into strings which can be used to invoke the process.\n\t * @return ArrayList of Strings containing the arguments for the process.\n\t */\n\tpublic ArrayList<String> asArgsArray() throws StfException {\n\t\tArrayList<String> argStrings = new ArrayList<String>();\n\t\t\n\t\tfor (ProcessArg arg : args) {\n\t\t\tArrayList<String> argAsString = arg.asString();\n\t\t\t// Add in all created arguments (argAsString may be empty, but that is ok)\n\t\t\targStrings.addAll(argAsString);\n\t\t}\n\t\t\n\t\treturn argStrings;\n\t}\n}"
    },
    "277": {
      "metadata": {
        "chunk_id": "841567e50905958be081db6e556c0f333f7e4b8d2ef6d07e6e51e79e5fd6aa9c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/ReportFilteredTestResults.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class can be used after an test has run to decide if the run passed or failed.\n * It also supports a results exclusions file, which can be used to decide if a test\n * failure is a known issue, and can therefore be treated as having passed.\n * \n * It takes 3 arguments:\n *   - then name of the test suite.\n *   - the results directory, in which the xml results file can be found.\n *   - the file name of an exclusion results file.\n *   \n * It returns 0 if all test passed, or were treated as having passed following the application \n * of the rules in the exclusions file.\n */",
        "start_line": 0,
        "end_line": 40,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 322,
        "node_type": null,
        "file_sha": "d7256334a1078f731fff3c3cc5ab4ae042552de7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.340152"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class can be used after an test has run to decide if the run passed or failed.\n * It also supports a results exclusions file, which can be used to decide if a test\n * failure is a known issue, and can therefore be treated as having passed.\n * \n * It takes 3 arguments:\n *   - then name of the test suite.\n *   - the results directory, in which the xml results file can be found.\n *   - the file name of an exclusion results file.\n *   \n * It returns 0 if all test passed, or were treated as having passed following the application \n * of the rules in the exclusions file.\n */"
    },
    "278": {
      "metadata": {
        "chunk_id": "e2511846fa426215b5a66568cf5a73b2a0c17f5b9e59292e5a239dbbf32609e2",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/ReportFilteredTestResults.java",
        "content": "public class ReportFilteredTestResults {\n\n\tpublic static void main(String[] args) throws StfException {\n\t\tif (args.length != 2) { \n\t\t\tSystem.out.println(\"ReportFilteredTestResults <results-dir> <exclusions-file.txt>\");\n\t\t\tSystem.exit(127);\n\t\t}\n\n\t\tString resultsDirString = args[0];\n\t\tString filterFileString = args[1];\t\n\n\t\t// Validate parameters\n\t\tFile resultsDir = new File(resultsDirString);\n\t\tif (!(resultsDir.exists() && resultsDir.isDirectory())) {\n\t\t\tthrow new StfException(\"Results directory does not exist, or is not a directory: \" + resultsDirString);\n\t\t}\n\t\tFile filterFile = new File(filterFileString);\n\t\tif (!(filterFile.exists() && filterFile.isFile())) {\n\t\t\tthrow new StfException(\"Filter file does not exist, or is not a file: \" + filterFileString);\n\t\t}\n\t\t\n\t\t// Find all the .tr result files\n\t\tArrayList<File> trResultFiles = new ArrayList<File>();\n\t\tfor (File trResultFile : resultsDir.listFiles()) {\n\t\t\tif (trResultFile.isFile() && trResultFile.getName().endsWith(\".tr\")) {\n\t\t\t\ttrResultFiles.add(trResultFile);\n\t\t\t}\n\t\t}\n\n\t\tif (trResultFiles.isEmpty()) {\n\t\t\tthrow new StfException(\"Failed to find any .tr file in directory: \" + resultsDir.getAbsolutePath());\n\t\t}\n\n\t\t// Sort result files, from oldest to newest\n\t\tCollections.sort(trResultFiles, new Comparator<File>() {\n\t        public int compare(File file1, File file2)\n\t        {\n\t        \tint cmp = Long.valueOf(file1.lastModified()).compareTo(Long.valueOf(file2.lastModified()));\n\t        \tif (cmp == 0) {\n\t        \t\tcmp = file1.getName().compareTo(file2.getName());\n\t        \t}\n\t        \treturn cmp;\n\t        }\n\t    });\n\t\t\n\t\t// Read the contents of the results file, and turn it into a big single result string\n\t\tStringBuilder testResults = new StringBuilder();\n\t\tfor (File trFile : trResultFiles) {\n\t\t\tSystem.out.println(\"Reading tr result file: \" + trFile.getAbsolutePath());\n\t\t\ttestResults.append(readFile(trFile));\n\t\t}\n\t\t\n\t\t// Apply the exclusions and report on the success/failure of the run \n\t\tboolean testRunPassed = new RunResultsFilter().process(testResults.toString(), filterFile);\n\t\t\n\t\tint exitCode = testRunPassed ? 0 : 1;\n\t\tSystem.exit(exitCode);\n\t}\n\n\tprivate static String readFile(File file) throws StfException {\n\t    BufferedReader bufferedReader = null;\n\t\ttry {\n\t\t\tbufferedReader = new BufferedReader(new FileReader(file));\n\t\t  \n\t\t\tStringBuffer fileContents = new StringBuffer();\n\t\t\tString line = null;\n\t\t\twhile ((line = bufferedReader.readLine()) != null) {\n\t\t\t   fileContents.append(line).append(\"\\n\");\n\t\t    }\n\t\t\treturn fileContents.toString();\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new StfException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tbufferedReader.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Failed to close file: \" + file.getAbsolutePath());\n\t\t\t}\n\t\t}\n\t}\n}",
        "start_line": 41,
        "end_line": 123,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 679,
        "node_type": null,
        "file_sha": "d7256334a1078f731fff3c3cc5ab4ae042552de7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.340178"
      },
      "text": "public class ReportFilteredTestResults {\n\n\tpublic static void main(String[] args) throws StfException {\n\t\tif (args.length != 2) { \n\t\t\tSystem.out.println(\"ReportFilteredTestResults <results-dir> <exclusions-file.txt>\");\n\t\t\tSystem.exit(127);\n\t\t}\n\n\t\tString resultsDirString = args[0];\n\t\tString filterFileString = args[1];\t\n\n\t\t// Validate parameters\n\t\tFile resultsDir = new File(resultsDirString);\n\t\tif (!(resultsDir.exists() && resultsDir.isDirectory())) {\n\t\t\tthrow new StfException(\"Results directory does not exist, or is not a directory: \" + resultsDirString);\n\t\t}\n\t\tFile filterFile = new File(filterFileString);\n\t\tif (!(filterFile.exists() && filterFile.isFile())) {\n\t\t\tthrow new StfException(\"Filter file does not exist, or is not a file: \" + filterFileString);\n\t\t}\n\t\t\n\t\t// Find all the .tr result files\n\t\tArrayList<File> trResultFiles = new ArrayList<File>();\n\t\tfor (File trResultFile : resultsDir.listFiles()) {\n\t\t\tif (trResultFile.isFile() && trResultFile.getName().endsWith(\".tr\")) {\n\t\t\t\ttrResultFiles.add(trResultFile);\n\t\t\t}\n\t\t}\n\n\t\tif (trResultFiles.isEmpty()) {\n\t\t\tthrow new StfException(\"Failed to find any .tr file in directory: \" + resultsDir.getAbsolutePath());\n\t\t}\n\n\t\t// Sort result files, from oldest to newest\n\t\tCollections.sort(trResultFiles, new Comparator<File>() {\n\t        public int compare(File file1, File file2)\n\t        {\n\t        \tint cmp = Long.valueOf(file1.lastModified()).compareTo(Long.valueOf(file2.lastModified()));\n\t        \tif (cmp == 0) {\n\t        \t\tcmp = file1.getName().compareTo(file2.getName());\n\t        \t}\n\t        \treturn cmp;\n\t        }\n\t    });\n\t\t\n\t\t// Read the contents of the results file, and turn it into a big single result string\n\t\tStringBuilder testResults = new StringBuilder();\n\t\tfor (File trFile : trResultFiles) {\n\t\t\tSystem.out.println(\"Reading tr result file: \" + trFile.getAbsolutePath());\n\t\t\ttestResults.append(readFile(trFile));\n\t\t}\n\t\t\n\t\t// Apply the exclusions and report on the success/failure of the run \n\t\tboolean testRunPassed = new RunResultsFilter().process(testResults.toString(), filterFile);\n\t\t\n\t\tint exitCode = testRunPassed ? 0 : 1;\n\t\tSystem.exit(exitCode);\n\t}\n\n\tprivate static String readFile(File file) throws StfException {\n\t    BufferedReader bufferedReader = null;\n\t\ttry {\n\t\t\tbufferedReader = new BufferedReader(new FileReader(file));\n\t\t  \n\t\t\tStringBuffer fileContents = new StringBuffer();\n\t\t\tString line = null;\n\t\t\twhile ((line = bufferedReader.readLine()) != null) {\n\t\t\t   fileContents.append(line).append(\"\\n\");\n\t\t    }\n\t\t\treturn fileContents.toString();\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new StfException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tbufferedReader.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new StfException(\"Failed to close file: \" + file.getAbsolutePath());\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "279": {
      "metadata": {
        "chunk_id": "ac53b10fb5f725ecbfd807981dff270160c1208ae737abdf65cbe9f8b4b4a206",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/ResultsFilter.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class takes a set of results and applies filtering rules.\n * \n * Once constructed, and filtering is complete, this class makes available its \n * results as being in 4 different categories:\n *   o passes - these are tests which passed when executed\n *   o filtered passes - which failing on execution, but matched a filtering rule. \n *   o failures - tests which failed execution and don't match any filtering rules.\n *   o ignored - tests which have the '@Ignore' annotation, and have not been run.\n */\npublic class ResultsFilter {\n\t// Holds results after applying filters\n\tprivate ArrayList<TestStatus> passes;\n\tprivate ArrayList<TestStatus> filteredPasses;\n\tprivate ArrayList<TestStatus> failures;\n\tprivate ArrayList<TestStatus> ignored;\n\n\t\n\tpublic ResultsFilter(ArrayList<TestStatus> actualResults, ArrayList<TestStatus> expectedFailures) throws StfException {\n\t\t// All test results are going to be examined - so start with all of them\n\t\tArrayList<TestStatus> results = new ArrayList<TestStatus>(actualResults);\n\t\t\n\t\t// Categories which results are going to be filed against\n\t\tthis.passes         = new ArrayList<TestStatus>();\n\t\tthis.filteredPasses = new ArrayList<TestStatus>();\n\t\tthis.failures       = new ArrayList<TestStatus>();\n\t\tthis.ignored        = new ArrayList<TestStatus>();\n\n\t\t// Attempt to apply every correction rule\n\t\tfor (TestStatus failureRule : expectedFailures) {\n\t\t\t// Check every remaining test against the current rule\n\t\t\tfor (Iterator<TestStatus> i = results.iterator(); i.hasNext();) {\n\t\t       TestStatus result = (TestStatus) i.next();\n\t\t       if (result.passed()) {\n\t\t    \t   passes.add(result);\n\t\t    \t   i.remove();\n\t\t       } else if (result.ignored()) {\n\t\t    \t   ignored.add(result);\n\t\t    \t   i.remove();\n\t\t       } else if (failureRule.matches(result)) {\n\t\t    \t   filteredPasses.add(result);\n\t\t    \t   i.remove();\n\t\t       }\n\t\t\t}\n\t\t}\n\t\t\n\t\t// All remaining tests have not matched a rule so are treated as failures\n\t\tthis.failures = results;\n\t}\n\n\t\n\tpublic ArrayList<TestStatus> getPasses() {\n\t\treturn passes;\n\t}\n\t\n\tpublic ArrayList<TestStatus> getFilteredPasses() {\n\t\treturn filteredPasses;\n\t}\n\t\n\tpublic ArrayList<TestStatus> getFailures() {\n\t\treturn failures;\n\t}\n\t\n\tpublic ArrayList<TestStatus> getIgnored() {\n\t\treturn ignored;\n\t}\n\t\n\tpublic int getRunCount() {\n\t\treturn passes.size() + filteredPasses.size() + failures.size();\n\t}\n\t\n\tpublic boolean wasSuccessful() {\n\t\treturn failures.isEmpty();\n\t}\n\t\n\tpublic String toString() { \n\t\treturn Arrays.toString(getFailures().toArray());\n\t}\n}",
        "start_line": 0,
        "end_line": 101,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 720,
        "node_type": null,
        "file_sha": "a679b045fb91154b0eef7478a9c7f0b614a10e96",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.356823"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class takes a set of results and applies filtering rules.\n * \n * Once constructed, and filtering is complete, this class makes available its \n * results as being in 4 different categories:\n *   o passes - these are tests which passed when executed\n *   o filtered passes - which failing on execution, but matched a filtering rule. \n *   o failures - tests which failed execution and don't match any filtering rules.\n *   o ignored - tests which have the '@Ignore' annotation, and have not been run.\n */\npublic class ResultsFilter {\n\t// Holds results after applying filters\n\tprivate ArrayList<TestStatus> passes;\n\tprivate ArrayList<TestStatus> filteredPasses;\n\tprivate ArrayList<TestStatus> failures;\n\tprivate ArrayList<TestStatus> ignored;\n\n\t\n\tpublic ResultsFilter(ArrayList<TestStatus> actualResults, ArrayList<TestStatus> expectedFailures) throws StfException {\n\t\t// All test results are going to be examined - so start with all of them\n\t\tArrayList<TestStatus> results = new ArrayList<TestStatus>(actualResults);\n\t\t\n\t\t// Categories which results are going to be filed against\n\t\tthis.passes         = new ArrayList<TestStatus>();\n\t\tthis.filteredPasses = new ArrayList<TestStatus>();\n\t\tthis.failures       = new ArrayList<TestStatus>();\n\t\tthis.ignored        = new ArrayList<TestStatus>();\n\n\t\t// Attempt to apply every correction rule\n\t\tfor (TestStatus failureRule : expectedFailures) {\n\t\t\t// Check every remaining test against the current rule\n\t\t\tfor (Iterator<TestStatus> i = results.iterator(); i.hasNext();) {\n\t\t       TestStatus result = (TestStatus) i.next();\n\t\t       if (result.passed()) {\n\t\t    \t   passes.add(result);\n\t\t    \t   i.remove();\n\t\t       } else if (result.ignored()) {\n\t\t    \t   ignored.add(result);\n\t\t    \t   i.remove();\n\t\t       } else if (failureRule.matches(result)) {\n\t\t    \t   filteredPasses.add(result);\n\t\t    \t   i.remove();\n\t\t       }\n\t\t\t}\n\t\t}\n\t\t\n\t\t// All remaining tests have not matched a rule so are treated as failures\n\t\tthis.failures = results;\n\t}\n\n\t\n\tpublic ArrayList<TestStatus> getPasses() {\n\t\treturn passes;\n\t}\n\t\n\tpublic ArrayList<TestStatus> getFilteredPasses() {\n\t\treturn filteredPasses;\n\t}\n\t\n\tpublic ArrayList<TestStatus> getFailures() {\n\t\treturn failures;\n\t}\n\t\n\tpublic ArrayList<TestStatus> getIgnored() {\n\t\treturn ignored;\n\t}\n\t\n\tpublic int getRunCount() {\n\t\treturn passes.size() + filteredPasses.size() + failures.size();\n\t}\n\t\n\tpublic boolean wasSuccessful() {\n\t\treturn failures.isEmpty();\n\t}\n\t\n\tpublic String toString() { \n\t\treturn Arrays.toString(getFailures().toArray());\n\t}\n}"
    },
    "280": {
      "metadata": {
        "chunk_id": "a4ea880541224f1da9a414223930f0924848c5f60ccc3550477a96112f83608f",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/ResultsParser.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class parses test results held in the form such as:\n *   suite=maths platform=linux_86-64 result=pass class=ArgumentsTests test=test01\n * \t suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=\"test -02\"\n * \n * This parsing has primarily been added so that rules, describing which test failures can be\n * treated as having passed, can be held in text files.\n * An example:\n *   # Memory test is buggy on linux\n *   platform=linux_86-64 class=MemTests test=Memory01\n *   # All cpu tests are dodgy on all platforms. note '=~' does regular expression compare\n *   test=~testCpu.*\n *   \n * If a value needs to contain a space character then the value should be enclosed in double qutoes. eg:\n *    message=\"Comparison failure\"\n */",
        "start_line": 0,
        "end_line": 41,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 367,
        "node_type": null,
        "file_sha": "f35fd60e80982806af7e2e1edf85a33b32988baa",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.371958"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class parses test results held in the form such as:\n *   suite=maths platform=linux_86-64 result=pass class=ArgumentsTests test=test01\n * \t suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=\"test -02\"\n * \n * This parsing has primarily been added so that rules, describing which test failures can be\n * treated as having passed, can be held in text files.\n * An example:\n *   # Memory test is buggy on linux\n *   platform=linux_86-64 class=MemTests test=Memory01\n *   # All cpu tests are dodgy on all platforms. note '=~' does regular expression compare\n *   test=~testCpu.*\n *   \n * If a value needs to contain a space character then the value should be enclosed in double qutoes. eg:\n *    message=\"Comparison failure\"\n */"
    },
    "281": {
      "metadata": {
        "chunk_id": "59741665ea19979c638a917a4e3c9dc44320560d1b12f16a4b68a5dd23fa653c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/ResultsParser.java",
        "content": "public class ResultsParser {\n\tprivate String resultString;\n\n\tprivate enum FieldNames {\n\t\tSUITE,\n\t\tPLATFORM,\n\t\tRESULT,\n\t\tCLASS,\n\t\tTEST,\n\t\tMESSAGE,\n\t\tEXCEPTION;\n\t}\n\t\n\t\n\tpublic ResultsParser(String resultString) {\n\t\tthis.resultString = resultString;\n\t}\n\t\n\t\n\tpublic ResultsParser(File exclusionsFile) throws StfException {\n\t    this(readFile(exclusionsFile));\n\t}\n\n\n\tpublic static String readFile(File exclusionsFile) throws StfException {\n\t\tBufferedReader reader = null;\n\t\t\n\t\ttry {\n\t\t\treader = new BufferedReader(new FileReader(exclusionsFile));\n\t\t\tString line = null;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\tString sep = System.getProperty(\"line.separator\");\n\n\t        while ((line = reader.readLine() ) != null) {\n\t            stringBuilder.append(line);\n\t            stringBuilder.append(sep);\n\t        }\n\n\t        return stringBuilder.toString();\n\t    } catch (IOException e) {\n\t    \tthrow new StfException(\"Failed to read from file: \" + exclusionsFile.getAbsolutePath(), e);\n\t\t} finally {\n\t        try {\n\t\t\t\treader.close();\n\t\t\t} catch (IOException e) {\n\t\t    \tthrow new StfException(\"Failed to close file: \" + exclusionsFile.getAbsolutePath(), e);\n\t\t\t}\n\t    }\n\t}\n\t\n\t\n\t/**\n\t * Parse the test results\n\t * @return an array list with one entry for each test result\n\t */\n\tpublic ArrayList<TestStatus> parse() throws StfException {\n\t\tArrayList<TestStatus> results = new ArrayList<TestStatus>();\n\t\t\n\t\tfor (String line : resultString.split(\"\\n\")) {\n\t\t\tString trimmedLine = line.trim();\n\t\t\tif (trimmedLine.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (trimmedLine.startsWith(\"#\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tTestStatus status = parseLine(trimmedLine);\n\t\t\tresults.add(status);\n\t\t}\n\t\t\n\t\treturn results;\n\t}\n\n\t\n\t// States used for parsing name/value pair lines. See comments below.\n\tprivate enum ParseState  { START, IN_NAME, CONDITION, IN_VALUE, IN_QUOTED_VALUE, FIELD_END };\n\t\n\t/**\n\t * This method parses the name/value pairs for a line into a TestStatus object.\n\t * It used to use a regular expression to extract these values but this was proving to \n\t * be unreliable on both IBM and Oracle JVMs when parsing long or complex lines.\n\t * Such lines would sometimes fail with stack overflows.\n\t * So the code now uses a state machine.\n\t * \n\t * The parsing is more complex that may be assumed because:\n\t *   1) The condition can be either '=' or '=~'\n\t *   2) The value may be say 'test=t1' or optionally enclosed in double quotes as 'test=\"t1\"'\n\t *   3) Values in double quotes can contain whitespace.\n\t *   4) Values in double quotes can contain quotes, which are encoded as \\\"\n\t *   5) Error checking needs to be able to spot badly formatted lines.\n\t *   \n\t * Here is a simple example of the sort of line which has forced the conversion\n\t * to a state machine. Note that the 2nd value contains whitespace, equals sign \n\t * and an encoded double-quote: test=BigTest2 message=\"Unknown user name: User=\\\"X\\\"\" \n\t */\n\tprivate TestStatus parseLine(String line) throws StfException {\n\t\t//System.out.println(line);\n\t\tHashMap<String, TestStatus.FieldDetails> fields = new HashMap<String, TestStatus.FieldDetails>();\n\t\t\n\t\tString name = null;\n\t\tString condition = null;\n\t\tString value = null;\n\t\n\t\tParseState state = ParseState.START;\n\t\t\n\t\tint i;\n\t\tchar c;\n\t\tchar next;\n\t\tStringBuilder buff = new StringBuilder();\n\t\tfor (i=0; i<=line.length(); i++) {\n\t\t\t// Find the current and next character.\n\t\t\t// Force the use of '\\n' character if at/past the end of the line.\n\t\t\tc = (i<line.length()) ? line.charAt(i) : '\\n';\n\t\t\tnext = (i+1 < line.length()) ? line.charAt(i+1) : '\\n';",
        "start_line": 42,
        "end_line": 156,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 865,
        "node_type": null,
        "file_sha": "f35fd60e80982806af7e2e1edf85a33b32988baa",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.371968"
      },
      "text": "public class ResultsParser {\n\tprivate String resultString;\n\n\tprivate enum FieldNames {\n\t\tSUITE,\n\t\tPLATFORM,\n\t\tRESULT,\n\t\tCLASS,\n\t\tTEST,\n\t\tMESSAGE,\n\t\tEXCEPTION;\n\t}\n\t\n\t\n\tpublic ResultsParser(String resultString) {\n\t\tthis.resultString = resultString;\n\t}\n\t\n\t\n\tpublic ResultsParser(File exclusionsFile) throws StfException {\n\t    this(readFile(exclusionsFile));\n\t}\n\n\n\tpublic static String readFile(File exclusionsFile) throws StfException {\n\t\tBufferedReader reader = null;\n\t\t\n\t\ttry {\n\t\t\treader = new BufferedReader(new FileReader(exclusionsFile));\n\t\t\tString line = null;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\tString sep = System.getProperty(\"line.separator\");\n\n\t        while ((line = reader.readLine() ) != null) {\n\t            stringBuilder.append(line);\n\t            stringBuilder.append(sep);\n\t        }\n\n\t        return stringBuilder.toString();\n\t    } catch (IOException e) {\n\t    \tthrow new StfException(\"Failed to read from file: \" + exclusionsFile.getAbsolutePath(), e);\n\t\t} finally {\n\t        try {\n\t\t\t\treader.close();\n\t\t\t} catch (IOException e) {\n\t\t    \tthrow new StfException(\"Failed to close file: \" + exclusionsFile.getAbsolutePath(), e);\n\t\t\t}\n\t    }\n\t}\n\t\n\t\n\t/**\n\t * Parse the test results\n\t * @return an array list with one entry for each test result\n\t */\n\tpublic ArrayList<TestStatus> parse() throws StfException {\n\t\tArrayList<TestStatus> results = new ArrayList<TestStatus>();\n\t\t\n\t\tfor (String line : resultString.split(\"\\n\")) {\n\t\t\tString trimmedLine = line.trim();\n\t\t\tif (trimmedLine.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (trimmedLine.startsWith(\"#\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tTestStatus status = parseLine(trimmedLine);\n\t\t\tresults.add(status);\n\t\t}\n\t\t\n\t\treturn results;\n\t}\n\n\t\n\t// States used for parsing name/value pair lines. See comments below.\n\tprivate enum ParseState  { START, IN_NAME, CONDITION, IN_VALUE, IN_QUOTED_VALUE, FIELD_END };\n\t\n\t/**\n\t * This method parses the name/value pairs for a line into a TestStatus object.\n\t * It used to use a regular expression to extract these values but this was proving to \n\t * be unreliable on both IBM and Oracle JVMs when parsing long or complex lines.\n\t * Such lines would sometimes fail with stack overflows.\n\t * So the code now uses a state machine.\n\t * \n\t * The parsing is more complex that may be assumed because:\n\t *   1) The condition can be either '=' or '=~'\n\t *   2) The value may be say 'test=t1' or optionally enclosed in double quotes as 'test=\"t1\"'\n\t *   3) Values in double quotes can contain whitespace.\n\t *   4) Values in double quotes can contain quotes, which are encoded as \\\"\n\t *   5) Error checking needs to be able to spot badly formatted lines.\n\t *   \n\t * Here is a simple example of the sort of line which has forced the conversion\n\t * to a state machine. Note that the 2nd value contains whitespace, equals sign \n\t * and an encoded double-quote: test=BigTest2 message=\"Unknown user name: User=\\\"X\\\"\" \n\t */\n\tprivate TestStatus parseLine(String line) throws StfException {\n\t\t//System.out.println(line);\n\t\tHashMap<String, TestStatus.FieldDetails> fields = new HashMap<String, TestStatus.FieldDetails>();\n\t\t\n\t\tString name = null;\n\t\tString condition = null;\n\t\tString value = null;\n\t\n\t\tParseState state = ParseState.START;\n\t\t\n\t\tint i;\n\t\tchar c;\n\t\tchar next;\n\t\tStringBuilder buff = new StringBuilder();\n\t\tfor (i=0; i<=line.length(); i++) {\n\t\t\t// Find the current and next character.\n\t\t\t// Force the use of '\\n' character if at/past the end of the line.\n\t\t\tc = (i<line.length()) ? line.charAt(i) : '\\n';\n\t\t\tnext = (i+1 < line.length()) ? line.charAt(i+1) : '\\n';"
    },
    "282": {
      "metadata": {
        "chunk_id": "b7eced7ba47bc3dd25468c83f4f9eaf49553b110297dd02754b36ca40a0e5e0b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/ResultsParser.java",
        "content": "boolean processedChar = false;\n\t\t\twhile (!processedChar) {\n\t\t\t\t//System.out.printf(\"  %3d '%c' '%c' %-17s '%s'\", i, c=='\\n'?'\\\\':c, next=='\\n'?'\\\\':next, state, buff.toString());\n\t\t\t\tswitch (state) {\n\t\t\t\tcase START:\n\t\t\t\t\tif (c == ' ' || c == '\\t' || c == '\\n') {\n\t\t\t\t\t\t// Absorb leading white space\n\t\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This character starts a new name\n\t\t\t\t\t\tstate = ParseState.IN_NAME;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase IN_NAME:\n\t\t\t\t\tif (c == '=') {\n\t\t\t\t\t\t// Name has finished. Capture and move to condition.\n\t\t\t\t\t\tname = buff.toString();\n\t\t\t\t\t\tbuff.setLength(0);\n\t\t\t\t\t\tstate = ParseState.CONDITION;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Grab the next character in this name\n\t\t\t\t\t\tbuff.append(c);\n\t\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase CONDITION:\n\t\t\t\t\tif (c == '=' && next == '~') {\n\t\t\t\t\t\tcondition = \"=~\";\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (c == '=') {\n\t\t\t\t\t\tcondition = \"=\";\n\t\t\t\t\t}\n\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\tstate = ParseState.IN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase IN_VALUE:\n\t\t\t\t\tif (buff.length() == 0  &&  c == '\\\"') {\n\t\t\t\t\t\t// This value is enclosed in a double quote\n\t\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\t\tstate = ParseState.IN_QUOTED_VALUE;\n\t\t\t\t\t} else if (c == ' ' || c == '\\t' || c == '\\n') {\n\t\t\t\t\t\t// Have hit the end of the field\n\t\t\t\t\t\tstate = ParseState.FIELD_END;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This character is part of the value\n\t\t\t\t\t\tbuff.append(c);\n\t\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IN_QUOTED_VALUE:\n\t\t\t\t\tif (c == '\\\"') {\n\t\t\t\t\t\t// Have hit the end of the field\n\t\t\t\t\t\tstate = ParseState.FIELD_END;\n\t\t\t\t\t} else if (c == '\\\\' && next == '\\\"') {\n\t\t\t\t\t\t// It's an encoded double-quote. ie. \\\"\n\t\t\t\t\t\tbuff.append('\"');\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This character is part of the value\n\t\t\t\t\t\tbuff.append(c);\n\t\t\t\t\t}\n\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase FIELD_END:\n\t\t\t\t\t// Have reached the end of the value part. Capture it, and reset the state machine.\n\t\t\t\t\tvalue = buff.toString();\n\t\t\t\t\tbuff.setLength(0);\n\t\t\t\t\tstate = ParseState.START;\n\t\t\t\t\t\n\t\t\t\t\t// Field is complete, so store into hashMap\n\t\t\t\t\tTestStatus.FieldDetails fieldDetails = createFieldObject(line, name, condition, value);\n\t\t\t\t\tif (fields.containsKey(name)) {\n\t\t\t\t    \tthrow new StfException(\"Duplicate field used: '\" + name + \"' in: \" + line);\n\t\t\t\t    }\n\t\t\t\t    fields.put(name, fieldDetails);\n\t\t\t\t\t//System.out.print(\"  Field completed. Name:'\" + name + \"' Condition:'\" + condition + \"' Value:'\" + value + \"'\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (state != ParseState.START) {\n\t\t\tthrow new StfException(\"Malformed results line. Parsing failed at about character \" + i + \" on line: \" + line);\n\t\t}\n\t\t\n\t\t// Build an object to represent the contents of this line\n\t\tTestStatus status = new TestStatus(line, fields.get(\"suite\"), fields.get(\"platform\"), fields.get(\"result\"), fields.get(\"class\"), fields.get(\"test\"), fields.get(\"message\"), fields.get(\"exception\"), fields.get(\"expectation\"));\n\t\treturn status;\n\t}\n\n\n\tprivate TestStatus.FieldDetails createFieldObject(String line, String name, String comparison, String value)\n\t\t\tthrows StfException {\n\t\t// Remove encoding for double-quotes. ie. return \\\" to \". \n\t\tvalue = value.replace(\"\\\\\\\"\", \"\\\"\");\n\t\t\n\t\t// Check and store the field name+value\n\t\ttry {\n\t\t\tFieldNames.valueOf(name.toUpperCase());\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new StfException(\"Found invalid field name: '\" + name + \"' on Line: \" + line);\n\t\t}\n\t\tTestStatus.FieldDetails fieldDetails = new TestStatus.FieldDetails(name, comparison.equals(\"=~\"), value);\n\t\treturn fieldDetails;\n\t}\n}",
        "start_line": 157,
        "end_line": 268,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 946,
        "node_type": null,
        "file_sha": "f35fd60e80982806af7e2e1edf85a33b32988baa",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.371972"
      },
      "text": "boolean processedChar = false;\n\t\t\twhile (!processedChar) {\n\t\t\t\t//System.out.printf(\"  %3d '%c' '%c' %-17s '%s'\", i, c=='\\n'?'\\\\':c, next=='\\n'?'\\\\':next, state, buff.toString());\n\t\t\t\tswitch (state) {\n\t\t\t\tcase START:\n\t\t\t\t\tif (c == ' ' || c == '\\t' || c == '\\n') {\n\t\t\t\t\t\t// Absorb leading white space\n\t\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This character starts a new name\n\t\t\t\t\t\tstate = ParseState.IN_NAME;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase IN_NAME:\n\t\t\t\t\tif (c == '=') {\n\t\t\t\t\t\t// Name has finished. Capture and move to condition.\n\t\t\t\t\t\tname = buff.toString();\n\t\t\t\t\t\tbuff.setLength(0);\n\t\t\t\t\t\tstate = ParseState.CONDITION;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Grab the next character in this name\n\t\t\t\t\t\tbuff.append(c);\n\t\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase CONDITION:\n\t\t\t\t\tif (c == '=' && next == '~') {\n\t\t\t\t\t\tcondition = \"=~\";\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (c == '=') {\n\t\t\t\t\t\tcondition = \"=\";\n\t\t\t\t\t}\n\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\tstate = ParseState.IN_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase IN_VALUE:\n\t\t\t\t\tif (buff.length() == 0  &&  c == '\\\"') {\n\t\t\t\t\t\t// This value is enclosed in a double quote\n\t\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\t\tstate = ParseState.IN_QUOTED_VALUE;\n\t\t\t\t\t} else if (c == ' ' || c == '\\t' || c == '\\n') {\n\t\t\t\t\t\t// Have hit the end of the field\n\t\t\t\t\t\tstate = ParseState.FIELD_END;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This character is part of the value\n\t\t\t\t\t\tbuff.append(c);\n\t\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IN_QUOTED_VALUE:\n\t\t\t\t\tif (c == '\\\"') {\n\t\t\t\t\t\t// Have hit the end of the field\n\t\t\t\t\t\tstate = ParseState.FIELD_END;\n\t\t\t\t\t} else if (c == '\\\\' && next == '\\\"') {\n\t\t\t\t\t\t// It's an encoded double-quote. ie. \\\"\n\t\t\t\t\t\tbuff.append('\"');\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This character is part of the value\n\t\t\t\t\t\tbuff.append(c);\n\t\t\t\t\t}\n\t\t\t\t\tprocessedChar = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase FIELD_END:\n\t\t\t\t\t// Have reached the end of the value part. Capture it, and reset the state machine.\n\t\t\t\t\tvalue = buff.toString();\n\t\t\t\t\tbuff.setLength(0);\n\t\t\t\t\tstate = ParseState.START;\n\t\t\t\t\t\n\t\t\t\t\t// Field is complete, so store into hashMap\n\t\t\t\t\tTestStatus.FieldDetails fieldDetails = createFieldObject(line, name, condition, value);\n\t\t\t\t\tif (fields.containsKey(name)) {\n\t\t\t\t    \tthrow new StfException(\"Duplicate field used: '\" + name + \"' in: \" + line);\n\t\t\t\t    }\n\t\t\t\t    fields.put(name, fieldDetails);\n\t\t\t\t\t//System.out.print(\"  Field completed. Name:'\" + name + \"' Condition:'\" + condition + \"' Value:'\" + value + \"'\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (state != ParseState.START) {\n\t\t\tthrow new StfException(\"Malformed results line. Parsing failed at about character \" + i + \" on line: \" + line);\n\t\t}\n\t\t\n\t\t// Build an object to represent the contents of this line\n\t\tTestStatus status = new TestStatus(line, fields.get(\"suite\"), fields.get(\"platform\"), fields.get(\"result\"), fields.get(\"class\"), fields.get(\"test\"), fields.get(\"message\"), fields.get(\"exception\"), fields.get(\"expectation\"));\n\t\treturn status;\n\t}\n\n\n\tprivate TestStatus.FieldDetails createFieldObject(String line, String name, String comparison, String value)\n\t\t\tthrows StfException {\n\t\t// Remove encoding for double-quotes. ie. return \\\" to \". \n\t\tvalue = value.replace(\"\\\\\\\"\", \"\\\"\");\n\t\t\n\t\t// Check and store the field name+value\n\t\ttry {\n\t\t\tFieldNames.valueOf(name.toUpperCase());\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new StfException(\"Found invalid field name: '\" + name + \"' on Line: \" + line);\n\t\t}\n\t\tTestStatus.FieldDetails fieldDetails = new TestStatus.FieldDetails(name, comparison.equals(\"=~\"), value);\n\t\treturn fieldDetails;\n\t}\n}"
    },
    "283": {
      "metadata": {
        "chunk_id": "7625fb6d7afd8eeb34fcf1379c7ede8b5038465811f31a6dff97723567065129",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/RunResultsFilter.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class is to run test results filtering. \n * This happens at the end of a test run and is a chance for tests which \n * failed with known failures to be treated as having passed.\n */\npublic class RunResultsFilter {\n\t// Main method for testing \n\tpublic static void main(String[] args) throws StfException {\n\t\tif (args.length != 2) { \n\t\t\tSystem.out.println(\"RunResultsFilter <testResultsFile> <exclusionsFile.txt>\");\n\t\t\tSystem.exit(127);\n\t\t}\n\n\t\tString testResultsFile = args[0];\n\t\tString exclusionsFile  = args[1];\n\t\t\n\t\tboolean testRunPassed = new RunResultsFilter().process(testResultsFile, new File(exclusionsFile));\n\t\t\n\t\tint exitCode = testRunPassed ? 0 : 1;\n\t\tSystem.exit(exitCode);\n\t}\n\t\n\n\tpublic boolean process(String testResultsString, File exclusionsFile) throws StfException {\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Using exclusions: \" + exclusionsFile);\n\t\t\n    \tArrayList<TestStatus> results = new ResultsParser(testResultsString).parse();\n    \tArrayList<TestStatus> filters = new ResultsParser(exclusionsFile).parse();\n\n    \tResultsFilter filteredResults = new ResultsFilter(results, filters);\n    \t\n        System.out.println();\n\t\tSystem.out.println(\"Test Results after filtering with exclusions\");\n        System.out.printf(\"  Ran             : %4d\\n\", filteredResults.getRunCount());\n        System.out.printf(\"  Clean passes    : %4d\\n\", filteredResults.getPasses().size());\n        System.out.printf(\"  Filtered passes : %4d\\n\", filteredResults.getFilteredPasses().size());\n        System.out.printf(\"  Failed          : %4d\\n\", filteredResults.getFailures().size());\n        System.out.printf(\"  Ignored         : %4d\\n\", filteredResults.getIgnored().size());\n\n        listResults(\"Filtered passes (failures upgraded to a pass)\", filteredResults.getFilteredPasses());\n        listResults(\"Failing tests\", filteredResults.getFailures());\n\n        System.out.printf(\"\\nOverall result : %s\\n\", (filteredResults.wasSuccessful() ? \"PASSED\" : \"FAILED\"));\n        \n        boolean testRunPassed = filteredResults.wasSuccessful();\n        return testRunPassed;\n\t}\n\n    \n\tprivate static void listResults(String title, ArrayList<TestStatus> results) {\n\t\tif (!results.isEmpty()) {\n\t\t    System.out.println();\n\t\t\tSystem.out.println(title + \": \" + results.size());\n\t\t    for (int i=0; i<results.size(); i++) {\n\t\t    \tTestStatus ts = results.get(i);\n\t\t    \tSystem.out.println(\"  \" + (i+1) + \") \" + ts.getClassName() + \" \" + ts.getTestName());\n\t\t    }\n\t\t}\n\t}\n}",
        "start_line": 0,
        "end_line": 82,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 735,
        "node_type": null,
        "file_sha": "2fd8cc1496e2234855789710725e7f9500bf62af",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.387983"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class is to run test results filtering. \n * This happens at the end of a test run and is a chance for tests which \n * failed with known failures to be treated as having passed.\n */\npublic class RunResultsFilter {\n\t// Main method for testing \n\tpublic static void main(String[] args) throws StfException {\n\t\tif (args.length != 2) { \n\t\t\tSystem.out.println(\"RunResultsFilter <testResultsFile> <exclusionsFile.txt>\");\n\t\t\tSystem.exit(127);\n\t\t}\n\n\t\tString testResultsFile = args[0];\n\t\tString exclusionsFile  = args[1];\n\t\t\n\t\tboolean testRunPassed = new RunResultsFilter().process(testResultsFile, new File(exclusionsFile));\n\t\t\n\t\tint exitCode = testRunPassed ? 0 : 1;\n\t\tSystem.exit(exitCode);\n\t}\n\t\n\n\tpublic boolean process(String testResultsString, File exclusionsFile) throws StfException {\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Using exclusions: \" + exclusionsFile);\n\t\t\n    \tArrayList<TestStatus> results = new ResultsParser(testResultsString).parse();\n    \tArrayList<TestStatus> filters = new ResultsParser(exclusionsFile).parse();\n\n    \tResultsFilter filteredResults = new ResultsFilter(results, filters);\n    \t\n        System.out.println();\n\t\tSystem.out.println(\"Test Results after filtering with exclusions\");\n        System.out.printf(\"  Ran             : %4d\\n\", filteredResults.getRunCount());\n        System.out.printf(\"  Clean passes    : %4d\\n\", filteredResults.getPasses().size());\n        System.out.printf(\"  Filtered passes : %4d\\n\", filteredResults.getFilteredPasses().size());\n        System.out.printf(\"  Failed          : %4d\\n\", filteredResults.getFailures().size());\n        System.out.printf(\"  Ignored         : %4d\\n\", filteredResults.getIgnored().size());\n\n        listResults(\"Filtered passes (failures upgraded to a pass)\", filteredResults.getFilteredPasses());\n        listResults(\"Failing tests\", filteredResults.getFailures());\n\n        System.out.printf(\"\\nOverall result : %s\\n\", (filteredResults.wasSuccessful() ? \"PASSED\" : \"FAILED\"));\n        \n        boolean testRunPassed = filteredResults.wasSuccessful();\n        return testRunPassed;\n\t}\n\n    \n\tprivate static void listResults(String title, ArrayList<TestStatus> results) {\n\t\tif (!results.isEmpty()) {\n\t\t    System.out.println();\n\t\t\tSystem.out.println(title + \": \" + results.size());\n\t\t    for (int i=0; i<results.size(); i++) {\n\t\t    \tTestStatus ts = results.get(i);\n\t\t    \tSystem.out.println(\"  \" + (i+1) + \") \" + ts.getClassName() + \" \" + ts.getTestName());\n\t\t    }\n\t\t}\n\t}\n}"
    },
    "284": {
      "metadata": {
        "chunk_id": "7055ec6b892a1ab1127e47db666f3cec1431c533c162950f49789c23efe1fb6d",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/TestStatus.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class holds the results of running a single test. \n * \n * Results filtering also uses the same fields so this object is also used to \n * represent a results filtering rule.\n */",
        "start_line": 0,
        "end_line": 24,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 184,
        "node_type": null,
        "file_sha": "983163588c9a07994293468c22432cec87c166ad",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.402954"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class holds the results of running a single test. \n * \n * Results filtering also uses the same fields so this object is also used to \n * represent a results filtering rule.\n */"
    },
    "285": {
      "metadata": {
        "chunk_id": "985a27341136929a0d5b5ec18e32dc0e56a267fe53c9d4b2a0f66de50119b7f8",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/results/TestStatus.java",
        "content": "public class TestStatus {\n\t// This inner class holds the name and value for a single field. eg testName = testMemory01\n\tpublic static class FieldDetails {\n\t\tpublic String name;\n\t\tpublic boolean isRegexComparison;\n\t\tpublic String value;\n\t\t\n\t\tpublic FieldDetails(String name, boolean isRegexComparison, String value) {\n\t\t\tthis.name = name;\n\t\t\tthis.isRegexComparison = isRegexComparison;\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\tprivate String originalText;\n\t\n\tprivate FieldDetails suiteName;\n\tprivate FieldDetails platform;\n\tprivate FieldDetails result;\n\tprivate FieldDetails testClass;\n\tprivate FieldDetails testName;\n\tprivate FieldDetails failureMessage;\n\tprivate FieldDetails exception;\n\tprivate FieldDetails expectation;\n\t\n\n\tpublic TestStatus(String originalText, \n\t\t\tFieldDetails suiteName, FieldDetails platform, FieldDetails result, FieldDetails testClass, FieldDetails testName, \n\t\t\tFieldDetails failureMessage, FieldDetails exception, FieldDetails expectation) throws StfException {\n\t\tthis.originalText = originalText.trim();\n\t\t\n\t\tthis.suiteName = suiteName;\n\t\tthis.platform = platform;\n\t\tthis.result = result;\n\t\tthis.testClass = testClass;\n\t\tthis.testName = testName;\n\t\tthis.failureMessage = failureMessage;\n\t\tthis.exception = exception;\n\t\tthis.expectation = expectation;\n\t\t\n\t\tif (result != null && !(result.value.equals(\"pass\") || result.value.equals(\"fail\") || result.value.equals(\"ignored\"))) {\n\t\t\tthrow new StfException(\"Invalid value for 'result' field: \" + result.value);\n\t\t}\n\t}\n\n\n\tpublic boolean passed() {\n\t\treturn result.value.equals(\"pass\");\n\t}\n\t\n\t\n\tpublic boolean ignored() {\n\t\treturn result.value.equals(\"ignored\");\n\t}\n\n\n\t/**\n\t * Returns true if the current TestStatus object matches another TestStatus.\n\t * They are only considered matching if all fields in the current object match \n\t * the corresponding field in the other object. \n\t * \n\t * @param other is the object to compare the current object against.\n\t * @return true if the current object matches the other object.\n\t * @throws StfException \n\t */\n\tpublic boolean matches(TestStatus other) throws StfException {\n\t\tboolean matched = match(suiteName, other.suiteName) \n\t\t\t\t&& match(this.platform, other.platform) \n\t\t\t\t&& match(this.result, other.result)\n\t\t\t\t&& match(this.testClass, other.testClass)\n\t\t\t\t&& match(this.testName, other.testName)\n\t\t\t\t&& match(this.failureMessage, other.failureMessage)\n\t\t\t\t&& match(this.exception, other.exception)\n\t\t\t\t&& match(this.expectation, other.expectation);\n\t\t\n\t\treturn matched;\n\t}\n\t\n\t\n\tprivate boolean match(FieldDetails ruleValue, FieldDetails otherValue) throws StfException {\n\t\t// There is no field value for the current object so treat it as matching\n\t\tif (ruleValue == null) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (otherValue == null) { \n\t\t\tthrow new StfException(\"Unable to match field '\" + ruleValue.name + \"' as no value in results data\");\n\t\t}\n\t\t\n\t\tString otherValueString = otherValue.value;\n\t\tString ruleValueString  = ruleValue.value;\n\n\t\tif (ruleValue.isRegexComparison) {\n\t\t\t// Decide if the other string matches the regex spec\n\t\t\treturn otherValueString.matches(ruleValueString);\n\t\t} else {\n\t\t\t// Simple equals comparison\n\t\t\treturn (ruleValueString.equals(otherValueString));\n\t\t}\n\t}\n\t\n\t\n\tpublic String getClassName() {\n\t\treturn testClass.value;\n\t}\n\t\n\tpublic String getTestName() {\n\t\treturn testName.value;\n\t}\n\n\t\n\tpublic String toString() {\n\t\treturn originalText;\n\t}\n}",
        "start_line": 25,
        "end_line": 139,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 765,
        "node_type": null,
        "file_sha": "983163588c9a07994293468c22432cec87c166ad",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.402964"
      },
      "text": "public class TestStatus {\n\t// This inner class holds the name and value for a single field. eg testName = testMemory01\n\tpublic static class FieldDetails {\n\t\tpublic String name;\n\t\tpublic boolean isRegexComparison;\n\t\tpublic String value;\n\t\t\n\t\tpublic FieldDetails(String name, boolean isRegexComparison, String value) {\n\t\t\tthis.name = name;\n\t\t\tthis.isRegexComparison = isRegexComparison;\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\tprivate String originalText;\n\t\n\tprivate FieldDetails suiteName;\n\tprivate FieldDetails platform;\n\tprivate FieldDetails result;\n\tprivate FieldDetails testClass;\n\tprivate FieldDetails testName;\n\tprivate FieldDetails failureMessage;\n\tprivate FieldDetails exception;\n\tprivate FieldDetails expectation;\n\t\n\n\tpublic TestStatus(String originalText, \n\t\t\tFieldDetails suiteName, FieldDetails platform, FieldDetails result, FieldDetails testClass, FieldDetails testName, \n\t\t\tFieldDetails failureMessage, FieldDetails exception, FieldDetails expectation) throws StfException {\n\t\tthis.originalText = originalText.trim();\n\t\t\n\t\tthis.suiteName = suiteName;\n\t\tthis.platform = platform;\n\t\tthis.result = result;\n\t\tthis.testClass = testClass;\n\t\tthis.testName = testName;\n\t\tthis.failureMessage = failureMessage;\n\t\tthis.exception = exception;\n\t\tthis.expectation = expectation;\n\t\t\n\t\tif (result != null && !(result.value.equals(\"pass\") || result.value.equals(\"fail\") || result.value.equals(\"ignored\"))) {\n\t\t\tthrow new StfException(\"Invalid value for 'result' field: \" + result.value);\n\t\t}\n\t}\n\n\n\tpublic boolean passed() {\n\t\treturn result.value.equals(\"pass\");\n\t}\n\t\n\t\n\tpublic boolean ignored() {\n\t\treturn result.value.equals(\"ignored\");\n\t}\n\n\n\t/**\n\t * Returns true if the current TestStatus object matches another TestStatus.\n\t * They are only considered matching if all fields in the current object match \n\t * the corresponding field in the other object. \n\t * \n\t * @param other is the object to compare the current object against.\n\t * @return true if the current object matches the other object.\n\t * @throws StfException \n\t */\n\tpublic boolean matches(TestStatus other) throws StfException {\n\t\tboolean matched = match(suiteName, other.suiteName) \n\t\t\t\t&& match(this.platform, other.platform) \n\t\t\t\t&& match(this.result, other.result)\n\t\t\t\t&& match(this.testClass, other.testClass)\n\t\t\t\t&& match(this.testName, other.testName)\n\t\t\t\t&& match(this.failureMessage, other.failureMessage)\n\t\t\t\t&& match(this.exception, other.exception)\n\t\t\t\t&& match(this.expectation, other.expectation);\n\t\t\n\t\treturn matched;\n\t}\n\t\n\t\n\tprivate boolean match(FieldDetails ruleValue, FieldDetails otherValue) throws StfException {\n\t\t// There is no field value for the current object so treat it as matching\n\t\tif (ruleValue == null) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (otherValue == null) { \n\t\t\tthrow new StfException(\"Unable to match field '\" + ruleValue.name + \"' as no value in results data\");\n\t\t}\n\t\t\n\t\tString otherValueString = otherValue.value;\n\t\tString ruleValueString  = ruleValue.value;\n\n\t\tif (ruleValue.isRegexComparison) {\n\t\t\t// Decide if the other string matches the regex spec\n\t\t\treturn otherValueString.matches(ruleValueString);\n\t\t} else {\n\t\t\t// Simple equals comparison\n\t\t\treturn (ruleValueString.equals(otherValueString));\n\t\t}\n\t}\n\t\n\t\n\tpublic String getClassName() {\n\t\treturn testClass.value;\n\t}\n\t\n\tpublic String getTestName() {\n\t\treturn testName.value;\n\t}\n\n\t\n\tpublic String toString() {\n\t\treturn originalText;\n\t}\n}"
    },
    "286": {
      "metadata": {
        "chunk_id": "55be7766aee5f6bb0a1d4c863ca444b8e5bb8a3d3149c92f5f879d8001ccb2f8",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/ClassPathConfigurator.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\n\n\n/**\n * This class contains code which sets the StfClassLoaders search path.\n * \n * This is required because STF is started with a classpath that is only \n * sufficient for running the STF classes, but it then has to be able to\n * run any testcase within the workspace. Hence the need to dynamically \n * extend the class path to cover a specific project.\n */",
        "start_line": 0,
        "end_line": 53,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 420,
        "node_type": null,
        "file_sha": "e40301d9a1c27fd5102ac1bf0211e2232daa6907",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.418720"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\n\n\n/**\n * This class contains code which sets the StfClassLoaders search path.\n * \n * This is required because STF is started with a classpath that is only \n * sufficient for running the STF classes, but it then has to be able to\n * run any testcase within the workspace. Hence the need to dynamically \n * extend the class path to cover a specific project.\n */"
    },
    "287": {
      "metadata": {
        "chunk_id": "1566fc3ffe47a2c9efae5746b11a0d38dbebb6db5ec9489797abd1155c7497d7",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/ClassPathConfigurator.java",
        "content": "public class ClassPathConfigurator {\n    private static final Logger logger = LogManager.getLogger(ClassPathConfigurator.class.getName());\n\n\t/**\n\t * This method tells the STF class loader to search for classes and jar files\n\t * based on the configuration for the specified project.\n\t * \n\t * This code parses the .classpath file to work out which directories and \n\t * jar files are on the classpath.\n\t * \n\t * @param environmentCore gives access to stf properties, workspace-root and test-root.\n\t * @param projectName is the name of the project containing the test plugin.\n\t * @return boolean set to true if the project uses the STF project or jar file.\n\t * @throws StfException\n\t */\n\tpublic static boolean configureClassLoader(StfEnvironmentCore environmentCore, String projectName) throws StfException {\n\t\t// Find the projects dependencies of the project by parsing its .classpath file\n\t\tArrayList<String> projectRoots = new ArrayList<String>();\n\t\tHashSet<String> jarsUsed = new LinkedHashSet<String>();\n\t\tHashSet<String> processedProjects = new LinkedHashSet<String>();  // To prevent indirect recursion\n\t\tfindProjectDependencies(environmentCore, projectName, projectRoots, jarsUsed, processedProjects);\n\n\n\t\tSystem.out.println(\"Classpath directories used by project '\" + projectName + \"': \");\n\t\tfor (String root : projectRoots) {\n\t\t\tSystem.out.println(\"  \" + root);\n\t\t}\n\t\tfor (String jarName : jarsUsed) {\n\t\t\tSystem.out.println(\"  \" + jarName);\n\t\t}\t\n\n\t\t// Log the discovered dependencies\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Classpath directories used by project '\" + projectName + \"': \");\n\t\t\tfor (String root : projectRoots) {\n\t\t\t\tlogger.debug(\"  \" + root);\n\t\t\t}\n\t\t\tlogger.debug(\"Jar files used by project '\" + projectName + \"': \");\n\t\t\tfor (String jarName : jarsUsed) {\n\t\t\t\tlogger.debug(\"  \" + jarName);\n\t\t\t}\t\n\t\t}\n\n\t\t// Configure the class loader for the plugins project dependencies\n\t\tStfClassLoader.setClassRoots(projectRoots);\n\t\tStfClassLoader.setJarPath(jarsUsed);",
        "start_line": 54,
        "end_line": 99,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 458,
        "node_type": null,
        "file_sha": "e40301d9a1c27fd5102ac1bf0211e2232daa6907",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.418749"
      },
      "text": "public class ClassPathConfigurator {\n    private static final Logger logger = LogManager.getLogger(ClassPathConfigurator.class.getName());\n\n\t/**\n\t * This method tells the STF class loader to search for classes and jar files\n\t * based on the configuration for the specified project.\n\t * \n\t * This code parses the .classpath file to work out which directories and \n\t * jar files are on the classpath.\n\t * \n\t * @param environmentCore gives access to stf properties, workspace-root and test-root.\n\t * @param projectName is the name of the project containing the test plugin.\n\t * @return boolean set to true if the project uses the STF project or jar file.\n\t * @throws StfException\n\t */\n\tpublic static boolean configureClassLoader(StfEnvironmentCore environmentCore, String projectName) throws StfException {\n\t\t// Find the projects dependencies of the project by parsing its .classpath file\n\t\tArrayList<String> projectRoots = new ArrayList<String>();\n\t\tHashSet<String> jarsUsed = new LinkedHashSet<String>();\n\t\tHashSet<String> processedProjects = new LinkedHashSet<String>();  // To prevent indirect recursion\n\t\tfindProjectDependencies(environmentCore, projectName, projectRoots, jarsUsed, processedProjects);\n\n\n\t\tSystem.out.println(\"Classpath directories used by project '\" + projectName + \"': \");\n\t\tfor (String root : projectRoots) {\n\t\t\tSystem.out.println(\"  \" + root);\n\t\t}\n\t\tfor (String jarName : jarsUsed) {\n\t\t\tSystem.out.println(\"  \" + jarName);\n\t\t}\t\n\n\t\t// Log the discovered dependencies\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Classpath directories used by project '\" + projectName + \"': \");\n\t\t\tfor (String root : projectRoots) {\n\t\t\t\tlogger.debug(\"  \" + root);\n\t\t\t}\n\t\t\tlogger.debug(\"Jar files used by project '\" + projectName + \"': \");\n\t\t\tfor (String jarName : jarsUsed) {\n\t\t\t\tlogger.debug(\"  \" + jarName);\n\t\t\t}\t\n\t\t}\n\n\t\t// Configure the class loader for the plugins project dependencies\n\t\tStfClassLoader.setClassRoots(projectRoots);\n\t\tStfClassLoader.setJarPath(jarsUsed);"
    },
    "288": {
      "metadata": {
        "chunk_id": "ec59f770d44ce84282dbc7bfc3b17f6a1a90ceccfd7e76586885678929eac92d",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/ClassPathConfigurator.java",
        "content": "System.out.println(\"Classpath directories used by project '\" + projectName + \"': \");\n\t\tfor (String root : projectRoots) {\n\t\t\tSystem.out.println(\"  \" + root);\n\t\t}\n\t\tfor (String jarName : jarsUsed) {\n\t\t\tSystem.out.println(\"  \" + jarName);\n\t\t}\t\n\n\t\t// Log the discovered dependencies\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Classpath directories used by project '\" + projectName + \"': \");\n\t\t\tfor (String root : projectRoots) {\n\t\t\t\tlogger.debug(\"  \" + root);\n\t\t\t}\n\t\t\tlogger.debug(\"Jar files used by project '\" + projectName + \"': \");\n\t\t\tfor (String jarName : jarsUsed) {\n\t\t\t\tlogger.debug(\"  \" + jarName);\n\t\t\t}\t\n\t\t}\n\n\t\t// Configure the class loader for the plugins project dependencies\n\t\tStfClassLoader.setClassRoots(projectRoots);\n\t\tStfClassLoader.setJarPath(jarsUsed);\n\n\t\t// Work out if the current project is using STF\n\t\tboolean usesStf = false;\n\t\tfor (String root : projectRoots) {\n\t\t\tif (new File(root).getParentFile().getName().equals(StfConstants.STF_PROJECT_NAME)) {\n\t\t\t\tusesStf = true;\n\t\t\t}\n\t\t}\n\t\tfor (String jarName : jarsUsed) {\n\t\t\tString jarFileName = new File(jarName).getName();\n\t\t\tif (jarFileName.startsWith(StfConstants.STF_JAR_PREFIX) && jarFileName.endsWith(\".jar\")) {\n\t\t\t\tusesStf = true;\n\t\t\t}\n\t\t}\t\n\t\t\n\t\treturn usesStf;\n\t}\n\t\n\t\n\t/** \n\t * This method parses the .classpath file for a project to extract:\n\t *   1) directories to include on the classpath and\n\t *   2) jar files used by the project.\n\t *   \n\t * It recursively traverses dependent projects to make sure that a full \n\t * classpath can be built.\n\t * \n\t * @param environmentCore gives access to stf properties.\n\t * @param testRoot points to the directory containing test classes.\n\t * @param projectName is the name of the project to examine.\n\t * @param projectRoots contains all discovered classpath directories.\n\t * @param jarsUsed contains all discovered jar files.\n\t * @param processedProjects prevents infinite recursion by tracking which projects have\n\t * already been processed.\n\t * @throws StfException\n\t */\n\tprivate static void findProjectDependencies(StfEnvironmentCore environmentCore, String projectName, \n\t\t\t\t\t\tArrayList<String> projectRoots, HashSet<String> jarsUsed, \n\t\t\t\t\t\tHashSet<String> processedProjects) throws StfException {\n\t\t// Abandon this project if already done. Need to prevent infinite recursion.\n\t\tif (processedProjects.contains(projectName)) {\n\t\t\treturn;\n\t\t}\n\t\tlogger.trace(\"Examining dependencies for '\" + projectName + \"'\");\n\t\tprocessedProjects.add(projectName);\n\t\t\n\t\t// Set 'projectRef' to the location of the project on disk.\n\t\t// Firstly see if the project lives at '$test-root/<project>'\n\t\tDirectoryRef projectRef = environmentCore.findTestDirectory(projectName);\n\t\n\t\t// Work out where to read classpath configuration from.\n\t\t// First choice is the stfclasspath.xml file, otherwise eclipse .classpath file.\n\t\tFileRef stfClasspathFile = projectRef.childFile(StfConstants.STF_CLASSPATH_XML_FILE);\n\t\tFileRef classpathFile = projectRef.childFile(\".classpath\");\n\t\tFileRef projectConfig = null;\n\t\tif (stfClasspathFile.asJavaFile().exists()) {\n\t\t\tlogger.debug(projectName + \"/\" + StfConstants.STF_CLASSPATH_XML_FILE + \" file takes precedence over the projects .classpath\");\n\t\t\tprojectConfig = stfClasspathFile;  \n\t\t} else {\n\t\t\t// Normal case. Find dependencies from '<project>/.classpath' file.\n\t\t\tprojectConfig = classpathFile;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t// Open the projects .classpath xml file\n\t\t\tDocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tDocument doc = db.parse(projectConfig.asJavaFile());",
        "start_line": 100,
        "end_line": 189,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 874,
        "node_type": null,
        "file_sha": "e40301d9a1c27fd5102ac1bf0211e2232daa6907",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.418753"
      },
      "text": "System.out.println(\"Classpath directories used by project '\" + projectName + \"': \");\n\t\tfor (String root : projectRoots) {\n\t\t\tSystem.out.println(\"  \" + root);\n\t\t}\n\t\tfor (String jarName : jarsUsed) {\n\t\t\tSystem.out.println(\"  \" + jarName);\n\t\t}\t\n\n\t\t// Log the discovered dependencies\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Classpath directories used by project '\" + projectName + \"': \");\n\t\t\tfor (String root : projectRoots) {\n\t\t\t\tlogger.debug(\"  \" + root);\n\t\t\t}\n\t\t\tlogger.debug(\"Jar files used by project '\" + projectName + \"': \");\n\t\t\tfor (String jarName : jarsUsed) {\n\t\t\t\tlogger.debug(\"  \" + jarName);\n\t\t\t}\t\n\t\t}\n\n\t\t// Configure the class loader for the plugins project dependencies\n\t\tStfClassLoader.setClassRoots(projectRoots);\n\t\tStfClassLoader.setJarPath(jarsUsed);\n\n\t\t// Work out if the current project is using STF\n\t\tboolean usesStf = false;\n\t\tfor (String root : projectRoots) {\n\t\t\tif (new File(root).getParentFile().getName().equals(StfConstants.STF_PROJECT_NAME)) {\n\t\t\t\tusesStf = true;\n\t\t\t}\n\t\t}\n\t\tfor (String jarName : jarsUsed) {\n\t\t\tString jarFileName = new File(jarName).getName();\n\t\t\tif (jarFileName.startsWith(StfConstants.STF_JAR_PREFIX) && jarFileName.endsWith(\".jar\")) {\n\t\t\t\tusesStf = true;\n\t\t\t}\n\t\t}\t\n\t\t\n\t\treturn usesStf;\n\t}\n\t\n\t\n\t/** \n\t * This method parses the .classpath file for a project to extract:\n\t *   1) directories to include on the classpath and\n\t *   2) jar files used by the project.\n\t *   \n\t * It recursively traverses dependent projects to make sure that a full \n\t * classpath can be built.\n\t * \n\t * @param environmentCore gives access to stf properties.\n\t * @param testRoot points to the directory containing test classes.\n\t * @param projectName is the name of the project to examine.\n\t * @param projectRoots contains all discovered classpath directories.\n\t * @param jarsUsed contains all discovered jar files.\n\t * @param processedProjects prevents infinite recursion by tracking which projects have\n\t * already been processed.\n\t * @throws StfException\n\t */\n\tprivate static void findProjectDependencies(StfEnvironmentCore environmentCore, String projectName, \n\t\t\t\t\t\tArrayList<String> projectRoots, HashSet<String> jarsUsed, \n\t\t\t\t\t\tHashSet<String> processedProjects) throws StfException {\n\t\t// Abandon this project if already done. Need to prevent infinite recursion.\n\t\tif (processedProjects.contains(projectName)) {\n\t\t\treturn;\n\t\t}\n\t\tlogger.trace(\"Examining dependencies for '\" + projectName + \"'\");\n\t\tprocessedProjects.add(projectName);\n\t\t\n\t\t// Set 'projectRef' to the location of the project on disk.\n\t\t// Firstly see if the project lives at '$test-root/<project>'\n\t\tDirectoryRef projectRef = environmentCore.findTestDirectory(projectName);\n\t\n\t\t// Work out where to read classpath configuration from.\n\t\t// First choice is the stfclasspath.xml file, otherwise eclipse .classpath file.\n\t\tFileRef stfClasspathFile = projectRef.childFile(StfConstants.STF_CLASSPATH_XML_FILE);\n\t\tFileRef classpathFile = projectRef.childFile(\".classpath\");\n\t\tFileRef projectConfig = null;\n\t\tif (stfClasspathFile.asJavaFile().exists()) {\n\t\t\tlogger.debug(projectName + \"/\" + StfConstants.STF_CLASSPATH_XML_FILE + \" file takes precedence over the projects .classpath\");\n\t\t\tprojectConfig = stfClasspathFile;  \n\t\t} else {\n\t\t\t// Normal case. Find dependencies from '<project>/.classpath' file.\n\t\t\tprojectConfig = classpathFile;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t// Open the projects .classpath xml file\n\t\t\tDocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tDocument doc = db.parse(projectConfig.asJavaFile());"
    },
    "289": {
      "metadata": {
        "chunk_id": "cebc3461db9a6ddd57588873c8e09fff55f24a07907699e877fcf94418b4815c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/ClassPathConfigurator.java",
        "content": "// Find any optional j9output entries.  for projects. ie. classpathentry of kind 'src' and whose path starts with a '/'.\n\t\t\t// Only used in stfclasspath.xml to add extra roots for class files. Added for Java 9 modularity support.\n\t\t\tXPath xpathSrc = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression exprSrc = xpathSrc.compile(\"/classpath/classpathentry[@kind=\\\"j9output\\\"]/@path\");\n\t\t\t\n\t\t\t// Run the xpath query to extract the src entries\n\t\t\tNodeList nl = (NodeList) exprSrc.evaluate(doc, XPathConstants.NODESET);\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tString srcValue = node.getNodeValue();\n\t\t\t\tDirectoryRef srcBin = projectRef.childDirectory(srcValue);\n\t\t\t\tprojectRoots.add(srcBin.asJavaFile().getAbsolutePath());\n\t\t\t}\n\n\t\t\tDirectoryRef binDirectory = projectRef.childDirectory(\"bin\");\n\t\t\tprojectRoots.add(binDirectory.getSpec());\n\t\t\t\n\t\t\t// Find entries for projects. ie. classpathentry of kind 'src' and whose path starts with a '/'.\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression expr = xpath.compile(\"/classpath/classpathentry[@kind=\\\"src\\\" and starts-with(@path, '/')]/@path\");\n\t\t\t\n\t\t\t// Run the xpath query to extract the referenced projects\n\t\t\tnl = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tString otherProjectName = node.getNodeValue().substring(1);\n\t\t\t\tfindProjectDependencies(environmentCore, otherProjectName, projectRoots, jarsUsed, processedProjects);\n\t\t\t}\n\t\t\n\n\t\t\t// Build a query to find the jars used by the project\n\t\t\tXPath xpathJars = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression exprJars = xpathJars.compile(\"/classpath/classpathentry[@kind=\\\"lib\\\"]/@path\");\n\t\t\t\n\t\t\t// Run the xpath query to extract the jar locations\n\t\t\tnl = (NodeList) exprJars.evaluate(doc, XPathConstants.NODESET);\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tString jarName = node.getNodeValue();\n\t\t\t\tlogger.trace(\"  \" + projectName + \": jarName: \" + jarName);\n\t\t\t\t\n\t\t\t\t// Some classpath entries will refer to the systemtest-prereqs directory. This\n\t\t\t\t// is fine for eclipse time compiles, as it knows where the prereqs jars\n\t\t\t\t// really are.\n\t\t\t\t// But it's not fine for STF. It decides that the workspace root is the\n\t\t\t\t// parent directory of 'stf.core/scripts/stf.pl'. This takes it to the root of\n\t\t\t\t// the project that contains the stf code but there is then no sign of \n\t\t\t\t// jar references such as say '/systemtest_prereqs/log4j/log4j-api.jar'.\n\t\t\t\t// In such cases the full path to the jar is created found by replacing the first\n\t\t\t\t// part with the relevant systemtest-prereqs root.\n\t\t\t\t//\n\t\t\t\t// tools.jar is a special case. In order to resolve dependencies test cases have on\n\t\t\t\t// classes in tools.jar, tools.jar is copied into systemtest_prereqs at make configure time\n\t\t\t\t// (a reference to a particular Java location cannot be hard coded into the classpath file).\n\t\t\t\t// However. post Java 8, tools.jar is no longer present, so on test machines which have never\n\t\t\t\t// run a Java 8 test, tools.jar will not be present in systemtest_prereqs. So if we running\n\t\t\t\t// post Java 8, do not try to locate tools.jar.",
        "start_line": 190,
        "end_line": 246,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 820,
        "node_type": null,
        "file_sha": "e40301d9a1c27fd5102ac1bf0211e2232daa6907",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.418756"
      },
      "text": "// Find any optional j9output entries.  for projects. ie. classpathentry of kind 'src' and whose path starts with a '/'.\n\t\t\t// Only used in stfclasspath.xml to add extra roots for class files. Added for Java 9 modularity support.\n\t\t\tXPath xpathSrc = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression exprSrc = xpathSrc.compile(\"/classpath/classpathentry[@kind=\\\"j9output\\\"]/@path\");\n\t\t\t\n\t\t\t// Run the xpath query to extract the src entries\n\t\t\tNodeList nl = (NodeList) exprSrc.evaluate(doc, XPathConstants.NODESET);\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tString srcValue = node.getNodeValue();\n\t\t\t\tDirectoryRef srcBin = projectRef.childDirectory(srcValue);\n\t\t\t\tprojectRoots.add(srcBin.asJavaFile().getAbsolutePath());\n\t\t\t}\n\n\t\t\tDirectoryRef binDirectory = projectRef.childDirectory(\"bin\");\n\t\t\tprojectRoots.add(binDirectory.getSpec());\n\t\t\t\n\t\t\t// Find entries for projects. ie. classpathentry of kind 'src' and whose path starts with a '/'.\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression expr = xpath.compile(\"/classpath/classpathentry[@kind=\\\"src\\\" and starts-with(@path, '/')]/@path\");\n\t\t\t\n\t\t\t// Run the xpath query to extract the referenced projects\n\t\t\tnl = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tString otherProjectName = node.getNodeValue().substring(1);\n\t\t\t\tfindProjectDependencies(environmentCore, otherProjectName, projectRoots, jarsUsed, processedProjects);\n\t\t\t}\n\t\t\n\n\t\t\t// Build a query to find the jars used by the project\n\t\t\tXPath xpathJars = XPathFactory.newInstance().newXPath();\n\t\t\tXPathExpression exprJars = xpathJars.compile(\"/classpath/classpathentry[@kind=\\\"lib\\\"]/@path\");\n\t\t\t\n\t\t\t// Run the xpath query to extract the jar locations\n\t\t\tnl = (NodeList) exprJars.evaluate(doc, XPathConstants.NODESET);\n\t\t\tfor (int i=0; i<nl.getLength(); i++) {\n\t\t\t\tNode node = nl.item(i);\n\t\t\t\tString jarName = node.getNodeValue();\n\t\t\t\tlogger.trace(\"  \" + projectName + \": jarName: \" + jarName);\n\t\t\t\t\n\t\t\t\t// Some classpath entries will refer to the systemtest-prereqs directory. This\n\t\t\t\t// is fine for eclipse time compiles, as it knows where the prereqs jars\n\t\t\t\t// really are.\n\t\t\t\t// But it's not fine for STF. It decides that the workspace root is the\n\t\t\t\t// parent directory of 'stf.core/scripts/stf.pl'. This takes it to the root of\n\t\t\t\t// the project that contains the stf code but there is then no sign of \n\t\t\t\t// jar references such as say '/systemtest_prereqs/log4j/log4j-api.jar'.\n\t\t\t\t// In such cases the full path to the jar is created found by replacing the first\n\t\t\t\t// part with the relevant systemtest-prereqs root.\n\t\t\t\t//\n\t\t\t\t// tools.jar is a special case. In order to resolve dependencies test cases have on\n\t\t\t\t// classes in tools.jar, tools.jar is copied into systemtest_prereqs at make configure time\n\t\t\t\t// (a reference to a particular Java location cannot be hard coded into the classpath file).\n\t\t\t\t// However. post Java 8, tools.jar is no longer present, so on test machines which have never\n\t\t\t\t// run a Java 8 test, tools.jar will not be present in systemtest_prereqs. So if we running\n\t\t\t\t// post Java 8, do not try to locate tools.jar."
    },
    "290": {
      "metadata": {
        "chunk_id": "93faa7f687782396449321494e165c45b6a5830dd696c191b4a9ff126fbb62c1",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/ClassPathConfigurator.java",
        "content": "JavaVersion jvm = environmentCore.primaryJvm();\n\t\t\t\tif (jarName.startsWith(\"/systemtest_prereqs\")) {\n\t\t\t\t\tif ( jarName.endsWith(\"tools.jar\") && ! jvm.isJava8() ) {\n\t\t\t\t\t\tlogger.info(\"  \" + projectName + \": Ignoring classpath tools.jar entry because test is not executing against Java 8\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Jar needs to be found below a systemtest-prereqs root\n\t\t\t\t\t\tString tempJarPath = jarName.replace(\"/systemtest_prereqs\", \"\");\n\t\t\t\t\t\tString fullJarPath = environmentCore.findPrereqFile(tempJarPath).getSpec();\n\t\t\t\t\t\n\t\t\t\t\t\tjarsUsed.add(fullJarPath);\n\t\t\t\t\t\tif (!new File(fullJarPath).exists()) {\n\t\t\t\t\t\t\tthrow new StfException(\"Failed to parse '.classpath' file for project '\" + projectName + \"'. \"\n\t\t\t\t\t\t\t\t\t+ \"The jar file for entry '\" + jarName + \"' does not exist in any of the systemtest-prereqs roots at its expected location: '<systemtest_prereqs>\" + tempJarPath + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlogger.trace(\"  \" + projectName + \": Found prereq jar from 'lib' entry: '\" + fullJarPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Usual case. Find the jar within the eclipse workspace\n\t\t\t\t\tFileRef fullJarPath = environmentCore.findTestFile(jarName);\n\t\t\t\t\tjarsUsed.add(fullJarPath.getSpec());\n\t\t\t\t\tif (!fullJarPath.asJavaFile().exists()) {\n\t\t\t\t\t\tthrow new StfException(\"Failed to parse '.classpath' file for project '\" + projectName + \"'. \"\n\t\t\t\t\t\t\t\t+ \"The jar file for entry '\" + jarName + \"' does not exist in the eclipse workspace at '\" + fullJarPath + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tlogger.trace(\"  \" + projectName + \": Found jar from 'lib' entry: '\" + fullJarPath);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (XPathExpressionException e) {\n\t\t\tthrow new StfException(\"Failed to read from classpath file: \" + classpathFile.asJavaFile().getAbsolutePath(), e);\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new StfException(\"Failed to read from classpath file: \" + classpathFile.asJavaFile().getAbsolutePath(), e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to read from classpath file: \" + classpathFile.asJavaFile().getAbsolutePath(), e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new StfException(\"Failed to read from classpath file: \" + classpathFile.asJavaFile().getAbsolutePath(), e);\n\t\t}\n\t}\n}",
        "start_line": 247,
        "end_line": 285,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 561,
        "node_type": null,
        "file_sha": "e40301d9a1c27fd5102ac1bf0211e2232daa6907",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.418761"
      },
      "text": "JavaVersion jvm = environmentCore.primaryJvm();\n\t\t\t\tif (jarName.startsWith(\"/systemtest_prereqs\")) {\n\t\t\t\t\tif ( jarName.endsWith(\"tools.jar\") && ! jvm.isJava8() ) {\n\t\t\t\t\t\tlogger.info(\"  \" + projectName + \": Ignoring classpath tools.jar entry because test is not executing against Java 8\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Jar needs to be found below a systemtest-prereqs root\n\t\t\t\t\t\tString tempJarPath = jarName.replace(\"/systemtest_prereqs\", \"\");\n\t\t\t\t\t\tString fullJarPath = environmentCore.findPrereqFile(tempJarPath).getSpec();\n\t\t\t\t\t\n\t\t\t\t\t\tjarsUsed.add(fullJarPath);\n\t\t\t\t\t\tif (!new File(fullJarPath).exists()) {\n\t\t\t\t\t\t\tthrow new StfException(\"Failed to parse '.classpath' file for project '\" + projectName + \"'. \"\n\t\t\t\t\t\t\t\t\t+ \"The jar file for entry '\" + jarName + \"' does not exist in any of the systemtest-prereqs roots at its expected location: '<systemtest_prereqs>\" + tempJarPath + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlogger.trace(\"  \" + projectName + \": Found prereq jar from 'lib' entry: '\" + fullJarPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Usual case. Find the jar within the eclipse workspace\n\t\t\t\t\tFileRef fullJarPath = environmentCore.findTestFile(jarName);\n\t\t\t\t\tjarsUsed.add(fullJarPath.getSpec());\n\t\t\t\t\tif (!fullJarPath.asJavaFile().exists()) {\n\t\t\t\t\t\tthrow new StfException(\"Failed to parse '.classpath' file for project '\" + projectName + \"'. \"\n\t\t\t\t\t\t\t\t+ \"The jar file for entry '\" + jarName + \"' does not exist in the eclipse workspace at '\" + fullJarPath + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tlogger.trace(\"  \" + projectName + \": Found jar from 'lib' entry: '\" + fullJarPath);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (XPathExpressionException e) {\n\t\t\tthrow new StfException(\"Failed to read from classpath file: \" + classpathFile.asJavaFile().getAbsolutePath(), e);\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new StfException(\"Failed to read from classpath file: \" + classpathFile.asJavaFile().getAbsolutePath(), e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to read from classpath file: \" + classpathFile.asJavaFile().getAbsolutePath(), e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new StfException(\"Failed to read from classpath file: \" + classpathFile.asJavaFile().getAbsolutePath(), e);\n\t\t}\n\t}\n}"
    },
    "291": {
      "metadata": {
        "chunk_id": "d410869f404ffc1e1039ab7ff2973314eea7a09141e5137a8455cdd0763f5883",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/PluginFinder.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\n\n\n/**\n * This is an immutable class which takes a test plugin name (eg, 'UtilLoadTest') and finds:\n *   1) the class to run.\n *   2) the project it belongs to.\n */",
        "start_line": 0,
        "end_line": 32,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 249,
        "node_type": null,
        "file_sha": "286e274462a6001a5f071a7e4a23b70682f65153",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.439741"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\n\n\n/**\n * This is an immutable class which takes a test plugin name (eg, 'UtilLoadTest') and finds:\n *   1) the class to run.\n *   2) the project it belongs to.\n */"
    },
    "292": {
      "metadata": {
        "chunk_id": "faa89782ed01785e28655df221d02fa520741ac0b671e36900d3c5f09663c675",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/PluginFinder.java",
        "content": "public class PluginFinder {\n    private static final Logger logger = LogManager.getLogger(PluginFinder.class.getName());\n\n\tprivate String projectName; \n\tprivate String pluginClassName;\n\t\n\t/**\n\t * This constructor searches the workspace for a named test plugin.\n\t * This functionality is needed because running a test through STF requires only the \n\t * test name. Not having to specify anything more than just the test name makes it\n\t * easy to run a test, but does mean that STF has to do some more work.\n\t * \n\t * If the plugin class cannot be found then an exception is thrown. \n\t * \n\t * @param workspacePropertyValue contains the value of the workspace property. \n\t * @param workspaceRootRef points to the root of the workspace. ie. one level above the projects.\n\t * @param testRoot points to the directory containing test cases.\n\t * @param testName is the the name of the test whose plugin we want to find. eg, 'UtilLoadTest'\n\t * @throws StfException if a single suitable plugin class cannot be found.\n\t */\n\tpublic PluginFinder(ArrayList<DirectoryRef> testRootRefs, String testName) throws StfException {\n\n\t\tif (testRootRefs.isEmpty()) {\n\t\t\tthrow new StfException(\"PluginFinder was initialised with an empty list of potential test roots.\");\n\t\t}\n\t\t\n\t\tArrayList<File> javaProjects = new ArrayList<File>();\n\t\t\n\t\t// Find all projects below all test-roots\n\t\tfor (DirectoryRef testRootRef : testRootRefs) {\n\t\t\tFile testRoot = testRootRef.asJavaFile(); \n\t\t\tfor (File file : testRoot.listFiles()) {\n\t\t\t\tif (file.isDirectory()                         // We only want to examine projects, ie. directories\n\t\t\t\t\t\t&& !file.getName().startsWith(\".\")     // Ignore hidden directories/projects\n\t\t\t\t\t\t&& new File(file, \"bin\").exists()) {   // Java projects have a 'bin' directory\n\t\t\t\t\tjavaProjects.add(file);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Search through all projects looking for the test plugin\n\t\tLinkedHashSet<String> matchingProjects = new LinkedHashSet<String>();\n\t\tArrayList<String> matchingFiles = new ArrayList<String>();\n\t\tfor (File project : javaProjects) {\n\t\t\t// Start searching in the bin directory of the current project\n\t\t\tFile projectBin = new File(project, \"bin\");\n\t\t\tlogger.debug(\"Searching project: \" + projectBin.getAbsolutePath());\n\t\t\tif (findClass(testName + \".class\", projectBin, \"\", matchingFiles)) {\n\t\t\t\tlogger.info(\"Found test. Project: '\" + project.getName() + \"' class: '\" + testName + \".class\" + \"' Dir: '\" + projectBin.getAbsolutePath() + \"'\");\n\t\t\t\tmatchingProjects.add(project.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Fail if there is not exactly 1 matching class found \n\t\tif (matchingFiles.isEmpty()) {\n\t\t\t//First we assemble a list of test roots we searched in.\n\t\t\tString workspaces = \"\";\n\t\t\tfor (DirectoryRef oneTestRootRef : testRootRefs) {\n\t\t\t\tworkspaces = workspaces + \",'\" + oneTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error. \n\t\t\tSystem.out.println(Thread.currentThread().getStackTrace().toString());\n\t\t\tthrow new StfError(\"Could not find test plugin called '\" + testName + \"' \"\n\t\t\t\t\t+ \"in any of these workspaces: \" + workspaces.substring(1) + \". \"\n\t\t\t\t\t+ \"To fix this correct the name of the test plugin.\");\n\t\t}\n\t\tif (matchingFiles.size() > 1) {\n\t\t\tthrow new StfException(\"Ambiguous test name specified.\"\n\t\t\t\t\t+ \" Found \" + matchingFiles.size() + \" classes with the that name: \" + matchingFiles.toString() \n\t\t\t\t\t+ \" In projects: \" + matchingProjects);\n\t\t}\n\t\t\n\t\tthis.projectName = matchingProjects.iterator().next();\n\t\tthis.pluginClassName = matchingFiles.get(0);\n\n\t\tlogger.info(\"Found test. Project: '\" + projectName + \"' class: '\" + pluginClassName + \"'\");\n\t}",
        "start_line": 33,
        "end_line": 109,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 845,
        "node_type": null,
        "file_sha": "286e274462a6001a5f071a7e4a23b70682f65153",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.439774"
      },
      "text": "public class PluginFinder {\n    private static final Logger logger = LogManager.getLogger(PluginFinder.class.getName());\n\n\tprivate String projectName; \n\tprivate String pluginClassName;\n\t\n\t/**\n\t * This constructor searches the workspace for a named test plugin.\n\t * This functionality is needed because running a test through STF requires only the \n\t * test name. Not having to specify anything more than just the test name makes it\n\t * easy to run a test, but does mean that STF has to do some more work.\n\t * \n\t * If the plugin class cannot be found then an exception is thrown. \n\t * \n\t * @param workspacePropertyValue contains the value of the workspace property. \n\t * @param workspaceRootRef points to the root of the workspace. ie. one level above the projects.\n\t * @param testRoot points to the directory containing test cases.\n\t * @param testName is the the name of the test whose plugin we want to find. eg, 'UtilLoadTest'\n\t * @throws StfException if a single suitable plugin class cannot be found.\n\t */\n\tpublic PluginFinder(ArrayList<DirectoryRef> testRootRefs, String testName) throws StfException {\n\n\t\tif (testRootRefs.isEmpty()) {\n\t\t\tthrow new StfException(\"PluginFinder was initialised with an empty list of potential test roots.\");\n\t\t}\n\t\t\n\t\tArrayList<File> javaProjects = new ArrayList<File>();\n\t\t\n\t\t// Find all projects below all test-roots\n\t\tfor (DirectoryRef testRootRef : testRootRefs) {\n\t\t\tFile testRoot = testRootRef.asJavaFile(); \n\t\t\tfor (File file : testRoot.listFiles()) {\n\t\t\t\tif (file.isDirectory()                         // We only want to examine projects, ie. directories\n\t\t\t\t\t\t&& !file.getName().startsWith(\".\")     // Ignore hidden directories/projects\n\t\t\t\t\t\t&& new File(file, \"bin\").exists()) {   // Java projects have a 'bin' directory\n\t\t\t\t\tjavaProjects.add(file);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Search through all projects looking for the test plugin\n\t\tLinkedHashSet<String> matchingProjects = new LinkedHashSet<String>();\n\t\tArrayList<String> matchingFiles = new ArrayList<String>();\n\t\tfor (File project : javaProjects) {\n\t\t\t// Start searching in the bin directory of the current project\n\t\t\tFile projectBin = new File(project, \"bin\");\n\t\t\tlogger.debug(\"Searching project: \" + projectBin.getAbsolutePath());\n\t\t\tif (findClass(testName + \".class\", projectBin, \"\", matchingFiles)) {\n\t\t\t\tlogger.info(\"Found test. Project: '\" + project.getName() + \"' class: '\" + testName + \".class\" + \"' Dir: '\" + projectBin.getAbsolutePath() + \"'\");\n\t\t\t\tmatchingProjects.add(project.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Fail if there is not exactly 1 matching class found \n\t\tif (matchingFiles.isEmpty()) {\n\t\t\t//First we assemble a list of test roots we searched in.\n\t\t\tString workspaces = \"\";\n\t\t\tfor (DirectoryRef oneTestRootRef : testRootRefs) {\n\t\t\t\tworkspaces = workspaces + \",'\" + oneTestRootRef.getSpec() + \"'\";\n\t\t\t}\n\t\t\t//Then we throw the error. \n\t\t\tSystem.out.println(Thread.currentThread().getStackTrace().toString());\n\t\t\tthrow new StfError(\"Could not find test plugin called '\" + testName + \"' \"\n\t\t\t\t\t+ \"in any of these workspaces: \" + workspaces.substring(1) + \". \"\n\t\t\t\t\t+ \"To fix this correct the name of the test plugin.\");\n\t\t}\n\t\tif (matchingFiles.size() > 1) {\n\t\t\tthrow new StfException(\"Ambiguous test name specified.\"\n\t\t\t\t\t+ \" Found \" + matchingFiles.size() + \" classes with the that name: \" + matchingFiles.toString() \n\t\t\t\t\t+ \" In projects: \" + matchingProjects);\n\t\t}\n\t\t\n\t\tthis.projectName = matchingProjects.iterator().next();\n\t\tthis.pluginClassName = matchingFiles.get(0);\n\n\t\tlogger.info(\"Found test. Project: '\" + projectName + \"' class: '\" + pluginClassName + \"'\");\n\t}"
    },
    "293": {
      "metadata": {
        "chunk_id": "40f16cf09c45db4d328f62605e13fd778400d0c7d354cbc7a0bca031d69be5fe",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/PluginFinder.java",
        "content": "logger.info(\"Found test. Project: '\" + projectName + \"' class: '\" + pluginClassName + \"'\");\n\t}\n\n\n\t/**\n\t * Recursively finds a particular class file within a project.\n\t * \n\t * @param targetClassFile is the name of class to find. eg 'UtilLoadTest.class'\n\t * @param dir is the directory to search.\n\t * @param currPath is the path to the current directory.\n\t * @param matchingFiles is an ArrayList containing details on all matching classes.\n\t * @returns true if a matching class was found.\n\t */\n\tprivate boolean findClass(String targetClassFile, File dir, String currPath, ArrayList<String> matchingFiles) throws StfException {\n\t\tboolean found = false;\n\t\t\n\t\tif (dir == null) { \n\t\t\tthrow new StfException(\"Internal error: Cannot search null directory: \" + currPath);\n\t\t}\n\t\t\n\t\t// Produce debug output if the 'impossible' happens, and File.listFiles() returns null.\n\t\tFile[] directoryContents = dir.listFiles();\n\t\tif (directoryContents == null) {\n\t\t\t// Abandon search of the current directory\n\t\t\tlogger.warn(\"WARNING: PluginFinder.findClass() had a null return value from File.listFiles(). dir=\" + dir.getAbsolutePath() + \" path=\" + currPath);\n\t\t\treturn found;\n\t\t}\n\t\t\n\t\t// Search the contents of the current directory and its children\n\t\tfor (File f : directoryContents) {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tString newPath = currPath + \".\" + f.getName();\n\t\t\t\tfound |= findClass(targetClassFile, f, newPath, matchingFiles);\n\t\t\t} else if (f.getName().equals(targetClassFile)) {\n\t\t\t\t// Matching class file found. Add to results.\n\t\t\t\tString cleanedFileName = (currPath + \".\" + f.getName().replaceAll(\".class$\", \"\"));\n\t\t\t\tmatchingFiles.add(cleanedFileName.substring(1));\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn found;\n\t}\n\t\n\tpublic String getProjectName() {\n\t\treturn projectName;\n\t}\n\n\tpublic String getPluginClassName() {\n\t\treturn pluginClassName;\n\t}\n}",
        "start_line": 110,
        "end_line": 161,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 441,
        "node_type": null,
        "file_sha": "286e274462a6001a5f071a7e4a23b70682f65153",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.439778"
      },
      "text": "logger.info(\"Found test. Project: '\" + projectName + \"' class: '\" + pluginClassName + \"'\");\n\t}\n\n\n\t/**\n\t * Recursively finds a particular class file within a project.\n\t * \n\t * @param targetClassFile is the name of class to find. eg 'UtilLoadTest.class'\n\t * @param dir is the directory to search.\n\t * @param currPath is the path to the current directory.\n\t * @param matchingFiles is an ArrayList containing details on all matching classes.\n\t * @returns true if a matching class was found.\n\t */\n\tprivate boolean findClass(String targetClassFile, File dir, String currPath, ArrayList<String> matchingFiles) throws StfException {\n\t\tboolean found = false;\n\t\t\n\t\tif (dir == null) { \n\t\t\tthrow new StfException(\"Internal error: Cannot search null directory: \" + currPath);\n\t\t}\n\t\t\n\t\t// Produce debug output if the 'impossible' happens, and File.listFiles() returns null.\n\t\tFile[] directoryContents = dir.listFiles();\n\t\tif (directoryContents == null) {\n\t\t\t// Abandon search of the current directory\n\t\t\tlogger.warn(\"WARNING: PluginFinder.findClass() had a null return value from File.listFiles(). dir=\" + dir.getAbsolutePath() + \" path=\" + currPath);\n\t\t\treturn found;\n\t\t}\n\t\t\n\t\t// Search the contents of the current directory and its children\n\t\tfor (File f : directoryContents) {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tString newPath = currPath + \".\" + f.getName();\n\t\t\t\tfound |= findClass(targetClassFile, f, newPath, matchingFiles);\n\t\t\t} else if (f.getName().equals(targetClassFile)) {\n\t\t\t\t// Matching class file found. Add to results.\n\t\t\t\tString cleanedFileName = (currPath + \".\" + f.getName().replaceAll(\".class$\", \"\"));\n\t\t\t\tmatchingFiles.add(cleanedFileName.substring(1));\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn found;\n\t}\n\t\n\tpublic String getProjectName() {\n\t\treturn projectName;\n\t}\n\n\tpublic String getPluginClassName() {\n\t\treturn pluginClassName;\n\t}\n}"
    },
    "294": {
      "metadata": {
        "chunk_id": "f6b7a47170783bd3ca788cda11e80c40640f7d6855df0dbbf078e450eb579f37",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfClassLoader.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class loads the classes used by a STF plugin.\n * STF needs its own classloader because STF is started with the name of the plugin \n * to run, and not the full classpath needed for that plugin. \n * \n * It may seem more attractive to start STF with a suitable classpath and avoid the \n * complexities of having a custom class loader, but the 2 obvious solutions both \n * have significant problems: \n *   1) Starting with test specific classpath. \n *      For this to work STF would need to be started with the full classpath, which \n *      would either have to be supplied by the tester or read from some table\n *      containing the classpath needed for every test.\n *      It would obviously work but looses the current simplicity of just adding a \n *      new test and running with just a test name. Also introduces maintenance headaches. \n *   2) Start with every-in-the-workspace classpath.\n *      This is how the STF prototype used to work but has 2 problems. Firstly this \n *      classpath will become huge as projects are added, and secondly those projects \n *      will use external jar files which also have to be in the classpath (a problem \n *      which the prototype did not address.\n */",
        "start_line": 0,
        "end_line": 54,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 504,
        "node_type": null,
        "file_sha": "3f91f38f6160087ceff9f0ebe4b6bb66dc7b9e48",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.456901"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class loads the classes used by a STF plugin.\n * STF needs its own classloader because STF is started with the name of the plugin \n * to run, and not the full classpath needed for that plugin. \n * \n * It may seem more attractive to start STF with a suitable classpath and avoid the \n * complexities of having a custom class loader, but the 2 obvious solutions both \n * have significant problems: \n *   1) Starting with test specific classpath. \n *      For this to work STF would need to be started with the full classpath, which \n *      would either have to be supplied by the tester or read from some table\n *      containing the classpath needed for every test.\n *      It would obviously work but looses the current simplicity of just adding a \n *      new test and running with just a test name. Also introduces maintenance headaches. \n *   2) Start with every-in-the-workspace classpath.\n *      This is how the STF prototype used to work but has 2 problems. Firstly this \n *      classpath will become huge as projects are added, and secondly those projects \n *      will use external jar files which also have to be in the classpath (a problem \n *      which the prototype did not address.\n */"
    },
    "295": {
      "metadata": {
        "chunk_id": "478eb79e7b1f453254770fbc3af71bae8297cd357dfb3362a27baf84694a12f4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfClassLoader.java",
        "content": "public class StfClassLoader extends ClassLoader {\n    private static Logger logger = null;\n\n    // This holds a list of the projects from which classes are to be loaded.\n\tprivate String[] projectRoots = null;\n\t\n\t// This class loader is used to read classes from jar files used by the plugin.\n\tprivate ClassLoader jarClassLoader = null;\n\t\n\t// This maps from a full class name to the project it was loaded from.\n\t// This is needed so that the default properties for an extension can be found. \n\tprivate HashMap<String, String> loadedClassToProjectMap = new HashMap<String, String>();\n\t\n\t\n\tpublic StfClassLoader(ClassLoader parent) {\n\t\tsuper(parent);\n\t\t\n\t\t// In order to get this class loader to load StfRunner we need to find out where \n\t\t// this class lives on the file system, so that classes which live in the same\n\t\t// project (ie. the STF project) can be loaded.\n\t\t// Once StfRunner is running it will identify the test plugin to run, and from this it can  \n\t\t// find the projects and jars which that plugin needs to use. Once this has been done the  \n\t\t// root directories will be updated.\n\t\t// NB. This step is important. Without it the system class loader will load StfRunner\n\t\t// and the same class loader, and not this one, will be used to load everything else.\n    \tString currentProjectLocation = this.getClass().getProtectionDomain().getCodeSource().getLocation().getFile();\n    \tprojectRoots = new String[] { currentProjectLocation };\n\t}\n\n\t\n    public StfClassLoader() {\n        super(StfClassLoader.class.getClassLoader());\n    }  \n\n    \n    /**\n     * This method is called to tell the class loader about project directories which classes \n     * can be loaded from.\n     * @param projectRoots is an array containing the file names of project directories.\n     */\n    public void internalSetClassRoots(String... projectRoots) {\n    \tthis.projectRoots = projectRoots;\n    }\n\n    \n    public String internalGetProjectName(String className) {\n    \treturn loadedClassToProjectMap.get(className);\n    }\n\n    \n    /**\n     * This method is called to tell the class loader about jar files which the this class \n     * loader also needs to load classes from.\n     * @param jarList is a array containing the full path to jar files.\n     * @throws StfException\n     */\n    public void internalSetJarPath(String... jarList) throws StfException {\n    \tArrayList<URL> urls = new ArrayList<URL>();\n    \t\n    \t// Convert the jar file names to URL objects\n    \tfor (String jarFileName : jarList) {\n    \t\ttry {\n    \t\t\tFile jarFile  = new File(jarFileName);\n    \t\t\turls.add(jarFile.toURI().toURL());\n    \t\t} catch (MalformedURLException e) {\n    \t\t\tthrow new StfException(\"Failed to get URL for jar file: \" + jarFileName);\n    \t\t}  \n    \t}\n    \t\n\t    jarClassLoader = new URLClassLoader(urls.toArray(new URL[] {}));\n    }\n    \n\n    /**\n     * This is the main method for class loading.\n     * It tries to load the class from several known sources\n     */\n    public Class<?> loadClass(String className) throws ClassNotFoundException {\n    \t// Shortcut for java classes. Always use the system class loader\n    \tif (className.startsWith(\"java.\") || className.startsWith(\"javax.\") || className.startsWith(\"sun.\") || className.startsWith(\"com.sun.\")) {\n    \t\treturn super.loadClass(className);\n    \t}\n    \t\n    \t// Work out the real name of the class\n    \tclassName = correctClassName(className);\n\n    \t// Try to load from the projects used by the plugin\n        Class<?> clazz = findClass(className);\n\t    if (clazz != null) { \n\t    \treturn clazz;\n\t    }\n        \n\t    // Try to get the class from a jar file\n        if (jarClassLoader != null) {\n            return jarClassLoader.loadClass(className);\n        }\n        \n        // As the last resort, use the system class loader\n        return super.loadClass(className);\n    }",
        "start_line": 55,
        "end_line": 154,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 851,
        "node_type": null,
        "file_sha": "3f91f38f6160087ceff9f0ebe4b6bb66dc7b9e48",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.456912"
      },
      "text": "public class StfClassLoader extends ClassLoader {\n    private static Logger logger = null;\n\n    // This holds a list of the projects from which classes are to be loaded.\n\tprivate String[] projectRoots = null;\n\t\n\t// This class loader is used to read classes from jar files used by the plugin.\n\tprivate ClassLoader jarClassLoader = null;\n\t\n\t// This maps from a full class name to the project it was loaded from.\n\t// This is needed so that the default properties for an extension can be found. \n\tprivate HashMap<String, String> loadedClassToProjectMap = new HashMap<String, String>();\n\t\n\t\n\tpublic StfClassLoader(ClassLoader parent) {\n\t\tsuper(parent);\n\t\t\n\t\t// In order to get this class loader to load StfRunner we need to find out where \n\t\t// this class lives on the file system, so that classes which live in the same\n\t\t// project (ie. the STF project) can be loaded.\n\t\t// Once StfRunner is running it will identify the test plugin to run, and from this it can  \n\t\t// find the projects and jars which that plugin needs to use. Once this has been done the  \n\t\t// root directories will be updated.\n\t\t// NB. This step is important. Without it the system class loader will load StfRunner\n\t\t// and the same class loader, and not this one, will be used to load everything else.\n    \tString currentProjectLocation = this.getClass().getProtectionDomain().getCodeSource().getLocation().getFile();\n    \tprojectRoots = new String[] { currentProjectLocation };\n\t}\n\n\t\n    public StfClassLoader() {\n        super(StfClassLoader.class.getClassLoader());\n    }  \n\n    \n    /**\n     * This method is called to tell the class loader about project directories which classes \n     * can be loaded from.\n     * @param projectRoots is an array containing the file names of project directories.\n     */\n    public void internalSetClassRoots(String... projectRoots) {\n    \tthis.projectRoots = projectRoots;\n    }\n\n    \n    public String internalGetProjectName(String className) {\n    \treturn loadedClassToProjectMap.get(className);\n    }\n\n    \n    /**\n     * This method is called to tell the class loader about jar files which the this class \n     * loader also needs to load classes from.\n     * @param jarList is a array containing the full path to jar files.\n     * @throws StfException\n     */\n    public void internalSetJarPath(String... jarList) throws StfException {\n    \tArrayList<URL> urls = new ArrayList<URL>();\n    \t\n    \t// Convert the jar file names to URL objects\n    \tfor (String jarFileName : jarList) {\n    \t\ttry {\n    \t\t\tFile jarFile  = new File(jarFileName);\n    \t\t\turls.add(jarFile.toURI().toURL());\n    \t\t} catch (MalformedURLException e) {\n    \t\t\tthrow new StfException(\"Failed to get URL for jar file: \" + jarFileName);\n    \t\t}  \n    \t}\n    \t\n\t    jarClassLoader = new URLClassLoader(urls.toArray(new URL[] {}));\n    }\n    \n\n    /**\n     * This is the main method for class loading.\n     * It tries to load the class from several known sources\n     */\n    public Class<?> loadClass(String className) throws ClassNotFoundException {\n    \t// Shortcut for java classes. Always use the system class loader\n    \tif (className.startsWith(\"java.\") || className.startsWith(\"javax.\") || className.startsWith(\"sun.\") || className.startsWith(\"com.sun.\")) {\n    \t\treturn super.loadClass(className);\n    \t}\n    \t\n    \t// Work out the real name of the class\n    \tclassName = correctClassName(className);\n\n    \t// Try to load from the projects used by the plugin\n        Class<?> clazz = findClass(className);\n\t    if (clazz != null) { \n\t    \treturn clazz;\n\t    }\n        \n\t    // Try to get the class from a jar file\n        if (jarClassLoader != null) {\n            return jarClassLoader.loadClass(className);\n        }\n        \n        // As the last resort, use the system class loader\n        return super.loadClass(className);\n    }"
    },
    "296": {
      "metadata": {
        "chunk_id": "a6785e1a5cfba379058ed3fd3ca3dcb64035a2af756ba757279d9e5b1025e32b",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfClassLoader.java",
        "content": "// Try to load from the projects used by the plugin\n        Class<?> clazz = findClass(className);\n\t    if (clazz != null) { \n\t    \treturn clazz;\n\t    }\n        \n\t    // Try to get the class from a jar file\n        if (jarClassLoader != null) {\n            return jarClassLoader.loadClass(className);\n        }\n        \n        // As the last resort, use the system class loader\n        return super.loadClass(className);\n    }  \n\n\n    // The search for classes recursively looks at all classes below the projects bin file.\n    // This works fine for Java 8 and earlier but breaks down with the structure currently used \n    // for Java 9 modularity projects, which effectively have multiple project roots within\n    // the bin hierarchy.\n    // This method takes the presumed class name for a class found below the bin directory and\n    // works out what its class name really is.\n    //\n    // Here is a simplified example. A project could have 2 bin roots defined:\n    //    /tmp/runtimestest_build/ascii/test.modularity/bin/common/displayServiceImpl4\n    //    /tmp/runtimestest_build/ascii/test.modularity/bin\n    // The search in the projects bin directory finds the file:\n    //    common/displayServiceImpl4/net/adoptopenjdk/displayImpl4/DisplayServiceImpl4.class\n    // Which is converted to the class name:\n    //    common.displayServiceImpl4.net.adoptopenjdk.displayImpl4.DisplayServiceImpl4\n    // A classfile is *not* found at:\n    //    .../test.modularity/bin/common/displayServiceImpl4/common/displayServiceImpl4/net/adoptopenjdk/displayImpl4/DisplayServiceImpl4.class\n    // But notice that the end of the project root and the start of the proposed class \n    // name are the same, so removing this part of the class name does find an actual \n    // class file at:\n    //    .../test.modularity/bin/common/displayServiceImpl4/net/adoptopenjdk/displayImpl4/DisplayServiceImpl4.class\n    // So in this case the 'common/displayServiceImpl4/' is removed and the class name is corrected to:\n    //    net/adoptopenjdk/displayImpl4/DisplayServiceImpl4\n    //\n    // This complex logic is needed because the trees created in the bin directory by \n    // a projects modules and normal source code unfortunately overlap. \n    private String correctClassName(String className) {\n        String slashedClassName = className.replace('.', File.separatorChar);\n        \n        // Examine every root to see if the class belongs to it\n    \tfor (String currentRoot : projectRoots) {\n    \t\t// Remove any trailing slash from the project root\n    \t\tif (currentRoot.endsWith(File.separator)) {\n    \t\t\tcurrentRoot = currentRoot.substring(0, currentRoot.length()-1);\n    \t\t}\n    \t\t\n    \t\t// Abandon search if file exists within the current project root\n\t\t\tString fileName = currentRoot + File.separatorChar + slashedClassName + \".class\";\n\t        File file = new File(fileName);\n\t        if (file.exists()) {\n\t        \tbreak;\n\t        }\n\n\t        // Examine the end of the currentRoot string to see if it overlaps the start of the class name.\n\t        // Works back through every '/' from the end to the start of current root.\n\t        int lastSlashIndex = currentRoot.lastIndexOf(File.separatorChar);\n        \tboolean foundOverlap = false;\n        \t// Keep going whilst the last part of current root can be found in the slashedClassName\n        \twhile (lastSlashIndex >=0 && slashedClassName.contains(currentRoot.substring(lastSlashIndex+1))) {\n        \t\tif (slashedClassName.startsWith(currentRoot.substring(lastSlashIndex+1))) {\n        \t\t\t// Full overlap found. \n        \t\t\tfoundOverlap = true;\n        \t\t\tbreak;\n        \t\t}\n        \t\tlastSlashIndex = currentRoot.lastIndexOf(File.separatorChar, lastSlashIndex-1);\n        \t}\n        \tif (!foundOverlap) {\n        \t\t// The class doesn't live within the current project root\n        \t\tcontinue;\n        \t}",
        "start_line": 155,
        "end_line": 229,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 820,
        "node_type": null,
        "file_sha": "3f91f38f6160087ceff9f0ebe4b6bb66dc7b9e48",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.456916"
      },
      "text": "// Try to load from the projects used by the plugin\n        Class<?> clazz = findClass(className);\n\t    if (clazz != null) { \n\t    \treturn clazz;\n\t    }\n        \n\t    // Try to get the class from a jar file\n        if (jarClassLoader != null) {\n            return jarClassLoader.loadClass(className);\n        }\n        \n        // As the last resort, use the system class loader\n        return super.loadClass(className);\n    }  \n\n\n    // The search for classes recursively looks at all classes below the projects bin file.\n    // This works fine for Java 8 and earlier but breaks down with the structure currently used \n    // for Java 9 modularity projects, which effectively have multiple project roots within\n    // the bin hierarchy.\n    // This method takes the presumed class name for a class found below the bin directory and\n    // works out what its class name really is.\n    //\n    // Here is a simplified example. A project could have 2 bin roots defined:\n    //    /tmp/runtimestest_build/ascii/test.modularity/bin/common/displayServiceImpl4\n    //    /tmp/runtimestest_build/ascii/test.modularity/bin\n    // The search in the projects bin directory finds the file:\n    //    common/displayServiceImpl4/net/adoptopenjdk/displayImpl4/DisplayServiceImpl4.class\n    // Which is converted to the class name:\n    //    common.displayServiceImpl4.net.adoptopenjdk.displayImpl4.DisplayServiceImpl4\n    // A classfile is *not* found at:\n    //    .../test.modularity/bin/common/displayServiceImpl4/common/displayServiceImpl4/net/adoptopenjdk/displayImpl4/DisplayServiceImpl4.class\n    // But notice that the end of the project root and the start of the proposed class \n    // name are the same, so removing this part of the class name does find an actual \n    // class file at:\n    //    .../test.modularity/bin/common/displayServiceImpl4/net/adoptopenjdk/displayImpl4/DisplayServiceImpl4.class\n    // So in this case the 'common/displayServiceImpl4/' is removed and the class name is corrected to:\n    //    net/adoptopenjdk/displayImpl4/DisplayServiceImpl4\n    //\n    // This complex logic is needed because the trees created in the bin directory by \n    // a projects modules and normal source code unfortunately overlap. \n    private String correctClassName(String className) {\n        String slashedClassName = className.replace('.', File.separatorChar);\n        \n        // Examine every root to see if the class belongs to it\n    \tfor (String currentRoot : projectRoots) {\n    \t\t// Remove any trailing slash from the project root\n    \t\tif (currentRoot.endsWith(File.separator)) {\n    \t\t\tcurrentRoot = currentRoot.substring(0, currentRoot.length()-1);\n    \t\t}\n    \t\t\n    \t\t// Abandon search if file exists within the current project root\n\t\t\tString fileName = currentRoot + File.separatorChar + slashedClassName + \".class\";\n\t        File file = new File(fileName);\n\t        if (file.exists()) {\n\t        \tbreak;\n\t        }\n\n\t        // Examine the end of the currentRoot string to see if it overlaps the start of the class name.\n\t        // Works back through every '/' from the end to the start of current root.\n\t        int lastSlashIndex = currentRoot.lastIndexOf(File.separatorChar);\n        \tboolean foundOverlap = false;\n        \t// Keep going whilst the last part of current root can be found in the slashedClassName\n        \twhile (lastSlashIndex >=0 && slashedClassName.contains(currentRoot.substring(lastSlashIndex+1))) {\n        \t\tif (slashedClassName.startsWith(currentRoot.substring(lastSlashIndex+1))) {\n        \t\t\t// Full overlap found. \n        \t\t\tfoundOverlap = true;\n        \t\t\tbreak;\n        \t\t}\n        \t\tlastSlashIndex = currentRoot.lastIndexOf(File.separatorChar, lastSlashIndex-1);\n        \t}\n        \tif (!foundOverlap) {\n        \t\t// The class doesn't live within the current project root\n        \t\tcontinue;\n        \t}"
    },
    "297": {
      "metadata": {
        "chunk_id": "d9b69e38706cbb83ad3b16fad885402f1b0df5a33b8da187658f47e0f75087be",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfClassLoader.java",
        "content": "// Found an overlap between end of current root and the start of the class name.\n        \t// We know how long the overlap is, so remove that many characters from the start of the class name.\n        \tint overlapLen = currentRoot.length() - lastSlashIndex;\n        \tString actualClassName = className.substring(overlapLen);\n        \tfileName = currentRoot + File.separatorChar + actualClassName.replace('.', File.separatorChar) + \".class\";\n        \tfile = new File(fileName);\n        \tif (file.exists()) {\n        \t\t// Class exists! Return corrected name\n        \t\treturn actualClassName;\n        \t}        \t\n        }\n        \n    \t// No change\n        return className;         \n    }\n    \n    \n    public Class<?> findClass(String name) throws ClassNotFoundException{\n\t\t// If the class has already been loaded then return the existing class object.\n    \t// Very rare code path, but can happen when running on an Oracle JVM.\n    \tClass<?> cachedClass = findLoadedClass(name);\n    \tif (cachedClass != null) {\n    \t\tlogger.trace(\"Class already loaded: \" + name);\n    \t\treturn cachedClass; \n    \t}\n\n    \tbyte[] classBytes = loadClassBytes(name);\n        if (classBytes != null) {\n        \treturn defineClass(name, classBytes, 0, classBytes.length);\n        } else {\n        \treturn null;\n        }\n    }\n    \n    \n    /**\n     * Attempt to load a class from the root bin directory of all know projects.\n     * It is this method which allows STF to load the classes from plugins project.\n     * \n     * @param className is the full name of the class to load.\n     * @return the bytes of the class, or null if it cannot be found in the known projects.\n     * @throws ClassNotFoundException if there was an IO error.\n     */\n    public byte[] loadClassBytes(String className) throws ClassNotFoundException {\n    \t// Attempt to load the class from all projects.\n    \t// This is not optimal but appears adequate as it's not loading many classes.\n    \tfor (String currentRoot : projectRoots) {\n    \t\tBufferedInputStream inFile = null;\n\t        try{\n\t            String fileName = currentRoot + File.separatorChar + className.replace('.', File.separatorChar) + \".class\";\n\t            File file = new File(fileName);\n\t            if (!file.exists()) continue;\n\t            \n\t            // Record which project the class has been loaded from\n\t            loadedClassToProjectMap.put(className, currentRoot);\n\n\t            // Read in the contents of the class file\n\t\t\t\tinFile = new BufferedInputStream(new FileInputStream(file));\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream((int) file.length());\n\t\t\t\tint b;\n\t\t\t\twhile ((b = inFile.read()) != -1) {\n\t\t\t\t\tout.write(b);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Optional logging\n\t\t\t\tif (logger == null) {\n\t\t\t\t\t// find the logger at run time. If done during class initialisation then you get a recursive class loading error.\n\t\t\t\t\tlogger = LogManager.getLogger(StfClassLoader.class.getName());\n\t\t\t\t}\n\t\t\t\tlogger.trace(\"Loaded class: \" + currentRoot + \" \" + className);\n\t\t\t\t\n\t\t\t\treturn out.toByteArray();\n\t        }\n\t        catch (java.io.IOException e) {\n\t        \tthrow new ClassNotFoundException(\"Failed to load class '\" + className + \"' below '\" + currentRoot + \"'\", e);\n\t        } finally {\n\t        \ttry {\n\t\t\t\t\tif (inFile != null) inFile.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new ClassNotFoundException(\"Failed to close file for class '\" + className + \"' below '\" + currentRoot + \"'\", e);\n\t\t\t\t}\n\t        }\n    \t}\n    \t\n    \treturn null;\n    }\n    \n    \n    @Override\n    protected URL findResource(String resName) {\n    \tURL resource = super.findResource(resName);\n    \tif (resource != null) {\n    \t\treturn resource;\n    \t}",
        "start_line": 230,
        "end_line": 323,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 777,
        "node_type": null,
        "file_sha": "3f91f38f6160087ceff9f0ebe4b6bb66dc7b9e48",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.456919"
      },
      "text": "// Found an overlap between end of current root and the start of the class name.\n        \t// We know how long the overlap is, so remove that many characters from the start of the class name.\n        \tint overlapLen = currentRoot.length() - lastSlashIndex;\n        \tString actualClassName = className.substring(overlapLen);\n        \tfileName = currentRoot + File.separatorChar + actualClassName.replace('.', File.separatorChar) + \".class\";\n        \tfile = new File(fileName);\n        \tif (file.exists()) {\n        \t\t// Class exists! Return corrected name\n        \t\treturn actualClassName;\n        \t}        \t\n        }\n        \n    \t// No change\n        return className;         \n    }\n    \n    \n    public Class<?> findClass(String name) throws ClassNotFoundException{\n\t\t// If the class has already been loaded then return the existing class object.\n    \t// Very rare code path, but can happen when running on an Oracle JVM.\n    \tClass<?> cachedClass = findLoadedClass(name);\n    \tif (cachedClass != null) {\n    \t\tlogger.trace(\"Class already loaded: \" + name);\n    \t\treturn cachedClass; \n    \t}\n\n    \tbyte[] classBytes = loadClassBytes(name);\n        if (classBytes != null) {\n        \treturn defineClass(name, classBytes, 0, classBytes.length);\n        } else {\n        \treturn null;\n        }\n    }\n    \n    \n    /**\n     * Attempt to load a class from the root bin directory of all know projects.\n     * It is this method which allows STF to load the classes from plugins project.\n     * \n     * @param className is the full name of the class to load.\n     * @return the bytes of the class, or null if it cannot be found in the known projects.\n     * @throws ClassNotFoundException if there was an IO error.\n     */\n    public byte[] loadClassBytes(String className) throws ClassNotFoundException {\n    \t// Attempt to load the class from all projects.\n    \t// This is not optimal but appears adequate as it's not loading many classes.\n    \tfor (String currentRoot : projectRoots) {\n    \t\tBufferedInputStream inFile = null;\n\t        try{\n\t            String fileName = currentRoot + File.separatorChar + className.replace('.', File.separatorChar) + \".class\";\n\t            File file = new File(fileName);\n\t            if (!file.exists()) continue;\n\t            \n\t            // Record which project the class has been loaded from\n\t            loadedClassToProjectMap.put(className, currentRoot);\n\n\t            // Read in the contents of the class file\n\t\t\t\tinFile = new BufferedInputStream(new FileInputStream(file));\n\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream((int) file.length());\n\t\t\t\tint b;\n\t\t\t\twhile ((b = inFile.read()) != -1) {\n\t\t\t\t\tout.write(b);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Optional logging\n\t\t\t\tif (logger == null) {\n\t\t\t\t\t// find the logger at run time. If done during class initialisation then you get a recursive class loading error.\n\t\t\t\t\tlogger = LogManager.getLogger(StfClassLoader.class.getName());\n\t\t\t\t}\n\t\t\t\tlogger.trace(\"Loaded class: \" + currentRoot + \" \" + className);\n\t\t\t\t\n\t\t\t\treturn out.toByteArray();\n\t        }\n\t        catch (java.io.IOException e) {\n\t        \tthrow new ClassNotFoundException(\"Failed to load class '\" + className + \"' below '\" + currentRoot + \"'\", e);\n\t        } finally {\n\t        \ttry {\n\t\t\t\t\tif (inFile != null) inFile.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new ClassNotFoundException(\"Failed to close file for class '\" + className + \"' below '\" + currentRoot + \"'\", e);\n\t\t\t\t}\n\t        }\n    \t}\n    \t\n    \treturn null;\n    }\n    \n    \n    @Override\n    protected URL findResource(String resName) {\n    \tURL resource = super.findResource(resName);\n    \tif (resource != null) {\n    \t\treturn resource;\n    \t}"
    },
    "298": {
      "metadata": {
        "chunk_id": "6eee79cad78df1e7e8989777770379568c8fa7a1ec9578464b5b2bc9bff8ded2",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfClassLoader.java",
        "content": "// Attempt to find the resource in one of the projects\n    \tfor (String currentRoot : projectRoots) {\n            String candidateFileName = currentRoot + File.separatorChar + resName;\n            if (new File(candidateFileName).exists()) {\n\t\t\t\ttry {\n\t\t\t\t\treturn new URL(\"file://\" + candidateFileName);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new IllegalStateException(\"Failed to create URL for file at: \" + candidateFileName);\n\t\t\t\t}\n            }\n    \t}\n\n    \t// Didn't find. Let parent class loader decide what to do\n\t\treturn null;\n    }\n    \n\n    //=================================================================================================\n    // The following methods act as an interface to the STF class loader.\n    //\n    // NB. The class loader has to be called using reflection as calling it directly by\n    // getting its reference and casting it doesn't work (as the calling class and the \n    // StfClassLoader have been loaded by different class loaders).\n    // \n    // So the following static methods call the STF class loader by using reflection.\n    //\n    \n    /**\n     * This method is used to find out which project a loaded class belongs to.\n     *  \n     * @param className is the class name in the query.\n     * @return a String containing the project name which contains the class. \n     * @throws StfException if the reflection based call failed.\n     */\n    public static String getProjectName(String className) throws StfException {\n\t\tString methodName = \"internalGetProjectName\";\n\t\ttry {\n\t\t\tClassLoader cl = StfClassLoader.class.getClassLoader();\n\t\t\tMethod method = cl.getClass().getMethod(methodName, new Class[] { String.class });\n\t\t\tObject result = method.invoke(cl, new Object[] { className } );\n\t\t\tif (result == null) { \n\t\t\t\tthrow new StfException(\"Failed to find project owning class: \" + className);\n\t\t\t}\n\t\t\treturn (String) result;\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to invoke method: \" + methodName, e); \n\t\t}\n    }\n    \n\t// Tell the class loader which project directories we can load classes from.\n    public static void setClassRoots(ArrayList<String> projectRoots) throws StfException {\n\t\tString methodName = \"internalSetClassRoots\";\n\t\ttry {\n\t\t\tClassLoader stfClassLoader = StfClassLoader.class.getClassLoader();\n\t\t\tMethod method = stfClassLoader.getClass().getMethod(methodName, new Class[] { String[].class });\n\t\t\tString[] projectRootsAsArray = projectRoots.toArray(new String[] {});\n\t\t\tmethod.invoke(stfClassLoader, new Object[]{ projectRootsAsArray });\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to invoke method: \" + methodName, e); \n\t\t}\n    }\n    \n\t// Tell the stf class loader which jar files the plugin needs to use.\n    public static void setJarPath(HashSet<String> jarsUsed) throws StfException {\n    \tString methodName = \"internalSetJarPath\";\n\t\ttry {\n\t\t\tClassLoader stfClassLoader = StfClassLoader.class.getClassLoader();\n\t\t\tMethod method = stfClassLoader.getClass().getMethod(methodName, new Class[] { String[].class });\n\t\t\tString[] jarsUsedAsArray = jarsUsed.toArray(new String[] {});\n\t\t\tmethod.invoke(stfClassLoader, new Object[]{ jarsUsedAsArray });\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to invoke method: \" + methodName, e); \n\t\t}\n    }\n}",
        "start_line": 324,
        "end_line": 398,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 729,
        "node_type": null,
        "file_sha": "3f91f38f6160087ceff9f0ebe4b6bb66dc7b9e48",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.456921"
      },
      "text": "// Attempt to find the resource in one of the projects\n    \tfor (String currentRoot : projectRoots) {\n            String candidateFileName = currentRoot + File.separatorChar + resName;\n            if (new File(candidateFileName).exists()) {\n\t\t\t\ttry {\n\t\t\t\t\treturn new URL(\"file://\" + candidateFileName);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new IllegalStateException(\"Failed to create URL for file at: \" + candidateFileName);\n\t\t\t\t}\n            }\n    \t}\n\n    \t// Didn't find. Let parent class loader decide what to do\n\t\treturn null;\n    }\n    \n\n    //=================================================================================================\n    // The following methods act as an interface to the STF class loader.\n    //\n    // NB. The class loader has to be called using reflection as calling it directly by\n    // getting its reference and casting it doesn't work (as the calling class and the \n    // StfClassLoader have been loaded by different class loaders).\n    // \n    // So the following static methods call the STF class loader by using reflection.\n    //\n    \n    /**\n     * This method is used to find out which project a loaded class belongs to.\n     *  \n     * @param className is the class name in the query.\n     * @return a String containing the project name which contains the class. \n     * @throws StfException if the reflection based call failed.\n     */\n    public static String getProjectName(String className) throws StfException {\n\t\tString methodName = \"internalGetProjectName\";\n\t\ttry {\n\t\t\tClassLoader cl = StfClassLoader.class.getClassLoader();\n\t\t\tMethod method = cl.getClass().getMethod(methodName, new Class[] { String.class });\n\t\t\tObject result = method.invoke(cl, new Object[] { className } );\n\t\t\tif (result == null) { \n\t\t\t\tthrow new StfException(\"Failed to find project owning class: \" + className);\n\t\t\t}\n\t\t\treturn (String) result;\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to invoke method: \" + methodName, e); \n\t\t}\n    }\n    \n\t// Tell the class loader which project directories we can load classes from.\n    public static void setClassRoots(ArrayList<String> projectRoots) throws StfException {\n\t\tString methodName = \"internalSetClassRoots\";\n\t\ttry {\n\t\t\tClassLoader stfClassLoader = StfClassLoader.class.getClassLoader();\n\t\t\tMethod method = stfClassLoader.getClass().getMethod(methodName, new Class[] { String[].class });\n\t\t\tString[] projectRootsAsArray = projectRoots.toArray(new String[] {});\n\t\t\tmethod.invoke(stfClassLoader, new Object[]{ projectRootsAsArray });\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to invoke method: \" + methodName, e); \n\t\t}\n    }\n    \n\t// Tell the stf class loader which jar files the plugin needs to use.\n    public static void setJarPath(HashSet<String> jarsUsed) throws StfException {\n    \tString methodName = \"internalSetJarPath\";\n\t\ttry {\n\t\t\tClassLoader stfClassLoader = StfClassLoader.class.getClassLoader();\n\t\t\tMethod method = stfClassLoader.getClass().getMethod(methodName, new Class[] { String[].class });\n\t\t\tString[] jarsUsedAsArray = jarsUsed.toArray(new String[] {});\n\t\t\tmethod.invoke(stfClassLoader, new Object[]{ jarsUsedAsArray });\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to invoke method: \" + methodName, e); \n\t\t}\n    }\n}"
    },
    "299": {
      "metadata": {
        "chunk_id": "25cef07081a578de8c6ea307a8b83f018c823b294ac6903c711b33eb00bc5870",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport org.apache.logging.log4j.Level;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.core.LoggerContext;\nimport org.apache.logging.log4j.core.config.LoggerConfig;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.codeGeneration.Stage;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.OrderedProperties.PropertyFileDetails;\nimport net.adoptopenjdk.stf.extensions.Stf;\nimport net.adoptopenjdk.stf.extensions.StfExtensionBase;\nimport net.adoptopenjdk.stf.extensions.interfaces.StfExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginRootInterface;\nimport net.adoptopenjdk.stf.processes.definitions.JlinkDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JmodDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\nimport net.adoptopenjdk.stf.runner.modes.PluginList;\n\n\n/**\n * This class is the entry point for running STF.\n */",
        "start_line": 0,
        "end_line": 54,
        "chunk_index": 0,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 494,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474270"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport org.apache.logging.log4j.Level;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.core.LoggerContext;\nimport org.apache.logging.log4j.core.config.LoggerConfig;\n\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.codeGeneration.Stage;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.OrderedProperties.PropertyFileDetails;\nimport net.adoptopenjdk.stf.extensions.Stf;\nimport net.adoptopenjdk.stf.extensions.StfExtensionBase;\nimport net.adoptopenjdk.stf.extensions.interfaces.StfExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginRootInterface;\nimport net.adoptopenjdk.stf.processes.definitions.JlinkDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.JmodDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\nimport net.adoptopenjdk.stf.runner.modes.PluginList;\n\n\n/**\n * This class is the entry point for running STF.\n */"
    },
    "300": {
      "metadata": {
        "chunk_id": "0174bb45c760a7deafa757b4d4169d9a9bd93296ea7dbe337624991f6db049c4",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "public class StfRunner {\n    private static final Logger logger = LogManager.getLogger(StfRunner.class.getName());\n\n\tprivate String[] args;\n\tprivate String propertiesList = null;\n\tprivate ArrayList<PropertyFileDetails> initialPropertyFiles = null;\n\tprivate String testDir = null;\n\t\n\t\n\tpublic static void main(String[] args) throws StfException {\n\t\t// Run STF to generate the perl code\n\t\ttry {\n\t\t\tStfRunner runner = new StfRunner(args);\n\t\t\trunner.executeTest();\n\t\t\tSystem.exit(0);\n\t\t} catch (StfError e) {\n\t\t\tString boldStart = PlatformFinder.isLinux() ? \"\\u001B[1m\" : \"\";\n\t\t\tString boldEnd   = PlatformFinder.isLinux() ? \"\\u001B[0m\" : \"\";\n\t\t\tlogger.fatal(boldStart + \"** ERROR **  \" + e.getMessage() + boldEnd);\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\n\tpublic StfRunner(String[] args) throws StfException {\n\t\tthis.args = args;\n\t\t\n        int i = 0;\n        while (i < args.length) {\n        \tString arg = args[i++];\n        \t\n\t\t\tif (arg.equals(\"-properties\")) {\n\t    \t\tpropertiesList = getNextArg(args, i++, \"properties\");\n\n\t\t\t} else if (arg.equals(\"-testDir\")) {\n\t    \t\ttestDir = getNextArg(args, i++, \"testDir\");\n\n\t\t\t} else {\n    \t\t\tthrow new StfException(\"Unknown argument: \" + arg);\n    \t\t}\n\t\t}\n        \n    \tif (propertiesList == null) throw new StfException(\"No argument supplied for 'propertiesList'\");\n    \tif (testDir == null) throw new StfException(\"No argument supplied for 'testDir'\");\n\t}\n\t\n\t\n\tprivate String getNextArg(String[] args, int i, String propertyName) throws StfException {\n\t\tif (i >= args.length) {\n\t\t\tthrow new StfException(\"No value supplied for final property called: '\" + propertyName + \"'\");\n\t\t}\n        \n\t\tString value = args[i];\n\t\tif (value.startsWith(\"-\")) { \n\t\t\tthrow new StfException(\"No value supplied for the '\" + propertyName + \"' property.\");\n\t\t}\n\t\t\n\t\treturn value;\n\t}\n\n\t\n\t/**\n\t * This is the key method for starting a STF based test.\n\t *  \n\t * It is responsible for: \n\t *   - creating an instance of the plugin class.\n\t *   - validating the interface of the plugin object.\n\t *   - Running the generation methods of the plugin.\n\t *   \n\t * @throws StfException if anything goes wrong.\n\t */\n\tprivate void executeTest() throws StfException {\n\t\t// Convert the comma separated list of property files into File objects\n\t\t// This won't be the final list of properties but it's enough to bootstrap the plugin.\n\t\tinitialPropertyFiles = new ArrayList<PropertyFileDetails>();\n\t\tfor (String fileName : propertiesList.split(\",\")) {\n\t\t\tif (fileName.trim().isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tFile propertyFile = new File(fileName.trim());\n\t\t\tinitialPropertyFiles.add(new PropertyFileDetails(propertyFile, true));\n\t\t}\n\t\t\n\t\t// Create objects to represent environmental data\n\t\tStfEnvironmentCore environmentCore = new StfEnvironmentCore(initialPropertyFiles, buildFullArgumentList(null), testDir);\n\n\t\t// Logging detail set at runtime. So tell log4j what level we want\n\t\tif (environmentCore.isSuperVerboseSet()) {\n\t\t\tsetLog4jLevel(Level.TRACE);\n\t\t} else if (environmentCore.isVerboseSet()) {\n\t\t\tsetLog4jLevel(Level.DEBUG);\n\t\t}\n\n\t\t// Log the invocation arguments\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"StfRunner.java started. Arguments:\");\n\t\t\tint i = 0;\n\t\t\twhile (i < args.length) {\n\t\t\t\tlogger.debug(\"  \" + i + \") \" + args[i++]);\n\t\t\t}\n\t\t}\n\n\t\t// Log the property files being used\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Bootstrapping property files:\");\n\t\t\tfor (String fileName : propertiesList.split(\",\")) {\n\t\t\t\tif (fileName.trim().isEmpty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tFile propertyFile = new File(fileName.trim());\n\t\t\t\tlogger.debug(\"  \" + propertyFile.getAbsolutePath());\n\t\t\t}\n\t\t}",
        "start_line": 55,
        "end_line": 167,
        "chunk_index": 1,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 901,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474281"
      },
      "text": "public class StfRunner {\n    private static final Logger logger = LogManager.getLogger(StfRunner.class.getName());\n\n\tprivate String[] args;\n\tprivate String propertiesList = null;\n\tprivate ArrayList<PropertyFileDetails> initialPropertyFiles = null;\n\tprivate String testDir = null;\n\t\n\t\n\tpublic static void main(String[] args) throws StfException {\n\t\t// Run STF to generate the perl code\n\t\ttry {\n\t\t\tStfRunner runner = new StfRunner(args);\n\t\t\trunner.executeTest();\n\t\t\tSystem.exit(0);\n\t\t} catch (StfError e) {\n\t\t\tString boldStart = PlatformFinder.isLinux() ? \"\\u001B[1m\" : \"\";\n\t\t\tString boldEnd   = PlatformFinder.isLinux() ? \"\\u001B[0m\" : \"\";\n\t\t\tlogger.fatal(boldStart + \"** ERROR **  \" + e.getMessage() + boldEnd);\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\n\tpublic StfRunner(String[] args) throws StfException {\n\t\tthis.args = args;\n\t\t\n        int i = 0;\n        while (i < args.length) {\n        \tString arg = args[i++];\n        \t\n\t\t\tif (arg.equals(\"-properties\")) {\n\t    \t\tpropertiesList = getNextArg(args, i++, \"properties\");\n\n\t\t\t} else if (arg.equals(\"-testDir\")) {\n\t    \t\ttestDir = getNextArg(args, i++, \"testDir\");\n\n\t\t\t} else {\n    \t\t\tthrow new StfException(\"Unknown argument: \" + arg);\n    \t\t}\n\t\t}\n        \n    \tif (propertiesList == null) throw new StfException(\"No argument supplied for 'propertiesList'\");\n    \tif (testDir == null) throw new StfException(\"No argument supplied for 'testDir'\");\n\t}\n\t\n\t\n\tprivate String getNextArg(String[] args, int i, String propertyName) throws StfException {\n\t\tif (i >= args.length) {\n\t\t\tthrow new StfException(\"No value supplied for final property called: '\" + propertyName + \"'\");\n\t\t}\n        \n\t\tString value = args[i];\n\t\tif (value.startsWith(\"-\")) { \n\t\t\tthrow new StfException(\"No value supplied for the '\" + propertyName + \"' property.\");\n\t\t}\n\t\t\n\t\treturn value;\n\t}\n\n\t\n\t/**\n\t * This is the key method for starting a STF based test.\n\t *  \n\t * It is responsible for: \n\t *   - creating an instance of the plugin class.\n\t *   - validating the interface of the plugin object.\n\t *   - Running the generation methods of the plugin.\n\t *   \n\t * @throws StfException if anything goes wrong.\n\t */\n\tprivate void executeTest() throws StfException {\n\t\t// Convert the comma separated list of property files into File objects\n\t\t// This won't be the final list of properties but it's enough to bootstrap the plugin.\n\t\tinitialPropertyFiles = new ArrayList<PropertyFileDetails>();\n\t\tfor (String fileName : propertiesList.split(\",\")) {\n\t\t\tif (fileName.trim().isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tFile propertyFile = new File(fileName.trim());\n\t\t\tinitialPropertyFiles.add(new PropertyFileDetails(propertyFile, true));\n\t\t}\n\t\t\n\t\t// Create objects to represent environmental data\n\t\tStfEnvironmentCore environmentCore = new StfEnvironmentCore(initialPropertyFiles, buildFullArgumentList(null), testDir);\n\n\t\t// Logging detail set at runtime. So tell log4j what level we want\n\t\tif (environmentCore.isSuperVerboseSet()) {\n\t\t\tsetLog4jLevel(Level.TRACE);\n\t\t} else if (environmentCore.isVerboseSet()) {\n\t\t\tsetLog4jLevel(Level.DEBUG);\n\t\t}\n\n\t\t// Log the invocation arguments\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"StfRunner.java started. Arguments:\");\n\t\t\tint i = 0;\n\t\t\twhile (i < args.length) {\n\t\t\t\tlogger.debug(\"  \" + i + \") \" + args[i++]);\n\t\t\t}\n\t\t}\n\n\t\t// Log the property files being used\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Bootstrapping property files:\");\n\t\t\tfor (String fileName : propertiesList.split(\",\")) {\n\t\t\t\tif (fileName.trim().isEmpty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tFile propertyFile = new File(fileName.trim());\n\t\t\t\tlogger.debug(\"  \" + propertyFile.getAbsolutePath());\n\t\t\t}\n\t\t}"
    },
    "301": {
      "metadata": {
        "chunk_id": "5dde87521d361995fd90bd56f612fa1841d72640e31f6c9eb494db561ea2c7c1",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "// Log the invocation arguments\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"StfRunner.java started. Arguments:\");\n\t\t\tint i = 0;\n\t\t\twhile (i < args.length) {\n\t\t\t\tlogger.debug(\"  \" + i + \") \" + args[i++]);\n\t\t\t}\n\t\t}\n\n\t\t// Log the property files being used\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Bootstrapping property files:\");\n\t\t\tfor (String fileName : propertiesList.split(\",\")) {\n\t\t\t\tif (fileName.trim().isEmpty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tFile propertyFile = new File(fileName.trim());\n\t\t\t\tlogger.debug(\"  \" + propertyFile.getAbsolutePath());\n\t\t\t}\n\t\t}\n\n\t\t// Get hold test-root, ie, the directory containing test cases. \n\t\t// Fail if it's not set to at a valid looking value. \n\t\t//File testRoot = new File(environmentCore.getProperty(Stf.ARG_TEST_ROOT));\n\t\t//logger.debug(\"Test-root=\" + testRoot.getAbsolutePath());\n\t\t//if (!testRoot.exists()) {\n\t\t//\tthrow new StfError(\"Invalid test root. Directory does not exist: \" + testRoot.getAbsolutePath());\n\t\t//}\n\t\t//if (!testRoot.isDirectory()) {\n\t\t//\tthrow new StfError(\"Invalid test root. Not a directory: \" + testRoot.getAbsolutePath());\n\t\t//}\n\t\t\n\t\t// If the '-list' argument is used then search for all test cases in the workspace\n\t\tif (environmentCore.getBooleanProperty(Stf.ARG_LIST_TESTS) == true) {\n\t\t\tPluginList pluginList = new PluginList();\n\t\t\tpluginList.searchAndListTests(environmentCore, environmentCore.getTestRoots());\n\t\t\treturn;  // All done\n\t\t}\n\t\t\n\t\t// Create the plugin class. Part 1.\n\t\t// As part of the bootstrapping we need an instance of the plugin class to \n\t\t// find out which extension classes it's using.\n\t\tString testName = environmentCore.getProperty(Stf.ARG_TEST);\n\t\tPluginFinder pluginFinder = new PluginFinder(environmentCore.getTestRoots(), testName);\n        \n\t\t// Setup the STF class loader to use the dependencies used by the plugins project\n\t\tClassPathConfigurator.configureClassLoader(environmentCore, pluginFinder.getProjectName());\n\n\t\t// Create the plugin class. Part 2.\n\t\t// Now that the classpath has been configured to use the dependencies which the plugin \n\t\t// requires we can create and use an instance of the plugin class.\n\t\tStfPluginRootInterface plugin = createTestObject(pluginFinder.getPluginClassName());\n\t\t\n\t\t// Get hold of the key methods from the plugin class\n\t\tMethod helpMethod = null;\n\t\tMethod pluginInitMethod = null;\n\t\tMethod setupMethod = null;\n\t\tArrayList<Method> executeMethods = new ArrayList<Method>();\n\t\tMethod lastExecuteMethod = null;\n\t\tMethod teardownMethod = null;\n\t\tClass<? extends StfPluginRootInterface> pluginClass = plugin.getClass();\n\t\tString pluginName = pluginClass.getName();\n\t\tfor (Method method : pluginClass.getMethods()) {\n\t\t\tif (method.getName().equals(\"help\")) {\n\t\t\t\thelpMethod = method;\n\t\t\t} else if (method.getName().equals(Stage.INITIALISATION.getMethodName())) {\n\t\t\t\tpluginInitMethod = method;\n\t\t\t} else if (method.getName().equals(Stage.SETUP.getMethodName())) {\n\t\t\t\tsetupMethod = method;\n\t\t\t} else if (method.getName().startsWith(Stage.EXECUTE.getMethodName())) {\n\t\t\t\texecuteMethods.add(method);\n\t\t\t\tlastExecuteMethod = method;\n\t\t\t} else if (method.getName().equals(Stage.TEARDOWN.getMethodName())) {\n\t\t\t\tteardownMethod = method;\n\t\t\t}\n\t\t}\n\t\n\t\t// Verify that the plugin contains the expected methods\n\t\tvalidateMethod(pluginName, helpMethod, \"help\");\n\t\tvalidateMethod(pluginName, pluginInitMethod, Stage.INITIALISATION.getMethodName());\n\t\tvalidateMethod(pluginName, setupMethod, Stage.SETUP.getMethodName());\n\t\tvalidateMethod(pluginName, lastExecuteMethod, Stage.EXECUTE.getMethodName());  // ie, at least 1 execute method\n\t\tvalidateMethod(pluginName, teardownMethod, Stage.TEARDOWN.getMethodName());",
        "start_line": 168,
        "end_line": 250,
        "chunk_index": 2,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 892,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474286"
      },
      "text": "// Log the invocation arguments\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"StfRunner.java started. Arguments:\");\n\t\t\tint i = 0;\n\t\t\twhile (i < args.length) {\n\t\t\t\tlogger.debug(\"  \" + i + \") \" + args[i++]);\n\t\t\t}\n\t\t}\n\n\t\t// Log the property files being used\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Bootstrapping property files:\");\n\t\t\tfor (String fileName : propertiesList.split(\",\")) {\n\t\t\t\tif (fileName.trim().isEmpty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tFile propertyFile = new File(fileName.trim());\n\t\t\t\tlogger.debug(\"  \" + propertyFile.getAbsolutePath());\n\t\t\t}\n\t\t}\n\n\t\t// Get hold test-root, ie, the directory containing test cases. \n\t\t// Fail if it's not set to at a valid looking value. \n\t\t//File testRoot = new File(environmentCore.getProperty(Stf.ARG_TEST_ROOT));\n\t\t//logger.debug(\"Test-root=\" + testRoot.getAbsolutePath());\n\t\t//if (!testRoot.exists()) {\n\t\t//\tthrow new StfError(\"Invalid test root. Directory does not exist: \" + testRoot.getAbsolutePath());\n\t\t//}\n\t\t//if (!testRoot.isDirectory()) {\n\t\t//\tthrow new StfError(\"Invalid test root. Not a directory: \" + testRoot.getAbsolutePath());\n\t\t//}\n\t\t\n\t\t// If the '-list' argument is used then search for all test cases in the workspace\n\t\tif (environmentCore.getBooleanProperty(Stf.ARG_LIST_TESTS) == true) {\n\t\t\tPluginList pluginList = new PluginList();\n\t\t\tpluginList.searchAndListTests(environmentCore, environmentCore.getTestRoots());\n\t\t\treturn;  // All done\n\t\t}\n\t\t\n\t\t// Create the plugin class. Part 1.\n\t\t// As part of the bootstrapping we need an instance of the plugin class to \n\t\t// find out which extension classes it's using.\n\t\tString testName = environmentCore.getProperty(Stf.ARG_TEST);\n\t\tPluginFinder pluginFinder = new PluginFinder(environmentCore.getTestRoots(), testName);\n        \n\t\t// Setup the STF class loader to use the dependencies used by the plugins project\n\t\tClassPathConfigurator.configureClassLoader(environmentCore, pluginFinder.getProjectName());\n\n\t\t// Create the plugin class. Part 2.\n\t\t// Now that the classpath has been configured to use the dependencies which the plugin \n\t\t// requires we can create and use an instance of the plugin class.\n\t\tStfPluginRootInterface plugin = createTestObject(pluginFinder.getPluginClassName());\n\t\t\n\t\t// Get hold of the key methods from the plugin class\n\t\tMethod helpMethod = null;\n\t\tMethod pluginInitMethod = null;\n\t\tMethod setupMethod = null;\n\t\tArrayList<Method> executeMethods = new ArrayList<Method>();\n\t\tMethod lastExecuteMethod = null;\n\t\tMethod teardownMethod = null;\n\t\tClass<? extends StfPluginRootInterface> pluginClass = plugin.getClass();\n\t\tString pluginName = pluginClass.getName();\n\t\tfor (Method method : pluginClass.getMethods()) {\n\t\t\tif (method.getName().equals(\"help\")) {\n\t\t\t\thelpMethod = method;\n\t\t\t} else if (method.getName().equals(Stage.INITIALISATION.getMethodName())) {\n\t\t\t\tpluginInitMethod = method;\n\t\t\t} else if (method.getName().equals(Stage.SETUP.getMethodName())) {\n\t\t\t\tsetupMethod = method;\n\t\t\t} else if (method.getName().startsWith(Stage.EXECUTE.getMethodName())) {\n\t\t\t\texecuteMethods.add(method);\n\t\t\t\tlastExecuteMethod = method;\n\t\t\t} else if (method.getName().equals(Stage.TEARDOWN.getMethodName())) {\n\t\t\t\tteardownMethod = method;\n\t\t\t}\n\t\t}\n\t\n\t\t// Verify that the plugin contains the expected methods\n\t\tvalidateMethod(pluginName, helpMethod, \"help\");\n\t\tvalidateMethod(pluginName, pluginInitMethod, Stage.INITIALISATION.getMethodName());\n\t\tvalidateMethod(pluginName, setupMethod, Stage.SETUP.getMethodName());\n\t\tvalidateMethod(pluginName, lastExecuteMethod, Stage.EXECUTE.getMethodName());  // ie, at least 1 execute method\n\t\tvalidateMethod(pluginName, teardownMethod, Stage.TEARDOWN.getMethodName());"
    },
    "302": {
      "metadata": {
        "chunk_id": "ff9fbb2941e9311f3da50755980e4599ccf4b8ac9fa49ef08d79058e9171bcff",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "// Verify that all of the plugin init/setUp/execute/tearDown methods take an identical set of parameters\n\t\tClass<?>[] pluginMethodParameters = pluginInitMethod.getParameterTypes();\n\t\tvalidateParametersMatch(pluginName, pluginMethodParameters, setupMethod);\n\t\tfor (Method executeMethod : executeMethods) {\n\t\t\tvalidateParametersMatch(pluginName, pluginMethodParameters, executeMethod);\n\t\t}\n\t\tvalidateParametersMatch(pluginName, pluginMethodParameters, teardownMethod);\n\n\t\t// Find the longest plugin method name.\n\t\t// This allows neat formatting of the command summary table.\n\t\tint longestStageName = teardownMethod.getName().length();\n\t\tfor (Method executeMethod : executeMethods) {\n\t\t\tlongestStageName = Math.max(longestStageName, executeMethod.getName().length());\n\t\t}\n\t\tPerlCodeGenerator.setStageNameLength(longestStageName);\n\t\t\n\t\t// Now that the extensions used by the plugin are known we can build a full list of \n\t\t// all the property files that are used. \n\t\t// This is the first time that we can pull in properties/configuration for each extension  \n\t\tArrayList<PropertyFileDetails> propertyFiles = buildFullPropertyFileList(pluginMethodParameters);\n\t\tArrayList<Argument> allArguments = buildFullArgumentList(pluginMethodParameters);\n\n\t\t// Initial bootstrapping has been completed.\n\t\t// Now that the plugin class has been loaded and examined we know what extensions it requires.\n\t\t// So now rebuild the environment object with the full set of property files.\n\t\tenvironmentCore = new StfEnvironmentCore(propertyFiles, allArguments, testDir);\n\n\t\t// Tell significant STF objects about the environmentCore object.\n\t\t// The reference to environment core is set as a class static value to \n\t\t// prevent it being accessible to test code.\n\t\tJmodDefinition.setEnvironmentCore(environmentCore);\n\t\tJlinkDefinition.setEnvironmentCore(environmentCore);\n\t\t\n\t\t// To allow cross platform development optionally force the platform setting\n\t\tString platformOverride = environmentCore.getProperty(Stf.ARG_PLATFORM);\n\t\tif (platformOverride != \"\") {\n\t\t\tString originalPlatform = PlatformFinder.getPlatformAsString();\n\t\t\tPlatformFinder.forcePlatform(platformOverride);\n\t\t\tlogger.info(\"Forcing platform to '\" + PlatformFinder.getPlatformAsString() + \"' instead of '\" + originalPlatform + \"'\");\n\t\t}\n\t\t\n\t\t// Now that the full set of properties has been loaded we can dump and verify them\n\t\tenvironmentCore.dumpAndCheckAllProperties(allArguments);\n\t\t\n\t\t// If run with '-help' then provide help on all of the extensions in use\n\t\tif (environmentCore.getBooleanProperty(Stf.ARG_HELP) == true) {\n\t\t\tgenerateHelpText(plugin, helpMethod, pluginInitMethod.getParameterTypes());\n\t\t\treturn;\n\t\t} \n\t\t\n\t\t// Summarise what we are doing\n\t\tlogger.debug(\"Running script generation for:\");\n\t\tlogger.debug(\"  test:      '\" + testName + \"'\");\n\t\tlogger.debug(\"  test-args: '\" + environmentCore.getProperty(Stf.ARG_TEST_ARGS) + \"'\");\n\t\tlogger.debug(\"  platform:  '\" + PlatformFinder.getPlatformAsString() + \"'\");",
        "start_line": 251,
        "end_line": 305,
        "chunk_index": 3,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 652,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474290"
      },
      "text": "// Verify that all of the plugin init/setUp/execute/tearDown methods take an identical set of parameters\n\t\tClass<?>[] pluginMethodParameters = pluginInitMethod.getParameterTypes();\n\t\tvalidateParametersMatch(pluginName, pluginMethodParameters, setupMethod);\n\t\tfor (Method executeMethod : executeMethods) {\n\t\t\tvalidateParametersMatch(pluginName, pluginMethodParameters, executeMethod);\n\t\t}\n\t\tvalidateParametersMatch(pluginName, pluginMethodParameters, teardownMethod);\n\n\t\t// Find the longest plugin method name.\n\t\t// This allows neat formatting of the command summary table.\n\t\tint longestStageName = teardownMethod.getName().length();\n\t\tfor (Method executeMethod : executeMethods) {\n\t\t\tlongestStageName = Math.max(longestStageName, executeMethod.getName().length());\n\t\t}\n\t\tPerlCodeGenerator.setStageNameLength(longestStageName);\n\t\t\n\t\t// Now that the extensions used by the plugin are known we can build a full list of \n\t\t// all the property files that are used. \n\t\t// This is the first time that we can pull in properties/configuration for each extension  \n\t\tArrayList<PropertyFileDetails> propertyFiles = buildFullPropertyFileList(pluginMethodParameters);\n\t\tArrayList<Argument> allArguments = buildFullArgumentList(pluginMethodParameters);\n\n\t\t// Initial bootstrapping has been completed.\n\t\t// Now that the plugin class has been loaded and examined we know what extensions it requires.\n\t\t// So now rebuild the environment object with the full set of property files.\n\t\tenvironmentCore = new StfEnvironmentCore(propertyFiles, allArguments, testDir);\n\n\t\t// Tell significant STF objects about the environmentCore object.\n\t\t// The reference to environment core is set as a class static value to \n\t\t// prevent it being accessible to test code.\n\t\tJmodDefinition.setEnvironmentCore(environmentCore);\n\t\tJlinkDefinition.setEnvironmentCore(environmentCore);\n\t\t\n\t\t// To allow cross platform development optionally force the platform setting\n\t\tString platformOverride = environmentCore.getProperty(Stf.ARG_PLATFORM);\n\t\tif (platformOverride != \"\") {\n\t\t\tString originalPlatform = PlatformFinder.getPlatformAsString();\n\t\t\tPlatformFinder.forcePlatform(platformOverride);\n\t\t\tlogger.info(\"Forcing platform to '\" + PlatformFinder.getPlatformAsString() + \"' instead of '\" + originalPlatform + \"'\");\n\t\t}\n\t\t\n\t\t// Now that the full set of properties has been loaded we can dump and verify them\n\t\tenvironmentCore.dumpAndCheckAllProperties(allArguments);\n\t\t\n\t\t// If run with '-help' then provide help on all of the extensions in use\n\t\tif (environmentCore.getBooleanProperty(Stf.ARG_HELP) == true) {\n\t\t\tgenerateHelpText(plugin, helpMethod, pluginInitMethod.getParameterTypes());\n\t\t\treturn;\n\t\t} \n\t\t\n\t\t// Summarise what we are doing\n\t\tlogger.debug(\"Running script generation for:\");\n\t\tlogger.debug(\"  test:      '\" + testName + \"'\");\n\t\tlogger.debug(\"  test-args: '\" + environmentCore.getProperty(Stf.ARG_TEST_ARGS) + \"'\");\n\t\tlogger.debug(\"  platform:  '\" + PlatformFinder.getPlatformAsString() + \"'\");"
    },
    "303": {
      "metadata": {
        "chunk_id": "caf9395553e9408e0f57dc5ee71dbe246a704dc6164b67bd5b44a2006db758cd",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "// Run the code in the plugin methods to produce the perl files\n\t\tlogger.debug(\"Generating test scripts\");\n\t\tArrayList<PerlCodeGenerator> generators = new ArrayList<PerlCodeGenerator>();\n\t\trunStage(plugin, pluginInitMethod, environmentCore, Stage.INITIALISATION, true);\n\t\tgenerators.add(runStage(plugin, setupMethod, environmentCore, Stage.SETUP, true));\n\t\tint executeRepeatCount = environmentCore.getPropertyAsInt(Stf.ARG_REPEAT_COUNT);\n\t\tfor (Method executeMethod : executeMethods) {\n\t\t\tfor (int i=0; i<executeRepeatCount; i++) {\n\t\t\t\tgenerators.add(runStage(plugin, executeMethod, environmentCore, Stage.EXECUTE, i==executeRepeatCount-1));\n\t\t\t}\n\t\t}\n\t\tgenerators.add(runStage(plugin, teardownMethod, environmentCore, Stage.TEARDOWN, true));\n\t\t\n\t\t// Build a string which lists all of the execute scripts\n\t\tStringBuilder executeMethodNames = new StringBuilder();\n\t\tfor (Method executeMethod : executeMethods) {\n\t\t\texecuteMethodNames.append(executeMethod.getName() + \"\\n\");\n\t\t}\n\t\t\n\t\t// Create a file for stf.pl which lists all execute stages\n\t\tDirectoryRef testDir = environmentCore.getResultsDir().getParent();\n\t\tFileRef excuteStagesFile = testDir.childFile(\"executeStages.txt\");\n\t\twriteFile(excuteStagesFile.asJavaFile(), executeMethodNames.toString());\n\t\t\n\t\t// Produce summary of the commands generated. \n\t\t// This gives a high level view of what the test case is up to.\n\t\tlogger.info(\"\");\n\t\tlogger.info(\"Test command summary:\");\n\t\tlogger.info(String.format(\"  %s  %-\" + (longestStageName-1) + \"s %s           %s\", \"Step\", \"Stage\", \"Command\", \"Description\"));\n\t\tStringBuilder stageFiller = new StringBuilder();\n\t\tfor (int i=0; i<longestStageName; i++) { \n\t\t\tstageFiller.append(\"-\");\n\t\t}\n\t\tlogger.info(\" -----+\" + stageFiller.toString() + \"+-----------------+------------\");\n\t\tfor (PerlCodeGenerator generator : generators) {\n\t\t\tgenerator.summariseGeneratedCommands();\n\t\t}\n\t\t\n\t\t// Fail the run if the test has been invoked with unused test specific args\n\t\tenvironmentCore.verifyTestArgsUsed();\n\t}\n\n\n\t/**\n\t * This method takes a list of the classes used by the plugins setup/execute/etc methods and \n\t * builds a full list of all the property files which need to be loaded.\n\t * \n\t * @param pluginMethodParameters is the classes used by all of the plugin methods.\n\t * @return an ArrayList containing details on all property files, ordered from most to least important.\n\t * @throws StfException if a mandatory property file does not exist.\n\t */\n\tprivate ArrayList<PropertyFileDetails> buildFullPropertyFileList(Class<?>[] pluginMethodParameters) throws StfException {\n\t\tArrayList<PropertyFileDetails> propertyFiles = new ArrayList<PropertyFileDetails>();\n\t\t\n\t\t// The first property file contains the command line values from stf.pl\n\t\tPropertyFileDetails customisationProperties = initialPropertyFiles.get(0);\n\t\tpropertyFiles.add(customisationProperties);\n\n\t\t// Add in the users personal property files for each extension\n\t\tFile homeDirectory = new File(System.getProperty(\"user.home\"));\n\t\tfor (Class<?> c : pluginMethodParameters) { \n\t        String propertyFileName = convertExtensionNameToPropertyFileName(c.getSimpleName());\n\t        PropertyFileDetails propFile = resolvePropertyFile(homeDirectory, \".\" + propertyFileName, false);\n\t\t\tpropertyFiles.add(propFile);\n\t\t}\n\n\t\t// Add in personal STF property file\n\t\tpropertyFiles.add(resolvePropertyFile(homeDirectory, \".stf.properties\", false));\n\n\t\t// Add in the mandatory property file for each extension (from the workspace)\n\t\tfor (Class<?> extensionClass : pluginMethodParameters) {\n\t\t\t// Reference the property file for the current extension in the projects config directory.\n\t\t\tpropertyFiles.add(resolvePropertyFile(extensionClass, true));\n\t\t}\n\t\t\n\t\t// Add in final level of properties - the mandatory STF property file (again from the workspace)\n\t\tpropertyFiles.add(resolvePropertyFile(Stf.class, true));",
        "start_line": 306,
        "end_line": 382,
        "chunk_index": 4,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 890,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474293"
      },
      "text": "// Run the code in the plugin methods to produce the perl files\n\t\tlogger.debug(\"Generating test scripts\");\n\t\tArrayList<PerlCodeGenerator> generators = new ArrayList<PerlCodeGenerator>();\n\t\trunStage(plugin, pluginInitMethod, environmentCore, Stage.INITIALISATION, true);\n\t\tgenerators.add(runStage(plugin, setupMethod, environmentCore, Stage.SETUP, true));\n\t\tint executeRepeatCount = environmentCore.getPropertyAsInt(Stf.ARG_REPEAT_COUNT);\n\t\tfor (Method executeMethod : executeMethods) {\n\t\t\tfor (int i=0; i<executeRepeatCount; i++) {\n\t\t\t\tgenerators.add(runStage(plugin, executeMethod, environmentCore, Stage.EXECUTE, i==executeRepeatCount-1));\n\t\t\t}\n\t\t}\n\t\tgenerators.add(runStage(plugin, teardownMethod, environmentCore, Stage.TEARDOWN, true));\n\t\t\n\t\t// Build a string which lists all of the execute scripts\n\t\tStringBuilder executeMethodNames = new StringBuilder();\n\t\tfor (Method executeMethod : executeMethods) {\n\t\t\texecuteMethodNames.append(executeMethod.getName() + \"\\n\");\n\t\t}\n\t\t\n\t\t// Create a file for stf.pl which lists all execute stages\n\t\tDirectoryRef testDir = environmentCore.getResultsDir().getParent();\n\t\tFileRef excuteStagesFile = testDir.childFile(\"executeStages.txt\");\n\t\twriteFile(excuteStagesFile.asJavaFile(), executeMethodNames.toString());\n\t\t\n\t\t// Produce summary of the commands generated. \n\t\t// This gives a high level view of what the test case is up to.\n\t\tlogger.info(\"\");\n\t\tlogger.info(\"Test command summary:\");\n\t\tlogger.info(String.format(\"  %s  %-\" + (longestStageName-1) + \"s %s           %s\", \"Step\", \"Stage\", \"Command\", \"Description\"));\n\t\tStringBuilder stageFiller = new StringBuilder();\n\t\tfor (int i=0; i<longestStageName; i++) { \n\t\t\tstageFiller.append(\"-\");\n\t\t}\n\t\tlogger.info(\" -----+\" + stageFiller.toString() + \"+-----------------+------------\");\n\t\tfor (PerlCodeGenerator generator : generators) {\n\t\t\tgenerator.summariseGeneratedCommands();\n\t\t}\n\t\t\n\t\t// Fail the run if the test has been invoked with unused test specific args\n\t\tenvironmentCore.verifyTestArgsUsed();\n\t}\n\n\n\t/**\n\t * This method takes a list of the classes used by the plugins setup/execute/etc methods and \n\t * builds a full list of all the property files which need to be loaded.\n\t * \n\t * @param pluginMethodParameters is the classes used by all of the plugin methods.\n\t * @return an ArrayList containing details on all property files, ordered from most to least important.\n\t * @throws StfException if a mandatory property file does not exist.\n\t */\n\tprivate ArrayList<PropertyFileDetails> buildFullPropertyFileList(Class<?>[] pluginMethodParameters) throws StfException {\n\t\tArrayList<PropertyFileDetails> propertyFiles = new ArrayList<PropertyFileDetails>();\n\t\t\n\t\t// The first property file contains the command line values from stf.pl\n\t\tPropertyFileDetails customisationProperties = initialPropertyFiles.get(0);\n\t\tpropertyFiles.add(customisationProperties);\n\n\t\t// Add in the users personal property files for each extension\n\t\tFile homeDirectory = new File(System.getProperty(\"user.home\"));\n\t\tfor (Class<?> c : pluginMethodParameters) { \n\t        String propertyFileName = convertExtensionNameToPropertyFileName(c.getSimpleName());\n\t        PropertyFileDetails propFile = resolvePropertyFile(homeDirectory, \".\" + propertyFileName, false);\n\t\t\tpropertyFiles.add(propFile);\n\t\t}\n\n\t\t// Add in personal STF property file\n\t\tpropertyFiles.add(resolvePropertyFile(homeDirectory, \".stf.properties\", false));\n\n\t\t// Add in the mandatory property file for each extension (from the workspace)\n\t\tfor (Class<?> extensionClass : pluginMethodParameters) {\n\t\t\t// Reference the property file for the current extension in the projects config directory.\n\t\t\tpropertyFiles.add(resolvePropertyFile(extensionClass, true));\n\t\t}\n\t\t\n\t\t// Add in final level of properties - the mandatory STF property file (again from the workspace)\n\t\tpropertyFiles.add(resolvePropertyFile(Stf.class, true));"
    },
    "304": {
      "metadata": {
        "chunk_id": "835c16394f32f2914fc511a27e6315847273b293a6d00dd496508fdf33b45e0f",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "// Add in personal STF property file\n\t\tpropertyFiles.add(resolvePropertyFile(homeDirectory, \".stf.properties\", false));\n\n\t\t// Add in the mandatory property file for each extension (from the workspace)\n\t\tfor (Class<?> extensionClass : pluginMethodParameters) {\n\t\t\t// Reference the property file for the current extension in the projects config directory.\n\t\t\tpropertyFiles.add(resolvePropertyFile(extensionClass, true));\n\t\t}\n\t\t\n\t\t// Add in final level of properties - the mandatory STF property file (again from the workspace)\n\t\tpropertyFiles.add(resolvePropertyFile(Stf.class, true));\n\n\t\t// Log the details of all property files that are to be used.\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Property files used by test:\");\n\t\t\tfor (PropertyFileDetails p : propertyFiles) {\n\t\t\t\tString fileStatus = p.file.exists() ? \"   exists\" : \"does-not-exist\";\n\t\t\t\tlogger.debug(String.format(\"  %-80s %7s\", p.file.getAbsolutePath(), fileStatus));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn propertyFiles;\n\t}\n\n\n\t/**\n\t * This method returns all of the arguments supported by a set of STF extensions.\n\t * \n\t * @param extensionClasses is an array of Extension classes.\n\t * @return an arrayList of all arguments.\n\t * @throws StfException\n\t */\n\tprivate ArrayList<Argument> buildFullArgumentList(Class<?>[] extensionClasses) throws StfException {\n\t\tArrayList<Argument> allArguments = new ArrayList<Argument>();\n\t\t\n\t\t// Add arguments supported by the listed extension classes\n\t\tif (extensionClasses != null) {\n\t\t\tfor (Class<?> extensionClass : extensionClasses) { \n\t\t\t\tStfExtension extension = createExtension(extensionClass);\n\t\t\t\tArgument[] extensionArguments = extension.getSupportedArguments();\n\t\t\t\tif (extensionArguments != null) { \n\t\t\t\t\tallArguments.addAll(Arrays.asList(extensionArguments));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Finally add the arguments used by the mandatory STF extension\n\t\tArgument[] stfArguments = new Stf().getSupportedArguments();\n\t\tallArguments.addAll(Arrays.asList(stfArguments));\n\t\t\n\t\treturn allArguments;\n\t}\n\t\n\t\n\t/**\n\t * Returns information about a property file.\n\t * \n\t * @param extensionClass is the extension class whose property file we want to find.\n\t * @param propertyFileName is the name of the property file.\n\t * @param mustExist is set to true if the file is mandatory.\n\t * @return a File object for the property file.\n\t * @throws StfException if the directory does not exist or a mandatory property file does not exist.\n\t */\n\tprivate PropertyFileDetails resolvePropertyFile(Class<?> extensionClass, boolean mustExist) throws StfException {\n\t\t// Work out the config directory for the current extension\n\t\tString projectForClass = StfClassLoader.getProjectName(extensionClass.getName());\n\t\tFile projectDir = new File(projectForClass).getParentFile();\n\t\tFile configDir = new File(projectDir, \"config\");\n\n\t\t// The property file for the current extension is expected to live in the config \n\t\t// directory for the classes project. So build path to the expected location.\n\t\tString propertyFileName = convertExtensionNameToPropertyFileName(extensionClass.getSimpleName());\n\t\t\n\t\treturn resolvePropertyFile(configDir, propertyFileName, true);\n\t}",
        "start_line": 383,
        "end_line": 457,
        "chunk_index": 5,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 693,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474297"
      },
      "text": "// Add in personal STF property file\n\t\tpropertyFiles.add(resolvePropertyFile(homeDirectory, \".stf.properties\", false));\n\n\t\t// Add in the mandatory property file for each extension (from the workspace)\n\t\tfor (Class<?> extensionClass : pluginMethodParameters) {\n\t\t\t// Reference the property file for the current extension in the projects config directory.\n\t\t\tpropertyFiles.add(resolvePropertyFile(extensionClass, true));\n\t\t}\n\t\t\n\t\t// Add in final level of properties - the mandatory STF property file (again from the workspace)\n\t\tpropertyFiles.add(resolvePropertyFile(Stf.class, true));\n\n\t\t// Log the details of all property files that are to be used.\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Property files used by test:\");\n\t\t\tfor (PropertyFileDetails p : propertyFiles) {\n\t\t\t\tString fileStatus = p.file.exists() ? \"   exists\" : \"does-not-exist\";\n\t\t\t\tlogger.debug(String.format(\"  %-80s %7s\", p.file.getAbsolutePath(), fileStatus));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn propertyFiles;\n\t}\n\n\n\t/**\n\t * This method returns all of the arguments supported by a set of STF extensions.\n\t * \n\t * @param extensionClasses is an array of Extension classes.\n\t * @return an arrayList of all arguments.\n\t * @throws StfException\n\t */\n\tprivate ArrayList<Argument> buildFullArgumentList(Class<?>[] extensionClasses) throws StfException {\n\t\tArrayList<Argument> allArguments = new ArrayList<Argument>();\n\t\t\n\t\t// Add arguments supported by the listed extension classes\n\t\tif (extensionClasses != null) {\n\t\t\tfor (Class<?> extensionClass : extensionClasses) { \n\t\t\t\tStfExtension extension = createExtension(extensionClass);\n\t\t\t\tArgument[] extensionArguments = extension.getSupportedArguments();\n\t\t\t\tif (extensionArguments != null) { \n\t\t\t\t\tallArguments.addAll(Arrays.asList(extensionArguments));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Finally add the arguments used by the mandatory STF extension\n\t\tArgument[] stfArguments = new Stf().getSupportedArguments();\n\t\tallArguments.addAll(Arrays.asList(stfArguments));\n\t\t\n\t\treturn allArguments;\n\t}\n\t\n\t\n\t/**\n\t * Returns information about a property file.\n\t * \n\t * @param extensionClass is the extension class whose property file we want to find.\n\t * @param propertyFileName is the name of the property file.\n\t * @param mustExist is set to true if the file is mandatory.\n\t * @return a File object for the property file.\n\t * @throws StfException if the directory does not exist or a mandatory property file does not exist.\n\t */\n\tprivate PropertyFileDetails resolvePropertyFile(Class<?> extensionClass, boolean mustExist) throws StfException {\n\t\t// Work out the config directory for the current extension\n\t\tString projectForClass = StfClassLoader.getProjectName(extensionClass.getName());\n\t\tFile projectDir = new File(projectForClass).getParentFile();\n\t\tFile configDir = new File(projectDir, \"config\");\n\n\t\t// The property file for the current extension is expected to live in the config \n\t\t// directory for the classes project. So build path to the expected location.\n\t\tString propertyFileName = convertExtensionNameToPropertyFileName(extensionClass.getSimpleName());\n\t\t\n\t\treturn resolvePropertyFile(configDir, propertyFileName, true);\n\t}"
    },
    "305": {
      "metadata": {
        "chunk_id": "baea93911a9418b30e37b8e726469bae0c4947e36c4f422ade0d00e5ca1bf055",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "// The property file for the current extension is expected to live in the config \n\t\t// directory for the classes project. So build path to the expected location.\n\t\tString propertyFileName = convertExtensionNameToPropertyFileName(extensionClass.getSimpleName());\n\t\t\n\t\treturn resolvePropertyFile(configDir, propertyFileName, true);\n\t}\n\n\t\n\t/**\n\t * Returns information about a property file.\n\t * \n\t * @param extensionClass is the extension class whose property file we want to find.\n\t * @param propertyFileName is the name of the property file.\n\t * @param mustExist is set to true if the file is mandatory.\n\t * @return a File object for the property file.\n\t * @throws StfException if the directory does not exist or a mandatory property file does not exist.\n\t */\n\tprivate PropertyFileDetails resolvePropertyFile(File configDir, String propertyFileName, boolean mustExist) throws StfException {\n\t\tif (!configDir.exists()) {\n\t\t\tthrow new StfException(\"Directory does not exist: \" + configDir.getAbsolutePath());\n\t\t}\n\t\t\n\t\tFile propertyFile = new File(configDir, propertyFileName);\n\t\tif (mustExist && !propertyFile.exists()) {\n\t\t\tthrow new StfException(\"Unable to find property file at expected location: \" + propertyFile.getAbsolutePath());\n\t\t}\n\t\t\n\t\treturn new PropertyFileDetails(propertyFile, mustExist);\n\t}\n\n\t\n\t/** \n\t * Converts the classname of an extension into the expected property file name.\n\t * The property file name follows the Eclipse project naming convention and uses a \n\t * '.' character between words with no camel case.\n\t * eg. A name of 'StfSharedClasses' is converted to 'stf.shared.classes.properties'\n\t * \n\t * @param extensionName is the simple name of the extension class.\n\t * @return The name of the corresponding property file.\n\t */\n\tprivate String convertExtensionNameToPropertyFileName(String extensionName) {\n\t\tStringBuilder propertyFileName = new StringBuilder();\n\t\tfor (int i=0; i<extensionName.length(); i++) { \n\t\t\tchar c = extensionName.charAt(i);\n\t\t\tif (Character.isUpperCase(c) && i!=0) {\n\t\t\t\tpropertyFileName.append('.');\n\t\t\t}\n\t\t\tpropertyFileName.append(Character.toLowerCase(c));\n\t\t}\n\n\t\tpropertyFileName.append(\".properties\");\n\t\tString fileName = propertyFileName.toString();\n\t\t\n\t\t// Allow the extension classes to end in 'Extension' but not have this in their property file name.\n\t\tfileName = fileName.replace(\".extension.properties\", \".properties\");\n\n\t\treturn fileName;\n\t}\n\n\t\n\t// Verify that 2 sets of parameters are identical\n\tprivate void validateParametersMatch(String pluginName, Class<?>[] expectedParameters, Method otherMethod) throws StfException {\n\t\tString expected = Arrays.toString(expectedParameters);\n\t\tString other    = Arrays.toString(otherMethod.getParameterTypes());\n\t\t\n\t\tif (!other.equals(expected)) {\n\t\t\tthrow new StfException(\"Parameters for the 'pluginInit' and the '\" + otherMethod.getName() + \"' method do not match: \" \n\t\t\t\t\t\t+ \" \" + expected + \" vs. \" + other \n\t\t\t\t\t\t+ \" For plugin: \" + pluginName);\n\t\t}\t\n\t}\n\n\n\t/**\n\t * Verifies that a method has been found.\n\t * \n\t * @param pluginName is the name of the plugin class we are running.\n\t * @param method is one of the plugins expected methods.\n\t * @param methodName is the name of the method we expect the plugin to have.\n\t * @throws StfException if the plugin class does not contain the expected method.\n\t */\n\tprivate void validateMethod(String pluginName, Method method, String methodName) throws StfException {\n\t\tif (method == null) {\n\t\t\tthrow new StfException(\"STF plugin does not contain a mandatory method. Plugin: \" + pluginName + \" Method: \" + methodName);\n\t\t}\n\n\t\t// Verify that the generation method doesn't return anything\n\t\tif (!method.getReturnType().equals(Void.TYPE)) {\n\t\t\tthrow new StfException(\"Method return type must be void. Plugin: \" + pluginName + \" Method: \" + method.getName());\n\t\t}\n\t}",
        "start_line": 458,
        "end_line": 548,
        "chunk_index": 6,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 857,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474300"
      },
      "text": "// The property file for the current extension is expected to live in the config \n\t\t// directory for the classes project. So build path to the expected location.\n\t\tString propertyFileName = convertExtensionNameToPropertyFileName(extensionClass.getSimpleName());\n\t\t\n\t\treturn resolvePropertyFile(configDir, propertyFileName, true);\n\t}\n\n\t\n\t/**\n\t * Returns information about a property file.\n\t * \n\t * @param extensionClass is the extension class whose property file we want to find.\n\t * @param propertyFileName is the name of the property file.\n\t * @param mustExist is set to true if the file is mandatory.\n\t * @return a File object for the property file.\n\t * @throws StfException if the directory does not exist or a mandatory property file does not exist.\n\t */\n\tprivate PropertyFileDetails resolvePropertyFile(File configDir, String propertyFileName, boolean mustExist) throws StfException {\n\t\tif (!configDir.exists()) {\n\t\t\tthrow new StfException(\"Directory does not exist: \" + configDir.getAbsolutePath());\n\t\t}\n\t\t\n\t\tFile propertyFile = new File(configDir, propertyFileName);\n\t\tif (mustExist && !propertyFile.exists()) {\n\t\t\tthrow new StfException(\"Unable to find property file at expected location: \" + propertyFile.getAbsolutePath());\n\t\t}\n\t\t\n\t\treturn new PropertyFileDetails(propertyFile, mustExist);\n\t}\n\n\t\n\t/** \n\t * Converts the classname of an extension into the expected property file name.\n\t * The property file name follows the Eclipse project naming convention and uses a \n\t * '.' character between words with no camel case.\n\t * eg. A name of 'StfSharedClasses' is converted to 'stf.shared.classes.properties'\n\t * \n\t * @param extensionName is the simple name of the extension class.\n\t * @return The name of the corresponding property file.\n\t */\n\tprivate String convertExtensionNameToPropertyFileName(String extensionName) {\n\t\tStringBuilder propertyFileName = new StringBuilder();\n\t\tfor (int i=0; i<extensionName.length(); i++) { \n\t\t\tchar c = extensionName.charAt(i);\n\t\t\tif (Character.isUpperCase(c) && i!=0) {\n\t\t\t\tpropertyFileName.append('.');\n\t\t\t}\n\t\t\tpropertyFileName.append(Character.toLowerCase(c));\n\t\t}\n\n\t\tpropertyFileName.append(\".properties\");\n\t\tString fileName = propertyFileName.toString();\n\t\t\n\t\t// Allow the extension classes to end in 'Extension' but not have this in their property file name.\n\t\tfileName = fileName.replace(\".extension.properties\", \".properties\");\n\n\t\treturn fileName;\n\t}\n\n\t\n\t// Verify that 2 sets of parameters are identical\n\tprivate void validateParametersMatch(String pluginName, Class<?>[] expectedParameters, Method otherMethod) throws StfException {\n\t\tString expected = Arrays.toString(expectedParameters);\n\t\tString other    = Arrays.toString(otherMethod.getParameterTypes());\n\t\t\n\t\tif (!other.equals(expected)) {\n\t\t\tthrow new StfException(\"Parameters for the 'pluginInit' and the '\" + otherMethod.getName() + \"' method do not match: \" \n\t\t\t\t\t\t+ \" \" + expected + \" vs. \" + other \n\t\t\t\t\t\t+ \" For plugin: \" + pluginName);\n\t\t}\t\n\t}\n\n\n\t/**\n\t * Verifies that a method has been found.\n\t * \n\t * @param pluginName is the name of the plugin class we are running.\n\t * @param method is one of the plugins expected methods.\n\t * @param methodName is the name of the method we expect the plugin to have.\n\t * @throws StfException if the plugin class does not contain the expected method.\n\t */\n\tprivate void validateMethod(String pluginName, Method method, String methodName) throws StfException {\n\t\tif (method == null) {\n\t\t\tthrow new StfException(\"STF plugin does not contain a mandatory method. Plugin: \" + pluginName + \" Method: \" + methodName);\n\t\t}\n\n\t\t// Verify that the generation method doesn't return anything\n\t\tif (!method.getReturnType().equals(Void.TYPE)) {\n\t\t\tthrow new StfException(\"Method return type must be void. Plugin: \" + pluginName + \" Method: \" + method.getName());\n\t\t}\n\t}"
    },
    "306": {
      "metadata": {
        "chunk_id": "77614f5c84ce89de08b97a8951e5451077c42ee5846f224fcc0e53574dc21fe5",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "// Verify that the generation method doesn't return anything\n\t\tif (!method.getReturnType().equals(Void.TYPE)) {\n\t\t\tthrow new StfException(\"Method return type must be void. Plugin: \" + pluginName + \" Method: \" + method.getName());\n\t\t}\n\t}\n\n\n\t/**\n\t * This method executes one of the plugins mandatory methods - pluginInit, setup, execute or teardown.\n\t *  \n\t * @param pluginObject is an instance of a plugin test object.\n\t * @param targetMethod is a reference to the method to run\n\t * @param environmentCore contains environmental details.\n\t * @param stage allows different perl code to be generated for say setup or execute steps. \n\t * @param doExitCommand set to true if the exit command needs to be added to the end of the script.\n\t * @throws StfException\n\t */\n\tpublic PerlCodeGenerator runStage(StfPluginRootInterface pluginObject, Method targetMethod, StfEnvironmentCore environmentCore, Stage stage, boolean doExitCommand) throws StfException {\n\t\tenvironmentCore.setStage(stage);\n\t\t\n\t\t// Create the perl output file\n\t\tFileRef perlFile = null;\n\t\tif (stage != Stage.INITIALISATION) {\n\t\t\tString outputFileName = targetMethod.getName() + \".pl\";\n\t\t\tperlFile = environmentCore.createDirectoryRef(testDir).childFile(outputFileName);\n\t\t}\n\t\tPerlCodeGenerator generator = new PerlCodeGenerator(environmentCore, targetMethod.getName(), stage, perlFile);\n\t\tStfExtensionBase extensionBase = new StfExtensionBase(environmentCore, generator);\n\n\t\t// Create the extension objects. These are needed by the plugin method\n\t\tClass<?>[] extensionClasses = targetMethod.getParameterTypes();\n\t\tStfExtension[] extensionInstances = new StfExtension[extensionClasses.length];\n\t\tfor (int i=0; i<extensionClasses.length; i++) { \n\t\t\textensionInstances[i] = createExtension(extensionClasses[i]);\n\t\t\textensionInstances[i].initialise(environmentCore, extensionBase, generator);\n\t\t}\n\t\t\n\t\t// Run the plugin method, allowing it to generate perl code.\n\t\ttry {\n\t\t\ttargetMethod.invoke(pluginObject, (Object[]) extensionInstances);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable cause = e.getCause();\n\t\t\tif (cause instanceof StfException) {\n\t\t\t\tthrow (StfException) cause;\n\t\t\t} else if (cause instanceof RuntimeException) { \n\t\t\t\tthrow (RuntimeException) cause;\n\t\t\t} else {\n\t\t\t\tthrow new StfException(\"Generation failed for \" + targetMethod.getName() + \"(): \" + cause, e);\n\t\t\t}\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new StfException(\"Failed to call plugin method: \" + targetMethod.getName(), e);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new StfException(\"Failed to call plugin method: \" + targetMethod.getName(), e);\n\t\t}\n\t\t\n\t\tif (generator != null) {\n\t\t\tgenerator.closeOutput(doExitCommand);\n\t\t}\n\n\t\t// Prevent orphan processes.\n\t\t// Check that all processes started in the current stage have code generated to\n\t\t// make sure that they have either completed naturally or have been killed.\n\t\tString sourceFileName = pluginObject.getClass().getSimpleName() + \".java\";\n\t\textensionBase.verifyNoOrphanChildProcesses(sourceFileName);\n\t\t\n\t\treturn generator;\n\t}\n\n\t\n\t/**\n\t * Create and initialise an extension class.\n\t * \n\t * @param extensionClass is the class to be created.\n\t * @param environmentCore provides access to environmental data.\n\t * @param generator is an object which can be used to generate perl code.\n\t * @return an instance of a StfExtension\n\t * @throws StfException if anything goes wrong.\n\t */\n\tprivate StfExtension createExtension(Class<?> extensionClass) throws StfException {\n\t\t// Try to create an instance of the extension class.\n\t\tObject newObject;\n\t\ttry {\n\t\t\tnewObject = extensionClass.newInstance();\t\t\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new StfException(\"Failed to create instance of extension class: \" + extensionClass.getName(), e);\n\t\t} catch (InstantiationException e) {\n\t\t\tthrow new StfException(\"Failed to create instance of extension class: \" + extensionClass.getName(), e);\n\t\t}",
        "start_line": 549,
        "end_line": 636,
        "chunk_index": 7,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 905,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474303"
      },
      "text": "// Verify that the generation method doesn't return anything\n\t\tif (!method.getReturnType().equals(Void.TYPE)) {\n\t\t\tthrow new StfException(\"Method return type must be void. Plugin: \" + pluginName + \" Method: \" + method.getName());\n\t\t}\n\t}\n\n\n\t/**\n\t * This method executes one of the plugins mandatory methods - pluginInit, setup, execute or teardown.\n\t *  \n\t * @param pluginObject is an instance of a plugin test object.\n\t * @param targetMethod is a reference to the method to run\n\t * @param environmentCore contains environmental details.\n\t * @param stage allows different perl code to be generated for say setup or execute steps. \n\t * @param doExitCommand set to true if the exit command needs to be added to the end of the script.\n\t * @throws StfException\n\t */\n\tpublic PerlCodeGenerator runStage(StfPluginRootInterface pluginObject, Method targetMethod, StfEnvironmentCore environmentCore, Stage stage, boolean doExitCommand) throws StfException {\n\t\tenvironmentCore.setStage(stage);\n\t\t\n\t\t// Create the perl output file\n\t\tFileRef perlFile = null;\n\t\tif (stage != Stage.INITIALISATION) {\n\t\t\tString outputFileName = targetMethod.getName() + \".pl\";\n\t\t\tperlFile = environmentCore.createDirectoryRef(testDir).childFile(outputFileName);\n\t\t}\n\t\tPerlCodeGenerator generator = new PerlCodeGenerator(environmentCore, targetMethod.getName(), stage, perlFile);\n\t\tStfExtensionBase extensionBase = new StfExtensionBase(environmentCore, generator);\n\n\t\t// Create the extension objects. These are needed by the plugin method\n\t\tClass<?>[] extensionClasses = targetMethod.getParameterTypes();\n\t\tStfExtension[] extensionInstances = new StfExtension[extensionClasses.length];\n\t\tfor (int i=0; i<extensionClasses.length; i++) { \n\t\t\textensionInstances[i] = createExtension(extensionClasses[i]);\n\t\t\textensionInstances[i].initialise(environmentCore, extensionBase, generator);\n\t\t}\n\t\t\n\t\t// Run the plugin method, allowing it to generate perl code.\n\t\ttry {\n\t\t\ttargetMethod.invoke(pluginObject, (Object[]) extensionInstances);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable cause = e.getCause();\n\t\t\tif (cause instanceof StfException) {\n\t\t\t\tthrow (StfException) cause;\n\t\t\t} else if (cause instanceof RuntimeException) { \n\t\t\t\tthrow (RuntimeException) cause;\n\t\t\t} else {\n\t\t\t\tthrow new StfException(\"Generation failed for \" + targetMethod.getName() + \"(): \" + cause, e);\n\t\t\t}\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new StfException(\"Failed to call plugin method: \" + targetMethod.getName(), e);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new StfException(\"Failed to call plugin method: \" + targetMethod.getName(), e);\n\t\t}\n\t\t\n\t\tif (generator != null) {\n\t\t\tgenerator.closeOutput(doExitCommand);\n\t\t}\n\n\t\t// Prevent orphan processes.\n\t\t// Check that all processes started in the current stage have code generated to\n\t\t// make sure that they have either completed naturally or have been killed.\n\t\tString sourceFileName = pluginObject.getClass().getSimpleName() + \".java\";\n\t\textensionBase.verifyNoOrphanChildProcesses(sourceFileName);\n\t\t\n\t\treturn generator;\n\t}\n\n\t\n\t/**\n\t * Create and initialise an extension class.\n\t * \n\t * @param extensionClass is the class to be created.\n\t * @param environmentCore provides access to environmental data.\n\t * @param generator is an object which can be used to generate perl code.\n\t * @return an instance of a StfExtension\n\t * @throws StfException if anything goes wrong.\n\t */\n\tprivate StfExtension createExtension(Class<?> extensionClass) throws StfException {\n\t\t// Try to create an instance of the extension class.\n\t\tObject newObject;\n\t\ttry {\n\t\t\tnewObject = extensionClass.newInstance();\t\t\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new StfException(\"Failed to create instance of extension class: \" + extensionClass.getName(), e);\n\t\t} catch (InstantiationException e) {\n\t\t\tthrow new StfException(\"Failed to create instance of extension class: \" + extensionClass.getName(), e);\n\t\t}"
    },
    "307": {
      "metadata": {
        "chunk_id": "94d9bbba30abd8a75ee2b7ad4b231e70b5c67a4d8ec29fbc2fd6dd0e1997997f",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "// Verify that we have created an extension object\n\t\tif (!(newObject instanceof StfExtension)) {\n\t\t\tthrow new StfException(\"Extension class '\" + extensionClass.getName() + \"' does not implement \" + StfExtension.class.getName());\n\t\t}\n\t\tStfExtension extension = (StfExtension) newObject;\n\n\t\treturn extension;\n\t}\n\t\n\t\n\t/**\n\t * This method creates an instance of the test plugin.\n\t * ie. it creates an object described by the -test property.\n\t * \n\t * @param testClassName is the full class name of the test to create.\n\t * @return an instance of the test's plugin.\n\t * @throws StfException\n\t */\n\tprivate StfPluginRootInterface createTestObject(String testClassName) throws StfException {\n\t\t// Load the class for the plugin\n\t\tClass<?> pluginClass;\n\t\ttry {\n\t\t\tpluginClass = Class.forName(testClassName);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new StfException(\"Test class is not on classpath: '\" + testClassName + \"'\", e);\n\t\t}\n\t\t\n\t\t// Verify that the plugin is really a test plugin\n\t\tif (!(StfPluginRootInterface.class.isAssignableFrom(pluginClass))) {\n\t\t\tthrow new StfError(\"The '\" + testClassName + \"' class is not a STF test case. It does not implement '\" + StfPluginRootInterface.class.getSimpleName() + \"'\");\n\t\t}\n\n\t\t// Create an instance of the plugin class\n\t\tObject pluginObject;\n\t\ttry {\n\t\t\tpluginObject = pluginClass.newInstance();\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new StfException(\"Failed to create instance of test class: '\" + testClassName + \"'\", e);\n\t\t} catch (InstantiationException e) {\n\t\t\tthrow new StfException(\"Failed to create instance of test class: '\" + testClassName + \"'\", e);\n\t\t}\n\t\t\n\t\treturn (StfPluginRootInterface) pluginObject;\n\t}\n\t\n\n\t// Nasty log4j setup code to force logging to the level we actually want.\n\t//\n\t// The log4j config file sets the default level at runtime because it is the \n\t// stf user that needs to decide how much to see. \n\tprivate void setLog4jLevel(Level level) {\n\t\tLoggerContext ctx = (LoggerContext) LogManager.getContext(false);\n\t\tLoggerConfig loggerConfig = ctx.getConfiguration().getLoggerConfig(LogManager.ROOT_LOGGER_NAME); \n\t\tloggerConfig.setLevel(level);\n\t\tctx.updateLoggers();\n\t}\n\n\t\n\t// Creates a file with the supplied string\n    private void writeFile(File outputFile, String content) throws StfException {\n        BufferedWriter output = null;\n        try {\n            output = new BufferedWriter(new FileWriter(outputFile));\n            output.write(content);\n        } catch (IOException e) {\n            throw new StfException(\"Failed to write to file: \" + outputFile.getAbsolutePath(), e);\n        } finally {\n            if (output != null) {\n            \ttry {\n\t\t\t\t\toutput.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StfException(\"Failed to close file: \" + outputFile.getAbsolutePath(), e);\n\t\t\t\t}\n            }\n        }\n    }\n\n\n\tprivate void generateHelpText(StfPluginRootInterface pluginObject, Method helpMethod, Class<?>[] pluginExtensionClasses) throws StfException {\n\t\tHelpTextGenerator help = new HelpTextGenerator(PlatformFinder.isLinux());\n\t\t\n\t\thelp.outputLine();\n\t\thelp.outputHeading(\"NAME\");\n\t\thelp.outputText(\"stf - generates and executes system test perl scripts\");",
        "start_line": 637,
        "end_line": 720,
        "chunk_index": 8,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 733,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474307"
      },
      "text": "// Verify that we have created an extension object\n\t\tif (!(newObject instanceof StfExtension)) {\n\t\t\tthrow new StfException(\"Extension class '\" + extensionClass.getName() + \"' does not implement \" + StfExtension.class.getName());\n\t\t}\n\t\tStfExtension extension = (StfExtension) newObject;\n\n\t\treturn extension;\n\t}\n\t\n\t\n\t/**\n\t * This method creates an instance of the test plugin.\n\t * ie. it creates an object described by the -test property.\n\t * \n\t * @param testClassName is the full class name of the test to create.\n\t * @return an instance of the test's plugin.\n\t * @throws StfException\n\t */\n\tprivate StfPluginRootInterface createTestObject(String testClassName) throws StfException {\n\t\t// Load the class for the plugin\n\t\tClass<?> pluginClass;\n\t\ttry {\n\t\t\tpluginClass = Class.forName(testClassName);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new StfException(\"Test class is not on classpath: '\" + testClassName + \"'\", e);\n\t\t}\n\t\t\n\t\t// Verify that the plugin is really a test plugin\n\t\tif (!(StfPluginRootInterface.class.isAssignableFrom(pluginClass))) {\n\t\t\tthrow new StfError(\"The '\" + testClassName + \"' class is not a STF test case. It does not implement '\" + StfPluginRootInterface.class.getSimpleName() + \"'\");\n\t\t}\n\n\t\t// Create an instance of the plugin class\n\t\tObject pluginObject;\n\t\ttry {\n\t\t\tpluginObject = pluginClass.newInstance();\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new StfException(\"Failed to create instance of test class: '\" + testClassName + \"'\", e);\n\t\t} catch (InstantiationException e) {\n\t\t\tthrow new StfException(\"Failed to create instance of test class: '\" + testClassName + \"'\", e);\n\t\t}\n\t\t\n\t\treturn (StfPluginRootInterface) pluginObject;\n\t}\n\t\n\n\t// Nasty log4j setup code to force logging to the level we actually want.\n\t//\n\t// The log4j config file sets the default level at runtime because it is the \n\t// stf user that needs to decide how much to see. \n\tprivate void setLog4jLevel(Level level) {\n\t\tLoggerContext ctx = (LoggerContext) LogManager.getContext(false);\n\t\tLoggerConfig loggerConfig = ctx.getConfiguration().getLoggerConfig(LogManager.ROOT_LOGGER_NAME); \n\t\tloggerConfig.setLevel(level);\n\t\tctx.updateLoggers();\n\t}\n\n\t\n\t// Creates a file with the supplied string\n    private void writeFile(File outputFile, String content) throws StfException {\n        BufferedWriter output = null;\n        try {\n            output = new BufferedWriter(new FileWriter(outputFile));\n            output.write(content);\n        } catch (IOException e) {\n            throw new StfException(\"Failed to write to file: \" + outputFile.getAbsolutePath(), e);\n        } finally {\n            if (output != null) {\n            \ttry {\n\t\t\t\t\toutput.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StfException(\"Failed to close file: \" + outputFile.getAbsolutePath(), e);\n\t\t\t\t}\n            }\n        }\n    }\n\n\n\tprivate void generateHelpText(StfPluginRootInterface pluginObject, Method helpMethod, Class<?>[] pluginExtensionClasses) throws StfException {\n\t\tHelpTextGenerator help = new HelpTextGenerator(PlatformFinder.isLinux());\n\t\t\n\t\thelp.outputLine();\n\t\thelp.outputHeading(\"NAME\");\n\t\thelp.outputText(\"stf - generates and executes system test perl scripts\");"
    },
    "308": {
      "metadata": {
        "chunk_id": "89925f67e1db2827c9fe009a9379096d991be266a6dc1d7218542ab5de6d7785",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "private void generateHelpText(StfPluginRootInterface pluginObject, Method helpMethod, Class<?>[] pluginExtensionClasses) throws StfException {\n\t\tHelpTextGenerator help = new HelpTextGenerator(PlatformFinder.isLinux());\n\t\t\n\t\thelp.outputLine();\n\t\thelp.outputHeading(\"NAME\");\n\t\thelp.outputText(\"stf - generates and executes system test perl scripts\");\n\n\t\thelp.outputHeading(\"SYNOPSIS\");\n\t\thelp.outputText(\"stf.pl -workspace-root=<directory> -test=id [OPTIONS]\");\n\t\t\n\t\thelp.outputHeading(\"DESCRIPTION\");\n\t\thelp.outputText(\"stf (System Test Framework) generates and executes system tests. \"\n                      + \"The test name is used to locate Java code containing a test plugin. Stf runs the \"\n                      + \"plugins setup, execute and teardown methods to create platform specific scripts \"\n                      + \"for running that test.\\n\"\n                      + \"The generated perl scripts are then executed unless '-dry-run' is specified.\\n\"\n                      + \"A return code of '0' indicates success\");\n\t\t\n\t\thelp.outputHeading(\"OPTION VALUES\");\n\t\thelp.outputSection(\"Option layering\");\n\t\thelp.outputText(\"All options must have a value, but this can generally be the default value. \"\n\t\t\t\t\t  + \"The search order for an options value is:\\n\"\n\t\t\t\t\t  + \":space: - command line arguments\\n\"\n\t\t\t\t\t  + \":space: - user specific extension properties, eg. ~/.stf.runtimes.properties\\n\"\n\t\t\t\t\t  + \":space: - user specific stf properties, eg ~/.stf.properties\\n\"\n\t\t\t\t\t  + \":space: - extensions defaults, eg. stf.runtimes/config/stf.runtimes.properties\\n\"\n\t\t\t\t\t  + \":space: - default stf properties file, eg. stf/config/stf.properties\\n\");\n\n\t\thelp.outputSection(\"Option evaluation\");\n\t\thelp.outputText(\"There are special rules for parameter values which start with the following characters:\\n\"\n\t\t\t\t\t  + \":space: '$' - The value is replaced with the contents of corresponding environment variable. \"\n\t\t\t\t\t  + \"For example, 'javahome-execute=$JAVA_HOME'\\n\"\n\t\t\t\t\t  + \":space: '*' - Refers to the contents of another parameter. Resolution of the referenced \"\n\t\t\t\t\t  + \"parameter starts at the highest level.\");\n\n\n\t\t// Build list of extensions used by the current test case\n\t\tArrayList<Class<?>> extensionClasses = new ArrayList<Class<?>>();\n\t\textensionClasses.addAll(Arrays.asList(pluginExtensionClasses));\n\t\textensionClasses.add(Stf.class);\n\t\t\n\t\t// Get each extension to describe its options\n\t\thelp.outputHeading(\"OPTIONS\");\n\t\tCollections.reverse(extensionClasses);\n\t\tfor (Class<?> extensionClass : extensionClasses) {\n\t\t\tStfExtension extension = createExtension(extensionClass);\n\t\t\textension.help(help);\n\t\t}\n\t\t\n\t\t// Call the help method for the current test\n\t\ttry {\n\t\t\thelpMethod.invoke(pluginObject, help);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tif (e.getCause() instanceof StfError) {\n\t\t\t\tthrow (StfError) e.getCause();\n\t\t\t}\n\t\t\tthrow new StfException(\"Help text generation failed for \" + helpMethod.getName() + \"(): \" + e.getCause(), e);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new StfException(\"Failed to call plugin method: \" + helpMethod.getName(), e);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new StfException(\"Failed to call plugin method: \" + helpMethod.getName(), e);\n\t\t}",
        "start_line": 721,
        "end_line": 782,
        "chunk_index": 9,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 726,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474310"
      },
      "text": "private void generateHelpText(StfPluginRootInterface pluginObject, Method helpMethod, Class<?>[] pluginExtensionClasses) throws StfException {\n\t\tHelpTextGenerator help = new HelpTextGenerator(PlatformFinder.isLinux());\n\t\t\n\t\thelp.outputLine();\n\t\thelp.outputHeading(\"NAME\");\n\t\thelp.outputText(\"stf - generates and executes system test perl scripts\");\n\n\t\thelp.outputHeading(\"SYNOPSIS\");\n\t\thelp.outputText(\"stf.pl -workspace-root=<directory> -test=id [OPTIONS]\");\n\t\t\n\t\thelp.outputHeading(\"DESCRIPTION\");\n\t\thelp.outputText(\"stf (System Test Framework) generates and executes system tests. \"\n                      + \"The test name is used to locate Java code containing a test plugin. Stf runs the \"\n                      + \"plugins setup, execute and teardown methods to create platform specific scripts \"\n                      + \"for running that test.\\n\"\n                      + \"The generated perl scripts are then executed unless '-dry-run' is specified.\\n\"\n                      + \"A return code of '0' indicates success\");\n\t\t\n\t\thelp.outputHeading(\"OPTION VALUES\");\n\t\thelp.outputSection(\"Option layering\");\n\t\thelp.outputText(\"All options must have a value, but this can generally be the default value. \"\n\t\t\t\t\t  + \"The search order for an options value is:\\n\"\n\t\t\t\t\t  + \":space: - command line arguments\\n\"\n\t\t\t\t\t  + \":space: - user specific extension properties, eg. ~/.stf.runtimes.properties\\n\"\n\t\t\t\t\t  + \":space: - user specific stf properties, eg ~/.stf.properties\\n\"\n\t\t\t\t\t  + \":space: - extensions defaults, eg. stf.runtimes/config/stf.runtimes.properties\\n\"\n\t\t\t\t\t  + \":space: - default stf properties file, eg. stf/config/stf.properties\\n\");\n\n\t\thelp.outputSection(\"Option evaluation\");\n\t\thelp.outputText(\"There are special rules for parameter values which start with the following characters:\\n\"\n\t\t\t\t\t  + \":space: '$' - The value is replaced with the contents of corresponding environment variable. \"\n\t\t\t\t\t  + \"For example, 'javahome-execute=$JAVA_HOME'\\n\"\n\t\t\t\t\t  + \":space: '*' - Refers to the contents of another parameter. Resolution of the referenced \"\n\t\t\t\t\t  + \"parameter starts at the highest level.\");\n\n\n\t\t// Build list of extensions used by the current test case\n\t\tArrayList<Class<?>> extensionClasses = new ArrayList<Class<?>>();\n\t\textensionClasses.addAll(Arrays.asList(pluginExtensionClasses));\n\t\textensionClasses.add(Stf.class);\n\t\t\n\t\t// Get each extension to describe its options\n\t\thelp.outputHeading(\"OPTIONS\");\n\t\tCollections.reverse(extensionClasses);\n\t\tfor (Class<?> extensionClass : extensionClasses) {\n\t\t\tStfExtension extension = createExtension(extensionClass);\n\t\t\textension.help(help);\n\t\t}\n\t\t\n\t\t// Call the help method for the current test\n\t\ttry {\n\t\t\thelpMethod.invoke(pluginObject, help);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tif (e.getCause() instanceof StfError) {\n\t\t\t\tthrow (StfError) e.getCause();\n\t\t\t}\n\t\t\tthrow new StfException(\"Help text generation failed for \" + helpMethod.getName() + \"(): \" + e.getCause(), e);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new StfException(\"Failed to call plugin method: \" + helpMethod.getName(), e);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new StfException(\"Failed to call plugin method: \" + helpMethod.getName(), e);\n\t\t}"
    },
    "309": {
      "metadata": {
        "chunk_id": "e4cc4ada177e9f730ace958fe7de8f456bfc83d3b733e746fd94a47d416a1767",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/StfRunner.java",
        "content": "help.outputHeading(\"NOTES\");\n\t\thelp.outputSection(\"Development environment\");\n\t\thelp.outputText(\"To simplify the repeated execution of stf.pl it might be worth making a \"\n\t\t\t\t      + \"couple of changes to your development environment: \\n\"\n\t\t\t\t      + \"1) Simplify command lines by putting unchanging options, such as 'test-root' \"\n\t\t\t\t      + \"or 'systemtest_prereqs', into a '$HOME/.stf.properties' file.\\n\"\n\t\t\t\t      + \"2) On linux machines set an alias to stf.pl. for example \"\n\t\t\t\t      + \"'alias stf=\\\"$HOME/workspaces/java-testing/stf.core/scripts/stf.pl\\\"'. On Windows machines \"\n\t\t\t\t      + \"add the directory containing Stf.pl to the system path.\");\n\t\t\n\t\thelp.outputSection(\"Example commands\");\n\t\thelp.outputText(\"$ stf -test-root=$HOME/git/aqa-systemtest -test=LambdaLoadTest\");\n\t\thelp.outputText(\"$ stf -test-root=$HOME/git/aqa-systemtest -test=MathLoadTest -test-args=\\\"workload=autoSimd\\\"\");\n\t\thelp.outputText(\"$ stf -test-root=$HOME/git/aqa-systemtest -test=MathLoadTest -test-args=\\\"workload=bigDecimal\\\" -dry-run\");\n\t\t\n\t\thelp.outputLine();\n\t}\n}",
        "start_line": 783,
        "end_line": 800,
        "chunk_index": 10,
        "total_chunks": 11,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 269,
        "node_type": null,
        "file_sha": "0bbae7256ddde4e68bbd8341ded391bb7c54ed64",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.474314"
      },
      "text": "help.outputHeading(\"NOTES\");\n\t\thelp.outputSection(\"Development environment\");\n\t\thelp.outputText(\"To simplify the repeated execution of stf.pl it might be worth making a \"\n\t\t\t\t      + \"couple of changes to your development environment: \\n\"\n\t\t\t\t      + \"1) Simplify command lines by putting unchanging options, such as 'test-root' \"\n\t\t\t\t      + \"or 'systemtest_prereqs', into a '$HOME/.stf.properties' file.\\n\"\n\t\t\t\t      + \"2) On linux machines set an alias to stf.pl. for example \"\n\t\t\t\t      + \"'alias stf=\\\"$HOME/workspaces/java-testing/stf.core/scripts/stf.pl\\\"'. On Windows machines \"\n\t\t\t\t      + \"add the directory containing Stf.pl to the system path.\");\n\t\t\n\t\thelp.outputSection(\"Example commands\");\n\t\thelp.outputText(\"$ stf -test-root=$HOME/git/aqa-systemtest -test=LambdaLoadTest\");\n\t\thelp.outputText(\"$ stf -test-root=$HOME/git/aqa-systemtest -test=MathLoadTest -test-args=\\\"workload=autoSimd\\\"\");\n\t\thelp.outputText(\"$ stf -test-root=$HOME/git/aqa-systemtest -test=MathLoadTest -test-args=\\\"workload=bigDecimal\\\" -dry-run\");\n\t\t\n\t\thelp.outputLine();\n\t}\n}"
    },
    "310": {
      "metadata": {
        "chunk_id": "24298c5d711556b45258cf152d4dc85b1fc4711bee30cbf8016e104ef8aaf6a8",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/modes/HelpTextGenerator.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner.modes;\n\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n\n/**\n * This is a support class which aims to make it easier for extensions to \n * provide help information, which is triggered by running stf with '-help'.\n * \n * The generated help output copies the style of linux/unix man pages.\n */",
        "start_line": 0,
        "end_line": 25,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 196,
        "node_type": null,
        "file_sha": "0fe7e6d7549c2f3705ed9e3c1c3c12dcc20783a6",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.495816"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner.modes;\n\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n\n/**\n * This is a support class which aims to make it easier for extensions to \n * provide help information, which is triggered by running stf with '-help'.\n * \n * The generated help output copies the style of linux/unix man pages.\n */"
    },
    "311": {
      "metadata": {
        "chunk_id": "2b8b0ebb86c3daf41a8ee0b30a2be9e5c668cdc0d2ffda3bbeb373390f269890",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/modes/HelpTextGenerator.java",
        "content": "public class HelpTextGenerator {\n\tprivate String INDENT2 = \"   \";\n\tprivate String INDENT3 = \"       \";\n\tprivate String INDENT4 = \"              \";\n\t\n\tprivate int screenWidth = 79;\n\n\tprivate String ansiBold = \"\";\n\tprivate String ansiUnderline = \"\";\n\tprivate String ansiReset = \"\";\n\n\t// Counters to help add blank lines in at sensible places\t\n\tprivate int numSections = 0;\n\tprivate int numArgumentsInSection = 0;\n\t\n\t\n\tpublic HelpTextGenerator(boolean isLinux) {\n\t\tif (isLinux) {\n\t\t\tansiBold      = \"\\u001B[1m\";\n\t\t\tansiUnderline = \"\\u001B[4m\";\n\t\t\tansiReset     = \"\\u001B[0m\";\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Outputs a heading for a new section of the man page, eg 'NAME' or 'SYNOPSIS'.\n\t * This is the highest level of output.\n\t * The title is shown in bold text with no indentation.\n\t * \n\t * @param title contains the text to output.\n\t */\n\tpublic void outputHeading(String title) {\n\t\tSystem.out.println();\n\t\tSystem.out.println(ansiBold + title.toUpperCase() + ansiReset);\n\t\tnumSections = 0;\n\t}\n\n\t\n\t/**\n\t * Outputs a lower priority heading.\n\t * This is indented slightly, so that it fits below a 'heading'.\n\t *\n\t * @param text contains the text to output.\n\t */\n\tpublic void outputSection(String text) {\n\t\tif (numSections > 0) {\n\t\t\tSystem.out.println();\n\t\t}\n\t\tnumSections++;\n\n\t\tSystem.out.println(INDENT2 + ansiBold + text + ansiReset);\n\t\tnumArgumentsInSection = 0;\n\t}\n\n\n\t/**\n\t * This method outputs a block of formatted text.\n\t * The text is indented to below a section title.\n\t * '\\n' characters can be used to force a new line.\n\t * \n\t * @param text contains the text to output.\n\t */\n\tpublic void outputText(String text) {\n\t\toutput(INDENT3, text);\n\t}\n\t\n\t\n\t/**\n\t * Outputs an argument name in a standardised format.\n\t * \n\t * @param argName contains the name of the argument.\n\t */\n\tpublic void outputArgName(String argName) {\n\t\toutputArgName(argName, null);\n\t}\n\n\t\n\t/**\n\t * Outputs a line describing an argument and its value.\n\t * For example it produces a line such as '       -max-count=NUM'.\n\t * \n\t * @param argName contains the name of the argument.\n\t * @param argSpec names the value that can be expected.\n\t */\n\tpublic void outputArgName(String argName, String argSpec) {\n\t\tif (numArgumentsInSection > 0) {\n\t\t\tSystem.out.println();\n\t\t}\n\t\tnumArgumentsInSection++;\n\n\t\tif (argSpec == null) { \n\t\t\tSystem.out.println(INDENT3 + ansiBold + argName + ansiReset);\n\t\t} else {\n\t\t\tSystem.out.println(INDENT3 + ansiBold + argName + \"=\" + ansiReset + ansiUnderline + argSpec + ansiReset);\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Outputs in a standard format some text to describe an argument.\n\t * The text is split as necessary and indented.  \n\t * '\\n' characters can be used to force a new line.\n\t * \n\t * @param argDescription contains text to describe the argument.\n\t */\n\tpublic void outputArgDesc(String argDescription) {\n\t\toutput(INDENT4, argDescription);\n\t}\n\t\n\t\n\t/**\n\t * Force the output of a blank line. \n\t * Can be sparingly used to add lines to improve readability. \n\t */\n\tpublic void outputLine() {\n\t\tSystem.out.println();\n\t}\n\n\t\n\tprivate void output(String indent, String text) {\n\t\tArrayList<String> lines = splitIntoLines(text, screenWidth - indent.length());\n\t\t\n\t\tfor (String lineText : lines) { \n\t\t\tSystem.out.print(indent);\n\t\t\tSystem.out.println(lineText);\n\t\t}\n\t}",
        "start_line": 26,
        "end_line": 153,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 857,
        "node_type": null,
        "file_sha": "0fe7e6d7549c2f3705ed9e3c1c3c12dcc20783a6",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.495839"
      },
      "text": "public class HelpTextGenerator {\n\tprivate String INDENT2 = \"   \";\n\tprivate String INDENT3 = \"       \";\n\tprivate String INDENT4 = \"              \";\n\t\n\tprivate int screenWidth = 79;\n\n\tprivate String ansiBold = \"\";\n\tprivate String ansiUnderline = \"\";\n\tprivate String ansiReset = \"\";\n\n\t// Counters to help add blank lines in at sensible places\t\n\tprivate int numSections = 0;\n\tprivate int numArgumentsInSection = 0;\n\t\n\t\n\tpublic HelpTextGenerator(boolean isLinux) {\n\t\tif (isLinux) {\n\t\t\tansiBold      = \"\\u001B[1m\";\n\t\t\tansiUnderline = \"\\u001B[4m\";\n\t\t\tansiReset     = \"\\u001B[0m\";\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Outputs a heading for a new section of the man page, eg 'NAME' or 'SYNOPSIS'.\n\t * This is the highest level of output.\n\t * The title is shown in bold text with no indentation.\n\t * \n\t * @param title contains the text to output.\n\t */\n\tpublic void outputHeading(String title) {\n\t\tSystem.out.println();\n\t\tSystem.out.println(ansiBold + title.toUpperCase() + ansiReset);\n\t\tnumSections = 0;\n\t}\n\n\t\n\t/**\n\t * Outputs a lower priority heading.\n\t * This is indented slightly, so that it fits below a 'heading'.\n\t *\n\t * @param text contains the text to output.\n\t */\n\tpublic void outputSection(String text) {\n\t\tif (numSections > 0) {\n\t\t\tSystem.out.println();\n\t\t}\n\t\tnumSections++;\n\n\t\tSystem.out.println(INDENT2 + ansiBold + text + ansiReset);\n\t\tnumArgumentsInSection = 0;\n\t}\n\n\n\t/**\n\t * This method outputs a block of formatted text.\n\t * The text is indented to below a section title.\n\t * '\\n' characters can be used to force a new line.\n\t * \n\t * @param text contains the text to output.\n\t */\n\tpublic void outputText(String text) {\n\t\toutput(INDENT3, text);\n\t}\n\t\n\t\n\t/**\n\t * Outputs an argument name in a standardised format.\n\t * \n\t * @param argName contains the name of the argument.\n\t */\n\tpublic void outputArgName(String argName) {\n\t\toutputArgName(argName, null);\n\t}\n\n\t\n\t/**\n\t * Outputs a line describing an argument and its value.\n\t * For example it produces a line such as '       -max-count=NUM'.\n\t * \n\t * @param argName contains the name of the argument.\n\t * @param argSpec names the value that can be expected.\n\t */\n\tpublic void outputArgName(String argName, String argSpec) {\n\t\tif (numArgumentsInSection > 0) {\n\t\t\tSystem.out.println();\n\t\t}\n\t\tnumArgumentsInSection++;\n\n\t\tif (argSpec == null) { \n\t\t\tSystem.out.println(INDENT3 + ansiBold + argName + ansiReset);\n\t\t} else {\n\t\t\tSystem.out.println(INDENT3 + ansiBold + argName + \"=\" + ansiReset + ansiUnderline + argSpec + ansiReset);\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Outputs in a standard format some text to describe an argument.\n\t * The text is split as necessary and indented.  \n\t * '\\n' characters can be used to force a new line.\n\t * \n\t * @param argDescription contains text to describe the argument.\n\t */\n\tpublic void outputArgDesc(String argDescription) {\n\t\toutput(INDENT4, argDescription);\n\t}\n\t\n\t\n\t/**\n\t * Force the output of a blank line. \n\t * Can be sparingly used to add lines to improve readability. \n\t */\n\tpublic void outputLine() {\n\t\tSystem.out.println();\n\t}\n\n\t\n\tprivate void output(String indent, String text) {\n\t\tArrayList<String> lines = splitIntoLines(text, screenWidth - indent.length());\n\t\t\n\t\tfor (String lineText : lines) { \n\t\t\tSystem.out.print(indent);\n\t\t\tSystem.out.println(lineText);\n\t\t}\n\t}"
    },
    "312": {
      "metadata": {
        "chunk_id": "a1dc123351df5c8faaa975a75b85434a832bf7456ae439cc43256381e98eb37c",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/modes/HelpTextGenerator.java",
        "content": "/**\n\t * Outputs in a standard format some text to describe an argument.\n\t * The text is split as necessary and indented.  \n\t * '\\n' characters can be used to force a new line.\n\t * \n\t * @param argDescription contains text to describe the argument.\n\t */\n\tpublic void outputArgDesc(String argDescription) {\n\t\toutput(INDENT4, argDescription);\n\t}\n\t\n\t\n\t/**\n\t * Force the output of a blank line. \n\t * Can be sparingly used to add lines to improve readability. \n\t */\n\tpublic void outputLine() {\n\t\tSystem.out.println();\n\t}\n\n\t\n\tprivate void output(String indent, String text) {\n\t\tArrayList<String> lines = splitIntoLines(text, screenWidth - indent.length());\n\t\t\n\t\tfor (String lineText : lines) { \n\t\t\tSystem.out.print(indent);\n\t\t\tSystem.out.println(lineText);\n\t\t}\n\t}\n\n\t\n\t/**\n\t * This method takes some text and splits it into multiple lines, such that \n\t * none of the lines exceed a maximum size.\n\t * It supports the use of '\\n' characters which can be used to force the\n\t * start of a new line. \n\t * \n\t * @param text is the text to format \n\t * @param maxLineLength is the maximum number of characters which a line can contain.\n\t * @return An array list containing the text for each line.\n\t */\n\tprivate ArrayList<String> splitIntoLines(String text, int maxLineLength) {\n\t\tArrayList<String> lines = new ArrayList<String>();\n\t\tStringBuilder line = new StringBuilder(maxLineLength);\n\t\t\n\t\t// Split the text based on spaces and newline characters\n\t\tStringTokenizer tokenizer = new StringTokenizer(text.trim(), \" \\n\", true);\n\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t    String word = tokenizer.nextToken();\n\t\t    \n\t\t    if (word.equals(\"\\n\")) {\n\t\t    \t// Force a newline\n\t\t    \tlines.add(line.toString());\n\t\t    \tline.setLength(0);\n\t\t    \t\n\t\t    } else if (!word.equals(\" \")) {\n\t\t    \tif (word.equals(\":space:\")) {\n\t\t    \t\tword = \" \";\n\t\t    \t}\n\t\t    \tif (line.length() + word.length() > maxLineLength) {\n\t\t    \t\t// Need to start a new line to hold the current word\n\t\t\t    \tlines.add(line.toString());\n\t\t\t    \tline.setLength(0);\n\t\t    \t} else if (line.length() > 0) {\n\t\t    \t\t// Make sure there is a space before the word gets added\n\t\t    \t\tline.append(\" \");\n\t\t    \t}\n\t\t    \tline.append(word);\n\t\t    }\n\t\t}\n\t\t\n\t\t// Don't forget any part build output line\n\t\tif (line.length() > 0) {\n\t\t\tlines.add(line.toString());\n\t\t}\n\t\t\n\t\treturn lines;\n\t}\n}",
        "start_line": 154,
        "end_line": 232,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 565,
        "node_type": null,
        "file_sha": "0fe7e6d7549c2f3705ed9e3c1c3c12dcc20783a6",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.495842"
      },
      "text": "/**\n\t * Outputs in a standard format some text to describe an argument.\n\t * The text is split as necessary and indented.  \n\t * '\\n' characters can be used to force a new line.\n\t * \n\t * @param argDescription contains text to describe the argument.\n\t */\n\tpublic void outputArgDesc(String argDescription) {\n\t\toutput(INDENT4, argDescription);\n\t}\n\t\n\t\n\t/**\n\t * Force the output of a blank line. \n\t * Can be sparingly used to add lines to improve readability. \n\t */\n\tpublic void outputLine() {\n\t\tSystem.out.println();\n\t}\n\n\t\n\tprivate void output(String indent, String text) {\n\t\tArrayList<String> lines = splitIntoLines(text, screenWidth - indent.length());\n\t\t\n\t\tfor (String lineText : lines) { \n\t\t\tSystem.out.print(indent);\n\t\t\tSystem.out.println(lineText);\n\t\t}\n\t}\n\n\t\n\t/**\n\t * This method takes some text and splits it into multiple lines, such that \n\t * none of the lines exceed a maximum size.\n\t * It supports the use of '\\n' characters which can be used to force the\n\t * start of a new line. \n\t * \n\t * @param text is the text to format \n\t * @param maxLineLength is the maximum number of characters which a line can contain.\n\t * @return An array list containing the text for each line.\n\t */\n\tprivate ArrayList<String> splitIntoLines(String text, int maxLineLength) {\n\t\tArrayList<String> lines = new ArrayList<String>();\n\t\tStringBuilder line = new StringBuilder(maxLineLength);\n\t\t\n\t\t// Split the text based on spaces and newline characters\n\t\tStringTokenizer tokenizer = new StringTokenizer(text.trim(), \" \\n\", true);\n\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t    String word = tokenizer.nextToken();\n\t\t    \n\t\t    if (word.equals(\"\\n\")) {\n\t\t    \t// Force a newline\n\t\t    \tlines.add(line.toString());\n\t\t    \tline.setLength(0);\n\t\t    \t\n\t\t    } else if (!word.equals(\" \")) {\n\t\t    \tif (word.equals(\":space:\")) {\n\t\t    \t\tword = \" \";\n\t\t    \t}\n\t\t    \tif (line.length() + word.length() > maxLineLength) {\n\t\t    \t\t// Need to start a new line to hold the current word\n\t\t\t    \tlines.add(line.toString());\n\t\t\t    \tline.setLength(0);\n\t\t    \t} else if (line.length() > 0) {\n\t\t    \t\t// Make sure there is a space before the word gets added\n\t\t    \t\tline.append(\" \");\n\t\t    \t}\n\t\t    \tline.append(word);\n\t\t    }\n\t\t}\n\t\t\n\t\t// Don't forget any part build output line\n\t\tif (line.length() > 0) {\n\t\t\tlines.add(line.toString());\n\t\t}\n\t\t\n\t\treturn lines;\n\t}\n}"
    },
    "313": {
      "metadata": {
        "chunk_id": "17b0c4f030d9ab8a15b1a388689d8ee6a45bd9f15a275292d4dd96d904ce8135",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/modes/PluginList.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner.modes;\n\nimport java.io.File;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginRootInterface;\nimport net.adoptopenjdk.stf.runner.ClassPathConfigurator;\n\n\n/**\n * This class searches for test cases within a workspace, so that people\n * can get a full list of available tests.\n * Once the search is complete it produces a list of them.\n * \n * This code is triggered by running stf with the '-list' argument.\n */",
        "start_line": 0,
        "end_line": 41,
        "chunk_index": 0,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 335,
        "node_type": null,
        "file_sha": "7bc66f423844eee77b83d6e3d06904c3ac002c63",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.514369"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.runner.modes;\n\nimport java.io.File;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.stf.StfConstants;\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginRootInterface;\nimport net.adoptopenjdk.stf.runner.ClassPathConfigurator;\n\n\n/**\n * This class searches for test cases within a workspace, so that people\n * can get a full list of available tests.\n * Once the search is complete it produces a list of them.\n * \n * This code is triggered by running stf with the '-list' argument.\n */"
    },
    "314": {
      "metadata": {
        "chunk_id": "5e292eab6f17d43ae0c2068c39a7e51c6a759f0c22081be06e5692f77399b0b6",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/modes/PluginList.java",
        "content": "public class PluginList {\n    private static final Logger logger = LogManager.getLogger(PluginList.class.getName());\n\n\tprivate static class TestDetails {\n\t\tString projectName;\n\t\tString testName;\n\t\t\n\t\tpublic TestDetails(String projectName, String testName) {\n\t\t\tthis.projectName = projectName;\n\t\t\tthis.testName = testName;\n\t\t}\n\t}\n\t\n\tprivate static String CLASS_VERSION_INCOMPATIBLE_MESSAGE = \"<< Class-version-incompatibilities >>\";\n\t\n\t\n\t/**\n\t * Examine all classes within the supplied workspaces and list those which are test cases.\n\t * \n\t * @param environmentCore gives access to stf properties.\n\t * @param testRoots points to the workspaces to be searched.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void searchAndListTests(StfEnvironmentCore environmentCore, ArrayList<DirectoryRef> testRoots) throws StfException {\n\n\t\t//For each test root, find a list of all tests inside it.\n\t\tArrayList<TestDetails> tests = new ArrayList<TestDetails>();\n\t\tfor (DirectoryRef testRootDir : testRoots) {\n\t\t\tArrayList<TestDetails> testRootTests = searchWorkspace(environmentCore, testRootDir);\n\t\t\tif (testRootTests.isEmpty()) {\n\t\t\t\tthrow new StfError(\"No test cases found in test root '\" + testRootDir.getSpec() + \"'\" );\n\t\t\t}\n\t\t\t// Now build an ascii table to tell the user about all the tests they can run\n\t\t\tlistTestCases(testRootDir,testRootTests);\n\t\t\t\n\t\t\t// Finally, we add the sub-list of tests in this one test root to the main list of tests in all test roots.\n\t\t\ttests.addAll(testRootTests);\n\t\t}\n\t}\n\n\n\t/**\n\t * This method searches a workspace for test cases.\n\t * i.e. searches for class files which implement StfPluginRootInterface. \n\t * \n\t * @param environmentCore gives access to stf properties.\n\t * @param testRoot points to the directory containing test cases.\n\t * @return an ArrayList of test details for all STF test cases found.\n\t * @throws StfException\n\t */\n\tprivate ArrayList<TestDetails> searchWorkspace(StfEnvironmentCore environmentCore, DirectoryRef workspace) throws StfException {\n\t\tArrayList<TestDetails> tests = new ArrayList<TestDetails>();\n\n\t\t// Find all potential projects below the test-root\n\t\tFile[] projectFilesInTestRoot = workspace.asJavaFile().listFiles();\n\t\t\n\t\t// Combine the potential projects from  test-root into an arrayList\n\t\tArrayList<File> projectFiles = new ArrayList<File>();\n\t\tprojectFiles.addAll(Arrays.asList(projectFilesInTestRoot));\n\n\t\t// Search each potential project directory to identify those that really \n\t\t// are Java projects (and which may therefore contain test cases)\n\t\tArrayList<File> projects = new ArrayList<File>();\n\t\tfor (File file : projectFiles) {\n\t\t\tboolean hasStfClasspathFile = new File(file, StfConstants.STF_CLASSPATH_XML_FILE).exists();\n\t\t\tboolean hasClasspathFile    = new File(file, \".classpath\").exists();\n\t\t\tif (file.isDirectory() && (hasStfClasspathFile || hasClasspathFile)) {\n\t\t\t\tprojects.add(file);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Search each projects class files in turn\n\t\tfor (File project : projects) {\n\t\t\tFile projectBinDir = new File(project, \"bin\");\n\t\t\tif (projectBinDir.exists()) {\n\t\t\t\t// Setup the STF class loader to use the dependencies for the current project\n\t\t\t\tboolean projectUsesStf = ClassPathConfigurator.configureClassLoader(environmentCore, project.getName());",
        "start_line": 42,
        "end_line": 118,
        "chunk_index": 1,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 747,
        "node_type": null,
        "file_sha": "7bc66f423844eee77b83d6e3d06904c3ac002c63",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.514378"
      },
      "text": "public class PluginList {\n    private static final Logger logger = LogManager.getLogger(PluginList.class.getName());\n\n\tprivate static class TestDetails {\n\t\tString projectName;\n\t\tString testName;\n\t\t\n\t\tpublic TestDetails(String projectName, String testName) {\n\t\t\tthis.projectName = projectName;\n\t\t\tthis.testName = testName;\n\t\t}\n\t}\n\t\n\tprivate static String CLASS_VERSION_INCOMPATIBLE_MESSAGE = \"<< Class-version-incompatibilities >>\";\n\t\n\t\n\t/**\n\t * Examine all classes within the supplied workspaces and list those which are test cases.\n\t * \n\t * @param environmentCore gives access to stf properties.\n\t * @param testRoots points to the workspaces to be searched.\n\t * @throws StfException if anything goes wrong.\n\t */\n\tpublic void searchAndListTests(StfEnvironmentCore environmentCore, ArrayList<DirectoryRef> testRoots) throws StfException {\n\n\t\t//For each test root, find a list of all tests inside it.\n\t\tArrayList<TestDetails> tests = new ArrayList<TestDetails>();\n\t\tfor (DirectoryRef testRootDir : testRoots) {\n\t\t\tArrayList<TestDetails> testRootTests = searchWorkspace(environmentCore, testRootDir);\n\t\t\tif (testRootTests.isEmpty()) {\n\t\t\t\tthrow new StfError(\"No test cases found in test root '\" + testRootDir.getSpec() + \"'\" );\n\t\t\t}\n\t\t\t// Now build an ascii table to tell the user about all the tests they can run\n\t\t\tlistTestCases(testRootDir,testRootTests);\n\t\t\t\n\t\t\t// Finally, we add the sub-list of tests in this one test root to the main list of tests in all test roots.\n\t\t\ttests.addAll(testRootTests);\n\t\t}\n\t}\n\n\n\t/**\n\t * This method searches a workspace for test cases.\n\t * i.e. searches for class files which implement StfPluginRootInterface. \n\t * \n\t * @param environmentCore gives access to stf properties.\n\t * @param testRoot points to the directory containing test cases.\n\t * @return an ArrayList of test details for all STF test cases found.\n\t * @throws StfException\n\t */\n\tprivate ArrayList<TestDetails> searchWorkspace(StfEnvironmentCore environmentCore, DirectoryRef workspace) throws StfException {\n\t\tArrayList<TestDetails> tests = new ArrayList<TestDetails>();\n\n\t\t// Find all potential projects below the test-root\n\t\tFile[] projectFilesInTestRoot = workspace.asJavaFile().listFiles();\n\t\t\n\t\t// Combine the potential projects from  test-root into an arrayList\n\t\tArrayList<File> projectFiles = new ArrayList<File>();\n\t\tprojectFiles.addAll(Arrays.asList(projectFilesInTestRoot));\n\n\t\t// Search each potential project directory to identify those that really \n\t\t// are Java projects (and which may therefore contain test cases)\n\t\tArrayList<File> projects = new ArrayList<File>();\n\t\tfor (File file : projectFiles) {\n\t\t\tboolean hasStfClasspathFile = new File(file, StfConstants.STF_CLASSPATH_XML_FILE).exists();\n\t\t\tboolean hasClasspathFile    = new File(file, \".classpath\").exists();\n\t\t\tif (file.isDirectory() && (hasStfClasspathFile || hasClasspathFile)) {\n\t\t\t\tprojects.add(file);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Search each projects class files in turn\n\t\tfor (File project : projects) {\n\t\t\tFile projectBinDir = new File(project, \"bin\");\n\t\t\tif (projectBinDir.exists()) {\n\t\t\t\t// Setup the STF class loader to use the dependencies for the current project\n\t\t\t\tboolean projectUsesStf = ClassPathConfigurator.configureClassLoader(environmentCore, project.getName());"
    },
    "315": {
      "metadata": {
        "chunk_id": "47f6c2f4d46874b4e5fecaa62b72305965fdb9a68ef492b6e0d5a116a86f8013",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/modes/PluginList.java",
        "content": "if (!projectUsesStf) {\n\t\t\t\t\tlogger.debug(\"Not searching project '\" + project.getName() + \"' as it doesn't use STF\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Search all child directories of this projects bin directory\n\t\t\t\ttry {\n\t\t\t\t\tlogger.debug(\"Looking for tests in project \" + projectBinDir.getAbsolutePath());\n\t\t\t\t\tfor (File f : projectBinDir.listFiles()) {\n\t\t\t\t\t\tif (f.isDirectory()) {\n\t\t\t\t\t\t\tdoFindPlugins(project.getName(), f, f.getName(), tests);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (UnsupportedClassVersionError e) {\n\t\t\t\t\t// Project contains code for newer JVM version. Abandon search of this project.\n\t\t\t\t\ttests.add(new TestDetails(project.getName(), CLASS_VERSION_INCOMPATIBLE_MESSAGE));\n\t\t\t\t} catch (ClassFormatError e) {\n\t\t\t\t\tlogger.debug(\"ClassFormatError when searching project: \" + project.getName());\n\t\t\t\t} catch (LinkageError e) {\n\t\t\t\t\tlogger.debug(\"LnkageError when searching project: \" + project.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t// Sort the identified tests. Firstly by project name and then by test name\n\t\tCollections.sort(tests, new Comparator<TestDetails>() {\n\t\t\t    public int compare(TestDetails t1, TestDetails t2) {\n\t\t\t    \tint projectCompare = t1.projectName.compareTo(t2.projectName);\n\t\t\t    \tif (projectCompare != 0) {\n\t\t\t    \t\treturn projectCompare;\n\t\t\t    \t}\n\t\t\t    \treturn t1.testName.compareTo(t2.testName);\n\t\t\t    }\n\t\t\t}\n\t\t);\n\t\t\n\t\treturn tests;\n\t}\n\n\n\t/**\n\t * This method recursively searches for class files which are test cases.\n\t * \n\t * @param projectName is the name of the project being searched.\n\t * @param dir is the directory to look in.\n\t * @param cleanedClassName is the name that all classes in the current directory would start with. \n\t * @param tests is an ArrayList that found test cases are added to. \n\t * @throws StfException\n\t */\n\tprivate static void doFindPlugins(String projectName, File dir, String cleanedClassName, ArrayList<TestDetails> tests) throws StfException {\n\t\tlogger.debug(\"Looking for tests in dir \" + dir.getAbsolutePath());\n\t\tfor (File f : dir.listFiles()) {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tdoFindPlugins(projectName, f, cleanedClassName + \".\" + f.getName(), tests);\n\t\t\t} else if (f.getName().endsWith(\"module-info.class\")) {\n\t\t\t\treturn; // ignore\n\t\t\t} else if (f.getName().endsWith(\".class\")) {\n\t\t\t\t// Work out the full class name for the current file\n\t\t\t\tString testName = f.getName().replace(\".class\", \"\");\n\t\t\t\tString fullClassName = cleanedClassName + \".\" + testName;\n\t\t\t\t\n\t\t\t\t// Load the class\n\t\t\t\tClass<?> clazz = null;\n\t\t\t\ttry {\n\t\t\t\t\tclazz = Class.forName(fullClassName, false, ClassLoader.getSystemClassLoader());\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// Don't do anything about this exception. \n\t\t\t\t\t// It is only known to happen for classes with compilation \n\t\t\t\t\t// problems (so no great loss if we don't list these as tests) \n\t\t\t\t\tlogger.debug(\"Failed to load class: \" + fullClassName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check to see if the current class is a test case\n\t\t\t\tif (clazz != null) {\n\t\t\t\t\tboolean isAbstract = Modifier.isAbstract(clazz.getModifiers());\n\t\t\t\t\tif (!clazz.isInterface()  \n\t\t\t\t\t\t\t&& !isAbstract\n\t\t\t\t\t\t\t&& StfPluginRootInterface.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\ttests.add(new TestDetails(projectName, testName));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 119,
        "end_line": 203,
        "chunk_index": 2,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 766,
        "node_type": null,
        "file_sha": "7bc66f423844eee77b83d6e3d06904c3ac002c63",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.514381"
      },
      "text": "if (!projectUsesStf) {\n\t\t\t\t\tlogger.debug(\"Not searching project '\" + project.getName() + \"' as it doesn't use STF\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Search all child directories of this projects bin directory\n\t\t\t\ttry {\n\t\t\t\t\tlogger.debug(\"Looking for tests in project \" + projectBinDir.getAbsolutePath());\n\t\t\t\t\tfor (File f : projectBinDir.listFiles()) {\n\t\t\t\t\t\tif (f.isDirectory()) {\n\t\t\t\t\t\t\tdoFindPlugins(project.getName(), f, f.getName(), tests);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (UnsupportedClassVersionError e) {\n\t\t\t\t\t// Project contains code for newer JVM version. Abandon search of this project.\n\t\t\t\t\ttests.add(new TestDetails(project.getName(), CLASS_VERSION_INCOMPATIBLE_MESSAGE));\n\t\t\t\t} catch (ClassFormatError e) {\n\t\t\t\t\tlogger.debug(\"ClassFormatError when searching project: \" + project.getName());\n\t\t\t\t} catch (LinkageError e) {\n\t\t\t\t\tlogger.debug(\"LnkageError when searching project: \" + project.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t// Sort the identified tests. Firstly by project name and then by test name\n\t\tCollections.sort(tests, new Comparator<TestDetails>() {\n\t\t\t    public int compare(TestDetails t1, TestDetails t2) {\n\t\t\t    \tint projectCompare = t1.projectName.compareTo(t2.projectName);\n\t\t\t    \tif (projectCompare != 0) {\n\t\t\t    \t\treturn projectCompare;\n\t\t\t    \t}\n\t\t\t    \treturn t1.testName.compareTo(t2.testName);\n\t\t\t    }\n\t\t\t}\n\t\t);\n\t\t\n\t\treturn tests;\n\t}\n\n\n\t/**\n\t * This method recursively searches for class files which are test cases.\n\t * \n\t * @param projectName is the name of the project being searched.\n\t * @param dir is the directory to look in.\n\t * @param cleanedClassName is the name that all classes in the current directory would start with. \n\t * @param tests is an ArrayList that found test cases are added to. \n\t * @throws StfException\n\t */\n\tprivate static void doFindPlugins(String projectName, File dir, String cleanedClassName, ArrayList<TestDetails> tests) throws StfException {\n\t\tlogger.debug(\"Looking for tests in dir \" + dir.getAbsolutePath());\n\t\tfor (File f : dir.listFiles()) {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tdoFindPlugins(projectName, f, cleanedClassName + \".\" + f.getName(), tests);\n\t\t\t} else if (f.getName().endsWith(\"module-info.class\")) {\n\t\t\t\treturn; // ignore\n\t\t\t} else if (f.getName().endsWith(\".class\")) {\n\t\t\t\t// Work out the full class name for the current file\n\t\t\t\tString testName = f.getName().replace(\".class\", \"\");\n\t\t\t\tString fullClassName = cleanedClassName + \".\" + testName;\n\t\t\t\t\n\t\t\t\t// Load the class\n\t\t\t\tClass<?> clazz = null;\n\t\t\t\ttry {\n\t\t\t\t\tclazz = Class.forName(fullClassName, false, ClassLoader.getSystemClassLoader());\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// Don't do anything about this exception. \n\t\t\t\t\t// It is only known to happen for classes with compilation \n\t\t\t\t\t// problems (so no great loss if we don't list these as tests) \n\t\t\t\t\tlogger.debug(\"Failed to load class: \" + fullClassName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check to see if the current class is a test case\n\t\t\t\tif (clazz != null) {\n\t\t\t\t\tboolean isAbstract = Modifier.isAbstract(clazz.getModifiers());\n\t\t\t\t\tif (!clazz.isInterface()  \n\t\t\t\t\t\t\t&& !isAbstract\n\t\t\t\t\t\t\t&& StfPluginRootInterface.class.isAssignableFrom(clazz)) {\n\t\t\t\t\t\ttests.add(new TestDetails(projectName, testName));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
    },
    "316": {
      "metadata": {
        "chunk_id": "28ab4de0d61892603f2c281ba75edd43ebc4fac7687b0ade3b24046b5ca73818",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/runner/modes/PluginList.java",
        "content": "/**\n\t * This method writes out a table listing the project names and test names\n\t * @throws StfException \n\t */\n\tprivate void listTestCases(DirectoryRef testRoot, ArrayList<TestDetails> tests) throws StfException {\n\t\t// Find the longest project and test names\n\t\tint projectNameLen = 0;\n\t\tint testNameLen    = 0;\n\t\tfor (TestDetails test : tests) { \n\t\t\tprojectNameLen = Math.max(projectNameLen, test.projectName.length());\n\t\t\ttestNameLen    = Math.max(testNameLen, test.testName.length());\n\t\t}\n\t\t\n\t\t// Output a header line for the table listing all test cases\n\t\tlogger.info(\"\");\n\t\tlogger.info(\"Test automation in workspace at '\" + testRoot.getSpec() + \"': \");\n\t\tString titleLine = centerString(\"Project\", projectNameLen) + \" | \" + centerString(\"Test automation\", testNameLen);\n\t\tString borderString = buildRepeatingString('-', titleLine.length()+2);\n\t\tlogger.info(\"  +\" + borderString + \"+\");\n\t\tlogger.info(\"  | \" + titleLine + \" |\");\n\t\tlogger.info(\"  |\" + borderString + \"|\");\n\t\t\n\t\t// Output a 1 line summary for each test case\n\t\tfor (TestDetails test : tests) {\n\t\t    logger.info(String.format(\"  | %-\" + projectNameLen + \"s | %-\" + testNameLen + \"s |\", test.projectName, test.testName));\n\t\t}\n\t\tlogger.info(\"  +\" + borderString + \"+\");\n\n\t\t// Print warning if search had problems due to a class mismatch\n\t\tfor (TestDetails test : tests) {\n\t\t\tif (test.testName.equals(CLASS_VERSION_INCOMPATIBLE_MESSAGE)) {\n\t\t\t\tlogger.warn(\"Warning: One or more projects were not searched, as they contain classes newer that the running JVM\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tprivate String buildRepeatingString(char c, int num) {\n\t\tStringBuilder buff = new StringBuilder();\n\t\t\n\t\tfor (int i=0; i<num; i++) { \n\t\t\tbuff.append(c);\n\t\t}\n\t\t\n\t\treturn buff.toString();\n\t}\n\n\n\tprivate String centerString(String s, int width) {\n\t\tint beforeSpaces = (width - s.length()) /2;\n\t\tint afterSpaces = width - s.length() - beforeSpaces;\n\n\t\tString formatSpec = \"%\" + beforeSpaces + \"s%s%\" + afterSpaces + \"s\";\n\t\treturn String.format(formatSpec, \"\", s, \"\");\n\t}\n}",
        "start_line": 204,
        "end_line": 260,
        "chunk_index": 3,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 525,
        "node_type": null,
        "file_sha": "7bc66f423844eee77b83d6e3d06904c3ac002c63",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.514384"
      },
      "text": "/**\n\t * This method writes out a table listing the project names and test names\n\t * @throws StfException \n\t */\n\tprivate void listTestCases(DirectoryRef testRoot, ArrayList<TestDetails> tests) throws StfException {\n\t\t// Find the longest project and test names\n\t\tint projectNameLen = 0;\n\t\tint testNameLen    = 0;\n\t\tfor (TestDetails test : tests) { \n\t\t\tprojectNameLen = Math.max(projectNameLen, test.projectName.length());\n\t\t\ttestNameLen    = Math.max(testNameLen, test.testName.length());\n\t\t}\n\t\t\n\t\t// Output a header line for the table listing all test cases\n\t\tlogger.info(\"\");\n\t\tlogger.info(\"Test automation in workspace at '\" + testRoot.getSpec() + \"': \");\n\t\tString titleLine = centerString(\"Project\", projectNameLen) + \" | \" + centerString(\"Test automation\", testNameLen);\n\t\tString borderString = buildRepeatingString('-', titleLine.length()+2);\n\t\tlogger.info(\"  +\" + borderString + \"+\");\n\t\tlogger.info(\"  | \" + titleLine + \" |\");\n\t\tlogger.info(\"  |\" + borderString + \"|\");\n\t\t\n\t\t// Output a 1 line summary for each test case\n\t\tfor (TestDetails test : tests) {\n\t\t    logger.info(String.format(\"  | %-\" + projectNameLen + \"s | %-\" + testNameLen + \"s |\", test.projectName, test.testName));\n\t\t}\n\t\tlogger.info(\"  +\" + borderString + \"+\");\n\n\t\t// Print warning if search had problems due to a class mismatch\n\t\tfor (TestDetails test : tests) {\n\t\t\tif (test.testName.equals(CLASS_VERSION_INCOMPATIBLE_MESSAGE)) {\n\t\t\t\tlogger.warn(\"Warning: One or more projects were not searched, as they contain classes newer that the running JVM\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tprivate String buildRepeatingString(char c, int num) {\n\t\tStringBuilder buff = new StringBuilder();\n\t\t\n\t\tfor (int i=0; i<num; i++) { \n\t\t\tbuff.append(c);\n\t\t}\n\t\t\n\t\treturn buff.toString();\n\t}\n\n\n\tprivate String centerString(String s, int width) {\n\t\tint beforeSpaces = (width - s.length()) /2;\n\t\tint afterSpaces = width - s.length() - beforeSpaces;\n\n\t\tString formatSpec = \"%\" + beforeSpaces + \"s%s%\" + afterSpaces + \"s\";\n\t\treturn String.format(formatSpec, \"\", s, \"\");\n\t}\n}"
    },
    "317": {
      "metadata": {
        "chunk_id": "25f67d766c8cbbc05d4831782f24a4a85f99ecc818ab8fdbe9e89958eaa2ed90",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/supportApps/junit/JUnitRunner.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.supportApps.junit;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\nimport net.adoptopenjdk.stf.results.RunResultsFilter;\n\n\n/** \n * This class runs some JUnit tests and reports the results.\n * \n * The main benefit of this class is that it is easy to identify \n * hanging/crashing methods because this class reports the entry \n * and exit of each test method. \n */",
        "start_line": 0,
        "end_line": 37,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 277,
        "node_type": null,
        "file_sha": "dab9a6761490b23d8c12c166effe6e01230d2d49",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.531774"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.supportApps.junit;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\nimport net.adoptopenjdk.stf.results.RunResultsFilter;\n\n\n/** \n * This class runs some JUnit tests and reports the results.\n * \n * The main benefit of this class is that it is easy to identify \n * hanging/crashing methods because this class reports the entry \n * and exit of each test method. \n */"
    },
    "318": {
      "metadata": {
        "chunk_id": "d002c1b6f459f074e74c40713ed3744169d505c85dea592cdbcee64f6efdc153",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/supportApps/junit/JUnitRunner.java",
        "content": "public class JUnitRunner {\n    public static void main(String... args) throws ClassNotFoundException, StfException {\n    \tint firstClassNameArg = 0;\n    \t\n    \t// The first argument can optionally be the name of a file containing test exclusions\n    \tboolean useExclusions = false;\n    \tFile exclusionsFile = new File(args[0]);\n    \tif (exclusionsFile.exists()) {\n    \t\tSystem.out.println(\"Going to use test exclusions at: \" + exclusionsFile.getAbsolutePath());\n    \t\tuseExclusions = true;\n    \t\tfirstClassNameArg = 1;\n    \t}\n    \t\n    \t// Find the test classes that need to be run\n    \tSystem.out.println(\"Test classes to run:\");\n    \tArrayList<Class<?>> testClasses = new ArrayList<Class<?>>();\n    \tfor (int i=firstClassNameArg; i<args.length; i++) {\n    \t\tString className = args[i];\n    \t\tSystem.out.println(\"  \" + className);\n    \t\ttestClasses.add(Class.forName(className));\n    \t}\n    \tSystem.out.println();\n\n    \t// The results from this run are collected into this string buffer.\n    \t// Using string buffer for thread safety, as the anonymous inner class may be \n    \t// run in a different thread.\n    \tfinal StringBuffer resultsText = new StringBuffer();\n    \t\n    \tfinal String platform = PlatformFinder.getPlatformAsString();\n    \t\n    \tJUnitCore jUnitCore = new JUnitCore();\n        jUnitCore.addListener(new RunListener() {\n        \tprivate boolean awaitingResult = false;\n        \t\n        \tpublic void testRunStarted(Description description) throws Exception {\n        \t}\n        \tpublic void testRunFinished(Result result) throws Exception {\n        \t}\n        \tpublic void testStarted(Description description) throws Exception {\n        \t\treportProgress(\"testStarted : \" + description);\n        \t\tawaitingResult = true;\n        \t}\n        \tpublic void testFinished(Description description) throws Exception {\n        \t\treportProgress(\"testFinished: \" + description);\n        \t\t// Only report result if test has not already failed  \n        \t\tif (awaitingResult == true) {\n        \t\t\taddResult(\"pass\", platform, description, null, null);\n        \t\t\tawaitingResult = false;\n        \t\t}\n        \t}\n        \tpublic void testFailure(Failure failure) throws Exception {\n        \t\treportProgress(\"testFailure: \" + failure);\n        \t\tfailure.getException().printStackTrace(System.out);\n       \t\t\taddResult(\"fail\", platform, failure.getDescription(), failure.getMessage(), failure.getException());\n       \t\t\tawaitingResult = false;\n        \t}\n\t\t\tpublic void testAssumptionFailure(Failure failure) {\n\t\t\t\treportProgress(\"testAssumptionFailure: \" + failure);\n       \t\t\taddResult(\"fail\", platform, failure.getDescription(), failure.getMessage(), failure.getException());\n       \t\t\tawaitingResult = false;\n        \t}\n        \tpublic void testIgnored(Description description) throws Exception {\n        \t\treportProgress(\"testIgnored: \" + description);\n        \t\taddResult(\"ignored\", platform, description, null, null);\n        \t}\n\n        \tprivate void reportProgress(String testInfo) {\n        \t\t// With extra flushing to try and keep output in approximate time order - to help with debugging\n        \t\tSystem.out.flush();\n        \t\tSystem.err.flush();\n        \t\tSystem.out.println(testInfo);\n        \t\tSystem.out.flush();\n        \t\tSystem.err.flush();\n        \t}\n        \t\n        \t// Record the progress\n        \tprivate void addResult(String status, String platform, Description description, String message, Throwable exception) {\n        \t\tString messageText   = message == null ? \"\" : \" message=\\\"\" + message + \"\\\"\";\n        \t\tString exceptionText = exception == null ? \"\" : \" exception=\" + exception.getClass().getName();\n        \t\tString resultLine = \"platform=\" + platform \n        \t\t\t\t\t+ \" result=\" + status \n        \t\t\t\t\t+ \" class=\" + description.getClassName() \n        \t\t\t\t\t+ \" test=\" + description.getMethodName() \n        \t\t\t\t\t+ messageText\n        \t\t\t\t\t+ exceptionText; \n        \t\tresultsText.append(resultLine + \"\\n\");\n        \t}\n        });",
        "start_line": 38,
        "end_line": 125,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 800,
        "node_type": null,
        "file_sha": "dab9a6761490b23d8c12c166effe6e01230d2d49",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.531783"
      },
      "text": "public class JUnitRunner {\n    public static void main(String... args) throws ClassNotFoundException, StfException {\n    \tint firstClassNameArg = 0;\n    \t\n    \t// The first argument can optionally be the name of a file containing test exclusions\n    \tboolean useExclusions = false;\n    \tFile exclusionsFile = new File(args[0]);\n    \tif (exclusionsFile.exists()) {\n    \t\tSystem.out.println(\"Going to use test exclusions at: \" + exclusionsFile.getAbsolutePath());\n    \t\tuseExclusions = true;\n    \t\tfirstClassNameArg = 1;\n    \t}\n    \t\n    \t// Find the test classes that need to be run\n    \tSystem.out.println(\"Test classes to run:\");\n    \tArrayList<Class<?>> testClasses = new ArrayList<Class<?>>();\n    \tfor (int i=firstClassNameArg; i<args.length; i++) {\n    \t\tString className = args[i];\n    \t\tSystem.out.println(\"  \" + className);\n    \t\ttestClasses.add(Class.forName(className));\n    \t}\n    \tSystem.out.println();\n\n    \t// The results from this run are collected into this string buffer.\n    \t// Using string buffer for thread safety, as the anonymous inner class may be \n    \t// run in a different thread.\n    \tfinal StringBuffer resultsText = new StringBuffer();\n    \t\n    \tfinal String platform = PlatformFinder.getPlatformAsString();\n    \t\n    \tJUnitCore jUnitCore = new JUnitCore();\n        jUnitCore.addListener(new RunListener() {\n        \tprivate boolean awaitingResult = false;\n        \t\n        \tpublic void testRunStarted(Description description) throws Exception {\n        \t}\n        \tpublic void testRunFinished(Result result) throws Exception {\n        \t}\n        \tpublic void testStarted(Description description) throws Exception {\n        \t\treportProgress(\"testStarted : \" + description);\n        \t\tawaitingResult = true;\n        \t}\n        \tpublic void testFinished(Description description) throws Exception {\n        \t\treportProgress(\"testFinished: \" + description);\n        \t\t// Only report result if test has not already failed  \n        \t\tif (awaitingResult == true) {\n        \t\t\taddResult(\"pass\", platform, description, null, null);\n        \t\t\tawaitingResult = false;\n        \t\t}\n        \t}\n        \tpublic void testFailure(Failure failure) throws Exception {\n        \t\treportProgress(\"testFailure: \" + failure);\n        \t\tfailure.getException().printStackTrace(System.out);\n       \t\t\taddResult(\"fail\", platform, failure.getDescription(), failure.getMessage(), failure.getException());\n       \t\t\tawaitingResult = false;\n        \t}\n\t\t\tpublic void testAssumptionFailure(Failure failure) {\n\t\t\t\treportProgress(\"testAssumptionFailure: \" + failure);\n       \t\t\taddResult(\"fail\", platform, failure.getDescription(), failure.getMessage(), failure.getException());\n       \t\t\tawaitingResult = false;\n        \t}\n        \tpublic void testIgnored(Description description) throws Exception {\n        \t\treportProgress(\"testIgnored: \" + description);\n        \t\taddResult(\"ignored\", platform, description, null, null);\n        \t}\n\n        \tprivate void reportProgress(String testInfo) {\n        \t\t// With extra flushing to try and keep output in approximate time order - to help with debugging\n        \t\tSystem.out.flush();\n        \t\tSystem.err.flush();\n        \t\tSystem.out.println(testInfo);\n        \t\tSystem.out.flush();\n        \t\tSystem.err.flush();\n        \t}\n        \t\n        \t// Record the progress\n        \tprivate void addResult(String status, String platform, Description description, String message, Throwable exception) {\n        \t\tString messageText   = message == null ? \"\" : \" message=\\\"\" + message + \"\\\"\";\n        \t\tString exceptionText = exception == null ? \"\" : \" exception=\" + exception.getClass().getName();\n        \t\tString resultLine = \"platform=\" + platform \n        \t\t\t\t\t+ \" result=\" + status \n        \t\t\t\t\t+ \" class=\" + description.getClassName() \n        \t\t\t\t\t+ \" test=\" + description.getMethodName() \n        \t\t\t\t\t+ messageText\n        \t\t\t\t\t+ exceptionText; \n        \t\tresultsText.append(resultLine + \"\\n\");\n        \t}\n        });"
    },
    "319": {
      "metadata": {
        "chunk_id": "6b9e933e9ee56cf9a914d2a373c43d9ee557eff74f0ee71cc5a747981891b8f8",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/supportApps/junit/JUnitRunner.java",
        "content": "// Run the tests\n        Request request = Request.classes(testClasses.toArray(new Class[testClasses.size()]));\n\t\tResult result = jUnitCore.run(request);\n\t\t\n\t\t// Report results\n\t\tSystem.out.println();\n\t\tif (useExclusions) { \n\t\t\tSystem.out.println(\"Test Results before filtering:\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Test Results:\");\n\t\t}\n        System.out.println(\"  Ran    : \" + result.getRunCount());\n        System.out.println(\"  Passed : \" + (result.getRunCount() - result.getFailureCount()));\n        System.out.println(\"  Failed : \" + result.getFailureCount());\n        System.out.println(\"  Ignored: \" + result.getIgnoreCount());\n        System.out.println(\"  Result : \" + (result.wasSuccessful() ? \"PASSED\" : \"FAILED\"));\n        boolean testRunPassed = result.wasSuccessful();\n\n        // Optionally apply rules which allow failed tests to be re-categorised as having passed.\n        if (useExclusions) {\n        \tRunResultsFilter runResultsFilter = new RunResultsFilter();\n\t\t\ttestRunPassed = runResultsFilter.process(resultsText.toString(), exclusionsFile);\n        }\n        \n        System.exit(testRunPassed ? 0 : 1);\n    }\n}",
        "start_line": 126,
        "end_line": 152,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 260,
        "node_type": null,
        "file_sha": "dab9a6761490b23d8c12c166effe6e01230d2d49",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.531787"
      },
      "text": "// Run the tests\n        Request request = Request.classes(testClasses.toArray(new Class[testClasses.size()]));\n\t\tResult result = jUnitCore.run(request);\n\t\t\n\t\t// Report results\n\t\tSystem.out.println();\n\t\tif (useExclusions) { \n\t\t\tSystem.out.println(\"Test Results before filtering:\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Test Results:\");\n\t\t}\n        System.out.println(\"  Ran    : \" + result.getRunCount());\n        System.out.println(\"  Passed : \" + (result.getRunCount() - result.getFailureCount()));\n        System.out.println(\"  Failed : \" + result.getFailureCount());\n        System.out.println(\"  Ignored: \" + result.getIgnoreCount());\n        System.out.println(\"  Result : \" + (result.wasSuccessful() ? \"PASSED\" : \"FAILED\"));\n        boolean testRunPassed = result.wasSuccessful();\n\n        // Optionally apply rules which allow failed tests to be re-categorised as having passed.\n        if (useExclusions) {\n        \tRunResultsFilter runResultsFilter = new RunResultsFilter();\n\t\t\ttestRunPassed = runResultsFilter.process(resultsText.toString(), exclusionsFile);\n        }\n        \n        System.exit(testRunPassed ? 0 : 1);\n    }\n}"
    },
    "320": {
      "metadata": {
        "chunk_id": "250a9dc5f778af00d069958d8538cf213713e4941b65c1c793e527b3658e2901",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/util/FileOperations.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\npublic class FileOperations {\n\t/**\n\t * Copy a file. \n\t */\n\tpublic static void copyFile(File sourceFile, File destFile) throws StfException {\n\t\ttry {\n\t\t\t// Create destination directory if it doesn't exist\n\t\t\tFile parentDir = destFile.getParentFile();\n\t\t\tif (!parentDir.exists()) {\n\t\t\t\tparentDir.mkdirs();\n\t\t\t}\n\t\t\t\n\t\t    InputStream in = null;\n\t\t    OutputStream out = null;\n\t\t    try {\n\t\t        in = new FileInputStream(sourceFile);\n\t\t        out = new FileOutputStream(destFile);\n\t\t        byte[] buffer = new byte[1024];\n\t\t        int length;\n\t\t        while ((length = in.read(buffer)) > 0) {\n\t\t            out.write(buffer, 0, length);\n\t\t        }\n\t\t    } finally {\n\t\t        if (in != null) in.close();\n\t\t        if (out != null) out.close();\n\t\t    }\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to copy file. Source:\" + sourceFile.getAbsolutePath() + \" Dest:\" + destFile.getAbsolutePath(), e);\n\t\t}\n\t}\n}",
        "start_line": 0,
        "end_line": 56,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 393,
        "node_type": null,
        "file_sha": "2b1e55a815ab979d9d3370a8de2aefd2a43dbd29",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.549028"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\npublic class FileOperations {\n\t/**\n\t * Copy a file. \n\t */\n\tpublic static void copyFile(File sourceFile, File destFile) throws StfException {\n\t\ttry {\n\t\t\t// Create destination directory if it doesn't exist\n\t\t\tFile parentDir = destFile.getParentFile();\n\t\t\tif (!parentDir.exists()) {\n\t\t\t\tparentDir.mkdirs();\n\t\t\t}\n\t\t\t\n\t\t    InputStream in = null;\n\t\t    OutputStream out = null;\n\t\t    try {\n\t\t        in = new FileInputStream(sourceFile);\n\t\t        out = new FileOutputStream(destFile);\n\t\t        byte[] buffer = new byte[1024];\n\t\t        int length;\n\t\t        while ((length = in.read(buffer)) > 0) {\n\t\t            out.write(buffer, 0, length);\n\t\t        }\n\t\t    } finally {\n\t\t        if (in != null) in.close();\n\t\t        if (out != null) out.close();\n\t\t    }\n\t\t} catch (IOException e) {\n\t\t\tthrow new StfException(\"Failed to copy file. Source:\" + sourceFile.getAbsolutePath() + \" Dest:\" + destFile.getAbsolutePath(), e);\n\t\t}\n\t}\n}"
    },
    "321": {
      "metadata": {
        "chunk_id": "a9a52972a7f12869fadd42ae4dc3716a2a8c9234daaa0e8c411eacfe85e6d7cf",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/util/ProcessBuilderRunner.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n\n/**\n * This is a utility class to help with running processes from Java.\n * As with ProcessBuilder, an instance of this class can be run multiple times.\n *  \n * It does the mundane jobs of consuming the output and error streams.\n * Not consuming these streams can lead to process hangs or missed information about errors.\n * This class also avoids common bugs around the visibility of output captured by the stream handling threads.\n * \n * Note: Holds stdout and stderr output in StringBuilder, so don't use this class if these are going to be too big.  \n */",
        "start_line": 0,
        "end_line": 32,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 270,
        "node_type": null,
        "file_sha": "6885456b0dab3364683475fd780b968938784446",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.566804"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n\n/**\n * This is a utility class to help with running processes from Java.\n * As with ProcessBuilder, an instance of this class can be run multiple times.\n *  \n * It does the mundane jobs of consuming the output and error streams.\n * Not consuming these streams can lead to process hangs or missed information about errors.\n * This class also avoids common bugs around the visibility of output captured by the stream handling threads.\n * \n * Note: Holds stdout and stderr output in StringBuilder, so don't use this class if these are going to be too big.  \n */"
    },
    "322": {
      "metadata": {
        "chunk_id": "36b088eb66a17c59b717dfcc9ac2649274fb97069ef53b99b82fbd8ef4cd9a29",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/util/ProcessBuilderRunner.java",
        "content": "public class ProcessBuilderRunner {\n\tprivate final static long HEARTBEAT = 10*1000;\n    ProcessBuilder pb;\n\t\n    StreamConsumer stdOutConsumer;\n    StreamConsumer stdErrConsumer;\t\n\t\n\n    public ProcessBuilderRunner(ProcessBuilder pb) {\n        this.pb = pb;\n    }\n\n    /**\n     * Starts the process and waits for it's completion.\n     * \n     * @return int which holds the process exit value.\n     * @throws any exceptions encountered during stdout or stderr stream consumption.\n     */\n    public int execute() throws Exception {\n        Process process = pb.start();\n\n        // Start threads to consume the stdout and stderr output\n\t\tstdOutConsumer = new StreamConsumer(\"P4 OUT> \", process.getInputStream());\n\t\tstdErrConsumer = new StreamConsumer(\"P4 ERR> \", process.getErrorStream());\n\t\tstdOutConsumer.start();\n\t\tstdErrConsumer.start();\n\t\t\n\t\t// Wait for the process and the consumers to finish\n\t\tint exitValue = process.waitFor();\n\t\tstdOutConsumer.join();\n\t\tstdErrConsumer.join();\n\t\t\n\t\t// If any of the consumer threads had an exception, then rethrow\n\t\tstdOutConsumer.throwAnyCaughtExceptions();\n\t\tstdErrConsumer.throwAnyCaughtExceptions();\n\t\t\n\t\treturn exitValue;\n    }\n\n       \n    public ArrayList<String> getStdOut() {\n        return stdOutConsumer.getCapturedTextList();\n    }\n\t\n    public String getStdOutText() {\n    \treturn stdOutConsumer.getCapturedText();\n    }\n    \n    public ArrayList<String> getStdErr() {\n        return stdErrConsumer.getCapturedTextList();\n    }\n    \n    public String getStdErrText() {\n        return stdErrConsumer.getCapturedText();\n    }\n\t\n\t\n    /** \n     * Inner class for running thread to consume process output.\n     * Prevents deadlocks and hangs.\n     */\n    private class StreamConsumer extends Thread {\n        private InputStream in;\n        private ArrayList<String> capturedText = new ArrayList<String>();\n        @SuppressWarnings(\"unused\")\n\t\tprivate final String prefix;\n        \n        private volatile Exception caughtException = null;\n        \n        \n        StreamConsumer(String prefix,  InputStream in) {\n            this.in = in;\n            this.prefix = prefix;\n        }\n \n\t\t@Override\n        public void run() {\n\t\t\tlong lastTS = System.currentTimeMillis();\n            BufferedReader br = null;\n            try {\n                br = new BufferedReader(new InputStreamReader(in));\n                String line = null;\n                while ((line = br.readLine()) != null) {\n                \t//System.out.println(prefix+line);\n                    capturedText.add(line);\n                    if (System.currentTimeMillis()-lastTS>HEARTBEAT)\n                    {\n                    \t//System.out.println(prefix+\"Update: Read \"+capturedText.size()+\" lines\");\n                    \tlastTS = System.currentTimeMillis();\n                    }\n                }\n            } catch (IOException e) {\n            \tcaughtException = e;\n            } finally {\n                try {\n                    br.close();\n                } catch (IOException e) {\n                    caughtException = e;\n                }\n            }\n        }\n        \n\t\tpublic synchronized ArrayList<String> getCapturedTextList() {\n\t\t\treturn capturedText;\n\t\t}\n\t\t\n\t\tpublic synchronized String getCapturedText() { \n\t\t\tStringBuilder buff = new StringBuilder();\n\t\t\t\n\t\t\tfor (String line : capturedText) {\n\t\t\t\tbuff.append(line);\n\t\t\t\tbuff.append(\"\\n\");\n\t\t\t}\n\t\t\t\n            return buff.toString();\n        }\n        \n        void throwAnyCaughtExceptions() throws Exception { \n            if (caughtException != null) { \n                throw caughtException;\n            }\n        }\n    }",
        "start_line": 33,
        "end_line": 155,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 715,
        "node_type": null,
        "file_sha": "6885456b0dab3364683475fd780b968938784446",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.566817"
      },
      "text": "public class ProcessBuilderRunner {\n\tprivate final static long HEARTBEAT = 10*1000;\n    ProcessBuilder pb;\n\t\n    StreamConsumer stdOutConsumer;\n    StreamConsumer stdErrConsumer;\t\n\t\n\n    public ProcessBuilderRunner(ProcessBuilder pb) {\n        this.pb = pb;\n    }\n\n    /**\n     * Starts the process and waits for it's completion.\n     * \n     * @return int which holds the process exit value.\n     * @throws any exceptions encountered during stdout or stderr stream consumption.\n     */\n    public int execute() throws Exception {\n        Process process = pb.start();\n\n        // Start threads to consume the stdout and stderr output\n\t\tstdOutConsumer = new StreamConsumer(\"P4 OUT> \", process.getInputStream());\n\t\tstdErrConsumer = new StreamConsumer(\"P4 ERR> \", process.getErrorStream());\n\t\tstdOutConsumer.start();\n\t\tstdErrConsumer.start();\n\t\t\n\t\t// Wait for the process and the consumers to finish\n\t\tint exitValue = process.waitFor();\n\t\tstdOutConsumer.join();\n\t\tstdErrConsumer.join();\n\t\t\n\t\t// If any of the consumer threads had an exception, then rethrow\n\t\tstdOutConsumer.throwAnyCaughtExceptions();\n\t\tstdErrConsumer.throwAnyCaughtExceptions();\n\t\t\n\t\treturn exitValue;\n    }\n\n       \n    public ArrayList<String> getStdOut() {\n        return stdOutConsumer.getCapturedTextList();\n    }\n\t\n    public String getStdOutText() {\n    \treturn stdOutConsumer.getCapturedText();\n    }\n    \n    public ArrayList<String> getStdErr() {\n        return stdErrConsumer.getCapturedTextList();\n    }\n    \n    public String getStdErrText() {\n        return stdErrConsumer.getCapturedText();\n    }\n\t\n\t\n    /** \n     * Inner class for running thread to consume process output.\n     * Prevents deadlocks and hangs.\n     */\n    private class StreamConsumer extends Thread {\n        private InputStream in;\n        private ArrayList<String> capturedText = new ArrayList<String>();\n        @SuppressWarnings(\"unused\")\n\t\tprivate final String prefix;\n        \n        private volatile Exception caughtException = null;\n        \n        \n        StreamConsumer(String prefix,  InputStream in) {\n            this.in = in;\n            this.prefix = prefix;\n        }\n \n\t\t@Override\n        public void run() {\n\t\t\tlong lastTS = System.currentTimeMillis();\n            BufferedReader br = null;\n            try {\n                br = new BufferedReader(new InputStreamReader(in));\n                String line = null;\n                while ((line = br.readLine()) != null) {\n                \t//System.out.println(prefix+line);\n                    capturedText.add(line);\n                    if (System.currentTimeMillis()-lastTS>HEARTBEAT)\n                    {\n                    \t//System.out.println(prefix+\"Update: Read \"+capturedText.size()+\" lines\");\n                    \tlastTS = System.currentTimeMillis();\n                    }\n                }\n            } catch (IOException e) {\n            \tcaughtException = e;\n            } finally {\n                try {\n                    br.close();\n                } catch (IOException e) {\n                    caughtException = e;\n                }\n            }\n        }\n        \n\t\tpublic synchronized ArrayList<String> getCapturedTextList() {\n\t\t\treturn capturedText;\n\t\t}\n\t\t\n\t\tpublic synchronized String getCapturedText() { \n\t\t\tStringBuilder buff = new StringBuilder();\n\t\t\t\n\t\t\tfor (String line : capturedText) {\n\t\t\t\tbuff.append(line);\n\t\t\t\tbuff.append(\"\\n\");\n\t\t\t}\n\t\t\t\n            return buff.toString();\n        }\n        \n        void throwAnyCaughtExceptions() throws Exception { \n            if (caughtException != null) { \n                throw caughtException;\n            }\n        }\n    }"
    },
    "323": {
      "metadata": {
        "chunk_id": "62bcfeb9da178f26e1cc823bb8a04793094bf6ea789829cbd83af035f6dbab80",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/util/ProcessBuilderRunner.java",
        "content": "/**\n     * Utility method for describing a list of command line arguments.\n     * @param commands is the command arguments to be passed to processBuilder.\n     * @return A formatted string describing the commands to be run.\n     */\n\tpublic static String describeCommand(String... commands) {\n        StringBuilder commandDescription = new StringBuilder();\n        for (String commandComponent : commands) { \n            commandDescription.append(commandComponent);\n            commandDescription.append(\" \");\n        }\n\n        return commandDescription.toString();\n\t}\n}",
        "start_line": 156,
        "end_line": 170,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 99,
        "node_type": null,
        "file_sha": "6885456b0dab3364683475fd780b968938784446",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.566820"
      },
      "text": "/**\n     * Utility method for describing a list of command line arguments.\n     * @param commands is the command arguments to be passed to processBuilder.\n     * @return A formatted string describing the commands to be run.\n     */\n\tpublic static String describeCommand(String... commands) {\n        StringBuilder commandDescription = new StringBuilder();\n        for (String commandComponent : commands) { \n            commandDescription.append(commandComponent);\n            commandDescription.append(\" \");\n        }\n\n        return commandDescription.toString();\n\t}\n}"
    },
    "324": {
      "metadata": {
        "chunk_id": "cdae2fe6c74aadcffb33d7484989c1cb8d7d9892323474b37a6664b11ee319f9",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/util/StfDuration.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\n\n/**\n * Java's Duration class is not available in Java6, which STF uses, so this is \n * a mini equivalent implementation.\n * It has the same advantage as the Duration class in that it makes the units \n * for time specification very clear.\n */\npublic class StfDuration {\n\n\tprivate long milliseconds;\n\t\n\tprivate StfDuration(long milliseconds) {\n\t\tthis.milliseconds = milliseconds;\n\t}\n\t\n\tpublic static StfDuration ofMilliseconds(int milliseconds) {\n\t\treturn new StfDuration(milliseconds);\n\t}\n\t\n\tpublic static StfDuration ofSeconds(int seconds) {\n\t\treturn new StfDuration(seconds * 1000);\n\t}\n\t\n\tpublic static StfDuration ofMinutes(int minutes) {\n\t\treturn new StfDuration(minutes * 60 * 1000);\n\t}\n\n\tpublic static StfDuration ofHours(int hours) {\n\t\treturn new StfDuration(hours * 3600 * 1000);\n\t}\n\n\tpublic static StfDuration ofDays(int days) {\n\t\treturn StfDuration.ofHours(days * 24);\n\t}\n\n\tpublic static StfDuration ofHMSandMillis(int hours, int minutes, int seconds, int milliseconds) {\n\t\treturn new StfDuration(hours*3600*1000 + minutes*60*1000 + seconds*1000 + milliseconds);\n\t}\n\t\n\tpublic long getMilliseconds() {\n\t\treturn milliseconds;\n\t}\n\n\tpublic long getSeconds() {\n\t\treturn milliseconds / 1000;\n\t}\n\n\t// convert the duration to a human readable h+m+s+ms value. \n\t// eg, returns values such as '3h', '45m', \"2m30s, \"1h30m\", \"3h0m0s500ms\", etc\n\tpublic String toString() {\n\t\tlong h = milliseconds / (60*60*1000);\n\t\tlong m = (milliseconds / (60*1000)) % 60;\n\t\tlong s = (milliseconds / 1000) % 60;\n\t\tlong ms =  milliseconds % 1000;\n\t\t\n\t\tStringBuilder buff = new StringBuilder();\n\t\tif (h > 0) {\n\t\t\tbuff.append(Long.toString(h) + \"h\");\n\t\t}\n\t\tif (m > 0 || (h > 0 && (s > 0 || ms > 0))) {\n\t\t\tbuff.append(Long.toString(m) + \"m\");\n\t\t}\n\t\tif (s > 0 || ((h > 0 || m > 0) && ms >0)) {\n\t\t\tbuff.append(Long.toString(s) + \"s\");\n\t\t}\n\t\tif (ms > 0) {\n\t\t\tbuff.append(Long.toString(ms) + \"ms\");\n\t\t}\n\t\t\n\t\treturn buff.toString();\n\t}\n}",
        "start_line": 0,
        "end_line": 87,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 687,
        "node_type": null,
        "file_sha": "d03a97a7b76d86395a3e12ac75bcdc31712d1023",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.587757"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\n\n/**\n * Java's Duration class is not available in Java6, which STF uses, so this is \n * a mini equivalent implementation.\n * It has the same advantage as the Duration class in that it makes the units \n * for time specification very clear.\n */\npublic class StfDuration {\n\n\tprivate long milliseconds;\n\t\n\tprivate StfDuration(long milliseconds) {\n\t\tthis.milliseconds = milliseconds;\n\t}\n\t\n\tpublic static StfDuration ofMilliseconds(int milliseconds) {\n\t\treturn new StfDuration(milliseconds);\n\t}\n\t\n\tpublic static StfDuration ofSeconds(int seconds) {\n\t\treturn new StfDuration(seconds * 1000);\n\t}\n\t\n\tpublic static StfDuration ofMinutes(int minutes) {\n\t\treturn new StfDuration(minutes * 60 * 1000);\n\t}\n\n\tpublic static StfDuration ofHours(int hours) {\n\t\treturn new StfDuration(hours * 3600 * 1000);\n\t}\n\n\tpublic static StfDuration ofDays(int days) {\n\t\treturn StfDuration.ofHours(days * 24);\n\t}\n\n\tpublic static StfDuration ofHMSandMillis(int hours, int minutes, int seconds, int milliseconds) {\n\t\treturn new StfDuration(hours*3600*1000 + minutes*60*1000 + seconds*1000 + milliseconds);\n\t}\n\t\n\tpublic long getMilliseconds() {\n\t\treturn milliseconds;\n\t}\n\n\tpublic long getSeconds() {\n\t\treturn milliseconds / 1000;\n\t}\n\n\t// convert the duration to a human readable h+m+s+ms value. \n\t// eg, returns values such as '3h', '45m', \"2m30s, \"1h30m\", \"3h0m0s500ms\", etc\n\tpublic String toString() {\n\t\tlong h = milliseconds / (60*60*1000);\n\t\tlong m = (milliseconds / (60*1000)) % 60;\n\t\tlong s = (milliseconds / 1000) % 60;\n\t\tlong ms =  milliseconds % 1000;\n\t\t\n\t\tStringBuilder buff = new StringBuilder();\n\t\tif (h > 0) {\n\t\t\tbuff.append(Long.toString(h) + \"h\");\n\t\t}\n\t\tif (m > 0 || (h > 0 && (s > 0 || ms > 0))) {\n\t\t\tbuff.append(Long.toString(m) + \"m\");\n\t\t}\n\t\tif (s > 0 || ((h > 0 || m > 0) && ms >0)) {\n\t\t\tbuff.append(Long.toString(s) + \"s\");\n\t\t}\n\t\tif (ms > 0) {\n\t\t\tbuff.append(Long.toString(ms) + \"ms\");\n\t\t}\n\t\t\n\t\treturn buff.toString();\n\t}\n}"
    },
    "325": {
      "metadata": {
        "chunk_id": "5b3c0b067b92a2c5b69392f0b3ab8c64f47d2b5f46bc12c81c1121f3fa7c8d2a",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/util/StringSplitter.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\nimport java.util.ArrayList;\n\n\n/**\n * This is a utility class which splits a string into parts.\n * It splits on spaces except if the spaces are inside double quotes.\n */\npublic class StringSplitter {\n\tprivate enum SplitState { NORMAL, INQUOTE }; \n\n\t/**\n\t * This method takes an argument string and splits it into individual arguments.\n\t * It takes care not to split arguments inside a quoted part. \n\t * \n\t * So '-Xjit:counts=\"- - - - - - 1 1 1 1000 - \" -Xgcpolicy:optthruput' would not \n\t * be split inside the quoted section, and return only 2 values.\n\t * \n\t * @param argString is the full string containing multiple arguments.\n\t * @return an ArrayList of strings containing a single argument.\n\t */\n\tpublic static ArrayList<String> splitArguments(String argString) {\n\t\targString = argString.trim();\n\t\t\n\t\tArrayList<String> parts = new ArrayList<String>();\n\t\t\n\t\tStringBuilder output = new StringBuilder();\n\t\tSplitState state = SplitState.NORMAL;\n\t\t\n\t\tfor (int i=0; i<argString.length(); i++) {\n\t\t\tchar c = argString.charAt(i);\n\t\t\t\n\t\t\tif (state == SplitState.NORMAL && c == ' ') {\n\t\t\t\t// We have hit a space. Save the output found until this point.\n\t\t\t\tparts.add(output.toString());\n\t\t\t\toutput.setLength(0);\n\t\t\t} else if (state == SplitState.NORMAL && c == '\\\"') {\n\t\t\t\t// Start of quoted section. Get ready to ignore spaces\n\t\t\t\toutput.append(c);\n\t\t\t\tstate = SplitState.INQUOTE;\n\t\t\t} else if (state == SplitState.INQUOTE && c == '\\\"') {\n\t\t\t\t// End of quoted section\n\t\t\t\toutput.append(c);\n\t\t\t\tstate = SplitState.NORMAL;\n\t\t\t} else {\n\t\t\t\t// Save the ordinary character\n\t\t\t\toutput.append(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Tidy up any in-progress argument\n\t\tif (output.length() > 0) {\n\t\t\tparts.add(output.toString());\n\t\t}\n\t\t\n\t\treturn parts;\t\t\n\t}\n}",
        "start_line": 0,
        "end_line": 72,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 575,
        "node_type": null,
        "file_sha": "3d94344c2227c272f4375d22dc10a29838f1d0a8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.605433"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\nimport java.util.ArrayList;\n\n\n/**\n * This is a utility class which splits a string into parts.\n * It splits on spaces except if the spaces are inside double quotes.\n */\npublic class StringSplitter {\n\tprivate enum SplitState { NORMAL, INQUOTE }; \n\n\t/**\n\t * This method takes an argument string and splits it into individual arguments.\n\t * It takes care not to split arguments inside a quoted part. \n\t * \n\t * So '-Xjit:counts=\"- - - - - - 1 1 1 1000 - \" -Xgcpolicy:optthruput' would not \n\t * be split inside the quoted section, and return only 2 values.\n\t * \n\t * @param argString is the full string containing multiple arguments.\n\t * @return an ArrayList of strings containing a single argument.\n\t */\n\tpublic static ArrayList<String> splitArguments(String argString) {\n\t\targString = argString.trim();\n\t\t\n\t\tArrayList<String> parts = new ArrayList<String>();\n\t\t\n\t\tStringBuilder output = new StringBuilder();\n\t\tSplitState state = SplitState.NORMAL;\n\t\t\n\t\tfor (int i=0; i<argString.length(); i++) {\n\t\t\tchar c = argString.charAt(i);\n\t\t\t\n\t\t\tif (state == SplitState.NORMAL && c == ' ') {\n\t\t\t\t// We have hit a space. Save the output found until this point.\n\t\t\t\tparts.add(output.toString());\n\t\t\t\toutput.setLength(0);\n\t\t\t} else if (state == SplitState.NORMAL && c == '\\\"') {\n\t\t\t\t// Start of quoted section. Get ready to ignore spaces\n\t\t\t\toutput.append(c);\n\t\t\t\tstate = SplitState.INQUOTE;\n\t\t\t} else if (state == SplitState.INQUOTE && c == '\\\"') {\n\t\t\t\t// End of quoted section\n\t\t\t\toutput.append(c);\n\t\t\t\tstate = SplitState.NORMAL;\n\t\t\t} else {\n\t\t\t\t// Save the ordinary character\n\t\t\t\toutput.append(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Tidy up any in-progress argument\n\t\tif (output.length() > 0) {\n\t\t\tparts.add(output.toString());\n\t\t}\n\t\t\n\t\treturn parts;\t\t\n\t}\n}"
    },
    "326": {
      "metadata": {
        "chunk_id": "ca626a81521b49e86e4c44ffa6304a3ed53dc996d28e97d91917b720a2160626",
        "file_path": "stf.core/src/stf.core/net/adoptopenjdk/stf/util/TimeParser.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This utility class converts human readable time descriptions into seconds.\n * \n * Supported values are:\n *   'h' for hours\n *   'm' for minutes\n *   's' for seconds\n *   'ms' for milliseconds\n *   \n * For example '30s', '2m' or '6h'.\n * Values can be combined such as '1h15m' or '6h30m10s250ms'.\n */\npublic class TimeParser {\n\t/**\n\t * Converts a human friendly time value into seconds.\n\t * \n\t * @param timeSpecification is a string containing the hours, minutes and seconds. eg '1h30m'. \n\t * @return a StfDuration object representing the time from the timeSpecification argument. \n\t * @throws StfException if the timeSpecification string is not in the expected format.\n\t */\n\tpublic static StfDuration parseTimeSpecification(String timeSpecification) throws StfException {\n\t\tif (timeSpecification == null || timeSpecification.isEmpty()) { \n\t\t\tthrow new StfException(\"Time specification must be non-zero\");\n\t\t}\n\t\ttimeSpecification = timeSpecification.trim();\n\t\t\n\t\tint hours   = 0;\n\t\tint minutes = 0;\n\t\tint seconds = 0;\n\t\tint millis  = 0;\n\t\t\n\t\tint i = 0;\n\t\twhile (i < timeSpecification.length()) {\n\t\t\t// Parse the next time component. eg '30m'\n\t\t\t// Firstly, work out the character positions for the numeric part\n\t\t\tint digitStart = i;\n\t\t\twhile (i < timeSpecification.length() && Character.isDigit(timeSpecification.charAt(i))) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tint digitEnd = i;\n\t\t\t\n\t\t\t// Parse the value for the numeric part\n\t\t\tif (digitStart == digitEnd) {\n\t\t\t\tthrow new StfException(\"Failed to find numeric value at offset \" + digitStart + \" of time specification: \" + timeSpecification);\n\t\t\t}\n\t\t\tint value = Integer.parseInt(timeSpecification.substring(digitStart, digitEnd));\n\t\t\t\n\t\t\t// Extract the unit string. Should be one of 'h', 'm', 's' or 'ms'\n\t\t\tif (i >= timeSpecification.length()) {\n\t\t\t\tthrow new StfException(\"No time unit specified at offset \" + i + \" of time specification: \" + timeSpecification);\n\t\t\t}\n\t\t\tchar unitChar1 = timeSpecification.charAt(i++);\n\t\t\tchar unitChar2 = ' ';\n\t\t\tif (i < timeSpecification.length() && Character.isLetter(timeSpecification.charAt(i))) {\n\t\t\t    // Looks like the unit type has a 2nd character.\n\t\t\t\tunitChar2 = timeSpecification.charAt(i++);\n\t\t\t}\n\t\t\t\n\t\t\tif (unitChar1 == 'h' && unitChar2 == ' ') {\n\t\t\t\thours += value;\n\t\t\t} else if (unitChar1 == 'm' && unitChar2 == ' ') {\n\t\t\t\tminutes += value;\n\t\t\t} else if (unitChar1 == 's' && unitChar2 == ' ') {\n\t\t\t\tseconds += value;\n\t\t\t} else if (unitChar1 == 'm' && unitChar2 == 's') {\n\t\t\t\tmillis += value;\n\t\t\t} else { \n\t\t\t\tString timeType = \" \" + unitChar1 + unitChar2;\n\t\t\t\tthrow new StfException(\"Unknown time unit '\" + timeType.trim() + \"' in time specification: '\" + timeSpecification + \"'. Allowable units are 'h', 'm', 's' or 'ms'\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Build duration of the specified value\n\t\tStfDuration duration = StfDuration.ofHMSandMillis(hours, minutes, seconds, millis);\n\t\treturn duration;\n\t}\n}",
        "start_line": 0,
        "end_line": 95,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 920,
        "node_type": null,
        "file_sha": "9a3f119f3545d89db7b94edddba6781d7c6773c8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.624587"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.util;\n\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This utility class converts human readable time descriptions into seconds.\n * \n * Supported values are:\n *   'h' for hours\n *   'm' for minutes\n *   's' for seconds\n *   'ms' for milliseconds\n *   \n * For example '30s', '2m' or '6h'.\n * Values can be combined such as '1h15m' or '6h30m10s250ms'.\n */\npublic class TimeParser {\n\t/**\n\t * Converts a human friendly time value into seconds.\n\t * \n\t * @param timeSpecification is a string containing the hours, minutes and seconds. eg '1h30m'. \n\t * @return a StfDuration object representing the time from the timeSpecification argument. \n\t * @throws StfException if the timeSpecification string is not in the expected format.\n\t */\n\tpublic static StfDuration parseTimeSpecification(String timeSpecification) throws StfException {\n\t\tif (timeSpecification == null || timeSpecification.isEmpty()) { \n\t\t\tthrow new StfException(\"Time specification must be non-zero\");\n\t\t}\n\t\ttimeSpecification = timeSpecification.trim();\n\t\t\n\t\tint hours   = 0;\n\t\tint minutes = 0;\n\t\tint seconds = 0;\n\t\tint millis  = 0;\n\t\t\n\t\tint i = 0;\n\t\twhile (i < timeSpecification.length()) {\n\t\t\t// Parse the next time component. eg '30m'\n\t\t\t// Firstly, work out the character positions for the numeric part\n\t\t\tint digitStart = i;\n\t\t\twhile (i < timeSpecification.length() && Character.isDigit(timeSpecification.charAt(i))) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tint digitEnd = i;\n\t\t\t\n\t\t\t// Parse the value for the numeric part\n\t\t\tif (digitStart == digitEnd) {\n\t\t\t\tthrow new StfException(\"Failed to find numeric value at offset \" + digitStart + \" of time specification: \" + timeSpecification);\n\t\t\t}\n\t\t\tint value = Integer.parseInt(timeSpecification.substring(digitStart, digitEnd));\n\t\t\t\n\t\t\t// Extract the unit string. Should be one of 'h', 'm', 's' or 'ms'\n\t\t\tif (i >= timeSpecification.length()) {\n\t\t\t\tthrow new StfException(\"No time unit specified at offset \" + i + \" of time specification: \" + timeSpecification);\n\t\t\t}\n\t\t\tchar unitChar1 = timeSpecification.charAt(i++);\n\t\t\tchar unitChar2 = ' ';\n\t\t\tif (i < timeSpecification.length() && Character.isLetter(timeSpecification.charAt(i))) {\n\t\t\t    // Looks like the unit type has a 2nd character.\n\t\t\t\tunitChar2 = timeSpecification.charAt(i++);\n\t\t\t}\n\t\t\t\n\t\t\tif (unitChar1 == 'h' && unitChar2 == ' ') {\n\t\t\t\thours += value;\n\t\t\t} else if (unitChar1 == 'm' && unitChar2 == ' ') {\n\t\t\t\tminutes += value;\n\t\t\t} else if (unitChar1 == 's' && unitChar2 == ' ') {\n\t\t\t\tseconds += value;\n\t\t\t} else if (unitChar1 == 'm' && unitChar2 == 's') {\n\t\t\t\tmillis += value;\n\t\t\t} else { \n\t\t\t\tString timeType = \" \" + unitChar1 + unitChar2;\n\t\t\t\tthrow new StfException(\"Unknown time unit '\" + timeType.trim() + \"' in time specification: '\" + timeSpecification + \"'. Allowable units are 'h', 'm', 's' or 'ms'\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Build duration of the specified value\n\t\tStfDuration duration = StfDuration.ofHMSandMillis(hours, minutes, seconds, millis);\n\t\treturn duration;\n\t}\n}"
    },
    "327": {
      "metadata": {
        "chunk_id": "da0433097393abfc053ec48e7eee3d0b1c7e911657eaca63c179486085f093b3",
        "file_path": "stf.core/test/stf.core/net/adoptopenjdk/stf/TestArgumentProcessing.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport java.util.ArrayList;\n\nimport org.junit.Test;\n\nimport junit.framework.TestCase;\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.LayeredProperties;\nimport net.adoptopenjdk.stf.environment.properties.OrderedProperties;\nimport net.adoptopenjdk.stf.environment.properties.Argument.Required;\n\n\n/**\n * This test case verifies that property substitution of '${x}' values is working.\n */",
        "start_line": 0,
        "end_line": 31,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 241,
        "node_type": null,
        "file_sha": "9ef6572afe7d4972e6e230cfe548fc391e2bb9cb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.643431"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport java.util.ArrayList;\n\nimport org.junit.Test;\n\nimport junit.framework.TestCase;\nimport net.adoptopenjdk.stf.StfError;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.LayeredProperties;\nimport net.adoptopenjdk.stf.environment.properties.OrderedProperties;\nimport net.adoptopenjdk.stf.environment.properties.Argument.Required;\n\n\n/**\n * This test case verifies that property substitution of '${x}' values is working.\n */"
    },
    "328": {
      "metadata": {
        "chunk_id": "19bcaa403e90727d0a93097ef52d24e896ec26368370dc63ad784ecbb47f1364",
        "file_path": "stf.core/test/stf.core/net/adoptopenjdk/stf/TestArgumentProcessing.java",
        "content": "public class TestArgumentProcessing extends TestCase {\n\tprivate static Argument ARG_STF_BIN_DIR = new Argument(\"stf\", \"stf-bin-dir\", false, Required.OPTIONAL);\n\n\t\n\t@Test \n\tpublic void testOverridenProperty() throws StfException {\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"dry-run=false\", \n\t\t\t\t\t\t\"stf-bin-dir=/usr/home/bin\",  // new value\n\t\t\t\t\t\t\"x=y\" \n\t\t\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"p1=x\",\n\t\t\t\t\t\t\"p2=y\",\n\t\t\t\t\t\t\"stf-bin-dir=!!!!!\"   // old value\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\n\t\tassertEquals(\"/usr/home/bin\", props.getProperty(ARG_STF_BIN_DIR.getName()));\n\t}\n\t\n\t@Test \n\tpublic void testEnvironmentVariableReplacement() throws StfException {\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"dry-run=false\", \n\t\t\t\t\t\t\"stf-bin-dir=/home/${JAVA_HOME}/bin\",  // JAVA_HOME is not a sensible value for this. But it is available on all platforms\n\t\t\t\t\t\t\"x=y\" \n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\n\t\tassertEquals(\"/home/\" + System.getenv(\"JAVA_HOME\") + \"/bin\", props.getProperty(ARG_STF_BIN_DIR.getName()));\n\t}\n\t\n\t@Test \n\tpublic void testPropertyReplacement() throws StfException {\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"stf-bin-dir=/home/${user-name}/bin/${process-name}\",\n\t\t\t\t\t\t\"user-name=fred\",\n\t\t\t\t\t\t\"x=y\"\n\t\t\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"process-name=search.sh\",\n\t\t\t\t\t\t\"p1=x\",\n\t\t\t\t\t\t\"p2=y\",\n\t\t\t\t\t\t\"stf-bin-dir=!!!!!\"\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\n\t\tassertEquals(\"/home/fred/bin/search.sh\", props.getProperty(ARG_STF_BIN_DIR.getName()));\n\t}\n\t\n\t\n\t@Test \n\tpublic void testPropertyReplacementIndirect() throws StfException {\n\t\tString userNameVariable;\n\t\tif (System.getProperty(\"os.name\").equals(\"Linux\")) {\n\t\t\tuserNameVariable = \"USER\";\n\t\t} else {\n\t\t\tuserNameVariable = \"USERNAME\";\n\t\t}\n\t\t\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"user-name=${first-name}.${last-name}\",\n\t\t\t\t\t\t\"process-name=search.sh\",\n\t\t\t\t\t\t\"stf-bin-dir=/home/${user-name}/bin/${process-name}\",\n\t\t\t\t\t\t\"x=y\"\n\t\t\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"p1=x\",\n\t\t\t\t\t\t\"p2=y\",\n\t\t\t\t\t\t\"first-name=fred\",\n\t\t\t\t\t\t\"last-name=${\" + userNameVariable + \"}\",  // Pulls value from env.variable\n\t\t\t\t\t\t\"stf-bin-dir=!!!!!\"\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\n\t\tString expected = \"/home/fred.\" + System.getenv(userNameVariable) + \"/bin/search.sh\";\n\t\tString actual = props.getProperty(ARG_STF_BIN_DIR.getName());\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t\n\t@Test \n\tpublic void testPropertyReplacementIndirectFails() throws StfException {\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"user-name=${first-name}${last-name}\",\n\t\t\t\t\t\t\"process-name=search.sh\",\n\t\t\t\t\t\t\"stf-bin-dir=/home/${user-name}/bin/${process-name}\",\n\t\t\t\t\t\t\"x=y\"\n\t\t\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"p1=x\",\n\t\t\t\t\t\t\"p2=y\",\n\t\t\t\t\t\t\"first-name=fred\",\n\t\t\t\t\t\t\"last-name=${login-name}\",  // No value specified for login-name !!\n\t\t\t\t\t\t\"stf-bin-dir=!!!!!\"\n\t\t\t\t\t\t}\n\t\t\t\t);\n\n\t\tboolean gotException = false;\n\t\ttry {\n\t\t    props.getProperty(ARG_STF_BIN_DIR.getName());\n\t\t    fail();\n\t\t} catch (StfError e) {\n\t\t\tgotException = true;\n\t\t\tString expectedError = \"Unable to succesfully build value for property 'stf-bin-dir'. There is no enviroment variable or property defined for 'login-name'. Chain followed is: stf-bin-dir -> user-name -> last-name -> login-name\";\n\t\t\tassertEquals(expectedError, e.getMessage());\n\t\t}\n\t\t\n\t\tassertTrue(gotException);\n\t}",
        "start_line": 32,
        "end_line": 147,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 891,
        "node_type": null,
        "file_sha": "9ef6572afe7d4972e6e230cfe548fc391e2bb9cb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.643440"
      },
      "text": "public class TestArgumentProcessing extends TestCase {\n\tprivate static Argument ARG_STF_BIN_DIR = new Argument(\"stf\", \"stf-bin-dir\", false, Required.OPTIONAL);\n\n\t\n\t@Test \n\tpublic void testOverridenProperty() throws StfException {\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"dry-run=false\", \n\t\t\t\t\t\t\"stf-bin-dir=/usr/home/bin\",  // new value\n\t\t\t\t\t\t\"x=y\" \n\t\t\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"p1=x\",\n\t\t\t\t\t\t\"p2=y\",\n\t\t\t\t\t\t\"stf-bin-dir=!!!!!\"   // old value\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\n\t\tassertEquals(\"/usr/home/bin\", props.getProperty(ARG_STF_BIN_DIR.getName()));\n\t}\n\t\n\t@Test \n\tpublic void testEnvironmentVariableReplacement() throws StfException {\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"dry-run=false\", \n\t\t\t\t\t\t\"stf-bin-dir=/home/${JAVA_HOME}/bin\",  // JAVA_HOME is not a sensible value for this. But it is available on all platforms\n\t\t\t\t\t\t\"x=y\" \n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\n\t\tassertEquals(\"/home/\" + System.getenv(\"JAVA_HOME\") + \"/bin\", props.getProperty(ARG_STF_BIN_DIR.getName()));\n\t}\n\t\n\t@Test \n\tpublic void testPropertyReplacement() throws StfException {\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"stf-bin-dir=/home/${user-name}/bin/${process-name}\",\n\t\t\t\t\t\t\"user-name=fred\",\n\t\t\t\t\t\t\"x=y\"\n\t\t\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"process-name=search.sh\",\n\t\t\t\t\t\t\"p1=x\",\n\t\t\t\t\t\t\"p2=y\",\n\t\t\t\t\t\t\"stf-bin-dir=!!!!!\"\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\n\t\tassertEquals(\"/home/fred/bin/search.sh\", props.getProperty(ARG_STF_BIN_DIR.getName()));\n\t}\n\t\n\t\n\t@Test \n\tpublic void testPropertyReplacementIndirect() throws StfException {\n\t\tString userNameVariable;\n\t\tif (System.getProperty(\"os.name\").equals(\"Linux\")) {\n\t\t\tuserNameVariable = \"USER\";\n\t\t} else {\n\t\t\tuserNameVariable = \"USERNAME\";\n\t\t}\n\t\t\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"user-name=${first-name}.${last-name}\",\n\t\t\t\t\t\t\"process-name=search.sh\",\n\t\t\t\t\t\t\"stf-bin-dir=/home/${user-name}/bin/${process-name}\",\n\t\t\t\t\t\t\"x=y\"\n\t\t\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"p1=x\",\n\t\t\t\t\t\t\"p2=y\",\n\t\t\t\t\t\t\"first-name=fred\",\n\t\t\t\t\t\t\"last-name=${\" + userNameVariable + \"}\",  // Pulls value from env.variable\n\t\t\t\t\t\t\"stf-bin-dir=!!!!!\"\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\n\t\tString expected = \"/home/fred.\" + System.getenv(userNameVariable) + \"/bin/search.sh\";\n\t\tString actual = props.getProperty(ARG_STF_BIN_DIR.getName());\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t\n\t@Test \n\tpublic void testPropertyReplacementIndirectFails() throws StfException {\n\t\tLayeredProperties props = createProperties(\n\t\t\t\tnew String[] { \n\t\t\t\t\t\t\"user-name=${first-name}${last-name}\",\n\t\t\t\t\t\t\"process-name=search.sh\",\n\t\t\t\t\t\t\"stf-bin-dir=/home/${user-name}/bin/${process-name}\",\n\t\t\t\t\t\t\"x=y\"\n\t\t\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"p1=x\",\n\t\t\t\t\t\t\"p2=y\",\n\t\t\t\t\t\t\"first-name=fred\",\n\t\t\t\t\t\t\"last-name=${login-name}\",  // No value specified for login-name !!\n\t\t\t\t\t\t\"stf-bin-dir=!!!!!\"\n\t\t\t\t\t\t}\n\t\t\t\t);\n\n\t\tboolean gotException = false;\n\t\ttry {\n\t\t    props.getProperty(ARG_STF_BIN_DIR.getName());\n\t\t    fail();\n\t\t} catch (StfError e) {\n\t\t\tgotException = true;\n\t\t\tString expectedError = \"Unable to succesfully build value for property 'stf-bin-dir'. There is no enviroment variable or property defined for 'login-name'. Chain followed is: stf-bin-dir -> user-name -> last-name -> login-name\";\n\t\t\tassertEquals(expectedError, e.getMessage());\n\t\t}\n\t\t\n\t\tassertTrue(gotException);\n\t}"
    },
    "329": {
      "metadata": {
        "chunk_id": "76d29b8f65e41dfef24a4b3e5791e01a64b38938bfa32df6d6a1052114797e6c",
        "file_path": "stf.core/test/stf.core/net/adoptopenjdk/stf/TestArgumentProcessing.java",
        "content": "boolean gotException = false;\n\t\ttry {\n\t\t    props.getProperty(ARG_STF_BIN_DIR.getName());\n\t\t    fail();\n\t\t} catch (StfError e) {\n\t\t\tgotException = true;\n\t\t\tString expectedError = \"Unable to succesfully build value for property 'stf-bin-dir'. There is no enviroment variable or property defined for 'login-name'. Chain followed is: stf-bin-dir -> user-name -> last-name -> login-name\";\n\t\t\tassertEquals(expectedError, e.getMessage());\n\t\t}\n\t\t\n\t\tassertTrue(gotException);\n\t}\n\t\n\n\tprivate LayeredProperties createProperties(String[]... layers) {\n\t\tArrayList<OrderedProperties> properties = new ArrayList<OrderedProperties>();\n\t\t\n\t\tfor (String[] props : layers) {\n\t\t\t//System.out.println(\"Layer is: \" + Arrays.toString(props));\n\t\t\tOrderedProperties orderedProperties = new OrderedProperties();\n\t\t\tproperties.add(orderedProperties);\n\t\t\t\n\t\t\tfor (String nameValuePair : props) {\n\t\t\t\tnameValuePair = nameValuePair.trim();\n\t\t\t\tint equalsAt = nameValuePair.indexOf(\"=\");\n\t\t\t\tString name = nameValuePair.substring(0, equalsAt);\n\t\t\t\tString value = nameValuePair.substring(equalsAt+1);\n\t\t\t\t//System.out.println(\"  '\" + name + \"' = '\" + value + \"'\");\n\t\t\t\torderedProperties.put(name, value);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new LayeredProperties(properties, new ArrayList<Argument>());\n\t}\n}",
        "start_line": 148,
        "end_line": 182,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 290,
        "node_type": null,
        "file_sha": "9ef6572afe7d4972e6e230cfe548fc391e2bb9cb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.643444"
      },
      "text": "boolean gotException = false;\n\t\ttry {\n\t\t    props.getProperty(ARG_STF_BIN_DIR.getName());\n\t\t    fail();\n\t\t} catch (StfError e) {\n\t\t\tgotException = true;\n\t\t\tString expectedError = \"Unable to succesfully build value for property 'stf-bin-dir'. There is no enviroment variable or property defined for 'login-name'. Chain followed is: stf-bin-dir -> user-name -> last-name -> login-name\";\n\t\t\tassertEquals(expectedError, e.getMessage());\n\t\t}\n\t\t\n\t\tassertTrue(gotException);\n\t}\n\t\n\n\tprivate LayeredProperties createProperties(String[]... layers) {\n\t\tArrayList<OrderedProperties> properties = new ArrayList<OrderedProperties>();\n\t\t\n\t\tfor (String[] props : layers) {\n\t\t\t//System.out.println(\"Layer is: \" + Arrays.toString(props));\n\t\t\tOrderedProperties orderedProperties = new OrderedProperties();\n\t\t\tproperties.add(orderedProperties);\n\t\t\t\n\t\t\tfor (String nameValuePair : props) {\n\t\t\t\tnameValuePair = nameValuePair.trim();\n\t\t\t\tint equalsAt = nameValuePair.indexOf(\"=\");\n\t\t\t\tString name = nameValuePair.substring(0, equalsAt);\n\t\t\t\tString value = nameValuePair.substring(equalsAt+1);\n\t\t\t\t//System.out.println(\"  '\" + name + \"' = '\" + value + \"'\");\n\t\t\t\torderedProperties.put(name, value);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new LayeredProperties(properties, new ArrayList<Argument>());\n\t}\n}"
    },
    "330": {
      "metadata": {
        "chunk_id": "835a49c550d197e8150a4d9e2de202cc25d50de68f3ac7dfb080aa37494f81c9",
        "file_path": "stf.core/test/stf.core/net/adoptopenjdk/stf/results/TestResultsProcessor.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport org.junit.Test;\n\nimport junit.framework.TestCase;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.results.ResultsFilter;\nimport net.adoptopenjdk.stf.results.ResultsParser;\nimport net.adoptopenjdk.stf.results.TestStatus;\n\n/**\n * This class has test cases for verifying that the results processing code is \n * working as expected.\n * \n * i.e. given a list of test results and a list of filtering rules we verify that \n * some of the failing tests are correctly recategorised as filtered passes.\n */",
        "start_line": 0,
        "end_line": 33,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 259,
        "node_type": null,
        "file_sha": "34f9ec127d1048017a92b72e620fe70377986f95",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.663024"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.results;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport org.junit.Test;\n\nimport junit.framework.TestCase;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.results.ResultsFilter;\nimport net.adoptopenjdk.stf.results.ResultsParser;\nimport net.adoptopenjdk.stf.results.TestStatus;\n\n/**\n * This class has test cases for verifying that the results processing code is \n * working as expected.\n * \n * i.e. given a list of test results and a list of filtering rules we verify that \n * some of the failing tests are correctly recategorised as filtered passes.\n */"
    },
    "331": {
      "metadata": {
        "chunk_id": "04c4f5b736ede0233667161a9d191f5a3065fe5cf8cb2ba7729466903806a32a",
        "file_path": "stf.core/test/stf.core/net/adoptopenjdk/stf/results/TestResultsProcessor.java",
        "content": "public class TestResultsProcessor extends TestCase {\n\t/**\n\t * This test verifies that a run with all tests passing (and a failure rule) \n\t * reports that there were no test failures.\n\t */\n\t@Test \n\tpublic void testAllPassed() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=pass class=ArgumentsTests test=test01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=ArgumentsTests test=test02\";\n\n\t\tString filterText = \n\t\t\t  \"suite=jdtuirefactoring platform=linux_86-64 result=fail class=ArgumentsTests test=testMem1\";\n\n\t\t\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tassertEquals(filter.toString(), 2, filter.getPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFilteredPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\t}\n\n\n\t/**\n\t * This test verifies that a run with a mix of pass and fail results can have \n\t * some filters applied, so that there are no failure results remaining.  \n\t */\n\t@Test \n\tpublic void testFullyFiltered() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test01 message=\\\"expected:<51.0> but was:<5.0>\\\"\\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test02 exception=NullPointerException \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem03\";\n\n\t\tString filterText = \n\t\t\t  \"class=ArgumentsTests \\n\"\n\t\t\t+ \"class=MemTests test=testMem01\";\n\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tverifyResults(filter.getPasses(), \n\t\t\t\"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02\",\n\t\t\t\"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem03\");\n\t\tverifyResults(filter.getFilteredPasses(),\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test01 message=\\\"expected:<51.0> but was:<5.0>\\\"\",\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test02 exception=NullPointerException\",\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01\");\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\t}\n\n\t\n\t/**\n\t * This test verifies that the filters file will be able to run with real world \n\t * formatting, such as comment lines, blank lines and extra spacing.  \n\t */\n\t@Test \n\tpublic void testExpectedWithFormatting() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test01 message=\\\"expected:<51.0> but was:<5.0>\\\"\\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test02 exception=NullPointerException \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem03\";\n\n\t\tString filterText = \n\t\t\t  \"class=ArgumentsTests \\n\"\n\t\t\t+ \"\\n\"  // empty line\n\t\t\t+ \"# This is a random comment \\n\"\n\t\t\t+ \"\\t    class=MemTests\\t \\t     test=testMem01       \";   // Note the extra white space",
        "start_line": 34,
        "end_line": 108,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 987,
        "node_type": null,
        "file_sha": "34f9ec127d1048017a92b72e620fe70377986f95",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.663030"
      },
      "text": "public class TestResultsProcessor extends TestCase {\n\t/**\n\t * This test verifies that a run with all tests passing (and a failure rule) \n\t * reports that there were no test failures.\n\t */\n\t@Test \n\tpublic void testAllPassed() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=pass class=ArgumentsTests test=test01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=ArgumentsTests test=test02\";\n\n\t\tString filterText = \n\t\t\t  \"suite=jdtuirefactoring platform=linux_86-64 result=fail class=ArgumentsTests test=testMem1\";\n\n\t\t\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tassertEquals(filter.toString(), 2, filter.getPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFilteredPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\t}\n\n\n\t/**\n\t * This test verifies that a run with a mix of pass and fail results can have \n\t * some filters applied, so that there are no failure results remaining.  \n\t */\n\t@Test \n\tpublic void testFullyFiltered() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test01 message=\\\"expected:<51.0> but was:<5.0>\\\"\\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test02 exception=NullPointerException \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem03\";\n\n\t\tString filterText = \n\t\t\t  \"class=ArgumentsTests \\n\"\n\t\t\t+ \"class=MemTests test=testMem01\";\n\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tverifyResults(filter.getPasses(), \n\t\t\t\"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02\",\n\t\t\t\"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem03\");\n\t\tverifyResults(filter.getFilteredPasses(),\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test01 message=\\\"expected:<51.0> but was:<5.0>\\\"\",\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test02 exception=NullPointerException\",\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01\");\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\t}\n\n\t\n\t/**\n\t * This test verifies that the filters file will be able to run with real world \n\t * formatting, such as comment lines, blank lines and extra spacing.  \n\t */\n\t@Test \n\tpublic void testExpectedWithFormatting() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test01 message=\\\"expected:<51.0> but was:<5.0>\\\"\\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test02 exception=NullPointerException \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem03\";\n\n\t\tString filterText = \n\t\t\t  \"class=ArgumentsTests \\n\"\n\t\t\t+ \"\\n\"  // empty line\n\t\t\t+ \"# This is a random comment \\n\"\n\t\t\t+ \"\\t    class=MemTests\\t \\t     test=testMem01       \";   // Note the extra white space"
    },
    "332": {
      "metadata": {
        "chunk_id": "8fab50bb1a435bbf996ffca7a2c438d0df7acad3aaa2b830fd430514c092c7a1",
        "file_path": "stf.core/test/stf.core/net/adoptopenjdk/stf/results/TestResultsProcessor.java",
        "content": "String filterText = \n\t\t\t  \"class=ArgumentsTests \\n\"\n\t\t\t+ \"\\n\"  // empty line\n\t\t\t+ \"# This is a random comment \\n\"\n\t\t\t+ \"\\t    class=MemTests\\t \\t     test=testMem01       \";   // Note the extra white space\n\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tverifyResults(filter.getPasses(), \n\t\t\t\"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02\",\n\t\t\t\"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem03\");\n\t\tverifyResults(filter.getFilteredPasses(),\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test01 message=\\\"expected:<51.0> but was:<5.0>\\\"\",\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test02 exception=NullPointerException\",\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01\");\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\t}\n\n\n\t/**\n\t * This test verifies that a run with a mix of pass and fail results can have \n\t * some filters applied, so that there are no failure results remaining.  \n\t */\n\t@Test \n\tpublic void testIntermittentFailure() throws StfException {\n\t\tString passingRunText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02\";\n\n\t\tString failingRunText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02\";\n\n\t\tString filterText = \n\t\t\t  \"class=MemTests test=testMem01\";\n\n\t\t// Verify that the passing run has passed successfully\n\t\tArrayList<TestStatus> results = new ResultsParser(passingRunText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\n\t\tassertEquals(filter.toString(), 2, filter.getPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFilteredPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\n\t\t\n\t\t// Verify that the run with a failure also works\n\t\tresults = new ResultsParser(failingRunText).parse();\n\t\tfilter = new ResultsFilter(results, filters);\n\n\t\tassertEquals(filter.toString(), 1, filter.getPasses().size());\n\t\tassertEquals(filter.toString(), 1, filter.getFilteredPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\t}\n\n\t\n\t/**\n\t * Processes some run results with all possible outcomes, including a faling test which \n\t * is not filtered out, leading to an actual failure.  \n\t */\n\t@Test \n\tpublic void testMandatoryFailure() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem02 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem03\";\n\n\t\tString filterText = \"test=testMem02\";\n\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tverifyResults(filter.getPasses(),         \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem01\");\n\t\tverifyResults(filter.getFilteredPasses(), \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem02\");\n\t\tverifyResults(filter.getFailures(),       \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem03\");\n\t}",
        "start_line": 109,
        "end_line": 187,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 966,
        "node_type": null,
        "file_sha": "34f9ec127d1048017a92b72e620fe70377986f95",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.663033"
      },
      "text": "String filterText = \n\t\t\t  \"class=ArgumentsTests \\n\"\n\t\t\t+ \"\\n\"  // empty line\n\t\t\t+ \"# This is a random comment \\n\"\n\t\t\t+ \"\\t    class=MemTests\\t \\t     test=testMem01       \";   // Note the extra white space\n\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tverifyResults(filter.getPasses(), \n\t\t\t\"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02\",\n\t\t\t\"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem03\");\n\t\tverifyResults(filter.getFilteredPasses(),\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test01 message=\\\"expected:<51.0> but was:<5.0>\\\"\",\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=ArgumentsTests test=test02 exception=NullPointerException\",\n\t\t\t\"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01\");\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\t}\n\n\n\t/**\n\t * This test verifies that a run with a mix of pass and fail results can have \n\t * some filters applied, so that there are no failure results remaining.  \n\t */\n\t@Test \n\tpublic void testIntermittentFailure() throws StfException {\n\t\tString passingRunText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02\";\n\n\t\tString failingRunText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem02\";\n\n\t\tString filterText = \n\t\t\t  \"class=MemTests test=testMem01\";\n\n\t\t// Verify that the passing run has passed successfully\n\t\tArrayList<TestStatus> results = new ResultsParser(passingRunText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\n\t\tassertEquals(filter.toString(), 2, filter.getPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFilteredPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\n\t\t\n\t\t// Verify that the run with a failure also works\n\t\tresults = new ResultsParser(failingRunText).parse();\n\t\tfilter = new ResultsFilter(results, filters);\n\n\t\tassertEquals(filter.toString(), 1, filter.getPasses().size());\n\t\tassertEquals(filter.toString(), 1, filter.getFilteredPasses().size());\n\t\tassertEquals(filter.toString(), 0, filter.getFailures().size());\n\t}\n\n\t\n\t/**\n\t * Processes some run results with all possible outcomes, including a faling test which \n\t * is not filtered out, leading to an actual failure.  \n\t */\n\t@Test \n\tpublic void testMandatoryFailure() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem01 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem02 \\n\"\n\t\t\t+ \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem03\";\n\n\t\tString filterText = \"test=testMem02\";\n\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tverifyResults(filter.getPasses(),         \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem01\");\n\t\tverifyResults(filter.getFilteredPasses(), \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem02\");\n\t\tverifyResults(filter.getFailures(),       \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem03\");\n\t}"
    },
    "333": {
      "metadata": {
        "chunk_id": "7e3ca99b85644c4246c7ba5c02953a32d0d6f5be607c32dd1f1136d01b9e376b",
        "file_path": "stf.core/test/stf.core/net/adoptopenjdk/stf/results/TestResultsProcessor.java",
        "content": "String filterText = \"test=testMem02\";\n\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tverifyResults(filter.getPasses(),         \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem01\");\n\t\tverifyResults(filter.getFilteredPasses(), \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem02\");\n\t\tverifyResults(filter.getFailures(),       \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem03\");\n\t}\n\n\t\n\t/**\n\t * Verify that filter criteria can match on regular expressions\n\t */\n\t@Test\n\tpublic void testRegexMatching() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01 \\n\"  // match on the platform name\n\t\t\t+ \"suite=maths platform=win_x86-64  result=fail class=MemTests test=testMem02 \\n\"  // match on the '0' in the test name \n\t\t\t+ \"suite=stuff platform=win_x86-64  result=fail class=MemTests test=0testCpu \\n\"      // also match on the 0 in the test name\n\t\t\t+ \"suite=stuff platform=win_x86-64  result=fail class=MemTests test=testGraphics \\n\"  // really fails. doesn't match any regex\n\t\t\t+ \"suite=stuff platform=linux_86-64 result=pass class=MemTests test=testCpu02\";       // clear pass\n\n\t\tString filterText = \n\t\t\t\t  \"platform=~linux_86-(32|64)\\n\"\n\t\t\t\t+ \"test=~.*0.*\";\n\n\t\t// match with regex for platform name\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\n\t\tassertEquals(filter.toString(), 1, filter.getPasses().size());\n\t\tassertEquals(filter.toString(), 3, filter.getFilteredPasses().size());\n\t\tassertEquals(filter.toString(), 1, filter.getFailures().size());\n\t\t\n\t\tverifyResults(filter.getPasses(),         \"suite=stuff platform=linux_86-64 result=pass class=MemTests test=testCpu02\");\n\t\tverifyResults(filter.getFilteredPasses(), \n\t\t\t\t\"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01\",\n\t\t\t\t\"suite=maths platform=win_x86-64  result=fail class=MemTests test=testMem02\",\n\t\t\t\t\"suite=stuff platform=win_x86-64  result=fail class=MemTests test=0testCpu\");\n\t\tverifyResults(filter.getFailures(),       \"suite=stuff platform=win_x86-64  result=fail class=MemTests test=testGraphics\");\n\t}\n\t\n\tprivate void verifyResults(ArrayList<TestStatus> actual, String ... expected) {\n\t\tString actualStr = Arrays.toString(actual.toArray());\n\t\t\n\t\tStringBuilder expectedBuilder = new StringBuilder();\n\t\texpectedBuilder.append(\"[\");\n\t\tfor (int i=0; i<expected.length; i++) {\n\t\t\texpectedBuilder.append(expected[i].toString());\n\t\t\tif (i < expected.length-1) {\n\t\t\t\texpectedBuilder.append(\", \");\n\t\t\t}\n\t\t}\n\t\texpectedBuilder.append(\"]\");\n\t\t\t\t\n\t\tcheckStrings(expectedBuilder.toString(), actualStr);\n\t\tassertEquals(expectedBuilder.toString(), actualStr);\n\t}",
        "start_line": 188,
        "end_line": 248,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 789,
        "node_type": null,
        "file_sha": "34f9ec127d1048017a92b72e620fe70377986f95",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.663035"
      },
      "text": "String filterText = \"test=testMem02\";\n\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\t\t\n\t\tverifyResults(filter.getPasses(),         \"suite=maths platform=linux_86-64 result=pass class=MemTests test=testMem01\");\n\t\tverifyResults(filter.getFilteredPasses(), \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem02\");\n\t\tverifyResults(filter.getFailures(),       \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem03\");\n\t}\n\n\t\n\t/**\n\t * Verify that filter criteria can match on regular expressions\n\t */\n\t@Test\n\tpublic void testRegexMatching() throws StfException {\n\t\tString resultsText =\n\t\t\t  \"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01 \\n\"  // match on the platform name\n\t\t\t+ \"suite=maths platform=win_x86-64  result=fail class=MemTests test=testMem02 \\n\"  // match on the '0' in the test name \n\t\t\t+ \"suite=stuff platform=win_x86-64  result=fail class=MemTests test=0testCpu \\n\"      // also match on the 0 in the test name\n\t\t\t+ \"suite=stuff platform=win_x86-64  result=fail class=MemTests test=testGraphics \\n\"  // really fails. doesn't match any regex\n\t\t\t+ \"suite=stuff platform=linux_86-64 result=pass class=MemTests test=testCpu02\";       // clear pass\n\n\t\tString filterText = \n\t\t\t\t  \"platform=~linux_86-(32|64)\\n\"\n\t\t\t\t+ \"test=~.*0.*\";\n\n\t\t// match with regex for platform name\n\t\tArrayList<TestStatus> results = new ResultsParser(resultsText).parse();\n\t\tArrayList<TestStatus> filters = new ResultsParser(filterText).parse();\n\t\tResultsFilter filter = new ResultsFilter(results, filters);\n\n\t\tassertEquals(filter.toString(), 1, filter.getPasses().size());\n\t\tassertEquals(filter.toString(), 3, filter.getFilteredPasses().size());\n\t\tassertEquals(filter.toString(), 1, filter.getFailures().size());\n\t\t\n\t\tverifyResults(filter.getPasses(),         \"suite=stuff platform=linux_86-64 result=pass class=MemTests test=testCpu02\");\n\t\tverifyResults(filter.getFilteredPasses(), \n\t\t\t\t\"suite=maths platform=linux_86-64 result=fail class=MemTests test=testMem01\",\n\t\t\t\t\"suite=maths platform=win_x86-64  result=fail class=MemTests test=testMem02\",\n\t\t\t\t\"suite=stuff platform=win_x86-64  result=fail class=MemTests test=0testCpu\");\n\t\tverifyResults(filter.getFailures(),       \"suite=stuff platform=win_x86-64  result=fail class=MemTests test=testGraphics\");\n\t}\n\t\n\tprivate void verifyResults(ArrayList<TestStatus> actual, String ... expected) {\n\t\tString actualStr = Arrays.toString(actual.toArray());\n\t\t\n\t\tStringBuilder expectedBuilder = new StringBuilder();\n\t\texpectedBuilder.append(\"[\");\n\t\tfor (int i=0; i<expected.length; i++) {\n\t\t\texpectedBuilder.append(expected[i].toString());\n\t\t\tif (i < expected.length-1) {\n\t\t\t\texpectedBuilder.append(\", \");\n\t\t\t}\n\t\t}\n\t\texpectedBuilder.append(\"]\");\n\t\t\t\t\n\t\tcheckStrings(expectedBuilder.toString(), actualStr);\n\t\tassertEquals(expectedBuilder.toString(), actualStr);\n\t}"
    },
    "334": {
      "metadata": {
        "chunk_id": "605081af90406a75ff56690a146762fbf7a9096d0c10d25aa720c47c4c883613",
        "file_path": "stf.core/test/stf.core/net/adoptopenjdk/stf/results/TestResultsProcessor.java",
        "content": "// This method helps with debugging by making string differences more readable.\n\tprivate void checkStrings(String expected, String actual) {\n\t\tif (expected.equals(actual)) { \n\t\t\treturn;\n\t\t}\n\t\n\t\tint firstDiff = Integer.MAX_VALUE;\n\t\tStringBuilder statusLine = new StringBuilder();\n\t\t\n\t\tint max = Math.max(expected.length(), actual.length());\n\t\tfor (int i=0; i<max; i++) {\n\t\t\tchar e = i < expected.length() ? expected.charAt(i) : ' ';\n\t\t\tchar a = i < actual.length() ? actual.charAt(i) : ' ';\n\t\t\t\n\t\t\tif (e == a) {\n\t\t\t\tstatusLine.append('.');\n\t\t\t} else { \n\t\t\t\tstatusLine.append('*');\n\t\t\t\tfirstDiff = Math.min(firstDiff, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Report on the differences between the string.\n\t\tSystem.out.println(\"Differences detected. First diff at offset \" + firstDiff);\n\t\tSystem.out.println(\"Expected:\" + expected);\n\t\tSystem.out.println(\"Actual:  \" + actual);\n\t\tSystem.out.println(\"Status:  \" + statusLine.toString());\n\t\t\n\t\tassertEquals(expected, actual); // Will cause the test to fail\n\t}\n}",
        "start_line": 249,
        "end_line": 279,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 246,
        "node_type": null,
        "file_sha": "34f9ec127d1048017a92b72e620fe70377986f95",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.663038"
      },
      "text": "// This method helps with debugging by making string differences more readable.\n\tprivate void checkStrings(String expected, String actual) {\n\t\tif (expected.equals(actual)) { \n\t\t\treturn;\n\t\t}\n\t\n\t\tint firstDiff = Integer.MAX_VALUE;\n\t\tStringBuilder statusLine = new StringBuilder();\n\t\t\n\t\tint max = Math.max(expected.length(), actual.length());\n\t\tfor (int i=0; i<max; i++) {\n\t\t\tchar e = i < expected.length() ? expected.charAt(i) : ' ';\n\t\t\tchar a = i < actual.length() ? actual.charAt(i) : ' ';\n\t\t\t\n\t\t\tif (e == a) {\n\t\t\t\tstatusLine.append('.');\n\t\t\t} else { \n\t\t\t\tstatusLine.append('*');\n\t\t\t\tfirstDiff = Math.min(firstDiff, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Report on the differences between the string.\n\t\tSystem.out.println(\"Differences detected. First diff at offset \" + firstDiff);\n\t\tSystem.out.println(\"Expected:\" + expected);\n\t\tSystem.out.println(\"Actual:  \" + actual);\n\t\tSystem.out.println(\"Status:  \" + statusLine.toString());\n\t\t\n\t\tassertEquals(expected, actual); // Will cause the test to fail\n\t}\n}"
    },
    "335": {
      "metadata": {
        "chunk_id": "66ef91a055d21cd829f2cf0069c46f8bed66b1494aa50e7ddc9d4031a94da505",
        "file_path": "stf.load/.classpath",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<classpath>\n\t<classpathentry kind=\"src\" path=\"src/stf.load\"/>\n\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"/>\n\t<classpathentry kind=\"src\" path=\"/stf.core\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/junit/junit.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-api.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-core.jar\"/>\n\t<classpathentry kind=\"output\" path=\"bin\"/>\n</classpath>\n\n\n",
        "start_line": 0,
        "end_line": 12,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 150,
        "node_type": null,
        "file_sha": "18d084ebaa5f0d76eb392ee63dfe23352f2d07a8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.684006"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<classpath>\n\t<classpathentry kind=\"src\" path=\"src/stf.load\"/>\n\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"/>\n\t<classpathentry kind=\"src\" path=\"/stf.core\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/junit/junit.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-api.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-core.jar\"/>\n\t<classpathentry kind=\"output\" path=\"bin\"/>\n</classpath>\n\n\n"
    },
    "336": {
      "metadata": {
        "chunk_id": "8591b2e7a0bf14ffa207bdbe6d946cdc9455f3de05eef249ab3e475fdafee618",
        "file_path": "stf.load/.project",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>stf.load</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.jdt.core.javabuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.jdt.core.javanature</nature>\n\t</natures>\n</projectDescription>\n\n\n",
        "start_line": 0,
        "end_line": 19,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 119,
        "node_type": null,
        "file_sha": "b1068953c6e28beb625b529d03b30f3cb9d32524",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.708024"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>stf.load</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.jdt.core.javabuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.jdt.core.javanature</nature>\n\t</natures>\n</projectDescription>\n\n\n"
    },
    "337": {
      "metadata": {
        "chunk_id": "b19d483930ea53413e6cedc9bcad35ea238dc15c03e5b4b58bb1f370cae17967",
        "file_path": "stf.load/build.xml",
        "content": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n     http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<project name=\"stf.load\" default=\"build\">\n\n\t<echo message=\"Executing stf.load/build.xml\"/>\n\n\t<!-- Set default for source_root.  -->\n\t<property name=\"source_root\" location=\"../\"/>\n\n\t<property name=\"stf_root\" location=\"${source_root}/../stf\"/>\n\n\t<!-- Import settings used by multiple projects.  -->\n\t<import file=\"${stf_root}/stf.build/include/top.xml\"/>\n\n\t<path id=\"project.class.path\">\n\t\t<path refid=\"junit.class.path\" />\n\t\t<path refid=\"log4j.class.path\" />\n\t\t<path refid=\"asm.class.path\" />\n\t\t<pathelement location=\"${stf_root}/stf.core/bin/stf.core.jar\"/>\n\t</path>\n\n\t<!-- For modularity you need a directory above the package structure to hold the module.java file -->\n\t<property name=\"stf_load_module\" value=\"stf.load\" />\n\t<property name=\"stf_load_src_dir\" value=\"src/${stf_load_module}\" />\n\t<property name=\"stf_load_bin_dir\" value=\"bin\" />\n\n\t<property name=\"stf_load_jar_file\" value=\"${stf_load_bin_dir}/${stf_load_module}.jar\" />\n\n\t<!-- Projects which need to be built before this one. -->\n\t<!-- dir must be set on the ant task otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-dependencies\" depends=\"check-prereqs\">\n\t\t<ant antfile=\"${stf_root}/stf.core/build.xml\" dir=\"${stf_root}/stf.core\" inheritAll=\"true\"/>\n\t</target>\n\n\t<target name=\"build\" depends=\"build-no-natives, build-natives\">\n\t</target>\n\n\t<target name=\"build-no-natives\" depends=\"check-prereqs, build-dependencies, build-archives\">\n\t</target>\n\n\t<target name=\"build-natives\" depends=\"check-prereqs\">\n\t</target>\n\n\t<target name=\"build-archives\" depends=\"build-jar\">\n\t</target>\n\n\t<target name=\"build-jar\" depends=\"build-java, create-bin-dir\">\n\t\t<jar destfile=\"${stf_load_jar_file}\">\n\t\t\t<fileset dir=\"${stf_load_bin_dir}\" includes=\"**/*.class\" />\n\t\t\t<manifest>\n\t\t\t\t<attribute name=\"Premain-Class\" value=\"net.adoptopenjdk.blockedexitagent.BlockedExitAgent\"/>\n\t\t\t\t<attribute name=\"Can-Retransform-Classes\" value=\"true\"/>\n\t\t\t</manifest>\n\t\t</jar>\n\t</target>\n\n\t<target name=\"build-java\" depends=\"check-prereqs, create-bin-dir\">\n\t\t <!--\n\t\t \tThe Ant javac task only checks time dependencies between .java files and their .class files,\n\t\t\tso fails to recompile in situations such as the signatures of a dependent method changing.\n\t\t\tThe depend target checks the dependencies and deletes any .class files older than the files\n\t\t\twhich depend on them, thereby ensuring recompilation.\n\t\t-->\n\t\t<!--\n\t\tCommented out because depend appears to be evaluating class files as always out of date with jdk11 (at 28/03/2019)\n\t\t<depend srcdir=\"${stf_load_src_dir}\" destdir=\"${stf_load_bin_dir}\" classpathref=\"project.class.path\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</depend>\n\t\t-->\n\t    <!-- Classes can be built using Java 7 or later.  -->\n\t\t<javac srcdir=\"${stf_load_src_dir}\"\n\t\t\t   destdir=\"${stf_load_bin_dir}\"\n\t\t\t   debug=\"true\"\n\t\t\t   fork=\"true\"\n\t\t\t   executable=\"${java_compiler}\"\n\t\t\t   classpathref=\"project.class.path\"\n\t\t\t   encoding=\"${src-encoding}\"\n\t\t\t   includeantruntime=\"false\"\n\t\t\t   failonerror=\"true\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</javac>\n\t</target>\n\n\t<target name=\"create-bin-dir\">\n\t\t<mkdir dir=\"${stf_load_bin_dir}\"/>\n\t</target>\n\n\t<target name=\"clean\">\n\t\t<delete dir=\"${stf_load_bin_dir}\"/>\n\t</target>\n\n</project>",
        "start_line": 0,
        "end_line": 103,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 1018,
        "node_type": null,
        "file_sha": "f2fdc90d4b953648ec64b225fc67d2e7ee867244",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.730294"
      },
      "text": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n     http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<project name=\"stf.load\" default=\"build\">\n\n\t<echo message=\"Executing stf.load/build.xml\"/>\n\n\t<!-- Set default for source_root.  -->\n\t<property name=\"source_root\" location=\"../\"/>\n\n\t<property name=\"stf_root\" location=\"${source_root}/../stf\"/>\n\n\t<!-- Import settings used by multiple projects.  -->\n\t<import file=\"${stf_root}/stf.build/include/top.xml\"/>\n\n\t<path id=\"project.class.path\">\n\t\t<path refid=\"junit.class.path\" />\n\t\t<path refid=\"log4j.class.path\" />\n\t\t<path refid=\"asm.class.path\" />\n\t\t<pathelement location=\"${stf_root}/stf.core/bin/stf.core.jar\"/>\n\t</path>\n\n\t<!-- For modularity you need a directory above the package structure to hold the module.java file -->\n\t<property name=\"stf_load_module\" value=\"stf.load\" />\n\t<property name=\"stf_load_src_dir\" value=\"src/${stf_load_module}\" />\n\t<property name=\"stf_load_bin_dir\" value=\"bin\" />\n\n\t<property name=\"stf_load_jar_file\" value=\"${stf_load_bin_dir}/${stf_load_module}.jar\" />\n\n\t<!-- Projects which need to be built before this one. -->\n\t<!-- dir must be set on the ant task otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-dependencies\" depends=\"check-prereqs\">\n\t\t<ant antfile=\"${stf_root}/stf.core/build.xml\" dir=\"${stf_root}/stf.core\" inheritAll=\"true\"/>\n\t</target>\n\n\t<target name=\"build\" depends=\"build-no-natives, build-natives\">\n\t</target>\n\n\t<target name=\"build-no-natives\" depends=\"check-prereqs, build-dependencies, build-archives\">\n\t</target>\n\n\t<target name=\"build-natives\" depends=\"check-prereqs\">\n\t</target>\n\n\t<target name=\"build-archives\" depends=\"build-jar\">\n\t</target>\n\n\t<target name=\"build-jar\" depends=\"build-java, create-bin-dir\">\n\t\t<jar destfile=\"${stf_load_jar_file}\">\n\t\t\t<fileset dir=\"${stf_load_bin_dir}\" includes=\"**/*.class\" />\n\t\t\t<manifest>\n\t\t\t\t<attribute name=\"Premain-Class\" value=\"net.adoptopenjdk.blockedexitagent.BlockedExitAgent\"/>\n\t\t\t\t<attribute name=\"Can-Retransform-Classes\" value=\"true\"/>\n\t\t\t</manifest>\n\t\t</jar>\n\t</target>\n\n\t<target name=\"build-java\" depends=\"check-prereqs, create-bin-dir\">\n\t\t <!--\n\t\t \tThe Ant javac task only checks time dependencies between .java files and their .class files,\n\t\t\tso fails to recompile in situations such as the signatures of a dependent method changing.\n\t\t\tThe depend target checks the dependencies and deletes any .class files older than the files\n\t\t\twhich depend on them, thereby ensuring recompilation.\n\t\t-->\n\t\t<!--\n\t\tCommented out because depend appears to be evaluating class files as always out of date with jdk11 (at 28/03/2019)\n\t\t<depend srcdir=\"${stf_load_src_dir}\" destdir=\"${stf_load_bin_dir}\" classpathref=\"project.class.path\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</depend>\n\t\t-->\n\t    <!-- Classes can be built using Java 7 or later.  -->\n\t\t<javac srcdir=\"${stf_load_src_dir}\"\n\t\t\t   destdir=\"${stf_load_bin_dir}\"\n\t\t\t   debug=\"true\"\n\t\t\t   fork=\"true\"\n\t\t\t   executable=\"${java_compiler}\"\n\t\t\t   classpathref=\"project.class.path\"\n\t\t\t   encoding=\"${src-encoding}\"\n\t\t\t   includeantruntime=\"false\"\n\t\t\t   failonerror=\"true\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</javac>\n\t</target>\n\n\t<target name=\"create-bin-dir\">\n\t\t<mkdir dir=\"${stf_load_bin_dir}\"/>\n\t</target>\n\n\t<target name=\"clean\">\n\t\t<delete dir=\"${stf_load_bin_dir}\"/>\n\t</target>\n\n</project>"
    },
    "338": {
      "metadata": {
        "chunk_id": "d0add5743712249bda4450e01327a07cd8f65710b59a2cd5324283106f18d008",
        "file_path": "stf.load/docs/README.md",
        "content": "STF Load Test\n=============\n\n## Contents\n\n  * [Overview](#overview)\n  * [Load Test Features](#load-test-features)\n     * [Test selection](#test-selection)\n        * [Sequential selection](#sequential-selection)\n        * [Random selection](#random-selection)\n     * [Inventory files](#inventory-files)\n        * [Included inventory files](#included-inventory-files)\n        * [Exclude inventory files](#exclude-inventory-files)\n        * [Test weightings](#test-weightings)\n     * [Test adaptors](#test-adaptors)\n        * [JUnit tests](#junit-tests)\n        * [Mauve tests](#mauve-tests)\n        * [Arbitrary Java tests](#arbitrary-java-tests)\n     * [Execution logs](#execution-logs)\n     * [Formatting execution log ltm and ltd files](#formatting-execution-log-ltm-and-ltd-files)\n        * [Detail execution log formatter](#detail-execution-log-formatter)\n        * [Failure execution log formatter](#failure-execution-log-formatter)\n        * [Summary execution log formatter](#summary-execution-log-formatter)\n        * [MetaData execution log formatter](#metadata-execution-log-formatter)\n     * [Execution log disk space and pruning](#execution-log-disk-space-and-pruning)\n     * [Java dumps](#java-dumps)\n     * [Progress reporting](#progress-reporting)\n     * [Hang detection](#hang-detection)\n     * [Algorithm summary](#algorithm-summary)\n  * [STF Java Interface](#stf-java-interface)\n     * [Java methods](#load-test-jvm-arguments)\n        * [Load test JVM arguments](#load-test-jvm-arguments)\n        * [Arguments for the load test program itself](#arguments-for-the-load-test-program-itself)\n        * [To control test runtime](#to-control-test-runtime)\n        * [Suite Control](#suite-control)\n        * [Test selection](#test-selection)\n     * [Example Java test code](#example-java-test-code)\n     * [Example run](#example-run)\n  * [The Load Test Program Itself](#the-load-test-program-itself)\n     * [Load test arguments](#load-test-arguments)\n     * [Comments about load test arguments](#comments-about-load-test-arguments)\n     * [Example command line](#example-command-line)\n  * [Porting tests](#porting-tests)\n  * [Reproducing failures](#reproducing-failures)\n  * [Future Enhancements](#future-enhancements)\n\n## Overview\n\nThe load test application is a multi-threaded Java program which repeatedly executes\ncollections of Java tests. It aims to find JVM issues which occur only when the JVM\nhas been active for a period of time, such as:\n - just in Time (JIT) compiler errors.\n - garbage collector errors.\n - memory leaks.\n\nIt does this JVM stress testing by recycling existing or open source tests.\nThe available tests for a load test run are listed in 'inventory' files:\n - xml formatted files. 1 test per line.\n - to help with managing subsets an inventory file can include other inventory files.\n - broken tests can be added to an inventory exclude file.\n - frequency of execution is controlled by optional per-test weighting attribute.\n\nLoad test does its best to help with debugging in the face of a potentially unstable JVM:\n - generates javacore on first failure.\n - records start and end of each test to execution log file.\n - seed for randomly selecting tests can be recycled to get same test ordering.\n - stdout/stderr captured on a per test basis. Logged on failure with no intermingling of other test output.\n - minimal memory footprint. Can run indefinitely.\n\nLoad test aims to expose the bare minimum of complexity in the configuration of a\nload test scenario. A minimal set of arguments would allow light load to be\nplaced on a single worker thread, whereas a more complex scenario would specify several\ntest suites all running multiple threads and selecting their tests with different algorithms.\nThe key arguments are:\n - time based run vs. fixed test invocation count.\n - random vs. sequential test selection.\n - for random selection, a fixed or randomly generated starting seed.\n - number of worker threads.\n - test repetition. Defaults to 1.\n\n## Load Test Features\n\n#### Test selection\n\n##### *Sequential selection*\nIf a suite is set to run tests sequentially then tests are executed from top to\nbottom of the test inventory file. Once the end of the inventory has been reached\nselection starts again from the top.\n\nIf a suite has tests A, B, C, D, E and the suite has been told to run 7 tests\nthen it would execute ABCDEAB. With a repeat count of 2 it would run AABBCCD.\n\n",
        "start_line": 0,
        "end_line": 92,
        "chunk_index": 0,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 994,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750513"
      },
      "text": "STF Load Test\n=============\n\n## Contents\n\n  * [Overview](#overview)\n  * [Load Test Features](#load-test-features)\n     * [Test selection](#test-selection)\n        * [Sequential selection](#sequential-selection)\n        * [Random selection](#random-selection)\n     * [Inventory files](#inventory-files)\n        * [Included inventory files](#included-inventory-files)\n        * [Exclude inventory files](#exclude-inventory-files)\n        * [Test weightings](#test-weightings)\n     * [Test adaptors](#test-adaptors)\n        * [JUnit tests](#junit-tests)\n        * [Mauve tests](#mauve-tests)\n        * [Arbitrary Java tests](#arbitrary-java-tests)\n     * [Execution logs](#execution-logs)\n     * [Formatting execution log ltm and ltd files](#formatting-execution-log-ltm-and-ltd-files)\n        * [Detail execution log formatter](#detail-execution-log-formatter)\n        * [Failure execution log formatter](#failure-execution-log-formatter)\n        * [Summary execution log formatter](#summary-execution-log-formatter)\n        * [MetaData execution log formatter](#metadata-execution-log-formatter)\n     * [Execution log disk space and pruning](#execution-log-disk-space-and-pruning)\n     * [Java dumps](#java-dumps)\n     * [Progress reporting](#progress-reporting)\n     * [Hang detection](#hang-detection)\n     * [Algorithm summary](#algorithm-summary)\n  * [STF Java Interface](#stf-java-interface)\n     * [Java methods](#load-test-jvm-arguments)\n        * [Load test JVM arguments](#load-test-jvm-arguments)\n        * [Arguments for the load test program itself](#arguments-for-the-load-test-program-itself)\n        * [To control test runtime](#to-control-test-runtime)\n        * [Suite Control](#suite-control)\n        * [Test selection](#test-selection)\n     * [Example Java test code](#example-java-test-code)\n     * [Example run](#example-run)\n  * [The Load Test Program Itself](#the-load-test-program-itself)\n     * [Load test arguments](#load-test-arguments)\n     * [Comments about load test arguments](#comments-about-load-test-arguments)\n     * [Example command line](#example-command-line)\n  * [Porting tests](#porting-tests)\n  * [Reproducing failures](#reproducing-failures)\n  * [Future Enhancements](#future-enhancements)\n\n## Overview\n\nThe load test application is a multi-threaded Java program which repeatedly executes\ncollections of Java tests. It aims to find JVM issues which occur only when the JVM\nhas been active for a period of time, such as:\n - just in Time (JIT) compiler errors.\n - garbage collector errors.\n - memory leaks.\n\nIt does this JVM stress testing by recycling existing or open source tests.\nThe available tests for a load test run are listed in 'inventory' files:\n - xml formatted files. 1 test per line.\n - to help with managing subsets an inventory file can include other inventory files.\n - broken tests can be added to an inventory exclude file.\n - frequency of execution is controlled by optional per-test weighting attribute.\n\nLoad test does its best to help with debugging in the face of a potentially unstable JVM:\n - generates javacore on first failure.\n - records start and end of each test to execution log file.\n - seed for randomly selecting tests can be recycled to get same test ordering.\n - stdout/stderr captured on a per test basis. Logged on failure with no intermingling of other test output.\n - minimal memory footprint. Can run indefinitely.\n\nLoad test aims to expose the bare minimum of complexity in the configuration of a\nload test scenario. A minimal set of arguments would allow light load to be\nplaced on a single worker thread, whereas a more complex scenario would specify several\ntest suites all running multiple threads and selecting their tests with different algorithms.\nThe key arguments are:\n - time based run vs. fixed test invocation count.\n - random vs. sequential test selection.\n - for random selection, a fixed or randomly generated starting seed.\n - number of worker threads.\n - test repetition. Defaults to 1.\n\n## Load Test Features\n\n#### Test selection\n\n##### *Sequential selection*\nIf a suite is set to run tests sequentially then tests are executed from top to\nbottom of the test inventory file. Once the end of the inventory has been reached\nselection starts again from the top.\n\nIf a suite has tests A, B, C, D, E and the suite has been told to run 7 tests\nthen it would execute ABCDEAB. With a repeat count of 2 it would run AABBCCD.\n\n"
    },
    "339": {
      "metadata": {
        "chunk_id": "14c813c4d2b48f6134fe5bc8eb1b7989e0c006d701da7a24507d914964d48222",
        "file_path": "stf.load/docs/README.md",
        "content": "##### *Random selection*\nWhen running with random selection the next test to run is decided by the suites\nrandom number generator. The starting value can either be set explicitly by the\ntest or a new seed selected by using the default value of '-1'.\n\nReusing a seed from a failing run will reproduce the same sequence of tests.\nHowever, the reproduction will only happen if there haven't been any inventory\nchanges. This is because the tests are numbered at start-up time, so any additions\nor removals will change test number to test mappings.\n\nThe load test program outputs the seed value being used near the start of the\ntest run. To reuse the seed you can do either:\n1. Add a '.setSuiteSeed(long)' call in the tests source code.\n1. After a test run edit the 'exceute.pl' script and replace the existing\n'-suite.{suite-name}.seed' value.\n\nFor example, if running with a suite containing tests A, B, C, D, E, and repeat\ncount=1, seed=-1, could result in the selection of seed 9223852004 and the running\nof tests CEACBEE.\nRunning the same suite with a repeat count of 3 could result in CCCEEEA.\n\n#### Inventory files\n\nThe tests to be executed are listed in xml format 'inventory' files. Here is an example:\n```\n<inventory>\n\t<junit class=\"net.adoptopenjdk.stf.MiniJUnitTest\" />\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" method=\"runSimpleTest\" />\n</inventory>\n```\nThe keywords 'junit' and 'arbitraryJava' are known as 'test types'.\n\nAn inventory files can contain any sequence of supported test types. So the example above directs stf.load\n test to run junit and arbitraryJava tests.\n\nSTF load test copies the inventory files to the results directory, and these files\nare used by the executed perl code (in say execute.pl). This is done for several\nreasons:\n1. The used inventory files are visible in the any results file uploads - e.g. after a Jenkins job\nwhich executes the test.\n1. You can edit the inventory files are rerun 'execute.pl', with having to create a repository and\nbuild sandbox environments or having to make permanent edits.\n\nCopied inventory files can be found in the directory at '${resultsDir}/${resultsPrefix}inventory'.\n\n##### *Included inventory files*\nIn order to allow composition and reuse of existing inventory files, inventory\nfiles can include other inventory files. For example:\n```\n<inventory>\n    <include inventory=\"/test.load/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml\"/>\n    <include inventory=\"/test.load/config/inventories/sampleLoadTest/subtests/junitInventory.xml\"/>\n\n\t<junit class=\"net.adoptopenjdk.stf.MiniJUnitTest\" />\n</inventory>\n```\n\nThe include node specifies the location of the include file within the workspace,\nie, it starts with the top level project. It uses the '/' character as a platform\nneutral directory separator.\n\nIncluded inventory files can themselves include other inventory files.\n\nIncluded inventory files are copied to the results directory at test execution time. The directory structure\nis replicated so that inventory files can be copied without modification. This makes it easy to modify\nthe inventory files locally following a test run to aid a failure diagnosis.\n\n##### *Exclude inventory files*\n\nTests which are known to fail and which you don't want to run can be listed\nin an 'exclude' file. Tests which are listed in the inventory file and the\ncorresponding exclude file are not executed.\n\nExclude files are identified by the following rules:\n1. Exclude files live in the same directory as the inventory file.\n1. The exclude file has the same base file name as the inventory file.\n2. The base name of the exclude file ends with the regular expression '_exclude.*'.\n\nExclude files have the same format as inventory files.\n\nFor example, if there is an inventory file 'junitInventory.xml' then the tests listed\nin 'junitInventory_exclude-201495.xml' and 'junitInventory_exclude-sql-tests.xml' would not\nbe executed.\n\nThe rationale behind this approach is that if tests are temporarily disabled by commenting them out\nof a test list file (such as an inventory file) then it's all too easy to forget to uncomment them\nwhen an underlying defect is fixed. Exclude files make the disabled tests more visible, so a forgotten\ntest stands a better chance of being noticed and re-enabled.\n\n##### *Test weightings*\n\nTest entries in inventory files have an optional 'weighting' attribute. This\ncan be used to increase of decrease the odds of running the test when random\ntest selection is being used. The weighting value is ignored when running with sequential\ntest selection.\n\n",
        "start_line": 93,
        "end_line": 189,
        "chunk_index": 1,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 999,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750521"
      },
      "text": "##### *Random selection*\nWhen running with random selection the next test to run is decided by the suites\nrandom number generator. The starting value can either be set explicitly by the\ntest or a new seed selected by using the default value of '-1'.\n\nReusing a seed from a failing run will reproduce the same sequence of tests.\nHowever, the reproduction will only happen if there haven't been any inventory\nchanges. This is because the tests are numbered at start-up time, so any additions\nor removals will change test number to test mappings.\n\nThe load test program outputs the seed value being used near the start of the\ntest run. To reuse the seed you can do either:\n1. Add a '.setSuiteSeed(long)' call in the tests source code.\n1. After a test run edit the 'exceute.pl' script and replace the existing\n'-suite.{suite-name}.seed' value.\n\nFor example, if running with a suite containing tests A, B, C, D, E, and repeat\ncount=1, seed=-1, could result in the selection of seed 9223852004 and the running\nof tests CEACBEE.\nRunning the same suite with a repeat count of 3 could result in CCCEEEA.\n\n#### Inventory files\n\nThe tests to be executed are listed in xml format 'inventory' files. Here is an example:\n```\n<inventory>\n\t<junit class=\"net.adoptopenjdk.stf.MiniJUnitTest\" />\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" method=\"runSimpleTest\" />\n</inventory>\n```\nThe keywords 'junit' and 'arbitraryJava' are known as 'test types'.\n\nAn inventory files can contain any sequence of supported test types. So the example above directs stf.load\n test to run junit and arbitraryJava tests.\n\nSTF load test copies the inventory files to the results directory, and these files\nare used by the executed perl code (in say execute.pl). This is done for several\nreasons:\n1. The used inventory files are visible in the any results file uploads - e.g. after a Jenkins job\nwhich executes the test.\n1. You can edit the inventory files are rerun 'execute.pl', with having to create a repository and\nbuild sandbox environments or having to make permanent edits.\n\nCopied inventory files can be found in the directory at '${resultsDir}/${resultsPrefix}inventory'.\n\n##### *Included inventory files*\nIn order to allow composition and reuse of existing inventory files, inventory\nfiles can include other inventory files. For example:\n```\n<inventory>\n    <include inventory=\"/test.load/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml\"/>\n    <include inventory=\"/test.load/config/inventories/sampleLoadTest/subtests/junitInventory.xml\"/>\n\n\t<junit class=\"net.adoptopenjdk.stf.MiniJUnitTest\" />\n</inventory>\n```\n\nThe include node specifies the location of the include file within the workspace,\nie, it starts with the top level project. It uses the '/' character as a platform\nneutral directory separator.\n\nIncluded inventory files can themselves include other inventory files.\n\nIncluded inventory files are copied to the results directory at test execution time. The directory structure\nis replicated so that inventory files can be copied without modification. This makes it easy to modify\nthe inventory files locally following a test run to aid a failure diagnosis.\n\n##### *Exclude inventory files*\n\nTests which are known to fail and which you don't want to run can be listed\nin an 'exclude' file. Tests which are listed in the inventory file and the\ncorresponding exclude file are not executed.\n\nExclude files are identified by the following rules:\n1. Exclude files live in the same directory as the inventory file.\n1. The exclude file has the same base file name as the inventory file.\n2. The base name of the exclude file ends with the regular expression '_exclude.*'.\n\nExclude files have the same format as inventory files.\n\nFor example, if there is an inventory file 'junitInventory.xml' then the tests listed\nin 'junitInventory_exclude-201495.xml' and 'junitInventory_exclude-sql-tests.xml' would not\nbe executed.\n\nThe rationale behind this approach is that if tests are temporarily disabled by commenting them out\nof a test list file (such as an inventory file) then it's all too easy to forget to uncomment them\nwhen an underlying defect is fixed. Exclude files make the disabled tests more visible, so a forgotten\ntest stands a better chance of being noticed and re-enabled.\n\n##### *Test weightings*\n\nTest entries in inventory files have an optional 'weighting' attribute. This\ncan be used to increase of decrease the odds of running the test when random\ntest selection is being used. The weighting value is ignored when running with sequential\ntest selection.\n\n"
    },
    "340": {
      "metadata": {
        "chunk_id": "fb0a2bd6479e42aa40e85da63478708dbf15445dea8c5efd1e748e0f7add4119",
        "file_path": "stf.load/docs/README.md",
        "content": "For example:\n```\n<inventory>\n\t<junit class=\"net.adoptopenjdk.stf.MiniJUnitTest\" weighting=\"1\"/>\n\t<junit class=\"net.adoptopenjdk.stf.FailingJUnitTest\" weighting=\"0.5\"/>\n\t<junit class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" weighting=\"1.25\"/>\n</inventory>\n```\n\nIn order to allow fast test selection based on random numbers load test builds\nan array of all possible tests. This essentially allows test selection based on\ncode like 'nextTest = testList[rnd.nextInt(testList.length)]'.\nIf no tests have a weighting specified, and are all on a default value of 1, then\neach test has a single entry in the selection array.\n\nWeightings allow fractional values, so load test finds the best multiplier which will\nallow fast selection of tests whilst still preserving the desired selection\nprobabilities. For example, with the following tests:\n```\n   test A, weighting = 1\n   test B, weighting = 0.5\n   test C, weighting = 1.25\n```\nA multiplier of 4 will allow the specified probabilities to be achieved: AAAABBCCCCC.\nSo randomly picking for this array 11 times would, on average, result in\n4A's, 2B's and 5C's. This exactly matches the specified distribution.\n\nIt's not always possible to pick a multiplier that will perfectly reproduce the\ndesired weightings, so in such cases load test will chooses the closest multiplier.\nFor example, if the test list were:\n```\n   test X, weighting = 0.41\n   test Y, weighting = 0.39\n   test Z, weighting = 0.201\n```\nIf the maximum allowed multiplier is 10 then the best choice would be 5, which produces\na selection array of XXYYZ. In practice the errors between the desired and actual distribution\nare small, and certainly drowned out by the differences that random test selection causes.\n\nWeightings of less than 1 make it convenient to reduce the probability of running a particularly\nslow test by only requiring an edit of that tests entry.\n\n#### Test adaptors\n\nLoad test is able to call different types of tests by delegating their execution to\nadaptor classes, which use reflection to execute that type of test.\n\nThere are currently 3 types of test adaptors:\n - JUnit - to run any standard JUnit tests.\n - mauve - invokes 'mauve' tests from the mauve open source project: https://www.sourceware.org/mauve.\n - arbitraryJava - calls specific java methods.\n\nThe key responsibilities of an adaptor are:\n - Runs the test.\n - Decides if the test passed or failed.\n - Invoke first failure diagnostics capture as soon as an failure is spotted.\n\nstf.load test aims to allow the easy reuse of existing tests by not requiring any code changes to the tests themselves.\n\n##### *JUnit tests*\n\nJUnit tests can be added to a load test inventory with lines such as:\n```\n    <junit class=\"net.adoptopenjdk.test.binaryData.TestByteArray2IntegerNumBytes\"/>\n```\n\nAll JUnit tests in the class are executed and a custom run listener tracks the progress of the JUnit test methods.\n\n##### *Mauve tests*\n\nThe Mauve tests are open source java class library tests. See\nhttps://en.wikipedia.org/wiki/Mauve_%28test_suite%29 and https://www.sourceware.org/mauve for more details.\n\nThe Mauve adapter uses reflection to run the 'public void test(TestHarness harness)' of the named mauve class.\n\nThe output from running a mauve test is scanned to decide if the test passed or failed.\nThe Mauve code which verifies test conditions prefixes some output text with a 'PASS:' or 'FAIL:' string.\nHowever, many Mauve tests don't give any positive or negative confirmation so, although assumed\nto pass, are given an 'unknown' result status.\n\nOf course, executing the mauve tests requires that they are available. See the https://github.com/adoptium/aqa-systemtest project for details\nof how to enable this feature. Once the test cases are built a single test can be executed outside of the test.load\nharness as follows:\n```\n\nexport PREREQS=$HOME/systemtest_prereqs\n\njava -classpath $PREREQS/mauve/mauve.jar gnu.testlet.SingleTestHarness gnu.testlet.java.util.zip.ZipFile.DirEntryTest\n```\n\n##### *Arbitrary Java tests*\n\nThe arbitrary Java adapter uses reflection to call a named java method.\n\nIf the test completes it is given a result value of 'unknown'. It can only fail if the\ntest method throws an exception.\n\n",
        "start_line": 190,
        "end_line": 287,
        "chunk_index": 2,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 981,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750523"
      },
      "text": "For example:\n```\n<inventory>\n\t<junit class=\"net.adoptopenjdk.stf.MiniJUnitTest\" weighting=\"1\"/>\n\t<junit class=\"net.adoptopenjdk.stf.FailingJUnitTest\" weighting=\"0.5\"/>\n\t<junit class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" weighting=\"1.25\"/>\n</inventory>\n```\n\nIn order to allow fast test selection based on random numbers load test builds\nan array of all possible tests. This essentially allows test selection based on\ncode like 'nextTest = testList[rnd.nextInt(testList.length)]'.\nIf no tests have a weighting specified, and are all on a default value of 1, then\neach test has a single entry in the selection array.\n\nWeightings allow fractional values, so load test finds the best multiplier which will\nallow fast selection of tests whilst still preserving the desired selection\nprobabilities. For example, with the following tests:\n```\n   test A, weighting = 1\n   test B, weighting = 0.5\n   test C, weighting = 1.25\n```\nA multiplier of 4 will allow the specified probabilities to be achieved: AAAABBCCCCC.\nSo randomly picking for this array 11 times would, on average, result in\n4A's, 2B's and 5C's. This exactly matches the specified distribution.\n\nIt's not always possible to pick a multiplier that will perfectly reproduce the\ndesired weightings, so in such cases load test will chooses the closest multiplier.\nFor example, if the test list were:\n```\n   test X, weighting = 0.41\n   test Y, weighting = 0.39\n   test Z, weighting = 0.201\n```\nIf the maximum allowed multiplier is 10 then the best choice would be 5, which produces\na selection array of XXYYZ. In practice the errors between the desired and actual distribution\nare small, and certainly drowned out by the differences that random test selection causes.\n\nWeightings of less than 1 make it convenient to reduce the probability of running a particularly\nslow test by only requiring an edit of that tests entry.\n\n#### Test adaptors\n\nLoad test is able to call different types of tests by delegating their execution to\nadaptor classes, which use reflection to execute that type of test.\n\nThere are currently 3 types of test adaptors:\n - JUnit - to run any standard JUnit tests.\n - mauve - invokes 'mauve' tests from the mauve open source project: https://www.sourceware.org/mauve.\n - arbitraryJava - calls specific java methods.\n\nThe key responsibilities of an adaptor are:\n - Runs the test.\n - Decides if the test passed or failed.\n - Invoke first failure diagnostics capture as soon as an failure is spotted.\n\nstf.load test aims to allow the easy reuse of existing tests by not requiring any code changes to the tests themselves.\n\n##### *JUnit tests*\n\nJUnit tests can be added to a load test inventory with lines such as:\n```\n    <junit class=\"net.adoptopenjdk.test.binaryData.TestByteArray2IntegerNumBytes\"/>\n```\n\nAll JUnit tests in the class are executed and a custom run listener tracks the progress of the JUnit test methods.\n\n##### *Mauve tests*\n\nThe Mauve tests are open source java class library tests. See\nhttps://en.wikipedia.org/wiki/Mauve_%28test_suite%29 and https://www.sourceware.org/mauve for more details.\n\nThe Mauve adapter uses reflection to run the 'public void test(TestHarness harness)' of the named mauve class.\n\nThe output from running a mauve test is scanned to decide if the test passed or failed.\nThe Mauve code which verifies test conditions prefixes some output text with a 'PASS:' or 'FAIL:' string.\nHowever, many Mauve tests don't give any positive or negative confirmation so, although assumed\nto pass, are given an 'unknown' result status.\n\nOf course, executing the mauve tests requires that they are available. See the https://github.com/adoptium/aqa-systemtest project for details\nof how to enable this feature. Once the test cases are built a single test can be executed outside of the test.load\nharness as follows:\n```\n\nexport PREREQS=$HOME/systemtest_prereqs\n\njava -classpath $PREREQS/mauve/mauve.jar gnu.testlet.SingleTestHarness gnu.testlet.java.util.zip.ZipFile.DirEntryTest\n```\n\n##### *Arbitrary Java tests*\n\nThe arbitrary Java adapter uses reflection to call a named java method.\n\nIf the test completes it is given a result value of 'unknown'. It can only fail if the\ntest method throws an exception.\n\n"
    },
    "341": {
      "metadata": {
        "chunk_id": "0731544d9b0f02433718d6f98cd8e8041849f5e10ee80d53c3d0cea4343c51f5",
        "file_path": "stf.load/docs/README.md",
        "content": "Some example inventory lines:\n```\n    <arbitraryJava class=\"net.adoptopenjdk.test.simple.ConvertDecimal\" method=\"invokeTest\" />\n    <arbitraryJava class=\"net.adoptopenjdk.test.invoke.AsTypeTest\" method=\"testVoid\" constructorArguments=\"1\" />\n    <arbitraryJava class=\"net.adoptopenjdk.test.gc.heaphog.ObjectTree\" method=\"runTest\" methodArguments=\"120000000\" weighting=\"30\"/>\n    <arbitraryJava class=\"net.adoptopenjdk.stf.sample.ArbitraryJavaTest\" constructorArguments=\"ADD\" method=\"runTest\" methodArguments=\"5, 2,3\" />\n````\n\nIf no constructor or method arguments are supplied then it attempts to call the noargs method.\nIf 'constructorArguments' or 'methodArguments' are supplied then the adapter attempts to call\nthe most appropriate method. Each individual argument value is initially treated as a string and\nwill attempt to match against the following types in this order:\n - java.lang.String\n - int\n - long\n - float\n - double\n - boolean\n\nIf a constructor or test method with a matching method signature can't be found then\nan exception is thrown, which leads to the failure of the test.\n\n#### Execution logs\n\nTo help with debugging load test records the start and end of each tests execution.\nThe information captured in each record is:\n - Mnemonic to describe what's happened.\n - Timestamp in milliseconds.\n - Thread number. Numbered from 0. Not reset for each suite.\n - Test number. Also numbered from 0. Test numbers listed at start of run.\n - Suite number. Numbered from 0.\n - Stdout/stderr output if the test failed.\n\nYou can expect to find 2 for each test execution; 1 to record the start of the test\nexecution and 1 to record the outcome.\n\nThe mnemonics used for each record are:\n - S - Started test.\n - P - Passed test.\n - F - Test Failed.\n - U - Test completed with Unknown result. The test has executed with no sign of a\n pass, fail or exception. Regarded as a pass on the grounds that there is no\n sign of failure.\n - T - Test failed as it failed with a Throwable exception.\n - Z - Test attempted to call System.exit with a 0 exit value. The exit has been\n blocked and the test is treated as a pass.\n - E - Test attempted to call System.exit with a non-zero value. The exit was\n blocked and the test is recorded as having failed.\n\nThe amalgamated stdout/stderr for a failing test is recorded in the tests failing\nrecord. This is captured on a per test basis, so even if 2 tests were concurrently\nfailing they will each have their own output with no intermingling.\n\n#### Formatting execution log ltm and ltd files\n\nData about the test execution is stored in a binary format log, to\nallow the storage of as much history as possible in the available disk space.\nIt uses 10 bytes per entry, which allows the recording of about 52000 test invocations per MB.\n\nThe data is recorded in:\n - A single '.ltm' (load test metadata. file version number, time zone, test lists, etc) file.\n - 1 or more '.ltd' (load test data) files.\n\nThe execution log files are created at ${resultsDir}/${resultsPrefix}executionLog.ltd.\n\nThe easiest way to run the program is probably to run a perl script which lives in the stf\nscripts directory: 'formatExecutionLog.pl'. This can be run directly if you put the '${build-output}/stf/scripts'\ndirectory on your path or on linux systems create an alias for the script.\nA typical command would be something like '$HOME/git/stf/scripts/formatExecutionLog.pl --detail /stf/MathLoadTest/results/1.LT.executionlog'\n\n##### Detail execution log formatter\n\nTo dump the execution log, and get detailed information about each test start/end, run formatExecution with a '--detail' or '-d' argument.\n\nRunning with '--verbose' or '-v' will make the formatter dump the captured output from any failing tests.\n\nThe following sample output shows the first few records from a passing run:\n```\n$ $HOME/git/stf/scripts/formatExecutionLog.pl --detail /stf/SampleLoadTest/results/1.LT.executionlog\nFormatting execution log for: /stf/SampleLoadTest/results/1.LT.executionlog\n\nOwnership of 6 worker threads:\n  Suite 0 owns threads: 0 to 4\n  Suite 1 owns thread: 5\n\n",
        "start_line": 288,
        "end_line": 373,
        "chunk_index": 3,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 950,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750525"
      },
      "text": "Some example inventory lines:\n```\n    <arbitraryJava class=\"net.adoptopenjdk.test.simple.ConvertDecimal\" method=\"invokeTest\" />\n    <arbitraryJava class=\"net.adoptopenjdk.test.invoke.AsTypeTest\" method=\"testVoid\" constructorArguments=\"1\" />\n    <arbitraryJava class=\"net.adoptopenjdk.test.gc.heaphog.ObjectTree\" method=\"runTest\" methodArguments=\"120000000\" weighting=\"30\"/>\n    <arbitraryJava class=\"net.adoptopenjdk.stf.sample.ArbitraryJavaTest\" constructorArguments=\"ADD\" method=\"runTest\" methodArguments=\"5, 2,3\" />\n````\n\nIf no constructor or method arguments are supplied then it attempts to call the noargs method.\nIf 'constructorArguments' or 'methodArguments' are supplied then the adapter attempts to call\nthe most appropriate method. Each individual argument value is initially treated as a string and\nwill attempt to match against the following types in this order:\n - java.lang.String\n - int\n - long\n - float\n - double\n - boolean\n\nIf a constructor or test method with a matching method signature can't be found then\nan exception is thrown, which leads to the failure of the test.\n\n#### Execution logs\n\nTo help with debugging load test records the start and end of each tests execution.\nThe information captured in each record is:\n - Mnemonic to describe what's happened.\n - Timestamp in milliseconds.\n - Thread number. Numbered from 0. Not reset for each suite.\n - Test number. Also numbered from 0. Test numbers listed at start of run.\n - Suite number. Numbered from 0.\n - Stdout/stderr output if the test failed.\n\nYou can expect to find 2 for each test execution; 1 to record the start of the test\nexecution and 1 to record the outcome.\n\nThe mnemonics used for each record are:\n - S - Started test.\n - P - Passed test.\n - F - Test Failed.\n - U - Test completed with Unknown result. The test has executed with no sign of a\n pass, fail or exception. Regarded as a pass on the grounds that there is no\n sign of failure.\n - T - Test failed as it failed with a Throwable exception.\n - Z - Test attempted to call System.exit with a 0 exit value. The exit has been\n blocked and the test is treated as a pass.\n - E - Test attempted to call System.exit with a non-zero value. The exit was\n blocked and the test is recorded as having failed.\n\nThe amalgamated stdout/stderr for a failing test is recorded in the tests failing\nrecord. This is captured on a per test basis, so even if 2 tests were concurrently\nfailing they will each have their own output with no intermingling.\n\n#### Formatting execution log ltm and ltd files\n\nData about the test execution is stored in a binary format log, to\nallow the storage of as much history as possible in the available disk space.\nIt uses 10 bytes per entry, which allows the recording of about 52000 test invocations per MB.\n\nThe data is recorded in:\n - A single '.ltm' (load test metadata. file version number, time zone, test lists, etc) file.\n - 1 or more '.ltd' (load test data) files.\n\nThe execution log files are created at ${resultsDir}/${resultsPrefix}executionLog.ltd.\n\nThe easiest way to run the program is probably to run a perl script which lives in the stf\nscripts directory: 'formatExecutionLog.pl'. This can be run directly if you put the '${build-output}/stf/scripts'\ndirectory on your path or on linux systems create an alias for the script.\nA typical command would be something like '$HOME/git/stf/scripts/formatExecutionLog.pl --detail /stf/MathLoadTest/results/1.LT.executionlog'\n\n##### Detail execution log formatter\n\nTo dump the execution log, and get detailed information about each test start/end, run formatExecution with a '--detail' or '-d' argument.\n\nRunning with '--verbose' or '-v' will make the formatter dump the captured output from any failing tests.\n\nThe following sample output shows the first few records from a passing run:\n```\n$ $HOME/git/stf/scripts/formatExecutionLog.pl --detail /stf/SampleLoadTest/results/1.LT.executionlog\nFormatting execution log for: /stf/SampleLoadTest/results/1.LT.executionlog\n\nOwnership of 6 worker threads:\n  Suite 0 owns threads: 0 to 4\n  Suite 1 owns thread: 5\n\n"
    },
    "342": {
      "metadata": {
        "chunk_id": "75e847f11b7e16a6c23face808e197fc0ceef77186d951db8c1c13b7918b7766",
        "file_path": "stf.load/docs/README.md",
        "content": "                                                                                                              <-- suite 0 --><1>\n Timestamp       Delta Thr Event      Test   Test name                                                         0  1  2  3  4  5\n14:47:19.131     +15ms  0 Started       0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -  o                \n14:47:19.131     +15ms  4 Started       0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -  |           o    \n14:47:19.131     +15ms  2 Started       1 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -  |     o     |    \n14:47:19.131     +15ms  3 Started       1 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -  |     |  o  |    \n14:47:19.131     +15ms  0 Completed     0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -  V     |  |  |    \n14:47:19.131     +15ms  1 Started       0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -     o  |  |  |    \n14:47:19.131     +15ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -     |  |  |  |  o\n14:47:19.131     +15ms  4 Completed     0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -     |  |  |  V  |\n14:47:19.133     +17ms  1 Completed     0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -     V  |  |     |\n14:47:19.136     +20ms  2 Completed     1 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -        V  |     |\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  3 Completed     1 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           V     |\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -                 V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -                 o\n...\n```\n\n##### Failure execution log formatter\n\n",
        "start_line": 374,
        "end_line": 404,
        "chunk_index": 4,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 994,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750528"
      },
      "text": "                                                                                                              <-- suite 0 --><1>\n Timestamp       Delta Thr Event      Test   Test name                                                         0  1  2  3  4  5\n14:47:19.131     +15ms  0 Started       0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -  o                \n14:47:19.131     +15ms  4 Started       0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -  |           o    \n14:47:19.131     +15ms  2 Started       1 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -  |     o     |    \n14:47:19.131     +15ms  3 Started       1 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -  |     |  o  |    \n14:47:19.131     +15ms  0 Completed     0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -  V     |  |  |    \n14:47:19.131     +15ms  1 Started       0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -     o  |  |  |    \n14:47:19.131     +15ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -     |  |  |  |  o\n14:47:19.131     +15ms  4 Completed     0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -     |  |  |  V  |\n14:47:19.133     +17ms  1 Completed     0 net.adoptopenjdk.stf.ArbitraryJavaTest:runSimpleTest()            -     V  |  |     |\n14:47:19.136     +20ms  2 Completed     1 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -        V  |     |\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           |     o\n14:47:19.136     +20ms  3 Completed     1 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -           V     |\n14:47:19.136     +20ms  5 Completed    10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -                 V\n14:47:19.136     +20ms  5 Started      10 net.adoptopenjdk.stf.ArbitraryJavaTest:runTest()                  -                 o\n...\n```\n\n##### Failure execution log formatter\n\n"
    },
    "343": {
      "metadata": {
        "chunk_id": "1fd774883998b9f663a5cc73f8b13c6a2a2a2365f1ac90ee55af3b84d9f9973a",
        "file_path": "stf.load/docs/README.md",
        "content": "The failure formatter scans the execution log to find any failing tests. When run with '--failures'\nor '-f' it will output a 1 line summary for each failing test.\n\nIf run with '--verbose' or '-v' it will also output the captured text for each failing test.\n\n```\n$ $HOME/git/stf/scripts/formatExecutionLog.pl --failures /stf/SampleFailingLoadTest/results/1.LT.executionlog\nFormatting execution log for: /stf/SampleFailingLoadTest/\nresults/1.LT.executionlog\n\nTest failures:\n  Failure 1) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\n  Failure 2) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\n  Failure 3) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\n  Failure 4) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\n```\n\nThe verbose output would look like:\n```\n$ $HOME/git/stf/scripts/formatExecutionLog.pl --failures --verbose /stf/SampleFailingLoadTest/results/1.LT.executionlog\nTest failures:\n  Failure 1) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\ntestStarted : testPi(net.adoptopenjdk.stf.FailingJUnitTest)\ntestFailure: testPi(net.adoptopenjdk.stf.FailingJUnitTest): Wrong value of pi ex\npected:<3.0> but was:<3.141592653589793>\njunit.framework.AssertionFailedError: Wrong value of pi expected:<3.0> but was:<\n3.141592653589793>\n        at junit.framework.Assert.fail(Assert.java:57)\n        at junit.framework.Assert.failNotEquals(Assert.java:329)\n        at junit.framework.Assert.assertEquals(Assert.java:78)\n        at junit.framework.TestCase.assertEquals(TestCase.java:244)\n        at net.adoptopenjdk.stf.FailingJUnitTest.testPi(FailingJUnitTest.java:37\n)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n...\n```\n\n##### Summary execution log formatter\n\nThe summary formatter gives a high level view of a test run. To produce\nthis view run with '--summary' or '-s'\n\nThe first part of the output shows the coverage of each log file. See below for\ninformation about how the data is recorded across multiple files which are pruned\nas needed to prevent running out of disk space.\n\nFor example:\n```\n$ $HOME/git/stf/scripts/formatExecutionLog.pl --summary /stf/SampleLoadTest/results/1.LT.executionlog\nLog file summaries\n  Part 1  Covers 10:00:41.934 to 10:00:41.956  Started:57 Passed:56 Failed:0\n  Part 2  Covers 10:00:41.956 to 10:00:41.990  Started:57 Passed:56 Failed:0\n  Part 3  Covers 10:00:41.991 to 10:00:42.011  Started:58 Passed:55 Failed:0\n  Part 4  Missing\n  Part 5  Missing\n  Part 6  Covers 10:00:42.049 to 10:00:42.059  Started:36 Passed:37 Failed:0\n\nLog file counts\n  Number log files found  : 4\n  Number log files missing: 2\n\nOverall test result counts. Note: Partial results due to missing log file(s)\n  Started: 208\n  Passed : 204\n  Failed : 0\n ```\n\n##### MetaData execution log formatter\n\nThe information from the .ltm metadata file can be dumped by running with '--metadata' or '-m'.\n\nThis lists data such as\n- timezone that the test was run in.\n- number of suites and threads.\n- list of tests, with their allocated test number.  \n\n#### Execution log disk space and pruning\n\nTo prevent the execution logs from consuming an excessive amount of disk space,\nand to allow load tests to run indefinitely, there are 2 arguments to control the\nexecution logging and its log rotation.\n\nFirstly, there is the 'LoadTestProcessDefinition.setMaxTotalLogFileSpace()' which\ntells the load test application the maximum amount of disk space it can use for\nexecution logs. This is a string in the same form as Java's -Xmx, ie, '{number}(g|G|m|M|k|K)'.\n\n",
        "start_line": 405,
        "end_line": 491,
        "chunk_index": 5,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 952,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750530"
      },
      "text": "The failure formatter scans the execution log to find any failing tests. When run with '--failures'\nor '-f' it will output a 1 line summary for each failing test.\n\nIf run with '--verbose' or '-v' it will also output the captured text for each failing test.\n\n```\n$ $HOME/git/stf/scripts/formatExecutionLog.pl --failures /stf/SampleFailingLoadTest/results/1.LT.executionlog\nFormatting execution log for: /stf/SampleFailingLoadTest/\nresults/1.LT.executionlog\n\nTest failures:\n  Failure 1) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\n  Failure 2) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\n  Failure 3) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\n  Failure 4) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\n```\n\nThe verbose output would look like:\n```\n$ $HOME/git/stf/scripts/formatExecutionLog.pl --failures --verbose /stf/SampleFailingLoadTest/results/1.LT.executionlog\nTest failures:\n  Failure 1) Test number=0 Test=net.adoptopenjdk.stf.FailingJUnitTest\ntestStarted : testPi(net.adoptopenjdk.stf.FailingJUnitTest)\ntestFailure: testPi(net.adoptopenjdk.stf.FailingJUnitTest): Wrong value of pi ex\npected:<3.0> but was:<3.141592653589793>\njunit.framework.AssertionFailedError: Wrong value of pi expected:<3.0> but was:<\n3.141592653589793>\n        at junit.framework.Assert.fail(Assert.java:57)\n        at junit.framework.Assert.failNotEquals(Assert.java:329)\n        at junit.framework.Assert.assertEquals(Assert.java:78)\n        at junit.framework.TestCase.assertEquals(TestCase.java:244)\n        at net.adoptopenjdk.stf.FailingJUnitTest.testPi(FailingJUnitTest.java:37\n)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n...\n```\n\n##### Summary execution log formatter\n\nThe summary formatter gives a high level view of a test run. To produce\nthis view run with '--summary' or '-s'\n\nThe first part of the output shows the coverage of each log file. See below for\ninformation about how the data is recorded across multiple files which are pruned\nas needed to prevent running out of disk space.\n\nFor example:\n```\n$ $HOME/git/stf/scripts/formatExecutionLog.pl --summary /stf/SampleLoadTest/results/1.LT.executionlog\nLog file summaries\n  Part 1  Covers 10:00:41.934 to 10:00:41.956  Started:57 Passed:56 Failed:0\n  Part 2  Covers 10:00:41.956 to 10:00:41.990  Started:57 Passed:56 Failed:0\n  Part 3  Covers 10:00:41.991 to 10:00:42.011  Started:58 Passed:55 Failed:0\n  Part 4  Missing\n  Part 5  Missing\n  Part 6  Covers 10:00:42.049 to 10:00:42.059  Started:36 Passed:37 Failed:0\n\nLog file counts\n  Number log files found  : 4\n  Number log files missing: 2\n\nOverall test result counts. Note: Partial results due to missing log file(s)\n  Started: 208\n  Passed : 204\n  Failed : 0\n ```\n\n##### MetaData execution log formatter\n\nThe information from the .ltm metadata file can be dumped by running with '--metadata' or '-m'.\n\nThis lists data such as\n- timezone that the test was run in.\n- number of suites and threads.\n- list of tests, with their allocated test number.  \n\n#### Execution log disk space and pruning\n\nTo prevent the execution logs from consuming an excessive amount of disk space,\nand to allow load tests to run indefinitely, there are 2 arguments to control the\nexecution logging and its log rotation.\n\nFirstly, there is the 'LoadTestProcessDefinition.setMaxTotalLogFileSpace()' which\ntells the load test application the maximum amount of disk space it can use for\nexecution logs. This is a string in the same form as Java's -Xmx, ie, '{number}(g|G|m|M|k|K)'.\n\n"
    },
    "344": {
      "metadata": {
        "chunk_id": "42239d32ffd31e83b0afa8d31a5f0e79e7ad3aa1db8738616cebcb5ed0e21a67",
        "file_path": "stf.load/docs/README.md",
        "content": "Secondly, there is a 'LoadTestProcessDefinition.setMaxSingleLogSize()' method\nwhich sets the maximum size for any single log file. As with the maxTotalLogFileSpace\nthis can be specified with an absolute size, eg, '50M', or it can be\nset to a fractional value, eg '1/10'. If set to a fractional value load test\nwill calculate the actual limit based on the corresponding fraction of the total\nlog file space. For example, you could run with a maxTotalLogFileSpace of 600M and a\nmaxSingleLogSize of '1/50' which result in the maximum size of a single log file\nof 12M.\n\nAs the log file space used reaches the limit old log files are deleted. The log\ncontaining the lowest priority data is deleted. If disk space permits then load\ntest does its best to retain the log file containing the first failure and all\nlog files before the first failure.\nThe full order of priority, from highest\nto lowest, is:\n1. Log with first failure.\n1. Complete set of logs leading to initial failure.\n1. Final log.\n1. Any other logs with failures.\n1. Log immediately before a failing log.\n1. Other log files.\n\n#### Java dumps\n\nIf load test is running on an an IBM JVM then it takes a set of 'first-failure' dumps\nwhen the first test fails using the 'com.ibm.jvm.Dump' class.\n\nIt attempts to take the dump as soon as the failure is spotted, but be aware that tests\nin other threads may complete before the failure is spotted and the dump requested. For\na more accurate view of what other tests were running at the time of the failure you'll\nneed to dump the execution logs.\n\nIf the load test is being run by STF and it has exceeded it's maximum allowed runtime\nthen STF process monitoring will attempt to capture as many diagnostic Java files as\nthe possible. What can actually be captured will vary depending on the platform, but on\nlinux it will be 3 sets of javacore dumps and then a set of core, snap and jitdump files.\nAny process which exceeds it's maximum allowed runtime is treated as a test failure.\n\n#### Progress reporting\n\nLoad test outputs periodic status reports. As well as showing progress these also\nprevent any outer test harness which treats output not being written to stdout as a\nhung test from doing so erroneously. Here is some typical output:\n```\n...\n11:51:26.194 - Completed 1.8%. Number of tests started=486561\n11:51:46.217 - Completed 3.6%. Number of tests started=916629 (+430068)\n11:52:06.139 - Completed 5.4%. Number of tests started=1346891 (+430262)\n11:52:26.160 - Completed 7.2%. Number of tests started=1776672 (+429781)\n11:52:46.174 - Completed 9.0%. Number of tests started=2203310 (+426638)\n11:53:06.190 - Completed 10.8%. Number of tests started=2631735 (+428425)\n11:53:26.208 - Completed 12.6%. Number of tests started=3060563 (+428828)\n11:53:46.221 - Completed 14.4%. Number of tests started=3488503 (+427940)\n11:54:06.136 - Completed 16.2%. Number of tests started=3918253 (+429750)\n...\n```\n\nThe progress reports are numbered so that it's easy to confirm that none have been lost.\n\nThe default progress reporting interval is 20 seconds, but it can optionally\nbe overridden by a milliseconds value of the environment variable 'LT_REPORTING_FREQUENCY'.\nFor example, to get updates every quarter of a second:\n```\nexport LT_REPORTING_FREQUENCY=250\n```\n\n#### Hang detection\n\nLoad test outputs the string '**POSSIBLE HANG DETECTED**' if no tests have completed\nwithin the previous 15 minutes. Before the process is terminated the diagnostics\ncapture sequence described in 'java dumps' is triggered. If the test is being run on an\nIBM JVM this should result in 3 sets of java dumps, a core file, snap and jitdump files being\ncreated.\n\n#### Algorithm summary\n\nThe core of the load test program is driven by the following algorithm:\n```\ncheck arguments\nread inventory files\n\nfor all suites {\n    for suite-thread-count {\n        run worker thread {\n            // logic for each worker thread\n            while (still need to run tests) {\n                pick next test;\n\n                record test-start to execution log;\n                flush execution log;\n                result = execute test;\n                record test result to execution log;\n                flush execution log;\n\n",
        "start_line": 492,
        "end_line": 586,
        "chunk_index": 6,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 995,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750532"
      },
      "text": "Secondly, there is a 'LoadTestProcessDefinition.setMaxSingleLogSize()' method\nwhich sets the maximum size for any single log file. As with the maxTotalLogFileSpace\nthis can be specified with an absolute size, eg, '50M', or it can be\nset to a fractional value, eg '1/10'. If set to a fractional value load test\nwill calculate the actual limit based on the corresponding fraction of the total\nlog file space. For example, you could run with a maxTotalLogFileSpace of 600M and a\nmaxSingleLogSize of '1/50' which result in the maximum size of a single log file\nof 12M.\n\nAs the log file space used reaches the limit old log files are deleted. The log\ncontaining the lowest priority data is deleted. If disk space permits then load\ntest does its best to retain the log file containing the first failure and all\nlog files before the first failure.\nThe full order of priority, from highest\nto lowest, is:\n1. Log with first failure.\n1. Complete set of logs leading to initial failure.\n1. Final log.\n1. Any other logs with failures.\n1. Log immediately before a failing log.\n1. Other log files.\n\n#### Java dumps\n\nIf load test is running on an an IBM JVM then it takes a set of 'first-failure' dumps\nwhen the first test fails using the 'com.ibm.jvm.Dump' class.\n\nIt attempts to take the dump as soon as the failure is spotted, but be aware that tests\nin other threads may complete before the failure is spotted and the dump requested. For\na more accurate view of what other tests were running at the time of the failure you'll\nneed to dump the execution logs.\n\nIf the load test is being run by STF and it has exceeded it's maximum allowed runtime\nthen STF process monitoring will attempt to capture as many diagnostic Java files as\nthe possible. What can actually be captured will vary depending on the platform, but on\nlinux it will be 3 sets of javacore dumps and then a set of core, snap and jitdump files.\nAny process which exceeds it's maximum allowed runtime is treated as a test failure.\n\n#### Progress reporting\n\nLoad test outputs periodic status reports. As well as showing progress these also\nprevent any outer test harness which treats output not being written to stdout as a\nhung test from doing so erroneously. Here is some typical output:\n```\n...\n11:51:26.194 - Completed 1.8%. Number of tests started=486561\n11:51:46.217 - Completed 3.6%. Number of tests started=916629 (+430068)\n11:52:06.139 - Completed 5.4%. Number of tests started=1346891 (+430262)\n11:52:26.160 - Completed 7.2%. Number of tests started=1776672 (+429781)\n11:52:46.174 - Completed 9.0%. Number of tests started=2203310 (+426638)\n11:53:06.190 - Completed 10.8%. Number of tests started=2631735 (+428425)\n11:53:26.208 - Completed 12.6%. Number of tests started=3060563 (+428828)\n11:53:46.221 - Completed 14.4%. Number of tests started=3488503 (+427940)\n11:54:06.136 - Completed 16.2%. Number of tests started=3918253 (+429750)\n...\n```\n\nThe progress reports are numbered so that it's easy to confirm that none have been lost.\n\nThe default progress reporting interval is 20 seconds, but it can optionally\nbe overridden by a milliseconds value of the environment variable 'LT_REPORTING_FREQUENCY'.\nFor example, to get updates every quarter of a second:\n```\nexport LT_REPORTING_FREQUENCY=250\n```\n\n#### Hang detection\n\nLoad test outputs the string '**POSSIBLE HANG DETECTED**' if no tests have completed\nwithin the previous 15 minutes. Before the process is terminated the diagnostics\ncapture sequence described in 'java dumps' is triggered. If the test is being run on an\nIBM JVM this should result in 3 sets of java dumps, a core file, snap and jitdump files being\ncreated.\n\n#### Algorithm summary\n\nThe core of the load test program is driven by the following algorithm:\n```\ncheck arguments\nread inventory files\n\nfor all suites {\n    for suite-thread-count {\n        run worker thread {\n            // logic for each worker thread\n            while (still need to run tests) {\n                pick next test;\n\n                record test-start to execution log;\n                flush execution log;\n                result = execute test;\n                record test result to execution log;\n                flush execution log;\n\n"
    },
    "345": {
      "metadata": {
        "chunk_id": "60a975dbd8848d5d5260bd4a1bf69215d91a1e67e818721f88ac649189c8aceb",
        "file_path": "stf.load/docs/README.md",
        "content": "                if (result == failed && is-first-failure) {\n                    if (!first failure dumps created) {\n\t                    generate java dumps;\n\t                }\n                }\n                increment counts;\n            }\n        }\n    }\n}\n\n// Main thread waits for all worker threads\nwhile (worker thread still running) {\n    output intermittent progress report;\n    sleep;\n}\n\noutput test results;\n```\n\n## STF Java Interface\n\nSTF provides a builder style interface to the load test program in the LoadTestProcessDefinition.java class.\nThis allows a test to programmatically specify how to run the load test.\n\nOnce the test has created such a definition it then runs it using the standard STF process\nmanagement. The current tests typically describe how to run a load and then execute this\nas a single foreground process, although if they wanted to they would be free to run the\nload test process concurrently with other processes.\n\nThe building of the load definition has the following parts:\n  1. Any extra JVM arguments.\n  1. Build class path entries need to run the tests.\n  1. Information about the test suite to be run.\n  1. Optionally. Define 2nd and subsequent suites.\n\n#### Java methods\n\n##### *Load test JVM arguments*\n\nMethods which supply options for the JVM running the load test are:\n- addJvmOption\n- addModules - Add a Java 9 module onto the classpath.\n- addProjectToClasspath - Allows access to the contents of a top level project.\n- addJarToClasspath\n- addDirectoryToClasspath\n\n##### *Arguments for the load test program itself*\n- setAbortIfOutOfMemory - Control what happens on OutOfMemoryException.\n- setReportFailureLimit - Specify number of test failures to report in detail.\n- setAbortAtFailureLimit - Set how many tests are allowed to fail before aborting a run.\n- setMaxTotalLogFileSpace - Set size limit for recording test execution activity.\n- setMaxSingleLogSize - Set size limit for individual log file.\n\n##### *To control test runtime*\nAt least one of these methods must be called:\n- setSuiteNumTests - each suite can set how many tests are to be executed.\n- setTimeLimit - Overall run time limit. No new tests are started after running for this long. eg '1h30m', '2m30s', etc\n\n##### *Suite control*\nFor each suite the test needs to specify:\n- addSuite - which sets the name for the suite.\n- setSuiteThreadCount - the number of threads running tests for the suite.\n\n##### *Test selection*\nThe decision about the next test to run is controlled by:\n- setSuiteInventory - Lists the tests to run.\n- setSuiteSequentialSelection\n- setSuiteRandomSelection\n- setSuiteSeed - for random selection this sets the starting seed, or use the default of '-1' to randomly pick the starting seed.\n- setSuiteTestRepeatCount - is the number of times to execute a selected test.\n- setSuiteThinkingTime - specifies a minimum and maximum time for each worker thread to sleep between tests, eg '250ms..1s'. To disable use the range of '0ms..0ms'. If enabled a random number generator is used to decide how long to sleep.\n\n#### Example Java test code\n\nThe following code is taken from the example in SampleLoadTest.java and shows an example load test invocation:\n\n```java\npublic void execute(StfCoreExtension stfCore) throws Exception {\n  String inventoryFile1 = \"/stf.samples/config/inventories/sampleLoadTest/sampleInventory.xml\";\n  String inventoryFile2 = \"/stf.samples/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml\";\n  int numTests = InventoryData.getNumberOfTests(stfCore, inventoryFile1);\n\n",
        "start_line": 587,
        "end_line": 670,
        "chunk_index": 7,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 770,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750534"
      },
      "text": "                if (result == failed && is-first-failure) {\n                    if (!first failure dumps created) {\n\t                    generate java dumps;\n\t                }\n                }\n                increment counts;\n            }\n        }\n    }\n}\n\n// Main thread waits for all worker threads\nwhile (worker thread still running) {\n    output intermittent progress report;\n    sleep;\n}\n\noutput test results;\n```\n\n## STF Java Interface\n\nSTF provides a builder style interface to the load test program in the LoadTestProcessDefinition.java class.\nThis allows a test to programmatically specify how to run the load test.\n\nOnce the test has created such a definition it then runs it using the standard STF process\nmanagement. The current tests typically describe how to run a load and then execute this\nas a single foreground process, although if they wanted to they would be free to run the\nload test process concurrently with other processes.\n\nThe building of the load definition has the following parts:\n  1. Any extra JVM arguments.\n  1. Build class path entries need to run the tests.\n  1. Information about the test suite to be run.\n  1. Optionally. Define 2nd and subsequent suites.\n\n#### Java methods\n\n##### *Load test JVM arguments*\n\nMethods which supply options for the JVM running the load test are:\n- addJvmOption\n- addModules - Add a Java 9 module onto the classpath.\n- addProjectToClasspath - Allows access to the contents of a top level project.\n- addJarToClasspath\n- addDirectoryToClasspath\n\n##### *Arguments for the load test program itself*\n- setAbortIfOutOfMemory - Control what happens on OutOfMemoryException.\n- setReportFailureLimit - Specify number of test failures to report in detail.\n- setAbortAtFailureLimit - Set how many tests are allowed to fail before aborting a run.\n- setMaxTotalLogFileSpace - Set size limit for recording test execution activity.\n- setMaxSingleLogSize - Set size limit for individual log file.\n\n##### *To control test runtime*\nAt least one of these methods must be called:\n- setSuiteNumTests - each suite can set how many tests are to be executed.\n- setTimeLimit - Overall run time limit. No new tests are started after running for this long. eg '1h30m', '2m30s', etc\n\n##### *Suite control*\nFor each suite the test needs to specify:\n- addSuite - which sets the name for the suite.\n- setSuiteThreadCount - the number of threads running tests for the suite.\n\n##### *Test selection*\nThe decision about the next test to run is controlled by:\n- setSuiteInventory - Lists the tests to run.\n- setSuiteSequentialSelection\n- setSuiteRandomSelection\n- setSuiteSeed - for random selection this sets the starting seed, or use the default of '-1' to randomly pick the starting seed.\n- setSuiteTestRepeatCount - is the number of times to execute a selected test.\n- setSuiteThinkingTime - specifies a minimum and maximum time for each worker thread to sleep between tests, eg '250ms..1s'. To disable use the range of '0ms..0ms'. If enabled a random number generator is used to decide how long to sleep.\n\n#### Example Java test code\n\nThe following code is taken from the example in SampleLoadTest.java and shows an example load test invocation:\n\n```java\npublic void execute(StfCoreExtension stfCore) throws Exception {\n  String inventoryFile1 = \"/stf.samples/config/inventories/sampleLoadTest/sampleInventory.xml\";\n  String inventoryFile2 = \"/stf.samples/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml\";\n  int numTests = InventoryData.getNumberOfTests(stfCore, inventoryFile1);\n\n"
    },
    "346": {
      "metadata": {
        "chunk_id": "aadccf9b5abeb9897c3b6d5ea63f3330d191b811a9d2217b275e7d988f4613f7",
        "file_path": "stf.load/docs/README.md",
        "content": "  LoadTestProcessDefinition loadTestSpecification = stfCore.createLoadTestSpecification()\n      .addProjectToClasspath(\"stf.samples\")\n      .addJarToClasspath(JavaProcessDefinition.JarId.JUNIT)\n      .addJarToClasspath(JavaProcessDefinition.JarId.HAMCREST)\n      .setTimeLimit(\"12s\")\t\t\t\t// Don't start any tests after 12 seconds\n      .setMaxTotalLogFileSpace(\"500M\")    // Optional. Prevent logging from exceeding 500M of log files\n      .setMaxSingleLogSize(\"1/50\")        // Optional. Run with limit of 50 logs, each up to 10M.\n      .addSuite(\"suite1\")\t\t\t\t\t// Arguments for the first suite follow\n      .setSuiteThreadCount(Runtime.getRuntime().availableProcessors()-3, 2,16)  // Leave 1 cpu for the JIT, 1 for GC, 1 for the other suite. But always run at least two threads and never more than 16\n      .setSuiteInventory(inventoryFile1)\t//   Point at the file which lists the tests. There are no exclusion files.\n      .setSuiteNumTests(numTests * 10)    //   Number of tests to run varies with size of inventory file\n      .setSuiteTestRepeatCount(3)\t\t    //   Run each test 3 times\n      .setSuiteThinkingTime(\"5ms\", \"75ms\")//   Waiting time between tests is randomly selected between 5ms and 75ms. Can also use 's' for seconds.\n      .setSuiteSequentialSelection()\t    //   Not random selection. Sequential from start. eg, 0,1,2,3,4,5,0,1,...\n      .addSuite(\"suite2\")\t\t\t\t\t// Add 2nd (optional) suite\n      .setSuiteThreadCount(1)\t\t\t    //   Run in a single thread\n      .setSuiteInventory(inventoryFile2)\t//   Use the sample inventory file, which has 2 exclusion files.\n      .setSuiteNumTests(1000)\t\t\t    //   Run 1000 tests in total\n      .setSuiteTestRepeatCount(25)\t    //   Run which ever test is picked 25 times before picking next test\n      .setSuiteRandomSelection();\t\t    //   Randomly choose test to run. Note this suite doesn't have a 'thinking' time.\n\n  // Run load test and wait for it to finish\n  // Stdout and stderr output will be echoed and prefixed with the 'LT' mnemonic.\n  // The load test will be killed if not completed within the 5 minute time limit.\n  stfCore.doRunForegroundProcess(\"Run load test for project\", \"LT\", ECHO_ON,\n                                  ExpectedOutcome.cleanRun().within(\"5m\"),\n                                  loadTestSpecification);\n}\n```\n\n## The Load Test Program Itself\n\n#### Load test arguments\n\nThe load test application is normally run from within an STF based test, but it\nis a Java program so it can also be run directly.\n\nIt's also quite useful during troubleshooting to modify the load test arguments in the\nexecute.pl for a failing test. The JVM or load test arguments can be editing in a text\neditor whilst repeatedly getting perl to run the execute.pl script in another\ncommand line window.\n\n",
        "start_line": 671,
        "end_line": 713,
        "chunk_index": 8,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 695,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750536"
      },
      "text": "  LoadTestProcessDefinition loadTestSpecification = stfCore.createLoadTestSpecification()\n      .addProjectToClasspath(\"stf.samples\")\n      .addJarToClasspath(JavaProcessDefinition.JarId.JUNIT)\n      .addJarToClasspath(JavaProcessDefinition.JarId.HAMCREST)\n      .setTimeLimit(\"12s\")\t\t\t\t// Don't start any tests after 12 seconds\n      .setMaxTotalLogFileSpace(\"500M\")    // Optional. Prevent logging from exceeding 500M of log files\n      .setMaxSingleLogSize(\"1/50\")        // Optional. Run with limit of 50 logs, each up to 10M.\n      .addSuite(\"suite1\")\t\t\t\t\t// Arguments for the first suite follow\n      .setSuiteThreadCount(Runtime.getRuntime().availableProcessors()-3, 2,16)  // Leave 1 cpu for the JIT, 1 for GC, 1 for the other suite. But always run at least two threads and never more than 16\n      .setSuiteInventory(inventoryFile1)\t//   Point at the file which lists the tests. There are no exclusion files.\n      .setSuiteNumTests(numTests * 10)    //   Number of tests to run varies with size of inventory file\n      .setSuiteTestRepeatCount(3)\t\t    //   Run each test 3 times\n      .setSuiteThinkingTime(\"5ms\", \"75ms\")//   Waiting time between tests is randomly selected between 5ms and 75ms. Can also use 's' for seconds.\n      .setSuiteSequentialSelection()\t    //   Not random selection. Sequential from start. eg, 0,1,2,3,4,5,0,1,...\n      .addSuite(\"suite2\")\t\t\t\t\t// Add 2nd (optional) suite\n      .setSuiteThreadCount(1)\t\t\t    //   Run in a single thread\n      .setSuiteInventory(inventoryFile2)\t//   Use the sample inventory file, which has 2 exclusion files.\n      .setSuiteNumTests(1000)\t\t\t    //   Run 1000 tests in total\n      .setSuiteTestRepeatCount(25)\t    //   Run which ever test is picked 25 times before picking next test\n      .setSuiteRandomSelection();\t\t    //   Randomly choose test to run. Note this suite doesn't have a 'thinking' time.\n\n  // Run load test and wait for it to finish\n  // Stdout and stderr output will be echoed and prefixed with the 'LT' mnemonic.\n  // The load test will be killed if not completed within the 5 minute time limit.\n  stfCore.doRunForegroundProcess(\"Run load test for project\", \"LT\", ECHO_ON,\n                                  ExpectedOutcome.cleanRun().within(\"5m\"),\n                                  loadTestSpecification);\n}\n```\n\n## The Load Test Program Itself\n\n#### Load test arguments\n\nThe load test application is normally run from within an STF based test, but it\nis a Java program so it can also be run directly.\n\nIt's also quite useful during troubleshooting to modify the load test arguments in the\nexecute.pl for a failing test. The JVM or load test arguments can be editing in a text\neditor whilst repeatedly getting perl to run the execute.pl script in another\ncommand line window.\n\n"
    },
    "347": {
      "metadata": {
        "chunk_id": "54a2e550b45eea464b355e4de57d8f33f6e5c225433b88f9c8e90bd1dfa7e18a",
        "file_path": "stf.load/docs/README.md",
        "content": "| Argument                                                         | Comment |\n|------------------------------------------------------------------|---------|\n| -resultsDir {directory}                                          | Mandatory. Is an existing directory to which the results and execution log will be written |\n| -resultsPrefix {name}                                            | Optional string which is used as a prefix to all files written to the results directory |\n| -timeLimit {time-value}                                          | Optional. No tests will be started after running for this long |\n| -abortIfOutOfMemory {boolean}                                    | Optional. Default to 'true' to exist test on out of memory exception. Set to 'false' to keep going |\n| -reportFailureLimit {number}                                     | Optional. This is the number of test failures which will be reported in detail (with name of failing test, stack trace, etc). Set '-1' to disable for reporting of all failing tests |\n| -abortAtFailureLimit {number}                                    | Optional. Load test will abort when this many tests have failed. Set to '-1' to disable so that a run never aborts after a failure |\n| -maxTotalLogFileSpace {number}{unit}                             | Mandatory. Limits the disk space used for execution logging |\n| -maxSingleLogSize {number}{unit} <code>&#124;</code> 1/{number}  | Mandatory. Maximum size for an individual log file. Or calculated as a fraction of maxTotalLogFileSpace (eg '1/20') |\n| -suite.{name}.threadCount {number}                               | Mandatory. Is the number of threads to be used for running the tests of this suite |\n| -suite.{name}.inventoryFile {file}                               | Mandatory. Specifies the file which lists the test that can be run for the suite |\n| -suite.{name}.inventoryExcludeFile {file}                        | Mandatory. If some tests are known to fail and therefore shouldn't be executed then they can be listed in an exclude file. Use the value 'none' if there are no such tests |\n| -suite.{name}.totalNumberTests {number}                          | Optional. This is the number of tests which will run before completing this suite. If not specified the load test will run until the time limit |\n| -suite.{name}.selection 'sequential' <code>&#124;</code> 'random'| Mandatory. Controls how the next test will be selected. When running sequentially it loops back to the start of the inventory after executing the last test in the list |\n| -suite.{name}.seed {number}                                      | Mandatory. Sets the starting value for the random number generator used to select the next text. A value of '-1' will use a new seed. Use a pervious value to duplicate a run |\n| -suite.{name}.repeatCount {number}                               | Optional. This is the number of times that a test will be executed before a different test is selected. Defaults to '1' |\n| -suite.{name}.thinkingTime {number}ms..{number}ms                | Optional. Controls random delay in each load test thread before executing successive tests. Defaults to a disabled value of '0ms..0ms' |\n\nWhere:\n  * {directory} points to an existing directory\n  * {file} points to an existing file\n  * {name} as an ascii string, eg \"1.LT.\"\n  * {time-value} is a series of value and unit pairs. Supports hours, minutes and seconds. eg, \"1h15m\" or \"10s\"\n  * {number} is a whole number, eg \"250\"\n  * {unit} is a single character sizing in the form [g|G|m|M|k|K].\n\n#### Comments about load test arguments\n\nThe load test requires at least one 'suite' to execute. Each batch of suite\narguments are grouped by a common suite name.\n\nA load test run must be bounded to some extent, so if each suite doesn't\nspecify a 'totalNumberTests' value then you must use a '-time-limit' value.\nIf both 'totalNumberTests' and '-time-limit' bounds are set then the load test will\nrun until the either condition becomes true.\n\n## Adding additional load tests\n\nThe general pattern for turning a bunch of unit type tests into a load test is:\n1. Get hold of test source. Third party tests can be added to the prereqs directory. Original test cases and build scripts are added to the appropriate git repo.\n1. Add a new load test class. It's usually easiest to do a copy+paste+modify of\nSampleLoadTest or one of the other load-test based tests.\n1. Create inventory files, listing all of the new tests.\n1. Run and test locally.\n1. Add new test targets to the project/project.build/makefile.\n\n",
        "start_line": 714,
        "end_line": 761,
        "chunk_index": 9,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 982,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750539"
      },
      "text": "| Argument                                                         | Comment |\n|------------------------------------------------------------------|---------|\n| -resultsDir {directory}                                          | Mandatory. Is an existing directory to which the results and execution log will be written |\n| -resultsPrefix {name}                                            | Optional string which is used as a prefix to all files written to the results directory |\n| -timeLimit {time-value}                                          | Optional. No tests will be started after running for this long |\n| -abortIfOutOfMemory {boolean}                                    | Optional. Default to 'true' to exist test on out of memory exception. Set to 'false' to keep going |\n| -reportFailureLimit {number}                                     | Optional. This is the number of test failures which will be reported in detail (with name of failing test, stack trace, etc). Set '-1' to disable for reporting of all failing tests |\n| -abortAtFailureLimit {number}                                    | Optional. Load test will abort when this many tests have failed. Set to '-1' to disable so that a run never aborts after a failure |\n| -maxTotalLogFileSpace {number}{unit}                             | Mandatory. Limits the disk space used for execution logging |\n| -maxSingleLogSize {number}{unit} <code>&#124;</code> 1/{number}  | Mandatory. Maximum size for an individual log file. Or calculated as a fraction of maxTotalLogFileSpace (eg '1/20') |\n| -suite.{name}.threadCount {number}                               | Mandatory. Is the number of threads to be used for running the tests of this suite |\n| -suite.{name}.inventoryFile {file}                               | Mandatory. Specifies the file which lists the test that can be run for the suite |\n| -suite.{name}.inventoryExcludeFile {file}                        | Mandatory. If some tests are known to fail and therefore shouldn't be executed then they can be listed in an exclude file. Use the value 'none' if there are no such tests |\n| -suite.{name}.totalNumberTests {number}                          | Optional. This is the number of tests which will run before completing this suite. If not specified the load test will run until the time limit |\n| -suite.{name}.selection 'sequential' <code>&#124;</code> 'random'| Mandatory. Controls how the next test will be selected. When running sequentially it loops back to the start of the inventory after executing the last test in the list |\n| -suite.{name}.seed {number}                                      | Mandatory. Sets the starting value for the random number generator used to select the next text. A value of '-1' will use a new seed. Use a pervious value to duplicate a run |\n| -suite.{name}.repeatCount {number}                               | Optional. This is the number of times that a test will be executed before a different test is selected. Defaults to '1' |\n| -suite.{name}.thinkingTime {number}ms..{number}ms                | Optional. Controls random delay in each load test thread before executing successive tests. Defaults to a disabled value of '0ms..0ms' |\n\nWhere:\n  * {directory} points to an existing directory\n  * {file} points to an existing file\n  * {name} as an ascii string, eg \"1.LT.\"\n  * {time-value} is a series of value and unit pairs. Supports hours, minutes and seconds. eg, \"1h15m\" or \"10s\"\n  * {number} is a whole number, eg \"250\"\n  * {unit} is a single character sizing in the form [g|G|m|M|k|K].\n\n#### Comments about load test arguments\n\nThe load test requires at least one 'suite' to execute. Each batch of suite\narguments are grouped by a common suite name.\n\nA load test run must be bounded to some extent, so if each suite doesn't\nspecify a 'totalNumberTests' value then you must use a '-time-limit' value.\nIf both 'totalNumberTests' and '-time-limit' bounds are set then the load test will\nrun until the either condition becomes true.\n\n## Adding additional load tests\n\nThe general pattern for turning a bunch of unit type tests into a load test is:\n1. Get hold of test source. Third party tests can be added to the prereqs directory. Original test cases and build scripts are added to the appropriate git repo.\n1. Add a new load test class. It's usually easiest to do a copy+paste+modify of\nSampleLoadTest or one of the other load-test based tests.\n1. Create inventory files, listing all of the new tests.\n1. Run and test locally.\n1. Add new test targets to the project/project.build/makefile.\n\n"
    },
    "348": {
      "metadata": {
        "chunk_id": "583274aaabd890abfb6b3d5edb268cb506e21912c4ead97148eb8063a4fcbdc5",
        "file_path": "stf.load/docs/README.md",
        "content": "The 'run and test locally' step can be quite involved and is probably best broken down into stages.\nIf you are lucky you don't have to go through all stages but the full list from least to\nmost significant is:\n* Run all of the tests in a single thread with a repeat count of 1 1. Filter out the broken tests.\n* Run test single threaded with a repeat count (of say 500, 1000 or 2000) that is significant\nenough to get the dynamic compiler (Oracle Hotspot or IBM JIT) involved. Investigate failures. Filter out broken tests.\n* Run single threaded with random ordering. Do in chunks if there is a really large number of tests.\nSometimes tests will fail because of the actions of an earlier test break a later one. Probably need\nto investigate and decide which test to remove.\n* Run with 2 threads in random order. Investigate failures. Usually concludes with the removal\nof tests which are inherently not thread safe, or do something which impacts other\ntests (changing local, forcing out of memory errors, etc).\n* Run with 2 threads for significant time period. Until running cleanly.\n* Run with more threads. Again for significant time period until clean.\n\nRemember that if the tests require vendor specific features they should be added to the git repo for that vendor.\n\nSome of the reasons why tests are not runnable in a load test are:\n* Test is broken. It won't even pass running it just once in a single threaded test.\n* Badly behaved. Eg, sets machine time or locale, which impacts on other tests.\n* Deliberately forces an out of memory error (breaks other tests).\n* Test never completes.\n* Too fragile. Depends on fixed duration sleeps.\n* Test is not threadsafe. eg, uses a singleton or static data. Can only be run in a single threaded suite.\n* Does AWT GUI operations. Incompatible with other GUI tests. Run single threaded.\n\n## Reproducing failures\n\nThis section lists some techniques which have been used to substantially reduce the reproduction time, or\nimprove the reproduction rate, and in some cases extract the single test which exposes a JVM defect.\n\nFirstly, when faced with an inventory of several thousand tests then several cycles of binary chopping\nthe inventory can reduce reproduction time as the JVM doesn't have to spend time executing irrelevant tests.\n\nTry switching from random test selection to sequential with a repetition of 500 to 1000. If this reproduces\nthen dumping the execution log usually makes it easy to identify the triggering test.\n\nIf the previous point fails to reproduce then the failure may need the concurrent execution of\nanother test. In this circumstance set up another suite running the same tests, with either random selection\nor sequential selection and a different repeat number. If this reproduces then you'll usually see a\nlong list of passing tests from the first suite which then consistently fails as soon as the accomplice test runs.\n\nTry increasing or decreasing the thread count. Paradoxically reproduction rates are typically far better\nwith fewer threads. Can the defect still be exposed when running with a single worker thread?\n\nRunning for longer doesn't always increase the likelihood of detecting a failure. Some JIT related defects\neither happen within the first, say, 5 minutes or not all. This is a circumstance in which setting\na '-timeLimit' argument and STF repeat count can help.\n\nExperiment with Hotspot / JIT options, e.g. '-Xjit:optLevel=hot' forces the IBM JIT compiler to optimise the java classes to the 'hot' level which may make the occurrence of a defect more reliable.\n\nIf the load test has been run by STF, and you're going to be going round the modify/run cycle many times, then\nit's sometimes easiest to edit the previously run 'execute.pl' and manually rerun it.\n\n## Future Enhancements\n\nSome potential future enhancement include:\n* Improved analysis at the test execution log. For example:\n  * Human readable test names (instead of the current test numbers).\n  * Produce a list of tests that overlap the execution of a failing test.\n  * Filter activity for specific threads.\n  * Filter activity for named tests. Calculate failure rate.\n* Add TestNG test adaptor.\n* Allow load test arguments to be overridden on the STF command line. These would take\nprecedence over values specified in the test case. eg, to reproduce the thread count and\nrandom seed for a failing test: ``stf -test=SampleLoadTest -override=\"-suite.suite1.threadCount=4,-suite.suite1.seed=622344555\"``\n* Automatic test isolation. The process of binary chopping lists of tests to get a minimal set with faster reproduction times is quite a mechanical process, so it ought to be possible to automate this.\n\n\n",
        "start_line": 762,
        "end_line": 831,
        "chunk_index": 10,
        "total_chunks": 11,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 982,
        "node_type": null,
        "file_sha": "16af11da768e2cdeb4e73d86a92b813a2ee6a323",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.750541"
      },
      "text": "The 'run and test locally' step can be quite involved and is probably best broken down into stages.\nIf you are lucky you don't have to go through all stages but the full list from least to\nmost significant is:\n* Run all of the tests in a single thread with a repeat count of 1 1. Filter out the broken tests.\n* Run test single threaded with a repeat count (of say 500, 1000 or 2000) that is significant\nenough to get the dynamic compiler (Oracle Hotspot or IBM JIT) involved. Investigate failures. Filter out broken tests.\n* Run single threaded with random ordering. Do in chunks if there is a really large number of tests.\nSometimes tests will fail because of the actions of an earlier test break a later one. Probably need\nto investigate and decide which test to remove.\n* Run with 2 threads in random order. Investigate failures. Usually concludes with the removal\nof tests which are inherently not thread safe, or do something which impacts other\ntests (changing local, forcing out of memory errors, etc).\n* Run with 2 threads for significant time period. Until running cleanly.\n* Run with more threads. Again for significant time period until clean.\n\nRemember that if the tests require vendor specific features they should be added to the git repo for that vendor.\n\nSome of the reasons why tests are not runnable in a load test are:\n* Test is broken. It won't even pass running it just once in a single threaded test.\n* Badly behaved. Eg, sets machine time or locale, which impacts on other tests.\n* Deliberately forces an out of memory error (breaks other tests).\n* Test never completes.\n* Too fragile. Depends on fixed duration sleeps.\n* Test is not threadsafe. eg, uses a singleton or static data. Can only be run in a single threaded suite.\n* Does AWT GUI operations. Incompatible with other GUI tests. Run single threaded.\n\n## Reproducing failures\n\nThis section lists some techniques which have been used to substantially reduce the reproduction time, or\nimprove the reproduction rate, and in some cases extract the single test which exposes a JVM defect.\n\nFirstly, when faced with an inventory of several thousand tests then several cycles of binary chopping\nthe inventory can reduce reproduction time as the JVM doesn't have to spend time executing irrelevant tests.\n\nTry switching from random test selection to sequential with a repetition of 500 to 1000. If this reproduces\nthen dumping the execution log usually makes it easy to identify the triggering test.\n\nIf the previous point fails to reproduce then the failure may need the concurrent execution of\nanother test. In this circumstance set up another suite running the same tests, with either random selection\nor sequential selection and a different repeat number. If this reproduces then you'll usually see a\nlong list of passing tests from the first suite which then consistently fails as soon as the accomplice test runs.\n\nTry increasing or decreasing the thread count. Paradoxically reproduction rates are typically far better\nwith fewer threads. Can the defect still be exposed when running with a single worker thread?\n\nRunning for longer doesn't always increase the likelihood of detecting a failure. Some JIT related defects\neither happen within the first, say, 5 minutes or not all. This is a circumstance in which setting\na '-timeLimit' argument and STF repeat count can help.\n\nExperiment with Hotspot / JIT options, e.g. '-Xjit:optLevel=hot' forces the IBM JIT compiler to optimise the java classes to the 'hot' level which may make the occurrence of a defect more reliable.\n\nIf the load test has been run by STF, and you're going to be going round the modify/run cycle many times, then\nit's sometimes easiest to edit the previously run 'execute.pl' and manually rerun it.\n\n## Future Enhancements\n\nSome potential future enhancement include:\n* Improved analysis at the test execution log. For example:\n  * Human readable test names (instead of the current test numbers).\n  * Produce a list of tests that overlap the execution of a failing test.\n  * Filter activity for specific threads.\n  * Filter activity for named tests. Calculate failure rate.\n* Add TestNG test adaptor.\n* Allow load test arguments to be overridden on the STF command line. These would take\nprecedence over values specified in the test case. eg, to reproduce the thread count and\nrandom seed for a failing test: ``stf -test=SampleLoadTest -override=\"-suite.suite1.threadCount=4,-suite.suite1.seed=622344555\"``\n* Automatic test isolation. The process of binary chopping lists of tests to get a minimal set with faster reproduction times is quite a mechanical process, so it ought to be possible to automate this.\n\n\n"
    },
    "349": {
      "metadata": {
        "chunk_id": "6d776f2d924f8613ddc0906eb635045e48cfac1a970975474325cbc8080faac3",
        "file_path": "stf.load/docs/arguments.md",
        "content": "STF Load Test arguments\n=======================\n\nArgument - 'selection'\n--------------------\nFormat: ``--suite.<suite-name>.selection (random | sequential)``\n\nThis controls....\n\nArgument - 'seed'\n-----------------\nFormat: ``-suite.mauveSingle.seed (-1 | number)\n\nThe default value of '-1 ' tells the load test to pick a new seed for test selection.\n\n\n",
        "start_line": 0,
        "end_line": 16,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 76,
        "node_type": null,
        "file_sha": "264eb2deb99204f2a3b0bcd55c87aea780c5ffd7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.770898"
      },
      "text": "STF Load Test arguments\n=======================\n\nArgument - 'selection'\n--------------------\nFormat: ``--suite.<suite-name>.selection (random | sequential)``\n\nThis controls....\n\nArgument - 'seed'\n-----------------\nFormat: ``-suite.mauveSingle.seed (-1 | number)\n\nThe default value of '-1 ' tells the load test to pick a new seed for test selection.\n\n\n"
    },
    "350": {
      "metadata": {
        "chunk_id": "ce2013c56445c74b62dcb99aae62c5868c667c9d0a312a45823e1d8ecabd6600",
        "file_path": "stf.load/src/stf.load/log4j2.xml",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<Configuration status=\"WARN\" strict=\"true\">\n  <Appenders>\n    <!-- Appender for run of the mill messages going to the console. Minimal extra information -->\n    <Appender type=\"Console\" name=\"InformationAppender\" ignoreExceptions=\"false\">\n      <ThresholdFilter level=\"ERROR\" onMatch=\"DENY\" onMismatch=\"ACCEPT\" />\n      <Layout type=\"PatternLayout\" pattern=\"%d{HH:mm:ss.SSS} - %msg%n\"/>\n    </Appender>\n    \n    <!-- For Error and Fatal messages (shows the level string) -->\n    <Appender type=\"Console\" name=\"ErrorAppender\" ignoreExceptions=\"false\">\n      <ThresholdFilter level=\"ERROR\" onMatch=\"ACCEPT\" />\n      <Layout type=\"PatternLayout\" pattern=\"%d{HH:mm:ss.SSS} - **%level** %msg%n\"/>\n    </Appender>\n  </Appenders>\n\n  <Loggers>\n    <!-- Only handle logging from the load test tool itself.\n      -  Ignore logging from the tests themselves (which will be in a different package.\n      -  For debugging set the logging level to TRACE or DEBUG.\n      -->\n    <Logger name=\"net.adoptopenjdk\" level=\"INFO\" additivity=\"false\">\n      <AppenderRef ref=\"InformationAppender\"/>\n      <AppenderRef ref=\"ErrorAppender\"/>\n    </Logger>\n    <Root level=\"error\">\n    </Root>\n  </Loggers>\n</Configuration>",
        "start_line": 0,
        "end_line": 43,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 427,
        "node_type": null,
        "file_sha": "852e4ed5fd10fcdcebfa05f87c0f19d9d8ba2e8b",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.788382"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<Configuration status=\"WARN\" strict=\"true\">\n  <Appenders>\n    <!-- Appender for run of the mill messages going to the console. Minimal extra information -->\n    <Appender type=\"Console\" name=\"InformationAppender\" ignoreExceptions=\"false\">\n      <ThresholdFilter level=\"ERROR\" onMatch=\"DENY\" onMismatch=\"ACCEPT\" />\n      <Layout type=\"PatternLayout\" pattern=\"%d{HH:mm:ss.SSS} - %msg%n\"/>\n    </Appender>\n    \n    <!-- For Error and Fatal messages (shows the level string) -->\n    <Appender type=\"Console\" name=\"ErrorAppender\" ignoreExceptions=\"false\">\n      <ThresholdFilter level=\"ERROR\" onMatch=\"ACCEPT\" />\n      <Layout type=\"PatternLayout\" pattern=\"%d{HH:mm:ss.SSS} - **%level** %msg%n\"/>\n    </Appender>\n  </Appenders>\n\n  <Loggers>\n    <!-- Only handle logging from the load test tool itself.\n      -  Ignore logging from the tests themselves (which will be in a different package.\n      -  For debugging set the logging level to TRACE or DEBUG.\n      -->\n    <Logger name=\"net.adoptopenjdk\" level=\"INFO\" additivity=\"false\">\n      <AppenderRef ref=\"InformationAppender\"/>\n      <AppenderRef ref=\"ErrorAppender\"/>\n    </Logger>\n    <Root level=\"error\">\n    </Root>\n  </Loggers>\n</Configuration>"
    },
    "351": {
      "metadata": {
        "chunk_id": "b05db33220138f719fd0aa5dcd774f7299636d7b2875d7be8cb39771a1b897a4",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/blockedexitagent/BlockedExitAgent.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.blockedexitagent;\n\nimport java.lang.instrument.*;\nimport java.security.ProtectionDomain;\nimport org.objectweb.asm.*;\nimport org.objectweb.asm.commons.LocalVariablesSorter;\n\nimport static org.objectweb.asm.Opcodes.*;\n\n/*\n * Replace all calls to System.exit for load tests with BlockedExitException.\n * This ensures the test framework will not shut down before all tests\n * have completed.\n */",
        "start_line": 0,
        "end_line": 27,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 207,
        "node_type": null,
        "file_sha": "29886eca2c5cafc73cc954590a651b63193cfea7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.807862"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.blockedexitagent;\n\nimport java.lang.instrument.*;\nimport java.security.ProtectionDomain;\nimport org.objectweb.asm.*;\nimport org.objectweb.asm.commons.LocalVariablesSorter;\n\nimport static org.objectweb.asm.Opcodes.*;\n\n/*\n * Replace all calls to System.exit for load tests with BlockedExitException.\n * This ensures the test framework will not shut down before all tests\n * have completed.\n */"
    },
    "352": {
      "metadata": {
        "chunk_id": "566bfa739f50abc13d22f69fdfb2aed6df771bd61e77e74bd92bfc09045ae6a3",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/blockedexitagent/BlockedExitAgent.java",
        "content": "class BlockedExitAgent {\n    public static void premain(String args, Instrumentation instrumentation) {\n        instrumentation.addTransformer(new BlockedExitTransformer(), true);\n    }\n    static class BlockedExitTransformer implements ClassFileTransformer {\n        @Override\n        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classBytes) {\n            /* System.exit calls in LoadTest class should not be overwritten. */\n            if ((null != loader) && (!className.contains(\"net/adoptopenjdk/loadTest/LoadTest\"))) {    \n                ClassReader cr = new ClassReader(classBytes);\n                ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);\n                cr.accept(new BlockedExitClassVisitor(cw), ClassReader.EXPAND_FRAMES);\n                return cw.toByteArray();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public static class BlockedExitClassVisitor extends ClassVisitor {\n        public BlockedExitClassVisitor(ClassVisitor cv) {\n            super(ASM9, cv);\n        }\n\n        @Override\n        public MethodVisitor visitMethod(int methodAccess, String methodName, String methodDesc, String signature, String[] exceptions) {\n            MethodVisitor methodVisitor = cv.visitMethod(methodAccess, methodName, methodDesc, signature, exceptions);\n            return new BlockedExitMethodVisitor(methodAccess, methodDesc, methodVisitor);\n        }\n    }\n\n    static class BlockedExitMethodVisitor extends LocalVariablesSorter {\n        public BlockedExitMethodVisitor(int access, String descriptor, MethodVisitor methodVisitor) {\n            super(ASM9, access, descriptor, methodVisitor);\n        }\n        \n        @Override\n        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n            if (isSystemExitInsn(opcode, owner, name, descriptor)) {\n                String blockedExitException = \"net/adoptopenjdk/loadTest/BlockedExitException\";\n                /* The bytecode just before this will have loaded the exit code\n                 * onto the stack. Store it in a new local variable so it can\n                 * be passed into the new exception.\n                 */\n                int localId = super.newLocal(Type.INT_TYPE);\n\n                super.visitVarInsn(ISTORE, localId);\n                super.visitTypeInsn(NEW, blockedExitException);\n                super.visitInsn(DUP);\n                super.visitVarInsn(ILOAD, localId);\n                super.visitMethodInsn(INVOKESPECIAL, blockedExitException, \"<init>\", \"(I)V\");\n                super.visitInsn(ATHROW);\n                /* Manually update the stack map frame instead of using COMPUTE_FRAMES which was\n                 * causing a duplicate class loading error.\n                 */\n                super.visitFrame(F_APPEND, 3, new Object[] {INTEGER, INTEGER, \"java/lang/Object\"}, 0, null);\n            } else {\n                super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n            }\n        }\n\n        private boolean isSystemExitInsn(int opcode, String owner, String name, String descriptor) {\n            return (opcode == INVOKESTATIC)\n                && \"java/lang/System\".equals(owner)\n                && \"exit\".equals(name)\n                && \"(I)V\".equals(descriptor);\n        }\n    }\n}",
        "start_line": 28,
        "end_line": 96,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 652,
        "node_type": null,
        "file_sha": "29886eca2c5cafc73cc954590a651b63193cfea7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.807872"
      },
      "text": "class BlockedExitAgent {\n    public static void premain(String args, Instrumentation instrumentation) {\n        instrumentation.addTransformer(new BlockedExitTransformer(), true);\n    }\n    static class BlockedExitTransformer implements ClassFileTransformer {\n        @Override\n        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classBytes) {\n            /* System.exit calls in LoadTest class should not be overwritten. */\n            if ((null != loader) && (!className.contains(\"net/adoptopenjdk/loadTest/LoadTest\"))) {    \n                ClassReader cr = new ClassReader(classBytes);\n                ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);\n                cr.accept(new BlockedExitClassVisitor(cw), ClassReader.EXPAND_FRAMES);\n                return cw.toByteArray();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public static class BlockedExitClassVisitor extends ClassVisitor {\n        public BlockedExitClassVisitor(ClassVisitor cv) {\n            super(ASM9, cv);\n        }\n\n        @Override\n        public MethodVisitor visitMethod(int methodAccess, String methodName, String methodDesc, String signature, String[] exceptions) {\n            MethodVisitor methodVisitor = cv.visitMethod(methodAccess, methodName, methodDesc, signature, exceptions);\n            return new BlockedExitMethodVisitor(methodAccess, methodDesc, methodVisitor);\n        }\n    }\n\n    static class BlockedExitMethodVisitor extends LocalVariablesSorter {\n        public BlockedExitMethodVisitor(int access, String descriptor, MethodVisitor methodVisitor) {\n            super(ASM9, access, descriptor, methodVisitor);\n        }\n        \n        @Override\n        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n            if (isSystemExitInsn(opcode, owner, name, descriptor)) {\n                String blockedExitException = \"net/adoptopenjdk/loadTest/BlockedExitException\";\n                /* The bytecode just before this will have loaded the exit code\n                 * onto the stack. Store it in a new local variable so it can\n                 * be passed into the new exception.\n                 */\n                int localId = super.newLocal(Type.INT_TYPE);\n\n                super.visitVarInsn(ISTORE, localId);\n                super.visitTypeInsn(NEW, blockedExitException);\n                super.visitInsn(DUP);\n                super.visitVarInsn(ILOAD, localId);\n                super.visitMethodInsn(INVOKESPECIAL, blockedExitException, \"<init>\", \"(I)V\");\n                super.visitInsn(ATHROW);\n                /* Manually update the stack map frame instead of using COMPUTE_FRAMES which was\n                 * causing a duplicate class loading error.\n                 */\n                super.visitFrame(F_APPEND, 3, new Object[] {INTEGER, INTEGER, \"java/lang/Object\"}, 0, null);\n            } else {\n                super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n            }\n        }\n\n        private boolean isSystemExitInsn(int opcode, String owner, String name, String descriptor) {\n            return (opcode == INVOKESTATIC)\n                && \"java/lang/System\".equals(owner)\n                && \"exit\".equals(name)\n                && \"(I)V\".equals(descriptor);\n        }\n    }\n}"
    },
    "353": {
      "metadata": {
        "chunk_id": "77a1dcdc5317010626e3d47a6d2ec40b823f8fca6fb967dd4719d9dd446b694a",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/BlockedExitException.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\n\n/**\n * STF load tests prevents test code from terminating a process if some of the test\n * code calls System.exit().\n * \n * Attempts to exit the process are blocked by a custom security manager. This exception\n * is thrown to reject the exit request.\n * \n * An attempt to exit with non-zero value is used to indicate that the test failed. \n */\npublic class BlockedExitException extends SecurityException {\n\tprivate static final long serialVersionUID = 98234872344L;\n\t\n\tprivate int exitValue;\n\t\n\tpublic BlockedExitException(int exitValue) {\n\t\tsuper();\n\t\tthis.exitValue = exitValue;\n\t}\n\n\tpublic int getExitValue() {\n\t\treturn exitValue;\n\t}\n}",
        "start_line": 0,
        "end_line": 39,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 272,
        "node_type": null,
        "file_sha": "5ef32b5ada6b272f4a2a2511573534cc7af03cd9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.829110"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\n\n/**\n * STF load tests prevents test code from terminating a process if some of the test\n * code calls System.exit().\n * \n * Attempts to exit the process are blocked by a custom security manager. This exception\n * is thrown to reject the exit request.\n * \n * An attempt to exit with non-zero value is used to indicate that the test failed. \n */\npublic class BlockedExitException extends SecurityException {\n\tprivate static final long serialVersionUID = 98234872344L;\n\t\n\tprivate int exitValue;\n\t\n\tpublic BlockedExitException(int exitValue) {\n\t\tsuper();\n\t\tthis.exitValue = exitValue;\n\t}\n\n\tpublic int getExitValue() {\n\t\treturn exitValue;\n\t}\n}"
    },
    "354": {
      "metadata": {
        "chunk_id": "b115d4ed8445d2b51fbc47f7b266f4a4547dcaefe7d25ed9d0547f2bca00c5d5",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/FirstFailureDumper.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.loadTest.adaptors.LoadTestBase;\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class creates a set of java dumps when running on an OpenJ9 based JVM.\n * It has no effect when running on a hotspot based JVM.\n * \n * The 'createDumps()' method should only be called when load test has had its first failure.\n */",
        "start_line": 0,
        "end_line": 31,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 247,
        "node_type": null,
        "file_sha": "6964f0babbe2abfbc9a137fa65b7c27ce1e2eed0",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.849218"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.loadTest.adaptors.LoadTestBase;\nimport net.adoptopenjdk.stf.StfException;\n\n\n/**\n * This class creates a set of java dumps when running on an OpenJ9 based JVM.\n * It has no effect when running on a hotspot based JVM.\n * \n * The 'createDumps()' method should only be called when load test has had its first failure.\n */"
    },
    "355": {
      "metadata": {
        "chunk_id": "f9a4e5acc8d8495c1d7eb3ad8dadd89a3ea6fdedc60e93f13082022de50c9600",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/FirstFailureDumper.java",
        "content": "public class FirstFailureDumper {\n\tprivate static final Logger logger = LogManager.getLogger(FirstFailureDumper.class.getName());\n\n\tprivate static FirstFailureDumper instance = null;\n\t\n\tprivate static final String HEAPDUMP_FILE_NAME   = \"firstfailure.heapdump.%Y%m%d.%H%M%S.%pid.%seq.phd\";\n\tprivate static final String JAVADUMP_FILE_NAME   = \"firstfailure.javacore.%Y%m%d.%H%M%S.%pid.%seq.txt\";\n    private static final String SYSTEMDUMP_FILE_NAME = \"firstfailure.core.%Y%m%d.%H%M%S.%pid.%seq.dmp\";\n\n    // Dump methods accessed via reflection, so that this code can be compiled and \n    // executed on an Oracle JVM.\n    private final boolean isJ9;\n    private final Method heapDumpMethod;\n    private final Method javaDumpMethod;\n    private final Method systemDumpMethod;\n    \n    private boolean haveCreatedFirstFailureDumps = false;\n    \n    \n    /**\n     * Constructor uses reflection to get hold of method references to the dump methods.\n     * @throws StfException if there was a reflection related exception.\n     */\n    private FirstFailureDumper() throws StfException {\n    \tString jvmVendor = System.getProperty(\"java.vm.vendor\");\n    \tif (jvmVendor != null && ( jvmVendor.contains(\"IBM\") || jvmVendor.contains(\"OpenJ9\") ) ) {\n    \t\tthis.isJ9 = true;\n\t\t\ttry {\n\t\t\t\t// Get a reference to the IBM only dump methods.\n\t\t\t\tClass<?> dumpClass = Class.forName(\"com.ibm.jvm.Dump\");\n\t\t\t\tthis.heapDumpMethod = dumpClass.getDeclaredMethod(\"heapDumpToFile\", String.class);\n\t\t\t\tthis.javaDumpMethod = dumpClass.getDeclaredMethod(\"javaDumpToFile\", String.class);\n\t\t\t\tthis.systemDumpMethod = dumpClass.getDeclaredMethod(\"systemDumpToFile\", String.class);\n\t\t\t\t\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new StfException(\"Failed to access IBM Dump class\", e);\n\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\tthrow new StfException(\"Failed to access IBM Dump method\", e);\n\t\t\t} catch (SecurityException e) {\n\t\t\t\tthrow new StfException(\"Failed to access IBM Dump class\", e);\n\t\t\t}\n\n    \t} else {\n        \tthis.isJ9 = false;\n    \t\tthis.heapDumpMethod = null;\n    \t\tthis.javaDumpMethod = null;\n    \t\tthis.systemDumpMethod = null;\n    \t}\n    }\n\t\n    \n    /**\n     * Creates a first failure dumper object. Must be called before usage\n     */\n    public synchronized static void createInstance() throws StfException {\n    \tif (FirstFailureDumper.instance == null) {\n    \t\tFirstFailureDumper.instance = new FirstFailureDumper();\n    \t}\n    }\n\n    \n    /**\n     * Get hold of an instance of the FirstFailureDumper.\n     */\n    public synchronized static FirstFailureDumper instance() {\n    \tif (FirstFailureDumper.instance == null) {\n    \t\tthrow new IllegalStateException(\"FirstFailureDumper does not exist. Must be created before use\");\n    \t}\n    \t\n    \treturn FirstFailureDumper.instance;\n    }\n\n    \n    /**\n     * This methods creates a set of heap, java and system dumps.\n     * It should be called when load test has its first failure.\n     * @throws StfException if a dump method could not be called.\n     */\n    public synchronized void createDumpIfFirstFailure(LoadTestBase test, boolean dumpRequested) {\n        if (haveCreatedFirstFailureDumps) { \n        \treturn;\n        }\n\t\t\n        if (isJ9 && dumpRequested) {\n\t\t\tlogger.info(\"First failure detected by thread: \" + Thread.currentThread().getName() + \". Running test: \" + test.toString() + \". Creating java dumps.\");\n\t\t\tcreateDump(\"heap\", heapDumpMethod, HEAPDUMP_FILE_NAME);\n\t\t\tcreateDump(\"java\", javaDumpMethod, JAVADUMP_FILE_NAME);\n\t\t\tcreateDump(\"system\", systemDumpMethod, SYSTEMDUMP_FILE_NAME);\n\t\t\t\n\t\t} else {\n\t\t\tif (!dumpRequested) {\n\t\t\t\tlogger.info(\"First failure detected by thread: \" + Thread.currentThread().getName() + \". Not creating dumps as no dump generation is requested for this load test\");\n\t\t\t} else { \n\t\t\t\tlogger.info(\"First failure detected by thread: \" + Thread.currentThread().getName() + \". Not creating dumps as not running on an IBM JVM\");\n\t\t\t}\n\t\t}\n\t\t\n\t\thaveCreatedFirstFailureDumps = true;\n\t}",
        "start_line": 32,
        "end_line": 130,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 930,
        "node_type": null,
        "file_sha": "6964f0babbe2abfbc9a137fa65b7c27ce1e2eed0",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.849225"
      },
      "text": "public class FirstFailureDumper {\n\tprivate static final Logger logger = LogManager.getLogger(FirstFailureDumper.class.getName());\n\n\tprivate static FirstFailureDumper instance = null;\n\t\n\tprivate static final String HEAPDUMP_FILE_NAME   = \"firstfailure.heapdump.%Y%m%d.%H%M%S.%pid.%seq.phd\";\n\tprivate static final String JAVADUMP_FILE_NAME   = \"firstfailure.javacore.%Y%m%d.%H%M%S.%pid.%seq.txt\";\n    private static final String SYSTEMDUMP_FILE_NAME = \"firstfailure.core.%Y%m%d.%H%M%S.%pid.%seq.dmp\";\n\n    // Dump methods accessed via reflection, so that this code can be compiled and \n    // executed on an Oracle JVM.\n    private final boolean isJ9;\n    private final Method heapDumpMethod;\n    private final Method javaDumpMethod;\n    private final Method systemDumpMethod;\n    \n    private boolean haveCreatedFirstFailureDumps = false;\n    \n    \n    /**\n     * Constructor uses reflection to get hold of method references to the dump methods.\n     * @throws StfException if there was a reflection related exception.\n     */\n    private FirstFailureDumper() throws StfException {\n    \tString jvmVendor = System.getProperty(\"java.vm.vendor\");\n    \tif (jvmVendor != null && ( jvmVendor.contains(\"IBM\") || jvmVendor.contains(\"OpenJ9\") ) ) {\n    \t\tthis.isJ9 = true;\n\t\t\ttry {\n\t\t\t\t// Get a reference to the IBM only dump methods.\n\t\t\t\tClass<?> dumpClass = Class.forName(\"com.ibm.jvm.Dump\");\n\t\t\t\tthis.heapDumpMethod = dumpClass.getDeclaredMethod(\"heapDumpToFile\", String.class);\n\t\t\t\tthis.javaDumpMethod = dumpClass.getDeclaredMethod(\"javaDumpToFile\", String.class);\n\t\t\t\tthis.systemDumpMethod = dumpClass.getDeclaredMethod(\"systemDumpToFile\", String.class);\n\t\t\t\t\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new StfException(\"Failed to access IBM Dump class\", e);\n\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\tthrow new StfException(\"Failed to access IBM Dump method\", e);\n\t\t\t} catch (SecurityException e) {\n\t\t\t\tthrow new StfException(\"Failed to access IBM Dump class\", e);\n\t\t\t}\n\n    \t} else {\n        \tthis.isJ9 = false;\n    \t\tthis.heapDumpMethod = null;\n    \t\tthis.javaDumpMethod = null;\n    \t\tthis.systemDumpMethod = null;\n    \t}\n    }\n\t\n    \n    /**\n     * Creates a first failure dumper object. Must be called before usage\n     */\n    public synchronized static void createInstance() throws StfException {\n    \tif (FirstFailureDumper.instance == null) {\n    \t\tFirstFailureDumper.instance = new FirstFailureDumper();\n    \t}\n    }\n\n    \n    /**\n     * Get hold of an instance of the FirstFailureDumper.\n     */\n    public synchronized static FirstFailureDumper instance() {\n    \tif (FirstFailureDumper.instance == null) {\n    \t\tthrow new IllegalStateException(\"FirstFailureDumper does not exist. Must be created before use\");\n    \t}\n    \t\n    \treturn FirstFailureDumper.instance;\n    }\n\n    \n    /**\n     * This methods creates a set of heap, java and system dumps.\n     * It should be called when load test has its first failure.\n     * @throws StfException if a dump method could not be called.\n     */\n    public synchronized void createDumpIfFirstFailure(LoadTestBase test, boolean dumpRequested) {\n        if (haveCreatedFirstFailureDumps) { \n        \treturn;\n        }\n\t\t\n        if (isJ9 && dumpRequested) {\n\t\t\tlogger.info(\"First failure detected by thread: \" + Thread.currentThread().getName() + \". Running test: \" + test.toString() + \". Creating java dumps.\");\n\t\t\tcreateDump(\"heap\", heapDumpMethod, HEAPDUMP_FILE_NAME);\n\t\t\tcreateDump(\"java\", javaDumpMethod, JAVADUMP_FILE_NAME);\n\t\t\tcreateDump(\"system\", systemDumpMethod, SYSTEMDUMP_FILE_NAME);\n\t\t\t\n\t\t} else {\n\t\t\tif (!dumpRequested) {\n\t\t\t\tlogger.info(\"First failure detected by thread: \" + Thread.currentThread().getName() + \". Not creating dumps as no dump generation is requested for this load test\");\n\t\t\t} else { \n\t\t\t\tlogger.info(\"First failure detected by thread: \" + Thread.currentThread().getName() + \". Not creating dumps as not running on an IBM JVM\");\n\t\t\t}\n\t\t}\n\t\t\n\t\thaveCreatedFirstFailureDumps = true;\n\t}"
    },
    "356": {
      "metadata": {
        "chunk_id": "c171a7b8e8ca3afcceb18139ac4a44340c37448ac047c2b9946bf3ff459a4051",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/FirstFailureDumper.java",
        "content": "// Create a dump. If there is an exception during dump creation then \n    // it is logged but not propagated, as the test has already failed.\n\tprivate void createDump(String dumpType, Method dumpMethod, String dumpFileName) {\n\t\ttry {\n\t\t\tdumpMethod.invoke(null, dumpFileName);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tlogger.error(\"Failed to create a \" + dumpType + \"Dump\", e);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tlogger.error(\"Failed to create a \" + dumpType + \"Dump\", e);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tlogger.error(\"Failed to create a \" + dumpType + \"Dump\", e);\n\t\t}\n\t}\t\n}",
        "start_line": 131,
        "end_line": 144,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 150,
        "node_type": null,
        "file_sha": "6964f0babbe2abfbc9a137fa65b7c27ce1e2eed0",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.849228"
      },
      "text": "// Create a dump. If there is an exception during dump creation then \n    // it is logged but not propagated, as the test has already failed.\n\tprivate void createDump(String dumpType, Method dumpMethod, String dumpFileName) {\n\t\ttry {\n\t\t\tdumpMethod.invoke(null, dumpFileName);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tlogger.error(\"Failed to create a \" + dumpType + \"Dump\", e);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tlogger.error(\"Failed to create a \" + dumpType + \"Dump\", e);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tlogger.error(\"Failed to create a \" + dumpType + \"Dump\", e);\n\t\t}\n\t}\t\n}"
    },
    "357": {
      "metadata": {
        "chunk_id": "a93c747c8fdc5808f5cde8aff0878811b9a48af93aa6184e5615d5bc7cca174f",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/InventoryData.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\nimport net.adoptopenjdk.loadTest.adaptors.ArbitraryJavaAdaptor;\nimport net.adoptopenjdk.loadTest.adaptors.JUnitAdaptor;\nimport net.adoptopenjdk.loadTest.adaptors.MauveAdaptor;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.processes.definitions.LoadTestProcessDefinition;\n\n\n/**\n * This class parses an XML file containing a list of tests and gives access to \n * the resulting test objects.\n */",
        "start_line": 0,
        "end_line": 47,
        "chunk_index": 0,
        "total_chunks": 7,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 382,
        "node_type": null,
        "file_sha": "28301cca2157a1a6bc626c8096dff8b7a605e012",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.871378"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\nimport net.adoptopenjdk.loadTest.adaptors.ArbitraryJavaAdaptor;\nimport net.adoptopenjdk.loadTest.adaptors.JUnitAdaptor;\nimport net.adoptopenjdk.loadTest.adaptors.MauveAdaptor;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.processes.definitions.LoadTestProcessDefinition;\n\n\n/**\n * This class parses an XML file containing a list of tests and gives access to \n * the resulting test objects.\n */"
    },
    "358": {
      "metadata": {
        "chunk_id": "f6534c0b91be5db7e170426b2ba391d7215a476c99140219309703f95bb6da62",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/InventoryData.java",
        "content": "public class InventoryData {\n    private static final Logger logger = LogManager.getLogger(InventoryData.class.getName());\n    \n    private String inventoryFileRef;\n\t\n    // Set to true if this instance doesn't need to execute tests, but is only counting how many there are.\n\tprivate boolean countingOnly = false;\n\t\n\tprivate boolean verbose = false;\n\t\n\t// Allocation a unique number to each test. Doesn't reset for each inventory\n\tprivate final ArrayList<AdaptorInterface> testList;\n\tprivate static int nextTestNum = 0;\n\n\t// This is the multiplier to be applied to all weightings so that randomly selected \n\t// tests have a distribution as close as is reasonably possible to the desired distribution.\n\tprivate BigDecimal weightingMultiplier = BigDecimal.ONE;\n\t\n\t// This is the maximum allowed size of the test lookup table (for randomly selecting tests)\n\t// Lower values potentially use less memory, but will sometimes mean that the exact weightings\n\t// cannot be honoured.\n\tprivate static int MAX_WEIGHTING_LOOKUP_SIZE = 500000;\n\n\tprivate static boolean dumpRequested = false; \n\t\n\t/**\n\t * Parse an XML test 'inventory' file (which lists the tests to be run for the\n\t * current suite) and build the Objects for each individual test execution.\n\t * It also reads lists of tests from exclusion files and removes these tests.\n\t * eg, Tests can be removed from say 'mauvePt1.xml' if you have a file called 'mauvePt1_exclude_PR106330.xml'\n\t * Any number of exclusion files are processed, providing that their name starts with\n\t * the inventory name plus '_exclude'.\n\t * \n\t * @param root is a directory below which all inventory files are referenced.\n\t * @param inventoryFileRef points to an inventory file below the root directory to read.\n\t * @param exclusionFiles is a list of files listing tests that are not to run. \n\t * These tests are removed from the tests listed in the inventoryFileName file.\n\t * The exclusion files are also specified as paths below the root directory.\n\t * @param verbose should be set to true for debug level progress reporting.\n\t */\n\tInventoryData(ArrayList<DirectoryRef> testRoots, String inventoryFileRef, ArrayList<String> exclusionFiles, boolean countingOnly, boolean verbose, boolean dumpRequested) throws Exception {\n\t\tthis.inventoryFileRef = inventoryFileRef;\n\t\tthis.countingOnly = countingOnly;\n\t\tthis.verbose = verbose;\n\t\tthis.dumpRequested = dumpRequested; \n\t\t\n\t\t// Read the inventory file and any which it includes\n\t\ttestList = readInventoryFile(testRoots, inventoryFileRef);\n\t\t\n\t\t// Read any exclusions, and remove their tests from the main list\n\t\tfor (String exclusionFileRef : exclusionFiles) {\n\t\t\tif (verbose) {\n\t\t\t\tlogger.info(\"Reading exclusion file. File=\" + exclusionFileRef);\n\t\t\t}\n\t\t\tArrayList<AdaptorInterface> exclusions = readInventoryFile(testRoots, exclusionFileRef);\n\t\t\ttestList.removeAll(exclusions);\n\t\t}\n\t\t\n\t\tthis.weightingMultiplier = calculateWeightingMultiplier(testList);\n\n\t\t// List the tests to be used\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Final test list:\");\n\t\t\tString adjustedWeightingString = \" \";\n\t\t\tfor (AdaptorInterface test : testList) {\n\t\t\t\tif (weightingMultiplier.intValue() > 1) {\n\t\t\t\t\tint roundedWeighting = test.getRoundedAdjustedWeighting(weightingMultiplier);\n\t\t\t\t\tadjustedWeightingString = \"->\" + roundedWeighting;\n\t\t\t\t}\n\t\t\t\tlogger.info(\"  \" + test.getTestNum() + \" \" + test + \"  Weighting=\" + test.getWeighting() + adjustedWeightingString);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate ArrayList<AdaptorInterface> readInventoryFile(ArrayList<DirectoryRef> testRoots, String inventoryFileRef) throws SAXException, IOException,\n\t\t\tParserConfigurationException, ClassNotFoundException, NoSuchMethodException, StfException {\n\n\t\t// Find the inventory file\n\n\t\tDirectoryRef root = FileRef.findFileRoot(inventoryFileRef, testRoots);\n\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Parsing inventory file. Root=\" + root + \" File=\" + inventoryFileRef);\n\t\t}",
        "start_line": 48,
        "end_line": 131,
        "chunk_index": 1,
        "total_chunks": 7,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 873,
        "node_type": null,
        "file_sha": "28301cca2157a1a6bc626c8096dff8b7a605e012",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.871386"
      },
      "text": "public class InventoryData {\n    private static final Logger logger = LogManager.getLogger(InventoryData.class.getName());\n    \n    private String inventoryFileRef;\n\t\n    // Set to true if this instance doesn't need to execute tests, but is only counting how many there are.\n\tprivate boolean countingOnly = false;\n\t\n\tprivate boolean verbose = false;\n\t\n\t// Allocation a unique number to each test. Doesn't reset for each inventory\n\tprivate final ArrayList<AdaptorInterface> testList;\n\tprivate static int nextTestNum = 0;\n\n\t// This is the multiplier to be applied to all weightings so that randomly selected \n\t// tests have a distribution as close as is reasonably possible to the desired distribution.\n\tprivate BigDecimal weightingMultiplier = BigDecimal.ONE;\n\t\n\t// This is the maximum allowed size of the test lookup table (for randomly selecting tests)\n\t// Lower values potentially use less memory, but will sometimes mean that the exact weightings\n\t// cannot be honoured.\n\tprivate static int MAX_WEIGHTING_LOOKUP_SIZE = 500000;\n\n\tprivate static boolean dumpRequested = false; \n\t\n\t/**\n\t * Parse an XML test 'inventory' file (which lists the tests to be run for the\n\t * current suite) and build the Objects for each individual test execution.\n\t * It also reads lists of tests from exclusion files and removes these tests.\n\t * eg, Tests can be removed from say 'mauvePt1.xml' if you have a file called 'mauvePt1_exclude_PR106330.xml'\n\t * Any number of exclusion files are processed, providing that their name starts with\n\t * the inventory name plus '_exclude'.\n\t * \n\t * @param root is a directory below which all inventory files are referenced.\n\t * @param inventoryFileRef points to an inventory file below the root directory to read.\n\t * @param exclusionFiles is a list of files listing tests that are not to run. \n\t * These tests are removed from the tests listed in the inventoryFileName file.\n\t * The exclusion files are also specified as paths below the root directory.\n\t * @param verbose should be set to true for debug level progress reporting.\n\t */\n\tInventoryData(ArrayList<DirectoryRef> testRoots, String inventoryFileRef, ArrayList<String> exclusionFiles, boolean countingOnly, boolean verbose, boolean dumpRequested) throws Exception {\n\t\tthis.inventoryFileRef = inventoryFileRef;\n\t\tthis.countingOnly = countingOnly;\n\t\tthis.verbose = verbose;\n\t\tthis.dumpRequested = dumpRequested; \n\t\t\n\t\t// Read the inventory file and any which it includes\n\t\ttestList = readInventoryFile(testRoots, inventoryFileRef);\n\t\t\n\t\t// Read any exclusions, and remove their tests from the main list\n\t\tfor (String exclusionFileRef : exclusionFiles) {\n\t\t\tif (verbose) {\n\t\t\t\tlogger.info(\"Reading exclusion file. File=\" + exclusionFileRef);\n\t\t\t}\n\t\t\tArrayList<AdaptorInterface> exclusions = readInventoryFile(testRoots, exclusionFileRef);\n\t\t\ttestList.removeAll(exclusions);\n\t\t}\n\t\t\n\t\tthis.weightingMultiplier = calculateWeightingMultiplier(testList);\n\n\t\t// List the tests to be used\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Final test list:\");\n\t\t\tString adjustedWeightingString = \" \";\n\t\t\tfor (AdaptorInterface test : testList) {\n\t\t\t\tif (weightingMultiplier.intValue() > 1) {\n\t\t\t\t\tint roundedWeighting = test.getRoundedAdjustedWeighting(weightingMultiplier);\n\t\t\t\t\tadjustedWeightingString = \"->\" + roundedWeighting;\n\t\t\t\t}\n\t\t\t\tlogger.info(\"  \" + test.getTestNum() + \" \" + test + \"  Weighting=\" + test.getWeighting() + adjustedWeightingString);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate ArrayList<AdaptorInterface> readInventoryFile(ArrayList<DirectoryRef> testRoots, String inventoryFileRef) throws SAXException, IOException,\n\t\t\tParserConfigurationException, ClassNotFoundException, NoSuchMethodException, StfException {\n\n\t\t// Find the inventory file\n\n\t\tDirectoryRef root = FileRef.findFileRoot(inventoryFileRef, testRoots);\n\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Parsing inventory file. Root=\" + root + \" File=\" + inventoryFileRef);\n\t\t}"
    },
    "359": {
      "metadata": {
        "chunk_id": "563e6c949b5736eeb09ada0185fe1abebed98fd8e409deb210309822fb8c7b78",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/InventoryData.java",
        "content": "private ArrayList<AdaptorInterface> readInventoryFile(ArrayList<DirectoryRef> testRoots, String inventoryFileRef) throws SAXException, IOException,\n\t\t\tParserConfigurationException, ClassNotFoundException, NoSuchMethodException, StfException {\n\n\t\t// Find the inventory file\n\n\t\tDirectoryRef root = FileRef.findFileRoot(inventoryFileRef, testRoots);\n\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Parsing inventory file. Root=\" + root + \" File=\" + inventoryFileRef);\n\t\t}\n\n\t\t// Validate inventory file\n\t\tFile inventoryFile = root.childFile(inventoryFileRef).asJavaFile();\n\t\tif (!inventoryFile.exists()) {\n\t\t\tthrow new IllegalStateException(\"Inventory file does not exist: \" + inventoryFile);\n\t\t}\n\n\t\t// Open inventory file as xml document\n\t\tDocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n\t\tDocument doc = dbFactory.newDocumentBuilder().parse(inventoryFile);\n\t\t\n\t\t// Process every top level 'inventory' node\n\t\tArrayList<AdaptorInterface> tests = new ArrayList<AdaptorInterface>();\n\t\tfor (int i = 0; i < doc.getChildNodes().getLength(); i++) {\n\t\t\tNode inventoryNode = doc.getChildNodes().item(i);\n\t\t\tif (!inventoryNode.getNodeName().equals(\"inventory\") && !inventoryNode.getNodeName().equals(\"#comment\")) {\n\t\t\t\tthrow new IllegalStateException(\"Expected 'inventory' node but was '\" + inventoryNode.getNodeName());\n\t\t\t}\n\n\t\t\t// Parse inventory content. Expecting a list of tests\n\t\t\tNodeList testNodes = inventoryNode.getChildNodes();\n\t\t\tint nodeNumber = 0;\n\t\t\tfor (int j=0; j<testNodes.getLength(); j++) {\n\t\t\t\tNode testNode = testNodes.item(j);\n\t\t\t\tif (testNode.getNodeType() == Node.TEXT_NODE || testNode.getNodeType() == Node.COMMENT_NODE) {\n\t\t\t\t\tcontinue;  // Ignore text and comment nodes\n\t\t\t\t}\n\t\t\t\tnodeNumber++;\n\t\t\t\t\n\t\t\t\tString testType = testNode.getNodeName();\n\t\t\t\tif (testType.equals(\"mauve\")) {\n\t\t\t\t\t// Call old style gnu java tests\n\t\t\t\t\t// Validate attributes\n\t\t\t\t\tString[] mandatoryArgs = new String[]{ \"class\" };\n\t\t\t\t\tString[] optionalArgs  = new String[]{ \"weighting\" };\n\t\t\t\t\tvalidateNodeContents(testNode, inventoryFileRef, nodeNumber, \"mauve\", optionalArgs, mandatoryArgs);\n\t\t\t\t\t\n\t\t\t\t\t// Grab the mauve class name and weighting\n\t\t\t\t\tString mauveFullClassname = testNode.getAttributes().getNamedItem(\"class\").getNodeValue();\n\t\t\t\t\tBigDecimal weighting = parseWeighting(testNode, inventoryFileRef, nodeNumber);\n\t\t\t\t\t\n\t\t\t\t\tAdaptorInterface testcase = new MauveAdaptor(nextTestNum, mauveFullClassname, weighting, dumpRequested);\n\t\t\t\t\ttests.add(testcase);\n\t\t\t\t\tnextTestNum++;\n\t\t\t\t\t\t\n\t\t\t\t} else if (testType.equals(\"arbitraryJava\")) {\n\t\t\t\t\t// Run any java method\n\t\t\t\t\tString[] mandatoryArgs = new String[]{ \"class\", \"method\" };\n\t\t\t\t\tString[] optionalArgs  = new String[]{ \"constructorArguments\", \"methodArguments\", \"weighting\" };\n\t\t\t\t\tvalidateNodeContents(testNode, inventoryFileRef, nodeNumber, \"arbitraryJava\", optionalArgs, mandatoryArgs);\n\t\t\t\t\t\n\t\t\t\t\tString classname = testNode.getAttributes().getNamedItem(\"class\").getNodeValue();\n\t\t\t\t\tString methodName = testNode.getAttributes().getNamedItem(\"method\").getNodeValue();\n\t\t\t\t\tBigDecimal weighting = parseWeighting(testNode, inventoryFileRef, nodeNumber);\n\t\t\t\t\t\n\t\t\t\t\t// Parse optional argument for constructor+method arguments, which can specify a comma separated list of strings\n\t\t\t\t\tArrayList<String> constructorArgs = parseArgumentList(testNode, \"constructorArguments\");\n\t\t\t\t\tArrayList<String> methodArgs = parseArgumentList(testNode, \"methodArguments\");\n\t\t\t\t\t\n\t\t\t\t\tAdaptorInterface testcase = new ArbitraryJavaAdaptor(nextTestNum, classname, constructorArgs, methodName, methodArgs, weighting, countingOnly, dumpRequested);\n\t\t\t\t\ttests.add(testcase);\n\t\t\t\t\tnextTestNum++;",
        "start_line": 132,
        "end_line": 203,
        "chunk_index": 2,
        "total_chunks": 7,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 832,
        "node_type": null,
        "file_sha": "28301cca2157a1a6bc626c8096dff8b7a605e012",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.871389"
      },
      "text": "private ArrayList<AdaptorInterface> readInventoryFile(ArrayList<DirectoryRef> testRoots, String inventoryFileRef) throws SAXException, IOException,\n\t\t\tParserConfigurationException, ClassNotFoundException, NoSuchMethodException, StfException {\n\n\t\t// Find the inventory file\n\n\t\tDirectoryRef root = FileRef.findFileRoot(inventoryFileRef, testRoots);\n\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Parsing inventory file. Root=\" + root + \" File=\" + inventoryFileRef);\n\t\t}\n\n\t\t// Validate inventory file\n\t\tFile inventoryFile = root.childFile(inventoryFileRef).asJavaFile();\n\t\tif (!inventoryFile.exists()) {\n\t\t\tthrow new IllegalStateException(\"Inventory file does not exist: \" + inventoryFile);\n\t\t}\n\n\t\t// Open inventory file as xml document\n\t\tDocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n\t\tDocument doc = dbFactory.newDocumentBuilder().parse(inventoryFile);\n\t\t\n\t\t// Process every top level 'inventory' node\n\t\tArrayList<AdaptorInterface> tests = new ArrayList<AdaptorInterface>();\n\t\tfor (int i = 0; i < doc.getChildNodes().getLength(); i++) {\n\t\t\tNode inventoryNode = doc.getChildNodes().item(i);\n\t\t\tif (!inventoryNode.getNodeName().equals(\"inventory\") && !inventoryNode.getNodeName().equals(\"#comment\")) {\n\t\t\t\tthrow new IllegalStateException(\"Expected 'inventory' node but was '\" + inventoryNode.getNodeName());\n\t\t\t}\n\n\t\t\t// Parse inventory content. Expecting a list of tests\n\t\t\tNodeList testNodes = inventoryNode.getChildNodes();\n\t\t\tint nodeNumber = 0;\n\t\t\tfor (int j=0; j<testNodes.getLength(); j++) {\n\t\t\t\tNode testNode = testNodes.item(j);\n\t\t\t\tif (testNode.getNodeType() == Node.TEXT_NODE || testNode.getNodeType() == Node.COMMENT_NODE) {\n\t\t\t\t\tcontinue;  // Ignore text and comment nodes\n\t\t\t\t}\n\t\t\t\tnodeNumber++;\n\t\t\t\t\n\t\t\t\tString testType = testNode.getNodeName();\n\t\t\t\tif (testType.equals(\"mauve\")) {\n\t\t\t\t\t// Call old style gnu java tests\n\t\t\t\t\t// Validate attributes\n\t\t\t\t\tString[] mandatoryArgs = new String[]{ \"class\" };\n\t\t\t\t\tString[] optionalArgs  = new String[]{ \"weighting\" };\n\t\t\t\t\tvalidateNodeContents(testNode, inventoryFileRef, nodeNumber, \"mauve\", optionalArgs, mandatoryArgs);\n\t\t\t\t\t\n\t\t\t\t\t// Grab the mauve class name and weighting\n\t\t\t\t\tString mauveFullClassname = testNode.getAttributes().getNamedItem(\"class\").getNodeValue();\n\t\t\t\t\tBigDecimal weighting = parseWeighting(testNode, inventoryFileRef, nodeNumber);\n\t\t\t\t\t\n\t\t\t\t\tAdaptorInterface testcase = new MauveAdaptor(nextTestNum, mauveFullClassname, weighting, dumpRequested);\n\t\t\t\t\ttests.add(testcase);\n\t\t\t\t\tnextTestNum++;\n\t\t\t\t\t\t\n\t\t\t\t} else if (testType.equals(\"arbitraryJava\")) {\n\t\t\t\t\t// Run any java method\n\t\t\t\t\tString[] mandatoryArgs = new String[]{ \"class\", \"method\" };\n\t\t\t\t\tString[] optionalArgs  = new String[]{ \"constructorArguments\", \"methodArguments\", \"weighting\" };\n\t\t\t\t\tvalidateNodeContents(testNode, inventoryFileRef, nodeNumber, \"arbitraryJava\", optionalArgs, mandatoryArgs);\n\t\t\t\t\t\n\t\t\t\t\tString classname = testNode.getAttributes().getNamedItem(\"class\").getNodeValue();\n\t\t\t\t\tString methodName = testNode.getAttributes().getNamedItem(\"method\").getNodeValue();\n\t\t\t\t\tBigDecimal weighting = parseWeighting(testNode, inventoryFileRef, nodeNumber);\n\t\t\t\t\t\n\t\t\t\t\t// Parse optional argument for constructor+method arguments, which can specify a comma separated list of strings\n\t\t\t\t\tArrayList<String> constructorArgs = parseArgumentList(testNode, \"constructorArguments\");\n\t\t\t\t\tArrayList<String> methodArgs = parseArgumentList(testNode, \"methodArguments\");\n\t\t\t\t\t\n\t\t\t\t\tAdaptorInterface testcase = new ArbitraryJavaAdaptor(nextTestNum, classname, constructorArgs, methodName, methodArgs, weighting, countingOnly, dumpRequested);\n\t\t\t\t\ttests.add(testcase);\n\t\t\t\t\tnextTestNum++;"
    },
    "360": {
      "metadata": {
        "chunk_id": "2cad0dfd1fe49173b1c8607dc2fe7ca9a16d99eed589871ac4bb5c673308ae65",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/InventoryData.java",
        "content": "} else if (testType.equals(\"junit\")) {\n\t\t\t\t\t// Validate attributes\n\t\t\t\t\tString[] mandatoryArgs = new String[]{ \"class\" };\n\t\t\t\t\tString[] optionalArgs  = new String[]{ \"weighting\" };\n\t\t\t\t\tvalidateNodeContents(testNode, inventoryFileRef, nodeNumber, \"junit\", optionalArgs, mandatoryArgs);\n\t\t\t\t\t\n\t\t\t\t\t// Get full class name and test weighting\n\t\t\t\t\tString junitClassName = testNode.getAttributes().getNamedItem(\"class\").getNodeValue();\n\t\t\t\t\tBigDecimal weighting = parseWeighting(testNode, inventoryFileRef, nodeNumber);\n\t\t\t\t\t\n\t\t\t\t\tAdaptorInterface testcase = new JUnitAdaptor(nextTestNum, junitClassName, weighting, dumpRequested);\n\t\t\t\t\ttests.add(testcase);\n\t\t\t\t\tnextTestNum++;\n\n\t\t\t\t} else if (testType.equals(\"include\")) {\n\t\t\t\t\t// Pull in the contents of another inventory file\n\t\t\t\t\tString[] mandatoryArgs = new String[]{ \"inventory\" };\n\t\t\t\t\tvalidateNodeContents(testNode, inventoryFileRef, nodeNumber, \"include\", null, mandatoryArgs);\n\t\t\t\t\t\n\t\t\t\t\tNode includeInventoryNode = testNode.getAttributes().getNamedItem(\"inventory\");\n\t\t\t\t\tString includeFileName = includeInventoryNode.getNodeValue();\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tlogger.info(\"Found included inventory. File=\" + includeFileName);\n\t\t\t\t\t}\n\t\t\t\t\tArrayList<AdaptorInterface> includeTests = readInventoryFile(testRoots, includeFileName);\n\t\t\t\t\ttests.addAll(includeTests);\n\n\t\t\t\t} else { \n\t\t\t\t\tthrow new IllegalStateException(\"Unknown test type specified '\" + testType + \"' in inventory: \" + inventoryFile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tests;\n\t}\n\t\n\tprivate BigDecimal parseWeighting(Node testNode, String inventoryFile, int nodeNumber) throws StfException {\n\t\tNode weightingNode = testNode.getAttributes().getNamedItem(\"weighting\");\n\t\t\n\t\tif (weightingNode == null) {\n\t\t\treturn new BigDecimal(1);\n\t\t}\n\n\t\tString weightingStr = weightingNode.getNodeValue();\n\t\tBigDecimal weighting;\n\t\ttry {\n\t\t\tweighting = new BigDecimal(weightingStr);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new StfException(\"Invalid format for 'weighting' attribute. \"\n\t\t\t\t\t+ \"Value='\" + weightingStr + \"' at index '\" + nodeNumber + \"' of file '\" + inventoryFile + \"'\");\n\t\t}\n\n\t\treturn weighting;\n\t}\n\n\t/**\n\t * Validates attributes for an inventory node.\n\t * Throws an exception if:\n\t *   - mandatory argument is missing.\n\t *   - attribute found which is not on the mandatory or optional list.\n\t */\n\tprivate void validateNodeContents(Node node, String inventoryFile, int index, String nodeType, String[] optionalAttributes, String... mandatoryAttributes) throws StfException {\n\t\t// Verify that values are specified for all mandatory attributes\n\t\tfor (String attribute : mandatoryAttributes) {\n\t\t\tNode attributeNode = node.getAttributes().getNamedItem(attribute);\n\t\t\tif (attributeNode == null) {\n\t\t\t\tthrow new StfException(\"Failed to find mandatory attribute '\" + attribute + \"' for '\" + nodeType + \"' node. \"\n\t\t\t\t\t\t+ \"Parsing index '\" + index + \"' of file '\" + inventoryFile + \"'\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Build set of all valid attribute names\n\t\tLinkedHashSet<String> allowedAttributeNames = new LinkedHashSet<String>();\n\t\tallowedAttributeNames.addAll(Arrays.asList(mandatoryAttributes));\n\t\tallowedAttributeNames.addAll(optionalAttributes == null ? new ArrayList<String>() : Arrays.asList(optionalAttributes));\n\n\t\t// Build set of all used attribute names\n\t\tLinkedHashSet<String> actualAttributeNames = new LinkedHashSet<String>();\n\t\tfor (int i=0; i<node.getAttributes().getLength(); i++) {\n\t\t\tactualAttributeNames.add(node.getAttributes().item(i).getNodeName());\t\t\t\t\t\n\t\t}\n\t\t\n\t\t// Fail if unexpected attribute name found\n\t\tactualAttributeNames.removeAll(allowedAttributeNames);\n\t\tif (!actualAttributeNames.isEmpty()) {\n\t\t\tthrow new StfException(\"Unexpected attribute(s) found '\" + actualAttributeNames  + \"' for '\" + nodeType + \"' node. \"\n\t\t\t\t\t\t+ \"Parsing index '\" + index + \"' of file '\" + inventoryFile + \"'\");\n\t\t}\n\t}",
        "start_line": 204,
        "end_line": 292,
        "chunk_index": 3,
        "total_chunks": 7,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 878,
        "node_type": null,
        "file_sha": "28301cca2157a1a6bc626c8096dff8b7a605e012",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.871391"
      },
      "text": "} else if (testType.equals(\"junit\")) {\n\t\t\t\t\t// Validate attributes\n\t\t\t\t\tString[] mandatoryArgs = new String[]{ \"class\" };\n\t\t\t\t\tString[] optionalArgs  = new String[]{ \"weighting\" };\n\t\t\t\t\tvalidateNodeContents(testNode, inventoryFileRef, nodeNumber, \"junit\", optionalArgs, mandatoryArgs);\n\t\t\t\t\t\n\t\t\t\t\t// Get full class name and test weighting\n\t\t\t\t\tString junitClassName = testNode.getAttributes().getNamedItem(\"class\").getNodeValue();\n\t\t\t\t\tBigDecimal weighting = parseWeighting(testNode, inventoryFileRef, nodeNumber);\n\t\t\t\t\t\n\t\t\t\t\tAdaptorInterface testcase = new JUnitAdaptor(nextTestNum, junitClassName, weighting, dumpRequested);\n\t\t\t\t\ttests.add(testcase);\n\t\t\t\t\tnextTestNum++;\n\n\t\t\t\t} else if (testType.equals(\"include\")) {\n\t\t\t\t\t// Pull in the contents of another inventory file\n\t\t\t\t\tString[] mandatoryArgs = new String[]{ \"inventory\" };\n\t\t\t\t\tvalidateNodeContents(testNode, inventoryFileRef, nodeNumber, \"include\", null, mandatoryArgs);\n\t\t\t\t\t\n\t\t\t\t\tNode includeInventoryNode = testNode.getAttributes().getNamedItem(\"inventory\");\n\t\t\t\t\tString includeFileName = includeInventoryNode.getNodeValue();\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tlogger.info(\"Found included inventory. File=\" + includeFileName);\n\t\t\t\t\t}\n\t\t\t\t\tArrayList<AdaptorInterface> includeTests = readInventoryFile(testRoots, includeFileName);\n\t\t\t\t\ttests.addAll(includeTests);\n\n\t\t\t\t} else { \n\t\t\t\t\tthrow new IllegalStateException(\"Unknown test type specified '\" + testType + \"' in inventory: \" + inventoryFile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn tests;\n\t}\n\t\n\tprivate BigDecimal parseWeighting(Node testNode, String inventoryFile, int nodeNumber) throws StfException {\n\t\tNode weightingNode = testNode.getAttributes().getNamedItem(\"weighting\");\n\t\t\n\t\tif (weightingNode == null) {\n\t\t\treturn new BigDecimal(1);\n\t\t}\n\n\t\tString weightingStr = weightingNode.getNodeValue();\n\t\tBigDecimal weighting;\n\t\ttry {\n\t\t\tweighting = new BigDecimal(weightingStr);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new StfException(\"Invalid format for 'weighting' attribute. \"\n\t\t\t\t\t+ \"Value='\" + weightingStr + \"' at index '\" + nodeNumber + \"' of file '\" + inventoryFile + \"'\");\n\t\t}\n\n\t\treturn weighting;\n\t}\n\n\t/**\n\t * Validates attributes for an inventory node.\n\t * Throws an exception if:\n\t *   - mandatory argument is missing.\n\t *   - attribute found which is not on the mandatory or optional list.\n\t */\n\tprivate void validateNodeContents(Node node, String inventoryFile, int index, String nodeType, String[] optionalAttributes, String... mandatoryAttributes) throws StfException {\n\t\t// Verify that values are specified for all mandatory attributes\n\t\tfor (String attribute : mandatoryAttributes) {\n\t\t\tNode attributeNode = node.getAttributes().getNamedItem(attribute);\n\t\t\tif (attributeNode == null) {\n\t\t\t\tthrow new StfException(\"Failed to find mandatory attribute '\" + attribute + \"' for '\" + nodeType + \"' node. \"\n\t\t\t\t\t\t+ \"Parsing index '\" + index + \"' of file '\" + inventoryFile + \"'\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Build set of all valid attribute names\n\t\tLinkedHashSet<String> allowedAttributeNames = new LinkedHashSet<String>();\n\t\tallowedAttributeNames.addAll(Arrays.asList(mandatoryAttributes));\n\t\tallowedAttributeNames.addAll(optionalAttributes == null ? new ArrayList<String>() : Arrays.asList(optionalAttributes));\n\n\t\t// Build set of all used attribute names\n\t\tLinkedHashSet<String> actualAttributeNames = new LinkedHashSet<String>();\n\t\tfor (int i=0; i<node.getAttributes().getLength(); i++) {\n\t\t\tactualAttributeNames.add(node.getAttributes().item(i).getNodeName());\t\t\t\t\t\n\t\t}\n\t\t\n\t\t// Fail if unexpected attribute name found\n\t\tactualAttributeNames.removeAll(allowedAttributeNames);\n\t\tif (!actualAttributeNames.isEmpty()) {\n\t\t\tthrow new StfException(\"Unexpected attribute(s) found '\" + actualAttributeNames  + \"' for '\" + nodeType + \"' node. \"\n\t\t\t\t\t\t+ \"Parsing index '\" + index + \"' of file '\" + inventoryFile + \"'\");\n\t\t}\n\t}"
    },
    "361": {
      "metadata": {
        "chunk_id": "a270667f76853f61858498e297c0a01711ff69672b2bec5fd35df791e9c1ae83",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/InventoryData.java",
        "content": "// Build set of all used attribute names\n\t\tLinkedHashSet<String> actualAttributeNames = new LinkedHashSet<String>();\n\t\tfor (int i=0; i<node.getAttributes().getLength(); i++) {\n\t\t\tactualAttributeNames.add(node.getAttributes().item(i).getNodeName());\t\t\t\t\t\n\t\t}\n\t\t\n\t\t// Fail if unexpected attribute name found\n\t\tactualAttributeNames.removeAll(allowedAttributeNames);\n\t\tif (!actualAttributeNames.isEmpty()) {\n\t\t\tthrow new StfException(\"Unexpected attribute(s) found '\" + actualAttributeNames  + \"' for '\" + nodeType + \"' node. \"\n\t\t\t\t\t\t+ \"Parsing index '\" + index + \"' of file '\" + inventoryFile + \"'\");\n\t\t}\n\t}\n\n\n\t// Reads the value of an argument and converts it to an ArrayList of strings.\n\t// If the value exists then it should be in a comma separated form.\n\tprivate ArrayList<String> parseArgumentList(Node testNode, String argumentName) {\n\t\tArrayList<String> argValues = new ArrayList<String>();\n\t\tNode argumentNode = testNode.getAttributes().getNamedItem(argumentName);\n\t\tif (argumentNode != null) {\n\t\t\tString[] args = argumentNode.getNodeValue().split(\",\");\n\t\t\tfor (String arg : args) {\n\t\t\t\targValues.add(arg.trim());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn argValues;\n\t}\n\n\t\n\t/**\n\t * @return the number of tests held in this inventory file.\n\t */\n\tpublic int getNumberOfTests() {\n\t\treturn testList.size();\n\t}\n\n\tpublic String getInventoryFileRef() {\n\t\treturn inventoryFileRef;\n\t}\n\n\t/**\n\t * Gives access to information about a single test.\n\t * \n\t * @param testIndex specifies the test which is required. Numbered from 0.\n\t * @return details about the test.\n\t */\n\tpublic AdaptorInterface getTest(int testIndex) {\n\t\treturn testList.get(testIndex);\n\t}\n\t\n\t\n\t/**\n\t * Static method to find the number of tests in the specified inventory file.\n\t * The number of tests is found by loading the inventory file and then subtracting \n\t * the tests listed in any exclude files.\n\t * \n\t * @param stfCore so that the workspace root can be discovered.\n\t * @param inventoryFileRef points at the inventory file within the workspace. \n\t * @return the final number of tests.\n\t * @throws StfException \n\t */\n\tpublic static int getNumberOfTests(StfCoreExtension stfCore, String inventoryFileRef) throws StfException {\n\t\tArrayList<DirectoryRef> testRoots = stfCore.env().getTestRoots();\n\t\ttry {\n\t\t\tArrayList<String> exclusionFiles = LoadTestProcessDefinition.findExclusionFiles(testRoots, inventoryFileRef);\n\t\t\t\n\t\t\tInventoryData inventory = new InventoryData(testRoots, inventoryFileRef, exclusionFiles, true, false, dumpRequested);\n\t\t\treturn inventory.getNumberOfTests();\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to parse inventory file\", e);\n\t\t}\n\t}",
        "start_line": 293,
        "end_line": 366,
        "chunk_index": 4,
        "total_chunks": 7,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 629,
        "node_type": null,
        "file_sha": "28301cca2157a1a6bc626c8096dff8b7a605e012",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.871393"
      },
      "text": "// Build set of all used attribute names\n\t\tLinkedHashSet<String> actualAttributeNames = new LinkedHashSet<String>();\n\t\tfor (int i=0; i<node.getAttributes().getLength(); i++) {\n\t\t\tactualAttributeNames.add(node.getAttributes().item(i).getNodeName());\t\t\t\t\t\n\t\t}\n\t\t\n\t\t// Fail if unexpected attribute name found\n\t\tactualAttributeNames.removeAll(allowedAttributeNames);\n\t\tif (!actualAttributeNames.isEmpty()) {\n\t\t\tthrow new StfException(\"Unexpected attribute(s) found '\" + actualAttributeNames  + \"' for '\" + nodeType + \"' node. \"\n\t\t\t\t\t\t+ \"Parsing index '\" + index + \"' of file '\" + inventoryFile + \"'\");\n\t\t}\n\t}\n\n\n\t// Reads the value of an argument and converts it to an ArrayList of strings.\n\t// If the value exists then it should be in a comma separated form.\n\tprivate ArrayList<String> parseArgumentList(Node testNode, String argumentName) {\n\t\tArrayList<String> argValues = new ArrayList<String>();\n\t\tNode argumentNode = testNode.getAttributes().getNamedItem(argumentName);\n\t\tif (argumentNode != null) {\n\t\t\tString[] args = argumentNode.getNodeValue().split(\",\");\n\t\t\tfor (String arg : args) {\n\t\t\t\targValues.add(arg.trim());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn argValues;\n\t}\n\n\t\n\t/**\n\t * @return the number of tests held in this inventory file.\n\t */\n\tpublic int getNumberOfTests() {\n\t\treturn testList.size();\n\t}\n\n\tpublic String getInventoryFileRef() {\n\t\treturn inventoryFileRef;\n\t}\n\n\t/**\n\t * Gives access to information about a single test.\n\t * \n\t * @param testIndex specifies the test which is required. Numbered from 0.\n\t * @return details about the test.\n\t */\n\tpublic AdaptorInterface getTest(int testIndex) {\n\t\treturn testList.get(testIndex);\n\t}\n\t\n\t\n\t/**\n\t * Static method to find the number of tests in the specified inventory file.\n\t * The number of tests is found by loading the inventory file and then subtracting \n\t * the tests listed in any exclude files.\n\t * \n\t * @param stfCore so that the workspace root can be discovered.\n\t * @param inventoryFileRef points at the inventory file within the workspace. \n\t * @return the final number of tests.\n\t * @throws StfException \n\t */\n\tpublic static int getNumberOfTests(StfCoreExtension stfCore, String inventoryFileRef) throws StfException {\n\t\tArrayList<DirectoryRef> testRoots = stfCore.env().getTestRoots();\n\t\ttry {\n\t\t\tArrayList<String> exclusionFiles = LoadTestProcessDefinition.findExclusionFiles(testRoots, inventoryFileRef);\n\t\t\t\n\t\t\tInventoryData inventory = new InventoryData(testRoots, inventoryFileRef, exclusionFiles, true, false, dumpRequested);\n\t\t\treturn inventory.getNumberOfTests();\n\t\t} catch (Exception e) {\n\t\t\tthrow new StfException(\"Failed to parse inventory file\", e);\n\t\t}\n\t}"
    },
    "362": {
      "metadata": {
        "chunk_id": "369db8a3a6aa4d48216f0f32d585b9a7843d2eede2151e952e539af9c2244d11",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/InventoryData.java",
        "content": "// Weightings allow fractional values, so find the best multiplier which will \n\t// allow fast selection of tests whilst still preserving the desired selection\n\t// probabilities.\n\t// \n\t// For example, with the following tests:\n\t//    test A, weighting = 1\n\t//    test B, weighting = 0.5\n\t//    test C, weighting = 1.25\n\t// A multiplier of 4 will allow the specified probabilities to be achieved: AAAABBCCCCC\n\t// So randomly picking for this weighting array 11 times would, on average, result in\n\t// 4A's, 2B's and 5C's. This exactly matches the specified distribution.\n\t// \n\t// It's not always possible to pick a multiplier to get a perfect balance for all multipliers\n\t// so this selection algorithm chooses the closest multiplier.\n\t// For example, if the test list were:\n\t//    test X, weighting = 0.41\n\t//    test Y, weighting = 0.39\n\t//    test Z, weighting = 0.201\n\t// If we weren't allowing a multiplier higher than 10 then the best choice is 5, which produces \n\t// a selection array of XXYYZ:\n\t//    Test X, Weighting=0.41,  *5 = 2.05,  RoundedTo=2  Error=0.05\n\t//    test Y, Weighting=0.39,  *5 = 1.95,  RoundedTo=2  Error=0.05\n\t// \t  test Z, Weighting=0.201, *5 = 1.005  RoundedTo=1  Error=0.005\n\t// Note that in this simple example the maximum difference the actual and perfect values is 0.05\n\t//\n\t// If all tests have a weighting of 1 then a multiplier of 1 is returned.\n\tprivate BigDecimal calculateWeightingMultiplier(ArrayList<AdaptorInterface> testList) {\n\t\tboolean bestMultiplierSet = false;\n\t\tint bestMultiplier = 1;\n\t\tBigDecimal biggestErrorForBestMultiplier = null;\n\t\tBigDecimal totalErrorForBestMultiplier = null;\n\t\t\n\t\t// Find the best multiplier by stepping through them\n    \tfor (int multiplier=1; multiplier<1000; multiplier++) {\n    \t\tBigDecimal biggestError = BigDecimal.ZERO;\n    \t\tBigDecimal totalError = BigDecimal.ZERO;\n    \t\tlong totalWeightings = 0;\n    \t\t\n    \t\t// Convert the multiplier to big decimal as it gets used a lot\n    \t\tBigDecimal multiplierBD = new BigDecimal(multiplier);\n    \t\t\n    \t\tfor (AdaptorInterface test : testList) {\n    \t\t\tif (test.getWeighting().equals(BigDecimal.ONE)) {\n    \t\t\t\ttotalWeightings += multiplier;\n    \t\t\t} else {\n    \t\t\t\t// Calculate actual weighting for current multiplier\n    \t\t\t\tBigDecimal proposedWeighting = test.getAdjustedWeighting(multiplierBD);\n    \t\t\t\t// Round actual weighting to whole number (at least 1)\n        \t\t\tBigDecimal roundedWeighting = new BigDecimal(test.getRoundedAdjustedWeighting(multiplierBD));\n        \t\t\t// Work out how big the actual rounding error is. \n        \t\t\t// eg, weighting=1.5 for multiplier 3 gives actual weighting of 4.5. This gets rounded to 5 so 'error' is 0.5.\n        \t\t\tBigDecimal roundingError = roundedWeighting.subtract(proposedWeighting).abs();\n\t\t\t\t\t\n\t\t\t\t\t// Update counters\n\t\t\t\t\tbiggestError = biggestError.max(roundingError);\n\t\t\t\t\ttotalError = totalError.add(roundingError);\n\t\t\t\t\ttotalWeightings += roundedWeighting.longValue();\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\t// Stop searching if the current multiplier will result in a test lookup table which is too big\n    \t\tif (totalWeightings > MAX_WEIGHTING_LOOKUP_SIZE) {\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// Stop searching if perfect multiplier found\n    \t\tif (biggestError.equals(BigDecimal.ZERO)) {\n    \t\t\tbestMultiplier = multiplier;\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// Decide if current multiplier gives better results than the best so far\n    \t\tboolean foundBetter = false;\n    \t\tif (!bestMultiplierSet) {\n    \t\t\t// First time round. Use this multiplier\n    \t\t\tfoundBetter = true;\n    \t\t} else if (biggestError.compareTo(biggestErrorForBestMultiplier) < 0) {\n    \t\t\t// Use the current multiplier, as its maximum error is less than than the previous best\n    \t\t\tfoundBetter = true;\n    \t\t} else if (biggestError.compareTo(biggestErrorForBestMultiplier) == 0  &&  totalError.compareTo(totalErrorForBestMultiplier) < 0) {",
        "start_line": 367,
        "end_line": 446,
        "chunk_index": 5,
        "total_chunks": 7,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 979,
        "node_type": null,
        "file_sha": "28301cca2157a1a6bc626c8096dff8b7a605e012",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.871395"
      },
      "text": "// Weightings allow fractional values, so find the best multiplier which will \n\t// allow fast selection of tests whilst still preserving the desired selection\n\t// probabilities.\n\t// \n\t// For example, with the following tests:\n\t//    test A, weighting = 1\n\t//    test B, weighting = 0.5\n\t//    test C, weighting = 1.25\n\t// A multiplier of 4 will allow the specified probabilities to be achieved: AAAABBCCCCC\n\t// So randomly picking for this weighting array 11 times would, on average, result in\n\t// 4A's, 2B's and 5C's. This exactly matches the specified distribution.\n\t// \n\t// It's not always possible to pick a multiplier to get a perfect balance for all multipliers\n\t// so this selection algorithm chooses the closest multiplier.\n\t// For example, if the test list were:\n\t//    test X, weighting = 0.41\n\t//    test Y, weighting = 0.39\n\t//    test Z, weighting = 0.201\n\t// If we weren't allowing a multiplier higher than 10 then the best choice is 5, which produces \n\t// a selection array of XXYYZ:\n\t//    Test X, Weighting=0.41,  *5 = 2.05,  RoundedTo=2  Error=0.05\n\t//    test Y, Weighting=0.39,  *5 = 1.95,  RoundedTo=2  Error=0.05\n\t// \t  test Z, Weighting=0.201, *5 = 1.005  RoundedTo=1  Error=0.005\n\t// Note that in this simple example the maximum difference the actual and perfect values is 0.05\n\t//\n\t// If all tests have a weighting of 1 then a multiplier of 1 is returned.\n\tprivate BigDecimal calculateWeightingMultiplier(ArrayList<AdaptorInterface> testList) {\n\t\tboolean bestMultiplierSet = false;\n\t\tint bestMultiplier = 1;\n\t\tBigDecimal biggestErrorForBestMultiplier = null;\n\t\tBigDecimal totalErrorForBestMultiplier = null;\n\t\t\n\t\t// Find the best multiplier by stepping through them\n    \tfor (int multiplier=1; multiplier<1000; multiplier++) {\n    \t\tBigDecimal biggestError = BigDecimal.ZERO;\n    \t\tBigDecimal totalError = BigDecimal.ZERO;\n    \t\tlong totalWeightings = 0;\n    \t\t\n    \t\t// Convert the multiplier to big decimal as it gets used a lot\n    \t\tBigDecimal multiplierBD = new BigDecimal(multiplier);\n    \t\t\n    \t\tfor (AdaptorInterface test : testList) {\n    \t\t\tif (test.getWeighting().equals(BigDecimal.ONE)) {\n    \t\t\t\ttotalWeightings += multiplier;\n    \t\t\t} else {\n    \t\t\t\t// Calculate actual weighting for current multiplier\n    \t\t\t\tBigDecimal proposedWeighting = test.getAdjustedWeighting(multiplierBD);\n    \t\t\t\t// Round actual weighting to whole number (at least 1)\n        \t\t\tBigDecimal roundedWeighting = new BigDecimal(test.getRoundedAdjustedWeighting(multiplierBD));\n        \t\t\t// Work out how big the actual rounding error is. \n        \t\t\t// eg, weighting=1.5 for multiplier 3 gives actual weighting of 4.5. This gets rounded to 5 so 'error' is 0.5.\n        \t\t\tBigDecimal roundingError = roundedWeighting.subtract(proposedWeighting).abs();\n\t\t\t\t\t\n\t\t\t\t\t// Update counters\n\t\t\t\t\tbiggestError = biggestError.max(roundingError);\n\t\t\t\t\ttotalError = totalError.add(roundingError);\n\t\t\t\t\ttotalWeightings += roundedWeighting.longValue();\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\t// Stop searching if the current multiplier will result in a test lookup table which is too big\n    \t\tif (totalWeightings > MAX_WEIGHTING_LOOKUP_SIZE) {\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// Stop searching if perfect multiplier found\n    \t\tif (biggestError.equals(BigDecimal.ZERO)) {\n    \t\t\tbestMultiplier = multiplier;\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// Decide if current multiplier gives better results than the best so far\n    \t\tboolean foundBetter = false;\n    \t\tif (!bestMultiplierSet) {\n    \t\t\t// First time round. Use this multiplier\n    \t\t\tfoundBetter = true;\n    \t\t} else if (biggestError.compareTo(biggestErrorForBestMultiplier) < 0) {\n    \t\t\t// Use the current multiplier, as its maximum error is less than than the previous best\n    \t\t\tfoundBetter = true;\n    \t\t} else if (biggestError.compareTo(biggestErrorForBestMultiplier) == 0  &&  totalError.compareTo(totalErrorForBestMultiplier) < 0) {"
    },
    "363": {
      "metadata": {
        "chunk_id": "6d24ad2e996bf3ead733d2468d72090e87e019c26f46b516bae5c6bbd63e26db",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/InventoryData.java",
        "content": "break;\n    \t\t}\n    \t\t\n    \t\t// Stop searching if perfect multiplier found\n    \t\tif (biggestError.equals(BigDecimal.ZERO)) {\n    \t\t\tbestMultiplier = multiplier;\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// Decide if current multiplier gives better results than the best so far\n    \t\tboolean foundBetter = false;\n    \t\tif (!bestMultiplierSet) {\n    \t\t\t// First time round. Use this multiplier\n    \t\t\tfoundBetter = true;\n    \t\t} else if (biggestError.compareTo(biggestErrorForBestMultiplier) < 0) {\n    \t\t\t// Use the current multiplier, as its maximum error is less than than the previous best\n    \t\t\tfoundBetter = true;\n    \t\t} else if (biggestError.compareTo(biggestErrorForBestMultiplier) == 0  &&  totalError.compareTo(totalErrorForBestMultiplier) < 0) {\n    \t\t\t// Maximum error is the same, but this multiplier is preferred because the total of all errors is better\n    \t\t\tfoundBetter = true;\n    \t\t}\n    \t\t\n    \t\tif (foundBetter) {\n    \t\t\t// Current multiplier has smaller selection balance error than the current best multiplier.\n    \t\t\tbestMultiplier = multiplier;\n    \t\t\tbiggestErrorForBestMultiplier = biggestError;\n    \t\t\ttotalErrorForBestMultiplier = totalError;\n    \t\t\tbestMultiplierSet = true;\n    \t\t}\n    \t}\n    \t\n\t\treturn new BigDecimal(bestMultiplier);\n\t}\n\t\n\t\n\t/**\n\t * @return an int containing the multiplication factor that should be applied to weightings, to make\n\t * sure they are selected according to the probabilities controlled by their weightings. \n\t */\n\tpublic BigDecimal getWeightingMultiplier() { \n\t\treturn weightingMultiplier;\n\t}\n}",
        "start_line": 447,
        "end_line": 489,
        "chunk_index": 6,
        "total_chunks": 7,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 340,
        "node_type": null,
        "file_sha": "28301cca2157a1a6bc626c8096dff8b7a605e012",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.871398"
      },
      "text": "break;\n    \t\t}\n    \t\t\n    \t\t// Stop searching if perfect multiplier found\n    \t\tif (biggestError.equals(BigDecimal.ZERO)) {\n    \t\t\tbestMultiplier = multiplier;\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\t// Decide if current multiplier gives better results than the best so far\n    \t\tboolean foundBetter = false;\n    \t\tif (!bestMultiplierSet) {\n    \t\t\t// First time round. Use this multiplier\n    \t\t\tfoundBetter = true;\n    \t\t} else if (biggestError.compareTo(biggestErrorForBestMultiplier) < 0) {\n    \t\t\t// Use the current multiplier, as its maximum error is less than than the previous best\n    \t\t\tfoundBetter = true;\n    \t\t} else if (biggestError.compareTo(biggestErrorForBestMultiplier) == 0  &&  totalError.compareTo(totalErrorForBestMultiplier) < 0) {\n    \t\t\t// Maximum error is the same, but this multiplier is preferred because the total of all errors is better\n    \t\t\tfoundBetter = true;\n    \t\t}\n    \t\t\n    \t\tif (foundBetter) {\n    \t\t\t// Current multiplier has smaller selection balance error than the current best multiplier.\n    \t\t\tbestMultiplier = multiplier;\n    \t\t\tbiggestErrorForBestMultiplier = biggestError;\n    \t\t\ttotalErrorForBestMultiplier = totalError;\n    \t\t\tbestMultiplierSet = true;\n    \t\t}\n    \t}\n    \t\n\t\treturn new BigDecimal(bestMultiplier);\n\t}\n\t\n\t\n\t/**\n\t * @return an int containing the multiplication factor that should be applied to weightings, to make\n\t * sure they are selected according to the probabilities controlled by their weightings. \n\t */\n\tpublic BigDecimal getWeightingMultiplier() { \n\t\treturn weightingMultiplier;\n\t}\n}"
    },
    "364": {
      "metadata": {
        "chunk_id": "f61f3f264c03773025455a4a2952a11b32cea3b272e292e36d04c2a78619d476",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTest.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.loadTest.SuiteData.SelectionMode;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.util.TimeParser;\n\n\n/**\n * This class is the entry point for running a load test.\n * Most of it's work is to parse the command line arguments, before kicking off the test run.\n * \n * It uses these exit codes:\n *   0 - All tests ran successfully.\n *   1 - One or more tests failed.\n *   2 - Failed with usage message.\n */",
        "start_line": 0,
        "end_line": 42,
        "chunk_index": 0,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 318,
        "node_type": null,
        "file_sha": "fcc55194aa57a3463dc7a1db21a6db9d4968b784",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.889869"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.loadTest.SuiteData.SelectionMode;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.util.TimeParser;\n\n\n/**\n * This class is the entry point for running a load test.\n * Most of it's work is to parse the command line arguments, before kicking off the test run.\n * \n * It uses these exit codes:\n *   0 - All tests ran successfully.\n *   1 - One or more tests failed.\n *   2 - Failed with usage message.\n */"
    },
    "365": {
      "metadata": {
        "chunk_id": "1cc5dab392e36cbcd3f3714562fbe138897a043e063560054d6ffa02283fd22b",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTest.java",
        "content": "public class LoadTest {\n    private static final Logger logger = LogManager.getLogger(LoadTest.class.getName());\n\n\t// Supports suites numbered 0..7\n\tprivate static int MAX_SUITE_NUMBER = 7;\n\n\tprivate File resultsDir = null;\n\tprivate String resultsPrefix = \"\";\n\t\n\t// If the test is going to run for a fixed time period then no new tests will be\n\t// started after the testEndTime\n\tprivate boolean timeLimitedTest = false;\n\tprivate String timeLimitString;\n\tprivate long testEndTime;\n\t\n\t// If set, test will fail due to inactivity after the provided duration of \n\t// inactivity in a live test is encountered \n\tprivate String inactivityLimitString; \n\tprivate long inactivityLimit = 15 * 60 * 1000; // By default, set to 15 minutes; \n\t\n\t// LoadTest behaviour on OMM controllable through argument\n\tprivate boolean abortIfOutOfMemory = true; \n\t\n\t// This flag indicates whether or not to create core dumps on the event of first load test failure \n\tprivate boolean dumpRequested = false; \n\t\n\t// Error reporting control\n\tprivate int reportFailureLimit = 10; \n\tprivate int abortAtFailureLimit = 25;\n\t\n\t// To limit the disk space used for execution logs\n\tprivate long maxTotalLogFileSpace;\n\tprivate int maxSingleLogSize;\n\t\n\tprivate ArrayList<SuiteData> suites = new ArrayList<SuiteData>();\n\t\n\t// Holds the names of the fields that can be used to specify arguments for a suite.\n\t// For example: -suite.0.threadCount 2\n\tprivate static final Set<String> SUITE_ARGUMENTS = new HashSet<String>(Arrays.asList(\n\t\t    \"threadCount\", \n\t\t\t\"seed\",\n\t\t\t\"inventoryFile\", \n\t\t\t\"inventoryExcludeFile\", \n\t\t\t\"totalNumberTests\", \n\t\t\t\"repeatCount\",\n\t\t\t\"thinkingTime\",\n\t\t\t\"selection\"  // random or sequential\n\t\t\t));\n\t\n\t// Holds data on a single argument for suite data. eg '-suite0.threadCount 2'\n\tprivate static class SuiteArg { \n\t\tprivate String suiteName;\n\t\tprivate String argName;\n\t\tprivate String argValue;\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\t// Parse the arguments and inventory files\n\t\tLoadTest loadTest = null;\n\t\ttry {\n\t\t\tloadTest = new LoadTest(args);\n\t\t} catch (Exception e) {\n\t\t\tlogger.fatal(\"Failed to initialise LoadTest\", e);\n\t\t\tSystem.exit(2);\n\t\t}\n\n\t\t// Run the tests\n\t\tlong numberFailingTests = -1;\n\t\ttry {\n\t\t\tnumberFailingTests = loadTest.runLoadTest();\n\t\t} catch (Exception e) {\n\t\t\tlogger.fatal(\"Failed during LoadTest execution\", e);\n\t\t\tthrow new BlockedExitException(3);\n\t\t}\n\t\t\n\t\t// Exit with a non-zero value if a test has failed\n\t\tint exitCode = numberFailingTests == 0 ? 0 : 1;\n\t\tSystem.exit(exitCode);\n\t}\n\n\n\tprivate long runLoadTest() throws Exception {\n\t\t// Create now, so that it's ready to go to work when a failure happens\n\t\tFirstFailureDumper.createInstance();\n\t\t\n\t\tLoadTestRunner loadTestRunner = new LoadTestRunner(resultsDir, resultsPrefix, \n\t\t\t\ttimeLimitedTest, testEndTime, inactivityLimit, \n\t\t\t\tabortIfOutOfMemory,\n\t\t\t\treportFailureLimit, abortAtFailureLimit,\n\t\t\t\tmaxTotalLogFileSpace, maxSingleLogSize,\n\t\t\t\tsuites, dumpRequested);\n\t\treturn loadTestRunner.run();\n\t}\n\n\t\n\tpublic LoadTest(String[] args) throws Exception {\n\t\tString maxTotalLogFileSpaceStr = null;\n\t\tString maxSingleLogSizeStr = null;\n\t\t\n\t\t// Make sure we can number each suite as we parse the program arguments\n\t\tString currSuiteName = null;\n\t\tint currSuiteNum = -1;\n\t\tHashSet<String> previousArgs = new HashSet<String>();\n\n\t\t// Create a HashMap for each suite. Holds the suites arguments from the command line.\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tHashMap<String, String>[] suiteData = (HashMap<String, String>[]) new HashMap[MAX_SUITE_NUMBER];\n\t\tfor (int i=0; i<MAX_SUITE_NUMBER; i++) {\n\t\t\tsuiteData[i] = new HashMap<String, String>();\n\t\t}\n\t\tString[] suiteNames = new String[MAX_SUITE_NUMBER];\n\t\t\n\t\tint i = 0;\n\t\twhile (i < args.length) {\n\t\t\tString argName = args[i++];\n\t\t\t\n\t\t\tif (argName.equals(\"-resultsDir\")) {\n\t\t\t\tString resultsDirString = getArgValue(args, i++);\n\t\t\t\tthis.resultsDir = new File(resultsDirString);",
        "start_line": 43,
        "end_line": 162,
        "chunk_index": 1,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 976,
        "node_type": null,
        "file_sha": "fcc55194aa57a3463dc7a1db21a6db9d4968b784",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.889876"
      },
      "text": "public class LoadTest {\n    private static final Logger logger = LogManager.getLogger(LoadTest.class.getName());\n\n\t// Supports suites numbered 0..7\n\tprivate static int MAX_SUITE_NUMBER = 7;\n\n\tprivate File resultsDir = null;\n\tprivate String resultsPrefix = \"\";\n\t\n\t// If the test is going to run for a fixed time period then no new tests will be\n\t// started after the testEndTime\n\tprivate boolean timeLimitedTest = false;\n\tprivate String timeLimitString;\n\tprivate long testEndTime;\n\t\n\t// If set, test will fail due to inactivity after the provided duration of \n\t// inactivity in a live test is encountered \n\tprivate String inactivityLimitString; \n\tprivate long inactivityLimit = 15 * 60 * 1000; // By default, set to 15 minutes; \n\t\n\t// LoadTest behaviour on OMM controllable through argument\n\tprivate boolean abortIfOutOfMemory = true; \n\t\n\t// This flag indicates whether or not to create core dumps on the event of first load test failure \n\tprivate boolean dumpRequested = false; \n\t\n\t// Error reporting control\n\tprivate int reportFailureLimit = 10; \n\tprivate int abortAtFailureLimit = 25;\n\t\n\t// To limit the disk space used for execution logs\n\tprivate long maxTotalLogFileSpace;\n\tprivate int maxSingleLogSize;\n\t\n\tprivate ArrayList<SuiteData> suites = new ArrayList<SuiteData>();\n\t\n\t// Holds the names of the fields that can be used to specify arguments for a suite.\n\t// For example: -suite.0.threadCount 2\n\tprivate static final Set<String> SUITE_ARGUMENTS = new HashSet<String>(Arrays.asList(\n\t\t    \"threadCount\", \n\t\t\t\"seed\",\n\t\t\t\"inventoryFile\", \n\t\t\t\"inventoryExcludeFile\", \n\t\t\t\"totalNumberTests\", \n\t\t\t\"repeatCount\",\n\t\t\t\"thinkingTime\",\n\t\t\t\"selection\"  // random or sequential\n\t\t\t));\n\t\n\t// Holds data on a single argument for suite data. eg '-suite0.threadCount 2'\n\tprivate static class SuiteArg { \n\t\tprivate String suiteName;\n\t\tprivate String argName;\n\t\tprivate String argValue;\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\t// Parse the arguments and inventory files\n\t\tLoadTest loadTest = null;\n\t\ttry {\n\t\t\tloadTest = new LoadTest(args);\n\t\t} catch (Exception e) {\n\t\t\tlogger.fatal(\"Failed to initialise LoadTest\", e);\n\t\t\tSystem.exit(2);\n\t\t}\n\n\t\t// Run the tests\n\t\tlong numberFailingTests = -1;\n\t\ttry {\n\t\t\tnumberFailingTests = loadTest.runLoadTest();\n\t\t} catch (Exception e) {\n\t\t\tlogger.fatal(\"Failed during LoadTest execution\", e);\n\t\t\tthrow new BlockedExitException(3);\n\t\t}\n\t\t\n\t\t// Exit with a non-zero value if a test has failed\n\t\tint exitCode = numberFailingTests == 0 ? 0 : 1;\n\t\tSystem.exit(exitCode);\n\t}\n\n\n\tprivate long runLoadTest() throws Exception {\n\t\t// Create now, so that it's ready to go to work when a failure happens\n\t\tFirstFailureDumper.createInstance();\n\t\t\n\t\tLoadTestRunner loadTestRunner = new LoadTestRunner(resultsDir, resultsPrefix, \n\t\t\t\ttimeLimitedTest, testEndTime, inactivityLimit, \n\t\t\t\tabortIfOutOfMemory,\n\t\t\t\treportFailureLimit, abortAtFailureLimit,\n\t\t\t\tmaxTotalLogFileSpace, maxSingleLogSize,\n\t\t\t\tsuites, dumpRequested);\n\t\treturn loadTestRunner.run();\n\t}\n\n\t\n\tpublic LoadTest(String[] args) throws Exception {\n\t\tString maxTotalLogFileSpaceStr = null;\n\t\tString maxSingleLogSizeStr = null;\n\t\t\n\t\t// Make sure we can number each suite as we parse the program arguments\n\t\tString currSuiteName = null;\n\t\tint currSuiteNum = -1;\n\t\tHashSet<String> previousArgs = new HashSet<String>();\n\n\t\t// Create a HashMap for each suite. Holds the suites arguments from the command line.\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tHashMap<String, String>[] suiteData = (HashMap<String, String>[]) new HashMap[MAX_SUITE_NUMBER];\n\t\tfor (int i=0; i<MAX_SUITE_NUMBER; i++) {\n\t\t\tsuiteData[i] = new HashMap<String, String>();\n\t\t}\n\t\tString[] suiteNames = new String[MAX_SUITE_NUMBER];\n\t\t\n\t\tint i = 0;\n\t\twhile (i < args.length) {\n\t\t\tString argName = args[i++];\n\t\t\t\n\t\t\tif (argName.equals(\"-resultsDir\")) {\n\t\t\t\tString resultsDirString = getArgValue(args, i++);\n\t\t\t\tthis.resultsDir = new File(resultsDirString);"
    },
    "366": {
      "metadata": {
        "chunk_id": "825463ab2515622ef5627e93024b40a51348de268f1babf40fc09120398b1a06",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTest.java",
        "content": "// Create a HashMap for each suite. Holds the suites arguments from the command line.\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tHashMap<String, String>[] suiteData = (HashMap<String, String>[]) new HashMap[MAX_SUITE_NUMBER];\n\t\tfor (int i=0; i<MAX_SUITE_NUMBER; i++) {\n\t\t\tsuiteData[i] = new HashMap<String, String>();\n\t\t}\n\t\tString[] suiteNames = new String[MAX_SUITE_NUMBER];\n\t\t\n\t\tint i = 0;\n\t\twhile (i < args.length) {\n\t\t\tString argName = args[i++];\n\t\t\t\n\t\t\tif (argName.equals(\"-resultsDir\")) {\n\t\t\t\tString resultsDirString = getArgValue(args, i++);\n\t\t\t\tthis.resultsDir = new File(resultsDirString);\n\n\t\t\t} else if (argName.equals(\"-resultsPrefix\")) {\n\t\t\t\tthis.resultsPrefix = getArgValue(args, i++);;\n\t\t\t\n\t\t\t} else if (argName.equals(\"-timeLimit\")) {\n\t\t\t\tthis.timeLimitedTest = true;\n\t\t\t\tthis.timeLimitString = getArgValue(args, i++);\n\t\t\t\tlong timeLimitSeconds = TimeParser.parseTimeSpecification(timeLimitString).getSeconds();\n\t\t\t\tthis.testEndTime = System.currentTimeMillis() + (timeLimitSeconds * 1000);\n\n\t\t\t} else if (argName.equals(\"-inactivityLimit\")) {\n\t\t\t\tthis.inactivityLimitString = getArgValue(args, i++);\n\t\t\t\tlong inactivityLimitSeconds = TimeParser.parseTimeSpecification(inactivityLimitString).getSeconds();\n\t\t\t\tthis.inactivityLimit = System.currentTimeMillis() + (inactivityLimitSeconds * 1000);\n\n\t\t\t} else if (argName.equals(\"-abortIfOutOfMemory\")) {\n\t\t\t\tString abortValue = getArgValue(args, i++);\n\t\t\t\tthis.abortIfOutOfMemory = Boolean.parseBoolean(abortValue);\n\t\t\t\n\t\t\t} else if (argName.equals(\"-dumpRequested\")) {\n\t\t\t\tString dumpReq = getArgValue(args, i++);\n\t\t\t\tthis.dumpRequested = Boolean.parseBoolean(dumpReq);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"-reportFailureLimit\")) {\n\t\t\t\tthis.reportFailureLimit = Integer.parseInt(getArgValue(args, i++));\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"-abortAtFailureLimit\")) {\n\t\t\t\tthis.abortAtFailureLimit = Integer.parseInt(getArgValue(args, i++));\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"-maxTotalLogFileSpace\")) {\n\t\t\t\tmaxTotalLogFileSpaceStr = getArgValue(args, i++);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"-maxSingleLogSize\")) {\n\t\t\t\tmaxSingleLogSizeStr = getArgValue(args, i++);\n\t\t\t\t\n\t\t\t} else if (argName.startsWith(\"-suite.\")) {\n\t\t\t\t// Grab suite argument, and chop it up. eg '-suite.mauve.threadCount 3'\n\t\t\t\tString suiteArgValue = getArgValue(args, i++);\n\t\t\t\tSuiteArg suiteArg = parseSuiteArg(argName, suiteArgValue);\n\t\t\t\t\n\t\t\t\t// Validate that this is not a repeated argument. \n\t\t\t\t// Guards against people how copy+paste suite config, but don't change the suite name\n\t\t\t\tif (previousArgs.contains(argName)) {\n\t\t\t\t\tif (!argName.endsWith(\".inventoryExcludeFile\")) {  // There can be multiple exclude files\n\t\t\t\t\t    throw new StfException(\"Duplicate LoadTest argument: '\" + argName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreviousArgs.add(argName);\n\n\t\t\t\t// Check to see if this is a new suite\n\t\t\t\tif (!suiteArg.suiteName.equals(currSuiteName)) {\n\t\t\t\t\tcurrSuiteNum++;\n\t\t\t\t\tcurrSuiteName = suiteArg.suiteName;\n\t\t\t\t\tsuiteNames[currSuiteNum] = currSuiteName;\n\t\t\t\t\tif (currSuiteNum >= MAX_SUITE_NUMBER) {\n\t\t\t\t\t\tthrow new StfException(\"Too many suites. Max supported number: \" + MAX_SUITE_NUMBER);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Special case handling for exclude files.\n\t\t\t\t// There can be multiple files, so the single arg value into a comma separated list of files\n\t\t\t\tif (suiteArg.argName.equals(\"inventoryExcludeFile\") && suiteData[currSuiteNum].containsKey(suiteArg.argName)) {\n\t\t\t\t\t// There is already a value for the inventory file. Combine into a file list\n\t\t\t\t\tString existingExcludeFiles = suiteData[currSuiteNum].get(suiteArg.argName);\n\t\t\t\t\tString fullExcludeList = existingExcludeFiles + \", \" + suiteArg.argValue;\n\t\t\t\t\tsuiteData[currSuiteNum].put(suiteArg.argName, fullExcludeList);\n\t\t\t\t} else {\n\t\t\t\t\tsuiteData[currSuiteNum].put(suiteArg.argName, suiteArg.argValue);\n\t\t\t\t}",
        "start_line": 163,
        "end_line": 246,
        "chunk_index": 2,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 945,
        "node_type": null,
        "file_sha": "fcc55194aa57a3463dc7a1db21a6db9d4968b784",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.889878"
      },
      "text": "// Create a HashMap for each suite. Holds the suites arguments from the command line.\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tHashMap<String, String>[] suiteData = (HashMap<String, String>[]) new HashMap[MAX_SUITE_NUMBER];\n\t\tfor (int i=0; i<MAX_SUITE_NUMBER; i++) {\n\t\t\tsuiteData[i] = new HashMap<String, String>();\n\t\t}\n\t\tString[] suiteNames = new String[MAX_SUITE_NUMBER];\n\t\t\n\t\tint i = 0;\n\t\twhile (i < args.length) {\n\t\t\tString argName = args[i++];\n\t\t\t\n\t\t\tif (argName.equals(\"-resultsDir\")) {\n\t\t\t\tString resultsDirString = getArgValue(args, i++);\n\t\t\t\tthis.resultsDir = new File(resultsDirString);\n\n\t\t\t} else if (argName.equals(\"-resultsPrefix\")) {\n\t\t\t\tthis.resultsPrefix = getArgValue(args, i++);;\n\t\t\t\n\t\t\t} else if (argName.equals(\"-timeLimit\")) {\n\t\t\t\tthis.timeLimitedTest = true;\n\t\t\t\tthis.timeLimitString = getArgValue(args, i++);\n\t\t\t\tlong timeLimitSeconds = TimeParser.parseTimeSpecification(timeLimitString).getSeconds();\n\t\t\t\tthis.testEndTime = System.currentTimeMillis() + (timeLimitSeconds * 1000);\n\n\t\t\t} else if (argName.equals(\"-inactivityLimit\")) {\n\t\t\t\tthis.inactivityLimitString = getArgValue(args, i++);\n\t\t\t\tlong inactivityLimitSeconds = TimeParser.parseTimeSpecification(inactivityLimitString).getSeconds();\n\t\t\t\tthis.inactivityLimit = System.currentTimeMillis() + (inactivityLimitSeconds * 1000);\n\n\t\t\t} else if (argName.equals(\"-abortIfOutOfMemory\")) {\n\t\t\t\tString abortValue = getArgValue(args, i++);\n\t\t\t\tthis.abortIfOutOfMemory = Boolean.parseBoolean(abortValue);\n\t\t\t\n\t\t\t} else if (argName.equals(\"-dumpRequested\")) {\n\t\t\t\tString dumpReq = getArgValue(args, i++);\n\t\t\t\tthis.dumpRequested = Boolean.parseBoolean(dumpReq);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"-reportFailureLimit\")) {\n\t\t\t\tthis.reportFailureLimit = Integer.parseInt(getArgValue(args, i++));\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"-abortAtFailureLimit\")) {\n\t\t\t\tthis.abortAtFailureLimit = Integer.parseInt(getArgValue(args, i++));\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"-maxTotalLogFileSpace\")) {\n\t\t\t\tmaxTotalLogFileSpaceStr = getArgValue(args, i++);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"-maxSingleLogSize\")) {\n\t\t\t\tmaxSingleLogSizeStr = getArgValue(args, i++);\n\t\t\t\t\n\t\t\t} else if (argName.startsWith(\"-suite.\")) {\n\t\t\t\t// Grab suite argument, and chop it up. eg '-suite.mauve.threadCount 3'\n\t\t\t\tString suiteArgValue = getArgValue(args, i++);\n\t\t\t\tSuiteArg suiteArg = parseSuiteArg(argName, suiteArgValue);\n\t\t\t\t\n\t\t\t\t// Validate that this is not a repeated argument. \n\t\t\t\t// Guards against people how copy+paste suite config, but don't change the suite name\n\t\t\t\tif (previousArgs.contains(argName)) {\n\t\t\t\t\tif (!argName.endsWith(\".inventoryExcludeFile\")) {  // There can be multiple exclude files\n\t\t\t\t\t    throw new StfException(\"Duplicate LoadTest argument: '\" + argName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpreviousArgs.add(argName);\n\n\t\t\t\t// Check to see if this is a new suite\n\t\t\t\tif (!suiteArg.suiteName.equals(currSuiteName)) {\n\t\t\t\t\tcurrSuiteNum++;\n\t\t\t\t\tcurrSuiteName = suiteArg.suiteName;\n\t\t\t\t\tsuiteNames[currSuiteNum] = currSuiteName;\n\t\t\t\t\tif (currSuiteNum >= MAX_SUITE_NUMBER) {\n\t\t\t\t\t\tthrow new StfException(\"Too many suites. Max supported number: \" + MAX_SUITE_NUMBER);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Special case handling for exclude files.\n\t\t\t\t// There can be multiple files, so the single arg value into a comma separated list of files\n\t\t\t\tif (suiteArg.argName.equals(\"inventoryExcludeFile\") && suiteData[currSuiteNum].containsKey(suiteArg.argName)) {\n\t\t\t\t\t// There is already a value for the inventory file. Combine into a file list\n\t\t\t\t\tString existingExcludeFiles = suiteData[currSuiteNum].get(suiteArg.argName);\n\t\t\t\t\tString fullExcludeList = existingExcludeFiles + \", \" + suiteArg.argValue;\n\t\t\t\t\tsuiteData[currSuiteNum].put(suiteArg.argName, fullExcludeList);\n\t\t\t\t} else {\n\t\t\t\t\tsuiteData[currSuiteNum].put(suiteArg.argName, suiteArg.argValue);\n\t\t\t\t}"
    },
    "367": {
      "metadata": {
        "chunk_id": "9d7f6a525aa344976f19960eeff91266a49094dfa040b1614f5a9244d1aac9a0",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTest.java",
        "content": "// Special case handling for exclude files.\n\t\t\t\t// There can be multiple files, so the single arg value into a comma separated list of files\n\t\t\t\tif (suiteArg.argName.equals(\"inventoryExcludeFile\") && suiteData[currSuiteNum].containsKey(suiteArg.argName)) {\n\t\t\t\t\t// There is already a value for the inventory file. Combine into a file list\n\t\t\t\t\tString existingExcludeFiles = suiteData[currSuiteNum].get(suiteArg.argName);\n\t\t\t\t\tString fullExcludeList = existingExcludeFiles + \", \" + suiteArg.argValue;\n\t\t\t\t\tsuiteData[currSuiteNum].put(suiteArg.argName, fullExcludeList);\n\t\t\t\t} else {\n\t\t\t\t\tsuiteData[currSuiteNum].put(suiteArg.argName, suiteArg.argValue);\n\t\t\t\t}\n\n\t\t\t\t// Exit if this is not a valid suite field name\n\t\t\t\tif (!SUITE_ARGUMENTS.contains(suiteArg.argName)) {\n\t\t\t\t\tusage(\"Unknown suite argument type: \" + argName + \" \" + suiteArg.argValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tusage(\"Unknown argument: \" + argName);\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t// Validate the result directory\n\t\tif (resultsDir == null) { \n\t\t\tusage(\"Results directory must be supplied\");\n\t\t}\n\t\tif (!(resultsDir.isDirectory() && resultsDir.exists())) {\n\t\t\tusage(\"Results directory is not an existing directory: \" + resultsDir.getAbsolutePath());\n\t\t}\n\t\t\n\t\t// Make sure that it's possible to see if this is a time limited test run\n\t\tlogger.info(\"Load test parameters\");\n\t\tlogger.info(\"  Time limited         = \" + this.timeLimitedTest);\n\t\tif (timeLimitedTest) {\n\t\t\tlogger.info(\"  Time limit         = \" + this.timeLimitString);\n\t\t}\n\t\t\n\t\t// Report other load test arguments\n\t\tlogger.info(\"  abortIfOutOfMemory   = \" + abortIfOutOfMemory);\n\t\tlogger.info(\"  reportFailureLimit   = \" + reportFailureLimit);\n\t\tlogger.info(\"  abortAtFailureLimit  = \" + abortAtFailureLimit);\n\n\t\t// Find out log file sizes\n\t\tif (maxTotalLogFileSpaceStr == null) {\n\t\t\tusage(\"Value must be supplied for -maxTotalLogFileSpace\");\n\t\t}\n\t\tif (maxSingleLogSizeStr == null) {\n\t\t\tusage(\"Value must be supplied for -maxSingleLogSize\");\n\t\t}\n\t\t// Process argument for the total storage limits of log files\n\t\ttry {\n\t\t\tthis.maxTotalLogFileSpace = parseSizeWithUnits(maxTotalLogFileSpaceStr);\n\t\t} catch (StfException e) {\n\t\t\tusage(\"Failed to parse maxTotalLogFileSpace. Value: \" + maxTotalLogFileSpaceStr);\n\t\t\tthrow e;\n\t\t}\n\t\t// Process arg for max size of each log file \n\t\tif (maxSingleLogSizeStr.startsWith(\"1/\")) {\n\t\t\tString fractionalPart = maxSingleLogSizeStr.substring(maxSingleLogSizeStr.indexOf(\"/\")+1);\n\t\t\tthis.maxSingleLogSize = (int) (maxTotalLogFileSpace / Integer.parseInt(fractionalPart));\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tthis.maxSingleLogSize = (int) parseSizeWithUnits(maxSingleLogSizeStr);\n\t\t\t} catch (StfException e) {\n\t\t\t\tusage(\"Failed to parse maxSingleLogSize. Value: \" + maxSingleLogSizeStr);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t// Validation\n\t\tif (maxSingleLogSize > maxTotalLogFileSpace) {\n\t\t\tusage(\"Size of single log file cannot be greater that the size limit for all log files\");\n\t\t}\n\t\t// Show conclusion. For debugging\n\t\tlogger.info(\"  maxTotalLogFileSpace = \" + maxTotalLogFileSpace);\n\t\tlogger.info(\"  maxSingleLogSize     = \" + maxSingleLogSize);\n\t\t\n\t\t// Create suite objects, which will trigger the parsing of the inventory xml files\n\t\tfor (i=0; i<MAX_SUITE_NUMBER; i++) { \n\t\t\tHashMap<String, String> suiteArguments = suiteData[i];\n\t\t\tif (!suiteArguments.isEmpty()) {\n\t\t\t\tSuiteData suite = createSuite(resultsDir, i, suiteNames[i], suiteArguments);\n\t\t\t\tsuites.add(suite);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// Utility method to help process command line arguments.\n\t// Returns the argument at 'argNum', after checking that it exists.  \n\tprivate static String getArgValue(String[] args, int argNum) {\n\t\tif (argNum >= args.length) {\n\t\t\tString argName = args[argNum-1];\n\t\t\tthrow new IllegalStateException(\"No argument supplied for: \" + argName);\n\t\t}\n\t\t\n\t\treturn args[argNum].trim();\n\t}",
        "start_line": 247,
        "end_line": 342,
        "chunk_index": 3,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 980,
        "node_type": null,
        "file_sha": "fcc55194aa57a3463dc7a1db21a6db9d4968b784",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.889881"
      },
      "text": "// Special case handling for exclude files.\n\t\t\t\t// There can be multiple files, so the single arg value into a comma separated list of files\n\t\t\t\tif (suiteArg.argName.equals(\"inventoryExcludeFile\") && suiteData[currSuiteNum].containsKey(suiteArg.argName)) {\n\t\t\t\t\t// There is already a value for the inventory file. Combine into a file list\n\t\t\t\t\tString existingExcludeFiles = suiteData[currSuiteNum].get(suiteArg.argName);\n\t\t\t\t\tString fullExcludeList = existingExcludeFiles + \", \" + suiteArg.argValue;\n\t\t\t\t\tsuiteData[currSuiteNum].put(suiteArg.argName, fullExcludeList);\n\t\t\t\t} else {\n\t\t\t\t\tsuiteData[currSuiteNum].put(suiteArg.argName, suiteArg.argValue);\n\t\t\t\t}\n\n\t\t\t\t// Exit if this is not a valid suite field name\n\t\t\t\tif (!SUITE_ARGUMENTS.contains(suiteArg.argName)) {\n\t\t\t\t\tusage(\"Unknown suite argument type: \" + argName + \" \" + suiteArg.argValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tusage(\"Unknown argument: \" + argName);\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t// Validate the result directory\n\t\tif (resultsDir == null) { \n\t\t\tusage(\"Results directory must be supplied\");\n\t\t}\n\t\tif (!(resultsDir.isDirectory() && resultsDir.exists())) {\n\t\t\tusage(\"Results directory is not an existing directory: \" + resultsDir.getAbsolutePath());\n\t\t}\n\t\t\n\t\t// Make sure that it's possible to see if this is a time limited test run\n\t\tlogger.info(\"Load test parameters\");\n\t\tlogger.info(\"  Time limited         = \" + this.timeLimitedTest);\n\t\tif (timeLimitedTest) {\n\t\t\tlogger.info(\"  Time limit         = \" + this.timeLimitString);\n\t\t}\n\t\t\n\t\t// Report other load test arguments\n\t\tlogger.info(\"  abortIfOutOfMemory   = \" + abortIfOutOfMemory);\n\t\tlogger.info(\"  reportFailureLimit   = \" + reportFailureLimit);\n\t\tlogger.info(\"  abortAtFailureLimit  = \" + abortAtFailureLimit);\n\n\t\t// Find out log file sizes\n\t\tif (maxTotalLogFileSpaceStr == null) {\n\t\t\tusage(\"Value must be supplied for -maxTotalLogFileSpace\");\n\t\t}\n\t\tif (maxSingleLogSizeStr == null) {\n\t\t\tusage(\"Value must be supplied for -maxSingleLogSize\");\n\t\t}\n\t\t// Process argument for the total storage limits of log files\n\t\ttry {\n\t\t\tthis.maxTotalLogFileSpace = parseSizeWithUnits(maxTotalLogFileSpaceStr);\n\t\t} catch (StfException e) {\n\t\t\tusage(\"Failed to parse maxTotalLogFileSpace. Value: \" + maxTotalLogFileSpaceStr);\n\t\t\tthrow e;\n\t\t}\n\t\t// Process arg for max size of each log file \n\t\tif (maxSingleLogSizeStr.startsWith(\"1/\")) {\n\t\t\tString fractionalPart = maxSingleLogSizeStr.substring(maxSingleLogSizeStr.indexOf(\"/\")+1);\n\t\t\tthis.maxSingleLogSize = (int) (maxTotalLogFileSpace / Integer.parseInt(fractionalPart));\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tthis.maxSingleLogSize = (int) parseSizeWithUnits(maxSingleLogSizeStr);\n\t\t\t} catch (StfException e) {\n\t\t\t\tusage(\"Failed to parse maxSingleLogSize. Value: \" + maxSingleLogSizeStr);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t// Validation\n\t\tif (maxSingleLogSize > maxTotalLogFileSpace) {\n\t\t\tusage(\"Size of single log file cannot be greater that the size limit for all log files\");\n\t\t}\n\t\t// Show conclusion. For debugging\n\t\tlogger.info(\"  maxTotalLogFileSpace = \" + maxTotalLogFileSpace);\n\t\tlogger.info(\"  maxSingleLogSize     = \" + maxSingleLogSize);\n\t\t\n\t\t// Create suite objects, which will trigger the parsing of the inventory xml files\n\t\tfor (i=0; i<MAX_SUITE_NUMBER; i++) { \n\t\t\tHashMap<String, String> suiteArguments = suiteData[i];\n\t\t\tif (!suiteArguments.isEmpty()) {\n\t\t\t\tSuiteData suite = createSuite(resultsDir, i, suiteNames[i], suiteArguments);\n\t\t\t\tsuites.add(suite);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// Utility method to help process command line arguments.\n\t// Returns the argument at 'argNum', after checking that it exists.  \n\tprivate static String getArgValue(String[] args, int argNum) {\n\t\tif (argNum >= args.length) {\n\t\t\tString argName = args[argNum-1];\n\t\t\tthrow new IllegalStateException(\"No argument supplied for: \" + argName);\n\t\t}\n\t\t\n\t\treturn args[argNum].trim();\n\t}"
    },
    "368": {
      "metadata": {
        "chunk_id": "d2f0891914e8bedc3d8d8b2d3097471388c9ba633bea0e6554d4cdda007f24c3",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTest.java",
        "content": "// Utility method to help process command line arguments.\n\t// Returns the argument at 'argNum', after checking that it exists.  \n\tprivate static String getArgValue(String[] args, int argNum) {\n\t\tif (argNum >= args.length) {\n\t\t\tString argName = args[argNum-1];\n\t\t\tthrow new IllegalStateException(\"No argument supplied for: \" + argName);\n\t\t}\n\t\t\n\t\treturn args[argNum].trim();\n\t}\n\n\t\n\t// Parse a value such as '128k'\n\tprivate long parseSizeWithUnits(String valueStr) throws StfException {\n\t\tfinal Pattern pattern = Pattern.compile(\"^([0-9]+)([gGmMkK]?)$\");\n\t    Matcher matcher = pattern.matcher(valueStr);\n\t    if (!matcher.find()) {\n\t        throw new StfException(\"Invalid size specification: '\" + valueStr + \"'. Must be in the form '<size>[g|G|m|M|k|K]'\");\n\t    }\n\t    \n\t    long value = Long.parseLong(matcher.group(1));\n\t    \n\t    String unit = matcher.group(2).toUpperCase();\n\t    if (unit.equals(\"G\")) {\n\t    \tvalue = value * 1024 * 1024 *1024;\n\t    } else if (unit.equals(\"M\")) {\n\t\t    value = value * 1024 * 1024;\n\t    } else if (unit.equals(\"K\")) {\n\t    \tvalue = value * 1024;\n\t    }\n\t    \n\t\treturn value;\n\t}\n\n\n\t// Parse out the parts of a single suite argument.\n\t// eg parses \"-suite.mauve.threadCount 2\"\n\t// returns SuiteArg holding the suite number(3), argument name (threadCount) and argument value (2)\n\tprivate SuiteArg parseSuiteArg(String argName, String argValue) {\n\t\t// Extract the name of the suite\n\t\tString suitePrefix = \"-suite.\";\n\t\tint idEnd = argName.indexOf(\".\", suitePrefix.length());\n\t\tString suiteName = argName.substring(suitePrefix.length(), idEnd);\n\t\t\n\t\tSuiteArg suiteArg = new SuiteArg();\n\t\tsuiteArg.suiteName = suiteName;\t\t\n\t\tsuiteArg.argName = argName.substring(idEnd+1);\n\t\tsuiteArg.argValue = argValue;\n\t\t\n\t\treturn suiteArg;\n\t}",
        "start_line": 343,
        "end_line": 393,
        "chunk_index": 4,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 466,
        "node_type": null,
        "file_sha": "fcc55194aa57a3463dc7a1db21a6db9d4968b784",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.889883"
      },
      "text": "// Utility method to help process command line arguments.\n\t// Returns the argument at 'argNum', after checking that it exists.  \n\tprivate static String getArgValue(String[] args, int argNum) {\n\t\tif (argNum >= args.length) {\n\t\t\tString argName = args[argNum-1];\n\t\t\tthrow new IllegalStateException(\"No argument supplied for: \" + argName);\n\t\t}\n\t\t\n\t\treturn args[argNum].trim();\n\t}\n\n\t\n\t// Parse a value such as '128k'\n\tprivate long parseSizeWithUnits(String valueStr) throws StfException {\n\t\tfinal Pattern pattern = Pattern.compile(\"^([0-9]+)([gGmMkK]?)$\");\n\t    Matcher matcher = pattern.matcher(valueStr);\n\t    if (!matcher.find()) {\n\t        throw new StfException(\"Invalid size specification: '\" + valueStr + \"'. Must be in the form '<size>[g|G|m|M|k|K]'\");\n\t    }\n\t    \n\t    long value = Long.parseLong(matcher.group(1));\n\t    \n\t    String unit = matcher.group(2).toUpperCase();\n\t    if (unit.equals(\"G\")) {\n\t    \tvalue = value * 1024 * 1024 *1024;\n\t    } else if (unit.equals(\"M\")) {\n\t\t    value = value * 1024 * 1024;\n\t    } else if (unit.equals(\"K\")) {\n\t    \tvalue = value * 1024;\n\t    }\n\t    \n\t\treturn value;\n\t}\n\n\n\t// Parse out the parts of a single suite argument.\n\t// eg parses \"-suite.mauve.threadCount 2\"\n\t// returns SuiteArg holding the suite number(3), argument name (threadCount) and argument value (2)\n\tprivate SuiteArg parseSuiteArg(String argName, String argValue) {\n\t\t// Extract the name of the suite\n\t\tString suitePrefix = \"-suite.\";\n\t\tint idEnd = argName.indexOf(\".\", suitePrefix.length());\n\t\tString suiteName = argName.substring(suitePrefix.length(), idEnd);\n\t\t\n\t\tSuiteArg suiteArg = new SuiteArg();\n\t\tsuiteArg.suiteName = suiteName;\t\t\n\t\tsuiteArg.argName = argName.substring(idEnd+1);\n\t\tsuiteArg.argValue = argValue;\n\t\t\n\t\treturn suiteArg;\n\t}"
    },
    "369": {
      "metadata": {
        "chunk_id": "e2297efaaf794b39268d0b6cb7a0511eb4391d60de0d1ed52f5d4ab6afc02105",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTest.java",
        "content": "// Parse out the parts of a single suite argument.\n\t// eg parses \"-suite.mauve.threadCount 2\"\n\t// returns SuiteArg holding the suite number(3), argument name (threadCount) and argument value (2)\n\tprivate SuiteArg parseSuiteArg(String argName, String argValue) {\n\t\t// Extract the name of the suite\n\t\tString suitePrefix = \"-suite.\";\n\t\tint idEnd = argName.indexOf(\".\", suitePrefix.length());\n\t\tString suiteName = argName.substring(suitePrefix.length(), idEnd);\n\t\t\n\t\tSuiteArg suiteArg = new SuiteArg();\n\t\tsuiteArg.suiteName = suiteName;\t\t\n\t\tsuiteArg.argName = argName.substring(idEnd+1);\n\t\tsuiteArg.argValue = argValue;\n\t\t\n\t\treturn suiteArg;\n\t}\n\n\n\t/**\n\t * Create a SuiteData object to hold all the known information about a single suite.\n\t * \n\t * @param resultsDir is the STF results directory.\n\t * @param suiteNum is the number of the suite.\n\t * @param suiteName is the name the test has given the suite.\n\t * @param suiteArgs is a Hashmap of name/value pairs of the suite arguments.\n\t * @return a new SuiteData object.\n\t * @throws Exception if there is a missing suite arguments or if the inventory file cannot be parsed. \n\t */\n\tprivate SuiteData createSuite(File resultsDir, int suiteNum, String suiteName, HashMap<String, String> suiteArgs) throws Exception {\n\t\tint numThreads      = (int) readLongArg(suiteNum, suiteArgs, \"threadCount\", null);\n\t\tlong suppliedSeed    = readLongArg(suiteNum, suiteArgs, \"seed\", null);\n\t\tString inventoryFile = readArg(suiteNum, suiteArgs, \"inventoryFile\", null);\n\t\tString inventoryExcludeFiles = readArg(suiteNum, suiteArgs, \"inventoryExcludeFile\", null);\n\t\tlong numberTests     = readLongArg(suiteNum, suiteArgs, \"totalNumberTests\", \"-1\");\n\t\tint repeatCount      = (int) readLongArg(suiteNum, suiteArgs, \"repeatCount\", \"1\");\n\t\tString selectionModeString = readArg(suiteNum, suiteArgs, \"selection\", null);\n\t\tString thinkingTimeString = readArg(suiteNum, suiteArgs, \"thinkingTime\", \"0ms..0ms\");\n\t\t\n\t\tlogger.info(\"Parameters for suite \" + suiteNum);\n\t\tlogger.info(\"  Suite name     = \" + suiteName);\n\t\tlogger.info(\"  Number threads = \" + numThreads);\n\t\tlogger.info(\"  Supplied seed  = \" + suppliedSeed);\n\t\tlogger.info(\"  Inventory file = \" + inventoryFile);\n\t\tlogger.info(\"  Exclude file   = \" + inventoryExcludeFiles);\n\t\tlogger.info(\"  Number tests   = \" + numberTests);\n\t\tlogger.info(\"  Repeat count   = \" + repeatCount);\n\t\tlogger.info(\"  Thinking time  = \" + thinkingTimeString);\n\t\tlogger.info(\"  Selection mode = \" + selectionModeString);\n\t\t\n\t\t// Work out how tests are going to be selected\n\t\tSelectionMode selection;\n\t\tif (selectionModeString.equals(\"sequential\")) {\n\t\t\tselection = SelectionMode.SELECTION_SEQUENTIAL;\n\t\t} else if (selectionModeString.equals(\"random\")) {\n\t\t\tselection = SelectionMode.SELECTION_RANDOM;\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Section mode must be either 'sequential' or 'random'. Not: \" + selectionModeString);\n\t\t}\n\t\t\n\t\t// For random test selection set the seed. Either reuse previous seed, or pick a new one.\n\t\tlong seed = -1;\n\t\tif (selection == SelectionMode.SELECTION_RANDOM) {\n\t\t\tif (suppliedSeed == -1) {\n\t\t\t\t// No seed supplied. Generate a new one.\n\t\t\t\tseed = System.currentTimeMillis() + ((suiteNum+numThreads) * 277) + repeatCount*3 + inventoryFile.hashCode();\n\t\t\t} else {\n\t\t\t\t// Don't use a new seed. Use one supplied as suite argument.\n\t\t\t\tseed = suppliedSeed;\n\t\t\t}\n\t\t\tlogger.info(\"  Actual seed    = \" + seed);\n\t\t}\n\t\t\n\t\t// Parse the thinking time string into min and max values\n\t\tString[] thinkTimeValues = thinkingTimeString.split(\"\\\\.\\\\.\");\n\t\tif (thinkTimeValues.length != 2) {\n\t\t\tusage(\"Thinking time not in expected 'min..max' format: \" + thinkingTimeString);\n\t\t}\n\t\tlong minThinkingTime = TimeParser.parseTimeSpecification(thinkTimeValues[0]).getMilliseconds();\n\t\tlong maxThinkingTime = TimeParser.parseTimeSpecification(thinkTimeValues[1]).getMilliseconds();",
        "start_line": 394,
        "end_line": 472,
        "chunk_index": 5,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 971,
        "node_type": null,
        "file_sha": "fcc55194aa57a3463dc7a1db21a6db9d4968b784",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.889885"
      },
      "text": "// Parse out the parts of a single suite argument.\n\t// eg parses \"-suite.mauve.threadCount 2\"\n\t// returns SuiteArg holding the suite number(3), argument name (threadCount) and argument value (2)\n\tprivate SuiteArg parseSuiteArg(String argName, String argValue) {\n\t\t// Extract the name of the suite\n\t\tString suitePrefix = \"-suite.\";\n\t\tint idEnd = argName.indexOf(\".\", suitePrefix.length());\n\t\tString suiteName = argName.substring(suitePrefix.length(), idEnd);\n\t\t\n\t\tSuiteArg suiteArg = new SuiteArg();\n\t\tsuiteArg.suiteName = suiteName;\t\t\n\t\tsuiteArg.argName = argName.substring(idEnd+1);\n\t\tsuiteArg.argValue = argValue;\n\t\t\n\t\treturn suiteArg;\n\t}\n\n\n\t/**\n\t * Create a SuiteData object to hold all the known information about a single suite.\n\t * \n\t * @param resultsDir is the STF results directory.\n\t * @param suiteNum is the number of the suite.\n\t * @param suiteName is the name the test has given the suite.\n\t * @param suiteArgs is a Hashmap of name/value pairs of the suite arguments.\n\t * @return a new SuiteData object.\n\t * @throws Exception if there is a missing suite arguments or if the inventory file cannot be parsed. \n\t */\n\tprivate SuiteData createSuite(File resultsDir, int suiteNum, String suiteName, HashMap<String, String> suiteArgs) throws Exception {\n\t\tint numThreads      = (int) readLongArg(suiteNum, suiteArgs, \"threadCount\", null);\n\t\tlong suppliedSeed    = readLongArg(suiteNum, suiteArgs, \"seed\", null);\n\t\tString inventoryFile = readArg(suiteNum, suiteArgs, \"inventoryFile\", null);\n\t\tString inventoryExcludeFiles = readArg(suiteNum, suiteArgs, \"inventoryExcludeFile\", null);\n\t\tlong numberTests     = readLongArg(suiteNum, suiteArgs, \"totalNumberTests\", \"-1\");\n\t\tint repeatCount      = (int) readLongArg(suiteNum, suiteArgs, \"repeatCount\", \"1\");\n\t\tString selectionModeString = readArg(suiteNum, suiteArgs, \"selection\", null);\n\t\tString thinkingTimeString = readArg(suiteNum, suiteArgs, \"thinkingTime\", \"0ms..0ms\");\n\t\t\n\t\tlogger.info(\"Parameters for suite \" + suiteNum);\n\t\tlogger.info(\"  Suite name     = \" + suiteName);\n\t\tlogger.info(\"  Number threads = \" + numThreads);\n\t\tlogger.info(\"  Supplied seed  = \" + suppliedSeed);\n\t\tlogger.info(\"  Inventory file = \" + inventoryFile);\n\t\tlogger.info(\"  Exclude file   = \" + inventoryExcludeFiles);\n\t\tlogger.info(\"  Number tests   = \" + numberTests);\n\t\tlogger.info(\"  Repeat count   = \" + repeatCount);\n\t\tlogger.info(\"  Thinking time  = \" + thinkingTimeString);\n\t\tlogger.info(\"  Selection mode = \" + selectionModeString);\n\t\t\n\t\t// Work out how tests are going to be selected\n\t\tSelectionMode selection;\n\t\tif (selectionModeString.equals(\"sequential\")) {\n\t\t\tselection = SelectionMode.SELECTION_SEQUENTIAL;\n\t\t} else if (selectionModeString.equals(\"random\")) {\n\t\t\tselection = SelectionMode.SELECTION_RANDOM;\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Section mode must be either 'sequential' or 'random'. Not: \" + selectionModeString);\n\t\t}\n\t\t\n\t\t// For random test selection set the seed. Either reuse previous seed, or pick a new one.\n\t\tlong seed = -1;\n\t\tif (selection == SelectionMode.SELECTION_RANDOM) {\n\t\t\tif (suppliedSeed == -1) {\n\t\t\t\t// No seed supplied. Generate a new one.\n\t\t\t\tseed = System.currentTimeMillis() + ((suiteNum+numThreads) * 277) + repeatCount*3 + inventoryFile.hashCode();\n\t\t\t} else {\n\t\t\t\t// Don't use a new seed. Use one supplied as suite argument.\n\t\t\t\tseed = suppliedSeed;\n\t\t\t}\n\t\t\tlogger.info(\"  Actual seed    = \" + seed);\n\t\t}\n\t\t\n\t\t// Parse the thinking time string into min and max values\n\t\tString[] thinkTimeValues = thinkingTimeString.split(\"\\\\.\\\\.\");\n\t\tif (thinkTimeValues.length != 2) {\n\t\t\tusage(\"Thinking time not in expected 'min..max' format: \" + thinkingTimeString);\n\t\t}\n\t\tlong minThinkingTime = TimeParser.parseTimeSpecification(thinkTimeValues[0]).getMilliseconds();\n\t\tlong maxThinkingTime = TimeParser.parseTimeSpecification(thinkTimeValues[1]).getMilliseconds();"
    },
    "370": {
      "metadata": {
        "chunk_id": "2c8678752fe4f1e8317a0c2dab068eedbe82c88a7c5082cc97fc1a60aa25ae0b",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTest.java",
        "content": "// Make sure that the run is either time or test count limited\n\t\tif (!timeLimitedTest && numberTests == -1) {\n\t\t\tusage(\"Load test must be limited by either time or by the number of tests.\");\n\t\t}\n\t\t\n\t\t// Work out top level directory holding the copied inventory files\n\t\tDirectoryRef resultsRoot = DirectoryRef.createResultsDirectoryRef(resultsDir);\n\t\tDirectoryRef inventoryRoot = calculateInventoryRoot(inventoryFile, resultsRoot);\n\t\t\n\t\t// Work out where the inventory lives below inventoryRoot\n\t\tString inventoryFileOffset = inventoryRoot.getSubpathOf(inventoryFile);\n\t\t\n\t\t// There will be zero or more test exclude files. Build up an array list of them\n\t\tArrayList<String> excludeFiles = new ArrayList<String>();\n\t\tfor (String excludeName : inventoryExcludeFiles.split(\",\")) {\n\t\t\texcludeName = excludeName.trim();\n\t\t\tif (!excludeName.equals(\"none\")) {\n\t\t\t\tString excludeRef = inventoryRoot.getSubpathOf(excludeName);\n\t\t\t\texcludeFiles.add(excludeRef);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Read the lists of tests from the inventory file.\n\t\t// inventoryRoot is passed twice because InventoryData might receive two roots under which to look for files\n\t\t// (workspace root and test root).\n\t\tArrayList<DirectoryRef> inventoryRootArray = new ArrayList<DirectoryRef>();\n\t\tinventoryRootArray.add(inventoryRoot);\n\t\tInventoryData inventory = new InventoryData(inventoryRootArray, inventoryFileOffset, excludeFiles, false, true, dumpRequested);\n\n\t\treturn new SuiteData(suiteNum, numThreads, seed, inventory, numberTests, repeatCount, minThinkingTime, maxThinkingTime, selection);\n\t}\n\n\t\n\t// Calculates the directory which holds the load test inventories\n\t// For example,\n\t// inventoryFile = /stf/20161213-093256-SharedClassesWorkload/results/12.SCL.inventory/test.load/config/inventories/mauve/mauve_all.xml\n\t// resultsRoot   = /stf/20161213-093256-SharedClassesWorkload/results\n\t// means that:\n\t// inventoryDir  = 12.SCL.inventory\n\t// inventoryRoot = /stf/20161213-093256-SharedClassesWorkload/results/12.SCL.inventory\n\tDirectoryRef calculateInventoryRoot(String inventoryFile, DirectoryRef resultsRoot) throws StfException {\n\t\t// Remove results root prefix from the inventory file spec\n\t\tString inventory2ndHalf = resultsRoot.getSubpathOf(inventoryFile); \n\n\t\t// Create a reference to the top level directory holding inventory files\n\t\tString inventoryDirName = inventory2ndHalf.substring(0, inventory2ndHalf.indexOf(\"/\"));\n\t\tDirectoryRef inventoryRoot = resultsRoot.childDirectory(inventoryDirName);\n\n\t\treturn inventoryRoot;\n\t}\n\n\t\n\t/**\n\t * Returns a suite value from the map, or the supplied default.\n\t * @param suiteId is the number of the suite being processed.\n\t * @param suiteMap is a map containing name/value pairs with the suites arguments.\n\t * @param argName is the name of the argument to get the value for.\n\t * @param defaultValue is a default value, or null if it's a mandatory argument.\n\t * @return a String with the value of the named argument. \n\t */\n\tprivate static String readArg(int suiteId, HashMap<String, String> suiteMap, String argName, String defaultValue) {\n\t\tif (!suiteMap.containsKey(argName)) {\n\t\t\tif (defaultValue != null) { \n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\"Suite data for suite \" + suiteId + \" does not have a value for the '\" + argName + \"' field\");\n\t\t}\n\n\t\treturn suiteMap.get(argName);\n\t}\n\n\t\n\t/**\n\t * This variant of readArg() makes sure that the returned value holds a long number.\n\t */\n\tprivate static long readLongArg(int suiteId, HashMap<String, String> suiteMap, String argName, String defaultValue) {\n\t\tString longValue = readArg(suiteId, suiteMap, argName, defaultValue);\n\t\ttry { \n\t\t\treturn Long.parseLong(longValue);\n\t\t} catch (NumberFormatException e) {\n\t\t\tString fullArgName = \"suite.\" + suiteId + \".\" + argName;\n\t\t\tthrow new IllegalStateException(\"Failed to parse number for '\" + fullArgName + \"' with value: \" + longValue, e); \n\t\t}\n\t}",
        "start_line": 473,
        "end_line": 556,
        "chunk_index": 6,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 931,
        "node_type": null,
        "file_sha": "fcc55194aa57a3463dc7a1db21a6db9d4968b784",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.889887"
      },
      "text": "// Make sure that the run is either time or test count limited\n\t\tif (!timeLimitedTest && numberTests == -1) {\n\t\t\tusage(\"Load test must be limited by either time or by the number of tests.\");\n\t\t}\n\t\t\n\t\t// Work out top level directory holding the copied inventory files\n\t\tDirectoryRef resultsRoot = DirectoryRef.createResultsDirectoryRef(resultsDir);\n\t\tDirectoryRef inventoryRoot = calculateInventoryRoot(inventoryFile, resultsRoot);\n\t\t\n\t\t// Work out where the inventory lives below inventoryRoot\n\t\tString inventoryFileOffset = inventoryRoot.getSubpathOf(inventoryFile);\n\t\t\n\t\t// There will be zero or more test exclude files. Build up an array list of them\n\t\tArrayList<String> excludeFiles = new ArrayList<String>();\n\t\tfor (String excludeName : inventoryExcludeFiles.split(\",\")) {\n\t\t\texcludeName = excludeName.trim();\n\t\t\tif (!excludeName.equals(\"none\")) {\n\t\t\t\tString excludeRef = inventoryRoot.getSubpathOf(excludeName);\n\t\t\t\texcludeFiles.add(excludeRef);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Read the lists of tests from the inventory file.\n\t\t// inventoryRoot is passed twice because InventoryData might receive two roots under which to look for files\n\t\t// (workspace root and test root).\n\t\tArrayList<DirectoryRef> inventoryRootArray = new ArrayList<DirectoryRef>();\n\t\tinventoryRootArray.add(inventoryRoot);\n\t\tInventoryData inventory = new InventoryData(inventoryRootArray, inventoryFileOffset, excludeFiles, false, true, dumpRequested);\n\n\t\treturn new SuiteData(suiteNum, numThreads, seed, inventory, numberTests, repeatCount, minThinkingTime, maxThinkingTime, selection);\n\t}\n\n\t\n\t// Calculates the directory which holds the load test inventories\n\t// For example,\n\t// inventoryFile = /stf/20161213-093256-SharedClassesWorkload/results/12.SCL.inventory/test.load/config/inventories/mauve/mauve_all.xml\n\t// resultsRoot   = /stf/20161213-093256-SharedClassesWorkload/results\n\t// means that:\n\t// inventoryDir  = 12.SCL.inventory\n\t// inventoryRoot = /stf/20161213-093256-SharedClassesWorkload/results/12.SCL.inventory\n\tDirectoryRef calculateInventoryRoot(String inventoryFile, DirectoryRef resultsRoot) throws StfException {\n\t\t// Remove results root prefix from the inventory file spec\n\t\tString inventory2ndHalf = resultsRoot.getSubpathOf(inventoryFile); \n\n\t\t// Create a reference to the top level directory holding inventory files\n\t\tString inventoryDirName = inventory2ndHalf.substring(0, inventory2ndHalf.indexOf(\"/\"));\n\t\tDirectoryRef inventoryRoot = resultsRoot.childDirectory(inventoryDirName);\n\n\t\treturn inventoryRoot;\n\t}\n\n\t\n\t/**\n\t * Returns a suite value from the map, or the supplied default.\n\t * @param suiteId is the number of the suite being processed.\n\t * @param suiteMap is a map containing name/value pairs with the suites arguments.\n\t * @param argName is the name of the argument to get the value for.\n\t * @param defaultValue is a default value, or null if it's a mandatory argument.\n\t * @return a String with the value of the named argument. \n\t */\n\tprivate static String readArg(int suiteId, HashMap<String, String> suiteMap, String argName, String defaultValue) {\n\t\tif (!suiteMap.containsKey(argName)) {\n\t\t\tif (defaultValue != null) { \n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\"Suite data for suite \" + suiteId + \" does not have a value for the '\" + argName + \"' field\");\n\t\t}\n\n\t\treturn suiteMap.get(argName);\n\t}\n\n\t\n\t/**\n\t * This variant of readArg() makes sure that the returned value holds a long number.\n\t */\n\tprivate static long readLongArg(int suiteId, HashMap<String, String> suiteMap, String argName, String defaultValue) {\n\t\tString longValue = readArg(suiteId, suiteMap, argName, defaultValue);\n\t\ttry { \n\t\t\treturn Long.parseLong(longValue);\n\t\t} catch (NumberFormatException e) {\n\t\t\tString fullArgName = \"suite.\" + suiteId + \".\" + argName;\n\t\t\tthrow new IllegalStateException(\"Failed to parse number for '\" + fullArgName + \"' with value: \" + longValue, e); \n\t\t}\n\t}"
    },
    "371": {
      "metadata": {
        "chunk_id": "ff162c625baa7bda2b160d9e97298b12d649361ce0689e0ab7fe12c6c244bb3c",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTest.java",
        "content": "private void usage(String errorMessage) {\n\t\tlogger.info(\"\");\n\t\tlogger.error(errorMessage);\n\t\t\n\t\tlogger.info(\"\");\n\t\tlogger.info(\"Usage: LoadTest -resultsDir <directory> -timeLimit <time-specification> -abortIfOutOfMemory <boolean> -suite.x.name <suite-value> ...\");\n\t\tlogger.info(\"Where:\");\n\t\tdescribeArgument(\"-resultsDir <directory>\", \"Mandatory. Is an existing directory to which the results will be written.\");\n\t\tdescribeArgument(\"-resultsPrefix <string>\", \"Optional string which is used as a prefix to all files written to the results directory.\");\n\t\tdescribeArgument(\"-timeLimit <time-specification>\", \"Optional. Is the time after which no new tests will be started. Supports units of Hours, Minutes and Seconds. eg '1h15m'.\");\n\t\tdescribeArgument(\"-abortIfOutOfMemory <boolean>\", \"Optional. Set to 'false' to prevent the LoadTest aborting if out of memory. Default is 'true' (exits on OOM).\");\n\t\tdescribeArgument(\"-reportFailureLimit <int>\", \"Optional. This is the number of test failures which will be reported in detail (with name of failing test, stack trace, etc). Set '-1' to disable for reporting of all failing tests.\");\n\t\tdescribeArgument(\"-abortAtFailureLimit <int>\", \"Optional. Load test will abort when this many tests have failed. Set to '-1' to disable so that a run never aborts after a failure.\");\n\t\tdescribeArgument(\"-maxTotalLogFileSpace <size>[g|G|m|M|k|K]\", \"Mandatory. Limits the disk space used for logging test execution.\");\n\t\tdescribeArgument(\"-maxSingleLogSize <size>[g|G|m|M|k|K] | 1/<number>\", \"Mandatory. Maximum size for an individual log file. Or calculated as a fraction of maxTotalLogFileSpace (eg '1/20')\");\n\t\tdescribeArgument(\"-suite.x.threadCount <number>\", \"Mandatory. Is the number of threads to be used for running the tests of this suite.\"); \n\t\tdescribeArgument(\"-suite.x.seed <starting-seed>\", \"Mandatory. Sets the starting value for the random number generator used to select the next test. A value of '-1' will use a new seed. Use a pervious value to duplicate a run.\");\n\t\tdescribeArgument(\"-suite.x.inventoryFile <file>\", \"Mandatory. Specifies the file which lists the test that can be run for the suite.\"); \n\t\tdescribeArgument(\"-suite.x.totalNumberTests <number>\", \"Optional. This is the number of tests which will run before completing this suite. If not specified the load test wil run until the time limit.\"); \n\t\tdescribeArgument(\"-suite.x.repeatCount <number>\", \"Optional. This is the number of times that a test will executed before a different test is selected. Defaults to '1'.\"); \n\t\tdescribeArgument(\"-suite.x.thinkingTime min..max\", \"Optional. Random delay in load test thread between executing sucessive tests. Defaults to '0ms..0ms'.\"); \n\t\tdescribeArgument(\"-suite.x.selection ( random | sequential)\", \"Mandatory. Controls how the next test will be selected. When running sequentially it loops back to the start of the inventory after executing the last test in the list.\"); \n\t\t\t\n\t\tlogger.error(errorMessage);\n\t\t\n\t\tSystem.exit(2);\n\t}\n\t\n\t\n\tprivate void describeArgument(String argSpec, String argDescription) {\n\t\tlogger.info(\"  \" + argSpec); \n\t\t\n\t\t// Output long description texts over multiple info lines \n\t\tString[] words = argDescription.split(\" \");\n\t\tStringBuilder line = new StringBuilder();\n\t\tfor (String word : words) {\n\t\t\tif (line.length() + word.length() > 55) {\n\t\t\t\tlogger.info(\"     \" + line.toString());\n\t\t\t\tline.setLength(0);\n\t\t\t}\n\t\t\tline.append(\" \");\n\t\t\tline.append(word);\n\t\t}\n\t\t// Output the last few words\n\t\tlogger.info(\"     \" + line.toString());\n\t\tlogger.info(\"\");\n\t}\n}",
        "start_line": 557,
        "end_line": 604,
        "chunk_index": 7,
        "total_chunks": 8,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 828,
        "node_type": null,
        "file_sha": "fcc55194aa57a3463dc7a1db21a6db9d4968b784",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.889889"
      },
      "text": "private void usage(String errorMessage) {\n\t\tlogger.info(\"\");\n\t\tlogger.error(errorMessage);\n\t\t\n\t\tlogger.info(\"\");\n\t\tlogger.info(\"Usage: LoadTest -resultsDir <directory> -timeLimit <time-specification> -abortIfOutOfMemory <boolean> -suite.x.name <suite-value> ...\");\n\t\tlogger.info(\"Where:\");\n\t\tdescribeArgument(\"-resultsDir <directory>\", \"Mandatory. Is an existing directory to which the results will be written.\");\n\t\tdescribeArgument(\"-resultsPrefix <string>\", \"Optional string which is used as a prefix to all files written to the results directory.\");\n\t\tdescribeArgument(\"-timeLimit <time-specification>\", \"Optional. Is the time after which no new tests will be started. Supports units of Hours, Minutes and Seconds. eg '1h15m'.\");\n\t\tdescribeArgument(\"-abortIfOutOfMemory <boolean>\", \"Optional. Set to 'false' to prevent the LoadTest aborting if out of memory. Default is 'true' (exits on OOM).\");\n\t\tdescribeArgument(\"-reportFailureLimit <int>\", \"Optional. This is the number of test failures which will be reported in detail (with name of failing test, stack trace, etc). Set '-1' to disable for reporting of all failing tests.\");\n\t\tdescribeArgument(\"-abortAtFailureLimit <int>\", \"Optional. Load test will abort when this many tests have failed. Set to '-1' to disable so that a run never aborts after a failure.\");\n\t\tdescribeArgument(\"-maxTotalLogFileSpace <size>[g|G|m|M|k|K]\", \"Mandatory. Limits the disk space used for logging test execution.\");\n\t\tdescribeArgument(\"-maxSingleLogSize <size>[g|G|m|M|k|K] | 1/<number>\", \"Mandatory. Maximum size for an individual log file. Or calculated as a fraction of maxTotalLogFileSpace (eg '1/20')\");\n\t\tdescribeArgument(\"-suite.x.threadCount <number>\", \"Mandatory. Is the number of threads to be used for running the tests of this suite.\"); \n\t\tdescribeArgument(\"-suite.x.seed <starting-seed>\", \"Mandatory. Sets the starting value for the random number generator used to select the next test. A value of '-1' will use a new seed. Use a pervious value to duplicate a run.\");\n\t\tdescribeArgument(\"-suite.x.inventoryFile <file>\", \"Mandatory. Specifies the file which lists the test that can be run for the suite.\"); \n\t\tdescribeArgument(\"-suite.x.totalNumberTests <number>\", \"Optional. This is the number of tests which will run before completing this suite. If not specified the load test wil run until the time limit.\"); \n\t\tdescribeArgument(\"-suite.x.repeatCount <number>\", \"Optional. This is the number of times that a test will executed before a different test is selected. Defaults to '1'.\"); \n\t\tdescribeArgument(\"-suite.x.thinkingTime min..max\", \"Optional. Random delay in load test thread between executing sucessive tests. Defaults to '0ms..0ms'.\"); \n\t\tdescribeArgument(\"-suite.x.selection ( random | sequential)\", \"Mandatory. Controls how the next test will be selected. When running sequentially it loops back to the start of the inventory after executing the last test in the list.\"); \n\t\t\t\n\t\tlogger.error(errorMessage);\n\t\t\n\t\tSystem.exit(2);\n\t}\n\t\n\t\n\tprivate void describeArgument(String argSpec, String argDescription) {\n\t\tlogger.info(\"  \" + argSpec); \n\t\t\n\t\t// Output long description texts over multiple info lines \n\t\tString[] words = argDescription.split(\" \");\n\t\tStringBuilder line = new StringBuilder();\n\t\tfor (String word : words) {\n\t\t\tif (line.length() + word.length() > 55) {\n\t\t\t\tlogger.info(\"     \" + line.toString());\n\t\t\t\tline.setLength(0);\n\t\t\t}\n\t\t\tline.append(\" \");\n\t\t\tline.append(word);\n\t\t}\n\t\t// Output the last few words\n\t\tlogger.info(\"     \" + line.toString());\n\t\tlogger.info(\"\");\n\t}\n}"
    },
    "372": {
      "metadata": {
        "chunk_id": "2e9f4393a8bf4d33b0a9d44ba40517436348037decc2d594e768e32f1012f695",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTestRunner.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.Thread.UncaughtExceptionHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\nimport net.adoptopenjdk.loadTest.adaptors.LoadTestBase;\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface.ResultStatus;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionLog;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionTracker;\nimport net.adoptopenjdk.loadTest.reporting.OutputFilter;\n\n/**\n * This class holds the core of the load test.\n * It starts threads which run tests until the test limits are reached.\n */",
        "start_line": 0,
        "end_line": 42,
        "chunk_index": 0,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 335,
        "node_type": null,
        "file_sha": "85efc3d6538d9f5b69065cb36adbebd994e13ba3",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.910590"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.Thread.UncaughtExceptionHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\nimport net.adoptopenjdk.loadTest.adaptors.LoadTestBase;\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface.ResultStatus;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionLog;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionTracker;\nimport net.adoptopenjdk.loadTest.reporting.OutputFilter;\n\n/**\n * This class holds the core of the load test.\n * It starts threads which run tests until the test limits are reached.\n */"
    },
    "373": {
      "metadata": {
        "chunk_id": "42cd981d196f1f99d2cea8bfef035d42770becd13813c4ccd312eafcb7313f42",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTestRunner.java",
        "content": "class LoadTestRunner {\n    private static final Logger logger = LogManager.getLogger(LoadTestRunner.class.getName());\n    \n\tprivate static final String REPORTING_FREQUENCY_ENV_NAME = \"LT_REPORTING_FREQUENCY\";\t\n\tprivate static final long HUNG_MESSAGE_REPEAT_TIME = 5 * 1000; \n\t\n\tprivate final File resultsDir;\n\tprivate final String resultsPrefix;\n\tprivate final boolean timeLimitedTest;\n\tprivate final long testEndTime;\n\tprivate final long testInactivityLimit; \n\tprivate final boolean abortIfOutOfMemory;\n\tprivate final int reportFailureLimit;\n\tprivate final int abortAtFailureLimit;\n\tprivate final long maxTotalLogFileSpace;\n\tprivate final int maxSingleLogSize;\n\tprivate final ArrayList<SuiteData> suites;\n\tprivate final long reportingFrequency;\n\tprivate boolean dumpRequested; \n\n\t\n\tLoadTestRunner(File resultsDir, String resultsPrefix, boolean timeLimitedTest, long testEndTime, \n\t\t\t    long testInactivityLimit,\n\t\t\t\tboolean abortIfOutOfMemory,\n\t\t\t\tint reportFailureLimit, int abortAtFailureLimit,\n\t\t\t\tlong maxTotalLogFileSpace, int maxSingleLogSize,\n\t\t\t\tArrayList<SuiteData> suites,\n\t\t\t\tboolean dumpRequested) {\n\t\tthis.resultsDir = resultsDir;\n\t\tthis.resultsPrefix = resultsPrefix;\n\t\tthis.timeLimitedTest = timeLimitedTest;\n\t\tthis.testEndTime = testEndTime;\n\t\tthis.testInactivityLimit = testInactivityLimit; \n\t\tthis.abortIfOutOfMemory = abortIfOutOfMemory;\n\t\tthis.reportFailureLimit = reportFailureLimit;\n\t\tthis.abortAtFailureLimit = abortAtFailureLimit;\n\t\tthis.maxTotalLogFileSpace = maxTotalLogFileSpace;\n\t\tthis.maxSingleLogSize = maxSingleLogSize;\n\t\tthis.suites = suites;\n\t\tthis.dumpRequested = dumpRequested; \n\t\t\n\t\t// Decide how frequency progress reports are to be made\n\t\tString reportingFrequencyString = System.getenv(REPORTING_FREQUENCY_ENV_NAME);\n\t\tif (reportingFrequencyString != null) {\n\t\t\tthis.reportingFrequency = Long.parseLong(reportingFrequencyString);\t\t\t\n\t\t} else {\n\t\t\tthis.reportingFrequency = 20 * 1000;\n\t\t}\n\t}\n\n\t/**\n\t * Runs the tests.\n\t * @return long containing a count of the number of failing tests .\n\t * @throws Exception if there was an IO exception writing to a log file.\n\t */\n\tlong run() throws Exception {\n\t\t// Report and fail if there are any uncaught exceptions\n\t\tfinal AtomicLong numberUncaughtExceptions = new AtomicLong(0);\n\t\t Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {\n\t\t\t@Override\n\t\t\tpublic void uncaughtException(Thread thread, Throwable throwable) {\n\t\t\t\tnumberUncaughtExceptions.incrementAndGet();\n\t\t\t\tlogger.error(\"Uncaught exception: \", throwable);\n\t\t\t}\n\t\t});\n\t\t \n\t\t// For periodic progress reporting\n\t\tlong testStartTime = System.currentTimeMillis();\n\t\tlong numProgressUpdates = 0;\n\t\tlong firstReportTime = System.currentTimeMillis() + reportingFrequency;\n\t\tlong nextReportTime = firstReportTime;\n\t\tlong previousNumStartedTests = 0;\n\t\t\n\t\t// Track the number of passing/failing tests.\n\t\t// This is shared between all worker threads so using atomic counter.\n\t\tfinal AtomicLong numberStartedTests = new AtomicLong(0);\n\t\tfinal AtomicLong[] passingTestCounters = new AtomicLong[suites.size()];\n\t\tfinal AtomicLong[] failingTestCounters = new AtomicLong[suites.size()];\n\t\tfor (int i=0; i<suites.size(); i++) {\n\t\t\tpassingTestCounters[i] = new AtomicLong(0);\n\t\t\tfailingTestCounters[i] = new AtomicLong(0);\n\t\t}\n\t\t\n\t\t// Flag for forcing early thread completion\n\t\tfinal AtomicBoolean testRunAborted = new AtomicBoolean(false);",
        "start_line": 43,
        "end_line": 127,
        "chunk_index": 1,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 766,
        "node_type": null,
        "file_sha": "85efc3d6538d9f5b69065cb36adbebd994e13ba3",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.910599"
      },
      "text": "class LoadTestRunner {\n    private static final Logger logger = LogManager.getLogger(LoadTestRunner.class.getName());\n    \n\tprivate static final String REPORTING_FREQUENCY_ENV_NAME = \"LT_REPORTING_FREQUENCY\";\t\n\tprivate static final long HUNG_MESSAGE_REPEAT_TIME = 5 * 1000; \n\t\n\tprivate final File resultsDir;\n\tprivate final String resultsPrefix;\n\tprivate final boolean timeLimitedTest;\n\tprivate final long testEndTime;\n\tprivate final long testInactivityLimit; \n\tprivate final boolean abortIfOutOfMemory;\n\tprivate final int reportFailureLimit;\n\tprivate final int abortAtFailureLimit;\n\tprivate final long maxTotalLogFileSpace;\n\tprivate final int maxSingleLogSize;\n\tprivate final ArrayList<SuiteData> suites;\n\tprivate final long reportingFrequency;\n\tprivate boolean dumpRequested; \n\n\t\n\tLoadTestRunner(File resultsDir, String resultsPrefix, boolean timeLimitedTest, long testEndTime, \n\t\t\t    long testInactivityLimit,\n\t\t\t\tboolean abortIfOutOfMemory,\n\t\t\t\tint reportFailureLimit, int abortAtFailureLimit,\n\t\t\t\tlong maxTotalLogFileSpace, int maxSingleLogSize,\n\t\t\t\tArrayList<SuiteData> suites,\n\t\t\t\tboolean dumpRequested) {\n\t\tthis.resultsDir = resultsDir;\n\t\tthis.resultsPrefix = resultsPrefix;\n\t\tthis.timeLimitedTest = timeLimitedTest;\n\t\tthis.testEndTime = testEndTime;\n\t\tthis.testInactivityLimit = testInactivityLimit; \n\t\tthis.abortIfOutOfMemory = abortIfOutOfMemory;\n\t\tthis.reportFailureLimit = reportFailureLimit;\n\t\tthis.abortAtFailureLimit = abortAtFailureLimit;\n\t\tthis.maxTotalLogFileSpace = maxTotalLogFileSpace;\n\t\tthis.maxSingleLogSize = maxSingleLogSize;\n\t\tthis.suites = suites;\n\t\tthis.dumpRequested = dumpRequested; \n\t\t\n\t\t// Decide how frequency progress reports are to be made\n\t\tString reportingFrequencyString = System.getenv(REPORTING_FREQUENCY_ENV_NAME);\n\t\tif (reportingFrequencyString != null) {\n\t\t\tthis.reportingFrequency = Long.parseLong(reportingFrequencyString);\t\t\t\n\t\t} else {\n\t\t\tthis.reportingFrequency = 20 * 1000;\n\t\t}\n\t}\n\n\t/**\n\t * Runs the tests.\n\t * @return long containing a count of the number of failing tests .\n\t * @throws Exception if there was an IO exception writing to a log file.\n\t */\n\tlong run() throws Exception {\n\t\t// Report and fail if there are any uncaught exceptions\n\t\tfinal AtomicLong numberUncaughtExceptions = new AtomicLong(0);\n\t\t Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {\n\t\t\t@Override\n\t\t\tpublic void uncaughtException(Thread thread, Throwable throwable) {\n\t\t\t\tnumberUncaughtExceptions.incrementAndGet();\n\t\t\t\tlogger.error(\"Uncaught exception: \", throwable);\n\t\t\t}\n\t\t});\n\t\t \n\t\t// For periodic progress reporting\n\t\tlong testStartTime = System.currentTimeMillis();\n\t\tlong numProgressUpdates = 0;\n\t\tlong firstReportTime = System.currentTimeMillis() + reportingFrequency;\n\t\tlong nextReportTime = firstReportTime;\n\t\tlong previousNumStartedTests = 0;\n\t\t\n\t\t// Track the number of passing/failing tests.\n\t\t// This is shared between all worker threads so using atomic counter.\n\t\tfinal AtomicLong numberStartedTests = new AtomicLong(0);\n\t\tfinal AtomicLong[] passingTestCounters = new AtomicLong[suites.size()];\n\t\tfinal AtomicLong[] failingTestCounters = new AtomicLong[suites.size()];\n\t\tfor (int i=0; i<suites.size(); i++) {\n\t\t\tpassingTestCounters[i] = new AtomicLong(0);\n\t\t\tfailingTestCounters[i] = new AtomicLong(0);\n\t\t}\n\t\t\n\t\t// Flag for forcing early thread completion\n\t\tfinal AtomicBoolean testRunAborted = new AtomicBoolean(false);"
    },
    "374": {
      "metadata": {
        "chunk_id": "a5bf6e46ad25a25a4938221951c18ae8ba350c5c5a4fdd00281fcd9751d979a1",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTestRunner.java",
        "content": "// Redirect stdout/stderr. This is done so that:\n\t\t//  1) Minimises the output from a run.\n\t\t//  2) Allows the OutputFilter class to match the stdout/err output to the test which produced it.\n\t\tfinal PrintStream originalSystemOut = System.out;\n\t\tfinal PrintStream originalSystemErr = System.err;\n\t\tSystem.setOut(new OutputFilter(System.out, false)); \n        System.setErr(new OutputFilter(System.err, false));\n\t\t\n        // Create a file to hold binary data on test starts and results.\n\t\tFile executionLogFile = new File(resultsDir, resultsPrefix + \"executionlog\"); \n\t\tExecutionLog.createInstance(executionLogFile, maxTotalLogFileSpace, maxSingleLogSize, suites);\n\t\t\n\t\tExecutorService es = Executors.newCachedThreadPool();\n\t\t\n\t\tint nextThreadNum = 0;\n\t\tfor (int i=0; i<suites.size(); i++) {\n\t\t\tfinal SuiteData suite = suites.get(i);\n\t\t\tfor (int t=0; t<suite.getNumberThreads(); t++) {\n\t\t\t\tfinal int threadNum = nextThreadNum++;\n\t\t\t\tfinal AtomicLong numberPassingTests = passingTestCounters[suite.getSuiteId()];\n\t\t\t\tfinal AtomicLong numberFailingTests = failingTestCounters[suite.getSuiteId()];\n\t\t\t\t\n\t\t\t\tlogger.info(\"Starting thread. Suite=\" + suite.getSuiteId() + \" thread=\" + threadNum);\n\t\t\t\t\n\t\t\t\t// Start thread to run tests\n\t\t\t\tes.execute(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tString threadName = \"load-\" + threadNum;\n\t\t\t\t\t\tThread.currentThread().setName(threadName);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Variables to support inter test thinking time.\n\t\t\t\t\t\t// Note the random seed value. This allows inter test spacing to be reproducible from run to run.\n\t\t\t\t\t\tlong thinkingTimeMin = suite.getMinThinkingTime();\n\t\t\t\t\t\tint thinkingTimeRange = (int) (suite.getMaxThinkingTime() - thinkingTimeMin);\n\t\t\t\t\t\tboolean doThinkingTimeSleep = thinkingTimeMin > 0  ||  thinkingTimeRange > 0; \n\t\t\t\t\t\tRandom thinkingTimeRnd = new Random(threadName.hashCode() + thinkingTimeMin + thinkingTimeRange);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Create tracker object to record which test is running, output and result\n\t\t\t\t\t\tExecutionTracker.createNewTracker();\n\t\t\t\t\t\tExecutionTracker executionTracker = ExecutionTracker.instance();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Run tests until the inventory says there are none left, or the time limit is reached\n\t\t\t\t\t\tAdaptorInterface test;\n\t\t\t\t\t\twhile ((test = suite.getNextTest()) != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Keep note on which test this thread is running\n\t\t\t\t\t\t\t\texecutionTracker.recordTestStart(test, suite.getSuiteId(), threadNum);\n\n\t\t\t\t\t\t\t\t// Run the actual test\n\t\t\t\t\t\t\t\tnumberStartedTests.incrementAndGet();\n\t\t\t\t\t\t\t\tResultStatus testResult = null;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttestResult = test.executeTest();\n\t\t\t\t\t\t\t\t} catch(BlockedExitException exitException) {\n\t\t\t\t\t\t\t\t\t// The test has attempted to call System.exit(). Keep running.\n\t\t\t\t\t\t\t\t\tif (exitException.getExitValue() == 0) {\n\t\t\t\t\t\t\t\t\t\ttestResult = ResultStatus.BLOCKED_EXIT_PASS;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttestResult = ResultStatus.BLOCKED_EXIT_FAIL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\t// Some other exception. Rethrow to log as test failure.\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t}",
        "start_line": 128,
        "end_line": 191,
        "chunk_index": 2,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 700,
        "node_type": null,
        "file_sha": "85efc3d6538d9f5b69065cb36adbebd994e13ba3",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.910602"
      },
      "text": "// Redirect stdout/stderr. This is done so that:\n\t\t//  1) Minimises the output from a run.\n\t\t//  2) Allows the OutputFilter class to match the stdout/err output to the test which produced it.\n\t\tfinal PrintStream originalSystemOut = System.out;\n\t\tfinal PrintStream originalSystemErr = System.err;\n\t\tSystem.setOut(new OutputFilter(System.out, false)); \n        System.setErr(new OutputFilter(System.err, false));\n\t\t\n        // Create a file to hold binary data on test starts and results.\n\t\tFile executionLogFile = new File(resultsDir, resultsPrefix + \"executionlog\"); \n\t\tExecutionLog.createInstance(executionLogFile, maxTotalLogFileSpace, maxSingleLogSize, suites);\n\t\t\n\t\tExecutorService es = Executors.newCachedThreadPool();\n\t\t\n\t\tint nextThreadNum = 0;\n\t\tfor (int i=0; i<suites.size(); i++) {\n\t\t\tfinal SuiteData suite = suites.get(i);\n\t\t\tfor (int t=0; t<suite.getNumberThreads(); t++) {\n\t\t\t\tfinal int threadNum = nextThreadNum++;\n\t\t\t\tfinal AtomicLong numberPassingTests = passingTestCounters[suite.getSuiteId()];\n\t\t\t\tfinal AtomicLong numberFailingTests = failingTestCounters[suite.getSuiteId()];\n\t\t\t\t\n\t\t\t\tlogger.info(\"Starting thread. Suite=\" + suite.getSuiteId() + \" thread=\" + threadNum);\n\t\t\t\t\n\t\t\t\t// Start thread to run tests\n\t\t\t\tes.execute(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tString threadName = \"load-\" + threadNum;\n\t\t\t\t\t\tThread.currentThread().setName(threadName);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Variables to support inter test thinking time.\n\t\t\t\t\t\t// Note the random seed value. This allows inter test spacing to be reproducible from run to run.\n\t\t\t\t\t\tlong thinkingTimeMin = suite.getMinThinkingTime();\n\t\t\t\t\t\tint thinkingTimeRange = (int) (suite.getMaxThinkingTime() - thinkingTimeMin);\n\t\t\t\t\t\tboolean doThinkingTimeSleep = thinkingTimeMin > 0  ||  thinkingTimeRange > 0; \n\t\t\t\t\t\tRandom thinkingTimeRnd = new Random(threadName.hashCode() + thinkingTimeMin + thinkingTimeRange);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Create tracker object to record which test is running, output and result\n\t\t\t\t\t\tExecutionTracker.createNewTracker();\n\t\t\t\t\t\tExecutionTracker executionTracker = ExecutionTracker.instance();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Run tests until the inventory says there are none left, or the time limit is reached\n\t\t\t\t\t\tAdaptorInterface test;\n\t\t\t\t\t\twhile ((test = suite.getNextTest()) != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Keep note on which test this thread is running\n\t\t\t\t\t\t\t\texecutionTracker.recordTestStart(test, suite.getSuiteId(), threadNum);\n\n\t\t\t\t\t\t\t\t// Run the actual test\n\t\t\t\t\t\t\t\tnumberStartedTests.incrementAndGet();\n\t\t\t\t\t\t\t\tResultStatus testResult = null;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttestResult = test.executeTest();\n\t\t\t\t\t\t\t\t} catch(BlockedExitException exitException) {\n\t\t\t\t\t\t\t\t\t// The test has attempted to call System.exit(). Keep running.\n\t\t\t\t\t\t\t\t\tif (exitException.getExitValue() == 0) {\n\t\t\t\t\t\t\t\t\t\ttestResult = ResultStatus.BLOCKED_EXIT_PASS;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttestResult = ResultStatus.BLOCKED_EXIT_FAIL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\t// Some other exception. Rethrow to log as test failure.\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t}"
    },
    "375": {
      "metadata": {
        "chunk_id": "0db74bd6854559b1ef886616fdadf098881e6d7f73036d8459b0a743ff46877c",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTestRunner.java",
        "content": "// Run the actual test\n\t\t\t\t\t\t\t\tnumberStartedTests.incrementAndGet();\n\t\t\t\t\t\t\t\tResultStatus testResult = null;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttestResult = test.executeTest();\n\t\t\t\t\t\t\t\t} catch(BlockedExitException exitException) {\n\t\t\t\t\t\t\t\t\t// The test has attempted to call System.exit(). Keep running.\n\t\t\t\t\t\t\t\t\tif (exitException.getExitValue() == 0) {\n\t\t\t\t\t\t\t\t\t\ttestResult = ResultStatus.BLOCKED_EXIT_PASS;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttestResult = ResultStatus.BLOCKED_EXIT_FAIL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\t// Some other exception. Rethrow to log as test failure.\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Test completed. Record pass/fail result to file\n\t\t\t\t\t\t\t\tboolean testPassed = executionTracker.recordTestCompletion(testResult);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Keep in-memory count of pass/fail result\n\t\t\t\t\t\t\t\tif (testPassed) {\n\t\t\t\t\t\t\t\t\tnumberPassingTests.incrementAndGet();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Produce java dumps for only the first test failure if flag for creating dump is set by user\n\t\t\t\t\t\t\t\t\tlong failureNum = numberFailingTests.incrementAndGet();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tlogger.info(\"suite.getInventory().getInventoryFileRef(): \" + suite.getInventory().getInventoryFileRef());\n\t\t\t\t\t\t\t\t\tlogger.info(\"suite.isCreateDump() : \" + dumpRequested);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure((LoadTestBase) test, dumpRequested);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// Get log4j to report the test failure\n\t\t\t\t\t\t\t\t\treportFailure(failureNum, executionTracker.getCapturedOutput(), test, suite, threadNum);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Inter test thinking time\n\t\t\t\t\t\t\t\tif (doThinkingTimeSleep) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlong thinkingTime = thinkingTimeMin;\n\t\t\t\t\t\t\t\t\t\tif (thinkingTimeRange > 0) {\n\t\t\t\t\t\t\t\t\t\t\tthinkingTime += thinkingTimeRnd.nextInt(thinkingTimeRange);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tThread.sleep(thinkingTime);\n\t\t\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\t\t// Record test failure to binary execution log file\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\texecutionTracker.recordTestFailure(t);\n\t\t\t\t\t\t\t\t} catch (IOException ioException) {\n\t\t\t\t\t\t\t\t\t// Not sure what else can be done at this point.\n\t\t\t\t\t\t\t\t\t// We have caught a failure but then had another failure when logging this. \n\t\t\t\t\t\t\t\t\tlogger.error(\"Internal Error: Failed to record test failure\", ioException);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Produce java dumps if this is the first test error\n\t\t\t\t\t\t\t\tlong failureNum = numberFailingTests.incrementAndGet();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure((LoadTestBase) test, dumpRequested);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Report exception to process output\n\t\t\t\t\t\t\t\treportFailure(failureNum, executionTracker.getCapturedOutput(), test, suite, threadNum);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Out of memory exceptions are regarded as fatal for the JVM\n\t\t\t\t\t\t\t\tif (t instanceof OutOfMemoryError && abortIfOutOfMemory) {\n\t\t\t\t\t\t\t\t\t// Force completion of the test, by getting all threads to exit\n\t\t\t\t\t\t\t\t\tlogger.error(\"Out of memory exception. Aborting test run\", t);\n\t\t\t\t\t\t\t\t\ttestRunAborted.set(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Exit thread if it's a time restricted run and we have hit the time limit\n\t\t\t\t\t\t\tif (timeLimitedTest && System.currentTimeMillis() > testEndTime) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Check to see if the test has decided to abort or not\n\t\t\t\t\t\t\tif (testRunAborted.get()) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // end while\n\n\t\t\t\t\t\tlogger.info(\"Thread completed. Suite=\" + suite.getSuiteId() + \" thread=\" + threadNum);\n\t\t\t\t\t} // end run()",
        "start_line": 192,
        "end_line": 277,
        "chunk_index": 3,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 782,
        "node_type": null,
        "file_sha": "85efc3d6538d9f5b69065cb36adbebd994e13ba3",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.910604"
      },
      "text": "// Run the actual test\n\t\t\t\t\t\t\t\tnumberStartedTests.incrementAndGet();\n\t\t\t\t\t\t\t\tResultStatus testResult = null;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttestResult = test.executeTest();\n\t\t\t\t\t\t\t\t} catch(BlockedExitException exitException) {\n\t\t\t\t\t\t\t\t\t// The test has attempted to call System.exit(). Keep running.\n\t\t\t\t\t\t\t\t\tif (exitException.getExitValue() == 0) {\n\t\t\t\t\t\t\t\t\t\ttestResult = ResultStatus.BLOCKED_EXIT_PASS;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttestResult = ResultStatus.BLOCKED_EXIT_FAIL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\t// Some other exception. Rethrow to log as test failure.\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Test completed. Record pass/fail result to file\n\t\t\t\t\t\t\t\tboolean testPassed = executionTracker.recordTestCompletion(testResult);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Keep in-memory count of pass/fail result\n\t\t\t\t\t\t\t\tif (testPassed) {\n\t\t\t\t\t\t\t\t\tnumberPassingTests.incrementAndGet();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Produce java dumps for only the first test failure if flag for creating dump is set by user\n\t\t\t\t\t\t\t\t\tlong failureNum = numberFailingTests.incrementAndGet();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tlogger.info(\"suite.getInventory().getInventoryFileRef(): \" + suite.getInventory().getInventoryFileRef());\n\t\t\t\t\t\t\t\t\tlogger.info(\"suite.isCreateDump() : \" + dumpRequested);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure((LoadTestBase) test, dumpRequested);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// Get log4j to report the test failure\n\t\t\t\t\t\t\t\t\treportFailure(failureNum, executionTracker.getCapturedOutput(), test, suite, threadNum);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Inter test thinking time\n\t\t\t\t\t\t\t\tif (doThinkingTimeSleep) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlong thinkingTime = thinkingTimeMin;\n\t\t\t\t\t\t\t\t\t\tif (thinkingTimeRange > 0) {\n\t\t\t\t\t\t\t\t\t\t\tthinkingTime += thinkingTimeRnd.nextInt(thinkingTimeRange);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tThread.sleep(thinkingTime);\n\t\t\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\t\t// Record test failure to binary execution log file\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\texecutionTracker.recordTestFailure(t);\n\t\t\t\t\t\t\t\t} catch (IOException ioException) {\n\t\t\t\t\t\t\t\t\t// Not sure what else can be done at this point.\n\t\t\t\t\t\t\t\t\t// We have caught a failure but then had another failure when logging this. \n\t\t\t\t\t\t\t\t\tlogger.error(\"Internal Error: Failed to record test failure\", ioException);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Produce java dumps if this is the first test error\n\t\t\t\t\t\t\t\tlong failureNum = numberFailingTests.incrementAndGet();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure((LoadTestBase) test, dumpRequested);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Report exception to process output\n\t\t\t\t\t\t\t\treportFailure(failureNum, executionTracker.getCapturedOutput(), test, suite, threadNum);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Out of memory exceptions are regarded as fatal for the JVM\n\t\t\t\t\t\t\t\tif (t instanceof OutOfMemoryError && abortIfOutOfMemory) {\n\t\t\t\t\t\t\t\t\t// Force completion of the test, by getting all threads to exit\n\t\t\t\t\t\t\t\t\tlogger.error(\"Out of memory exception. Aborting test run\", t);\n\t\t\t\t\t\t\t\t\ttestRunAborted.set(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Exit thread if it's a time restricted run and we have hit the time limit\n\t\t\t\t\t\t\tif (timeLimitedTest && System.currentTimeMillis() > testEndTime) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Check to see if the test has decided to abort or not\n\t\t\t\t\t\t\tif (testRunAborted.get()) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // end while\n\n\t\t\t\t\t\tlogger.info(\"Thread completed. Suite=\" + suite.getSuiteId() + \" thread=\" + threadNum);\n\t\t\t\t\t} // end run()"
    },
    "376": {
      "metadata": {
        "chunk_id": "79b62d973e30250781874f9453f0b6d1c7da34cafe3d22ce15253f647162e2d2",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTestRunner.java",
        "content": "logger.info(\"Thread completed. Suite=\" + suite.getSuiteId() + \" thread=\" + threadNum);\n\t\t\t\t\t} // end run()\n\n\n\t\t\t\t\tprivate void reportFailure(long failureNum, ByteArrayOutputStream capturedOutput,\n\t\t\t\t\t\t\tAdaptorInterface test, final SuiteData suite, final int threadNum) {\n\t\t\t\t\t\tif (reportFailureLimit == -1 || failureNum <= reportFailureLimit) {\n\t\t\t\t\t\t\tlogger.error(\"Test failed\"\n\t\t\t\t\t\t\t\t+ \"\\n  Failure num.  = \" + failureNum\n\t\t\t\t\t\t\t\t+ \"\\n  Test number   = \" + test.getTestNum() \n\t\t\t\t\t\t\t\t+ \"\\n  Test details  = '\" + test.toString() + \"'\"\n\t\t\t\t\t\t\t\t+ \"\\n  Suite number  = \" + suite.getSuiteId()\n\t\t\t\t\t\t\t\t+ \"\\n  Thread number = \" + threadNum \n\t\t\t\t\t\t\t\t+ \"\\n>>> Captured test output >>>\\n\"\n\t\t\t\t\t\t\t\t+ capturedOutput.toString().trim()\n\t\t\t\t\t\t\t\t+ \"\\n<<<\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.error(\"Test failed. Details recorded in execution log.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (abortAtFailureLimit != -1 && failureNum == abortAtFailureLimit) {\n\t\t\t\t\t\t\tlogger.info(\"Number of test failures has reached 'AbortAtFailureLimit' (\" + failureNum + \"). Terminating load test\");\n\t\t\t\t\t\t\ttestRunAborted.set(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }); // end execute\n\t\t\t}\n\t\t}\n\n\n\t\t// Await completion of the threads running the tests \n\t\tes.shutdown();\n\t\t\n\t\t// Data used to detect a 'hung' load test\n\t\tlong numTestsExecuted = 0;\n\t\tlong activityDeadline = System.currentTimeMillis() + this.testInactivityLimit;\n\t\t\n\t\t// Wait for all worker threads to complete\n\t\twhile (!es.isTerminated()) {\n\t\t\t// Periodically report progress, so that people know that we are still running tests\n\t\t\tif (System.currentTimeMillis() >= nextReportTime) {\n\t\t\t\tnumProgressUpdates++;\n\t\t\t\tlong numberStarted = numberStartedTests.get();\n\t\t\t\tlong numberFailing = sumAll(failingTestCounters);\n\t\t\t\tString deltaText = previousNumStartedTests > 0 ? \" (+\" + (numberStarted - previousNumStartedTests) + \")\" : \"\";\n\t\t\t\tString failureSummaryText = numberFailing > 0 ? \" (with \" + numberFailing + \" failure(s))\" : \"\";\n\t\t\t\tlogger.info(\"Completed \" + String.format(\"%.1f%%. \", calculatePercentageDone(testStartTime)) \n\t\t\t\t\t\t+ \"Number of tests started=\" + numberStarted \n\t\t\t\t\t\t+ deltaText\n\t\t\t\t\t\t+ failureSummaryText);\n\t\t\t\t\n\t\t\t\tpreviousNumStartedTests = numberStarted;\n\t\t\t\tnextReportTime = firstReportTime + (numProgressUpdates * reportingFrequency);\n\t\t\t}\n\t\t\t\n\t\t\t// Check to see if load test execution has hung. A process is regarded as\n\t\t\t// being hung if there is no test progress for the number of milliseconds \n\t\t\t// in INACTIVITY_LIMIT. \n\t\t\t// When it's decided that a process has hung then a message in written to\n\t\t\t// stderr, which will result in the process monitoring code killing it.\n\t\t\tlong newNumTestsExecuted = sumAll(passingTestCounters) + sumAll(failingTestCounters);\n\t\t\tif (newNumTestsExecuted > numTestsExecuted) {\n\t\t\t\t// At least 1 test has completed since last time. Reset the deadline.\n\t\t\t\tnumTestsExecuted = newNumTestsExecuted;\n\t\t\t\tactivityDeadline = System.currentTimeMillis() + this.testInactivityLimit;\n\t\t\t} else if (System.currentTimeMillis() > activityDeadline) {\n\t\t\t    logger.error(\"**POSSIBLE HANG DETECTED**\");\n\t\t\t    activityDeadline = System.currentTimeMillis() + HUNG_MESSAGE_REPEAT_TIME;\n\t\t\t}\n\t\t\t\n\t\t\tThread.sleep(100);\n\t\t}\n\t\t\n\t\t// Stop the stdout/stderr interception. Reset back to original streams \n\t\tExecutionLog.instance().close();\n\t\tSystem.setOut(originalSystemOut);\n\t\tSystem.setErr(originalSystemErr);\n\t\t\n\t\t// Make sure time limited runs cannot be mistaken for a crash/bug\n\t\tif (timeLimitedTest && System.currentTimeMillis() > testEndTime) {\n\t\t\tlogger.info(\"Test stopped due to reaching runtime limit\");\n\t\t}",
        "start_line": 278,
        "end_line": 359,
        "chunk_index": 4,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 881,
        "node_type": null,
        "file_sha": "85efc3d6538d9f5b69065cb36adbebd994e13ba3",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.910607"
      },
      "text": "logger.info(\"Thread completed. Suite=\" + suite.getSuiteId() + \" thread=\" + threadNum);\n\t\t\t\t\t} // end run()\n\n\n\t\t\t\t\tprivate void reportFailure(long failureNum, ByteArrayOutputStream capturedOutput,\n\t\t\t\t\t\t\tAdaptorInterface test, final SuiteData suite, final int threadNum) {\n\t\t\t\t\t\tif (reportFailureLimit == -1 || failureNum <= reportFailureLimit) {\n\t\t\t\t\t\t\tlogger.error(\"Test failed\"\n\t\t\t\t\t\t\t\t+ \"\\n  Failure num.  = \" + failureNum\n\t\t\t\t\t\t\t\t+ \"\\n  Test number   = \" + test.getTestNum() \n\t\t\t\t\t\t\t\t+ \"\\n  Test details  = '\" + test.toString() + \"'\"\n\t\t\t\t\t\t\t\t+ \"\\n  Suite number  = \" + suite.getSuiteId()\n\t\t\t\t\t\t\t\t+ \"\\n  Thread number = \" + threadNum \n\t\t\t\t\t\t\t\t+ \"\\n>>> Captured test output >>>\\n\"\n\t\t\t\t\t\t\t\t+ capturedOutput.toString().trim()\n\t\t\t\t\t\t\t\t+ \"\\n<<<\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.error(\"Test failed. Details recorded in execution log.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (abortAtFailureLimit != -1 && failureNum == abortAtFailureLimit) {\n\t\t\t\t\t\t\tlogger.info(\"Number of test failures has reached 'AbortAtFailureLimit' (\" + failureNum + \"). Terminating load test\");\n\t\t\t\t\t\t\ttestRunAborted.set(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }); // end execute\n\t\t\t}\n\t\t}\n\n\n\t\t// Await completion of the threads running the tests \n\t\tes.shutdown();\n\t\t\n\t\t// Data used to detect a 'hung' load test\n\t\tlong numTestsExecuted = 0;\n\t\tlong activityDeadline = System.currentTimeMillis() + this.testInactivityLimit;\n\t\t\n\t\t// Wait for all worker threads to complete\n\t\twhile (!es.isTerminated()) {\n\t\t\t// Periodically report progress, so that people know that we are still running tests\n\t\t\tif (System.currentTimeMillis() >= nextReportTime) {\n\t\t\t\tnumProgressUpdates++;\n\t\t\t\tlong numberStarted = numberStartedTests.get();\n\t\t\t\tlong numberFailing = sumAll(failingTestCounters);\n\t\t\t\tString deltaText = previousNumStartedTests > 0 ? \" (+\" + (numberStarted - previousNumStartedTests) + \")\" : \"\";\n\t\t\t\tString failureSummaryText = numberFailing > 0 ? \" (with \" + numberFailing + \" failure(s))\" : \"\";\n\t\t\t\tlogger.info(\"Completed \" + String.format(\"%.1f%%. \", calculatePercentageDone(testStartTime)) \n\t\t\t\t\t\t+ \"Number of tests started=\" + numberStarted \n\t\t\t\t\t\t+ deltaText\n\t\t\t\t\t\t+ failureSummaryText);\n\t\t\t\t\n\t\t\t\tpreviousNumStartedTests = numberStarted;\n\t\t\t\tnextReportTime = firstReportTime + (numProgressUpdates * reportingFrequency);\n\t\t\t}\n\t\t\t\n\t\t\t// Check to see if load test execution has hung. A process is regarded as\n\t\t\t// being hung if there is no test progress for the number of milliseconds \n\t\t\t// in INACTIVITY_LIMIT. \n\t\t\t// When it's decided that a process has hung then a message in written to\n\t\t\t// stderr, which will result in the process monitoring code killing it.\n\t\t\tlong newNumTestsExecuted = sumAll(passingTestCounters) + sumAll(failingTestCounters);\n\t\t\tif (newNumTestsExecuted > numTestsExecuted) {\n\t\t\t\t// At least 1 test has completed since last time. Reset the deadline.\n\t\t\t\tnumTestsExecuted = newNumTestsExecuted;\n\t\t\t\tactivityDeadline = System.currentTimeMillis() + this.testInactivityLimit;\n\t\t\t} else if (System.currentTimeMillis() > activityDeadline) {\n\t\t\t    logger.error(\"**POSSIBLE HANG DETECTED**\");\n\t\t\t    activityDeadline = System.currentTimeMillis() + HUNG_MESSAGE_REPEAT_TIME;\n\t\t\t}\n\t\t\t\n\t\t\tThread.sleep(100);\n\t\t}\n\t\t\n\t\t// Stop the stdout/stderr interception. Reset back to original streams \n\t\tExecutionLog.instance().close();\n\t\tSystem.setOut(originalSystemOut);\n\t\tSystem.setErr(originalSystemErr);\n\t\t\n\t\t// Make sure time limited runs cannot be mistaken for a crash/bug\n\t\tif (timeLimitedTest && System.currentTimeMillis() > testEndTime) {\n\t\t\tlogger.info(\"Test stopped due to reaching runtime limit\");\n\t\t}"
    },
    "377": {
      "metadata": {
        "chunk_id": "82f56bd2be72a703e105d16015c003cab06b78f97489e12b9e0a7901a47e88bf",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/LoadTestRunner.java",
        "content": "// Summarise success of the run\n\t\tlong passedCount   = sumAll(passingTestCounters);\n\t\tlong failedCount   = sumAll(failingTestCounters);\n\t\tlong uncaughtCount = numberUncaughtExceptions.get();\n\t\tlogger.info(\"Load test completed\");\n        logger.info(\"  Ran     : \" + numberStartedTests.get());\n        logger.info(\"  Passed  : \" + passedCount);\n\t\tlogger.info(\"  Failed  : \" + failedCount);\n\t\tif (uncaughtCount > 0) {\n\t\t\tlogger.info(\"  Uncaught: \" + uncaughtCount);\t\n\t\t}\n        logger.info(\"  Result  : \" + (failedCount+uncaughtCount == 0 ? \"PASSED\" : \"FAILED\"));\n\t\t\n\t\tif (failedCount > reportFailureLimit) {\n\t\t\tlogger.info(\"Note that only the first \" + reportFailureLimit + \" failures have been reported\");\n\t\t}\n\t\t\n\t\treturn failedCount + uncaughtCount; \n\t}\n\n\n\tprivate double calculatePercentageDone(long testStartTime) {\n\t\t// Work out the percentage completed for the slowest suite\n\t\tdouble slowestSuitePercent = 100.0;\n\t\tboolean haveFoundSlowestSuite = false;\n\t\tfor (int s=0; s<suites.size(); s++) {\n\t\t\tdouble suitePercentageDone = suites.get(s).getPercentageDone();\n\t\t\tif (suitePercentageDone >= 0.0) {\n\t\t\t\tslowestSuitePercent = Math.min(slowestSuitePercent, suitePercentageDone);\n\t\t\t\thaveFoundSlowestSuite = true;\n\t\t\t} else {\n\t\t\t\t// At least one suite is not workload bound. Abandon search for slowest.\n\t\t\t\thaveFoundSlowestSuite = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Work out percentage completed if load test run time set\t\t\n\t\tdouble timePercentDone = 0.0;\n\t\tboolean haveTimePercent = false;\n\t\tif (timeLimitedTest) {\n\t\t\tdouble elapsedTime = System.currentTimeMillis() - testStartTime;\n\t\t\tdouble totalRunTime = testEndTime - testStartTime;\n\t\t\ttimePercentDone = (elapsedTime / totalRunTime) * 100.0;\n\t\t\thaveTimePercent = true;\n\t\t}\n\n\t\t// Decide overall percentage completed \n\t\tdouble overallPercentDone;\n\t\tif (haveFoundSlowestSuite && !haveTimePercent) {\n\t\t\toverallPercentDone = slowestSuitePercent;\n\t\t} else if (!haveFoundSlowestSuite && haveTimePercent) {\n\t\t\toverallPercentDone = timePercentDone;\n\t\t} else {\n\t\t\t// This run has at least 1 suite running a fixed load _and_ an overall runtime limit\n\t\t\toverallPercentDone = Math.max(slowestSuitePercent, timePercentDone);\n\t\t}\n\n\t\t// Completion percentage can be 100% because tests are allowed to run\n\t\t// until completion (and therefore pushing them over the time limit) \n\t\toverallPercentDone = Math.min(overallPercentDone, 100.0);\n\t\treturn overallPercentDone;\n\t}\n\n\tprivate long sumAll(AtomicLong[] atomics) {\n\t\tlong total = 0;\n\t\t\n\t\tfor (int i=0; i<atomics.length; i++) {\n\t\t\ttotal += atomics[i].get();\n\t\t}\n\t\t\n\t\treturn total;\n\t}\n}",
        "start_line": 360,
        "end_line": 433,
        "chunk_index": 5,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 691,
        "node_type": null,
        "file_sha": "85efc3d6538d9f5b69065cb36adbebd994e13ba3",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.910609"
      },
      "text": "// Summarise success of the run\n\t\tlong passedCount   = sumAll(passingTestCounters);\n\t\tlong failedCount   = sumAll(failingTestCounters);\n\t\tlong uncaughtCount = numberUncaughtExceptions.get();\n\t\tlogger.info(\"Load test completed\");\n        logger.info(\"  Ran     : \" + numberStartedTests.get());\n        logger.info(\"  Passed  : \" + passedCount);\n\t\tlogger.info(\"  Failed  : \" + failedCount);\n\t\tif (uncaughtCount > 0) {\n\t\t\tlogger.info(\"  Uncaught: \" + uncaughtCount);\t\n\t\t}\n        logger.info(\"  Result  : \" + (failedCount+uncaughtCount == 0 ? \"PASSED\" : \"FAILED\"));\n\t\t\n\t\tif (failedCount > reportFailureLimit) {\n\t\t\tlogger.info(\"Note that only the first \" + reportFailureLimit + \" failures have been reported\");\n\t\t}\n\t\t\n\t\treturn failedCount + uncaughtCount; \n\t}\n\n\n\tprivate double calculatePercentageDone(long testStartTime) {\n\t\t// Work out the percentage completed for the slowest suite\n\t\tdouble slowestSuitePercent = 100.0;\n\t\tboolean haveFoundSlowestSuite = false;\n\t\tfor (int s=0; s<suites.size(); s++) {\n\t\t\tdouble suitePercentageDone = suites.get(s).getPercentageDone();\n\t\t\tif (suitePercentageDone >= 0.0) {\n\t\t\t\tslowestSuitePercent = Math.min(slowestSuitePercent, suitePercentageDone);\n\t\t\t\thaveFoundSlowestSuite = true;\n\t\t\t} else {\n\t\t\t\t// At least one suite is not workload bound. Abandon search for slowest.\n\t\t\t\thaveFoundSlowestSuite = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Work out percentage completed if load test run time set\t\t\n\t\tdouble timePercentDone = 0.0;\n\t\tboolean haveTimePercent = false;\n\t\tif (timeLimitedTest) {\n\t\t\tdouble elapsedTime = System.currentTimeMillis() - testStartTime;\n\t\t\tdouble totalRunTime = testEndTime - testStartTime;\n\t\t\ttimePercentDone = (elapsedTime / totalRunTime) * 100.0;\n\t\t\thaveTimePercent = true;\n\t\t}\n\n\t\t// Decide overall percentage completed \n\t\tdouble overallPercentDone;\n\t\tif (haveFoundSlowestSuite && !haveTimePercent) {\n\t\t\toverallPercentDone = slowestSuitePercent;\n\t\t} else if (!haveFoundSlowestSuite && haveTimePercent) {\n\t\t\toverallPercentDone = timePercentDone;\n\t\t} else {\n\t\t\t// This run has at least 1 suite running a fixed load _and_ an overall runtime limit\n\t\t\toverallPercentDone = Math.max(slowestSuitePercent, timePercentDone);\n\t\t}\n\n\t\t// Completion percentage can be 100% because tests are allowed to run\n\t\t// until completion (and therefore pushing them over the time limit) \n\t\toverallPercentDone = Math.min(overallPercentDone, 100.0);\n\t\treturn overallPercentDone;\n\t}\n\n\tprivate long sumAll(AtomicLong[] atomics) {\n\t\tlong total = 0;\n\t\t\n\t\tfor (int i=0; i<atomics.length; i++) {\n\t\t\ttotal += atomics[i].get();\n\t\t}\n\t\t\n\t\treturn total;\n\t}\n}"
    },
    "378": {
      "metadata": {
        "chunk_id": "4591c416662889e6a5241d79e9b4ce9d2d7194a64f7da117a0e9cf569cdec7bb",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/SuiteData.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Random;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\n\n\n/**\n * Holds data on a single suite.\n * \n * Also decides on the ordering of test execution for the suites tests.  \n */",
        "start_line": 0,
        "end_line": 30,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 206,
        "node_type": null,
        "file_sha": "fe589de49b1b7f283c96d3bb1448dab5e95328a2",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.932175"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Random;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\n\n\n/**\n * Holds data on a single suite.\n * \n * Also decides on the ordering of test execution for the suites tests.  \n */"
    },
    "379": {
      "metadata": {
        "chunk_id": "62b0cb87b20c098462df5ca64cfb33c6c1586d32bac172a4a42ecab77c6d3349",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/SuiteData.java",
        "content": "public class SuiteData {\n    private static final Logger logger = LogManager.getLogger(SuiteData.class.getName());\n\t\n\tpublic enum SelectionMode { SELECTION_SEQUENTIAL, SELECTION_RANDOM };\n\n\t// Suite level parameters \n\tprivate final int suiteId;\n\tprivate final long numThreads;\n\tprivate final long numberTests;\n\tprivate final int repeatCount;  // How many times to run each test before picking the next one\n\tprivate final long minThinkingTime;\n\tprivate final long maxThinkingTime; \n\tprivate final SelectionMode selection;\n\n\t// The tests which this suite will run\n\tprivate final InventoryData inventory;\n\t\n\t// Data to keep track of test selection.\n\t// Allows consistent and repeatable choice of tests\n\tprivate Random rnd;\n\tprivate long outstandingTestCount;\n\tprivate AdaptorInterface currentTest = null;\n\tprivate int outstandingRepeats = 0;\n\t\n\t// Data for sequential selection\n\tprivate int lastUsedTest = -1;\n\n\t// Data for random test selection\n\tprivate AdaptorInterface weightedTestMap[];\n\tprivate int numWeightedTests;\n\n\n\tSuiteData(int suiteNum, int numThreads, long seed, InventoryData inventory, long numberTests, int repeatCount, long minThinkingTime, long maxThinkingTime, SelectionMode selection) {\n\t\tthis.suiteId = suiteNum;\n\t\tthis.numThreads = numThreads;\n\t\tthis.inventory = inventory;\n\t\tthis.numberTests = numberTests;\n\t\tthis.repeatCount = repeatCount;\n\t\tthis.minThinkingTime = minThinkingTime;\n\t\tthis.maxThinkingTime = maxThinkingTime;\n\t\tthis.selection = selection;\n\t\t\n\t\tthis.rnd = new Random(seed);\n\t\tthis.outstandingTestCount = numberTests;\n\t\t\n\t\tif (selection == SelectionMode.SELECTION_RANDOM) {\n\t\t\tweightedTestMap = createWeightedTestMap(inventory);\n\t\t\tnumWeightedTests = weightedTestMap.length;\n\t\t}\n\t}\n\t\n\n\tpublic int getSuiteId() {\n\t\treturn suiteId;\n\t}\n\t\n\tpublic String getInventoryFileRef() {\n\t\treturn inventory.getInventoryFileRef();\n\t}\n\n\tpublic long getNumberThreads() {\n\t\treturn numThreads;\n\t}\n\n\tpublic InventoryData getInventory() {\n\t\treturn inventory;\n\t}\n\n\t/**\n\t * @return double containing percentage completed for this suite, or '-1'\n\t * if not workload bound.\n\t */\n\tpublic synchronized double getPercentageDone() {\n\t\tif (numberTests == -1) {\n\t\t\treturn -1.0;\n\t\t}\n\t\t\n\t\tdouble numberStarted = numberTests - outstandingTestCount;\n\t\tdouble percentageDone = (numberStarted / (double) numberTests) * 100.0;\n\t\treturn percentageDone;\n\t}\n\n\tpublic synchronized long getMinThinkingTime() {\n\t\treturn minThinkingTime;\n\t}\n\n\tpublic synchronized long getMaxThinkingTime() {\n\t\treturn maxThinkingTime;\n\t}\n\n\t/**\n\t * @return The next test to run, or null if it's time to finish load testing.\n\t */\n\tsynchronized AdaptorInterface getNextTest() {\n\t\tif (outstandingTestCount == 0) {\n\t\t\treturn null;  // No more tests to run\n\t\t}\n\t\t\n\t\t// Execution only gets here if there is either 1) some time left or 2) some more tests to run\n\t\tif (outstandingRepeats == 0) {\n\t\t\t// Pick the next test\n\t\t\tif (selection == SelectionMode.SELECTION_SEQUENTIAL) {\n\t\t\t\tif (++lastUsedTest >= inventory.getNumberOfTests()) {\n\t\t\t\t\tlastUsedTest = 0;\n\t\t\t\t}\n\t\t\t\tcurrentTest = inventory.getTest(lastUsedTest);\n\t\t\t} else {\n\t\t\t\t// Random mode\n\t\t\t\tint testNum = rnd.nextInt(numWeightedTests);\n\t\t\t\tcurrentTest = this.weightedTestMap[testNum];\n\t\t\t}\n\t\t\toutstandingRepeats = repeatCount;\n\t\t}\n\n\t\tif (outstandingTestCount != -1) {\n\t\t\toutstandingTestCount--;  // Test run is limited by test count\n\t\t}\n\t\toutstandingRepeats--;\n\t\t\n\t\treturn currentTest;\n\t}",
        "start_line": 31,
        "end_line": 151,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 819,
        "node_type": null,
        "file_sha": "fe589de49b1b7f283c96d3bb1448dab5e95328a2",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.932184"
      },
      "text": "public class SuiteData {\n    private static final Logger logger = LogManager.getLogger(SuiteData.class.getName());\n\t\n\tpublic enum SelectionMode { SELECTION_SEQUENTIAL, SELECTION_RANDOM };\n\n\t// Suite level parameters \n\tprivate final int suiteId;\n\tprivate final long numThreads;\n\tprivate final long numberTests;\n\tprivate final int repeatCount;  // How many times to run each test before picking the next one\n\tprivate final long minThinkingTime;\n\tprivate final long maxThinkingTime; \n\tprivate final SelectionMode selection;\n\n\t// The tests which this suite will run\n\tprivate final InventoryData inventory;\n\t\n\t// Data to keep track of test selection.\n\t// Allows consistent and repeatable choice of tests\n\tprivate Random rnd;\n\tprivate long outstandingTestCount;\n\tprivate AdaptorInterface currentTest = null;\n\tprivate int outstandingRepeats = 0;\n\t\n\t// Data for sequential selection\n\tprivate int lastUsedTest = -1;\n\n\t// Data for random test selection\n\tprivate AdaptorInterface weightedTestMap[];\n\tprivate int numWeightedTests;\n\n\n\tSuiteData(int suiteNum, int numThreads, long seed, InventoryData inventory, long numberTests, int repeatCount, long minThinkingTime, long maxThinkingTime, SelectionMode selection) {\n\t\tthis.suiteId = suiteNum;\n\t\tthis.numThreads = numThreads;\n\t\tthis.inventory = inventory;\n\t\tthis.numberTests = numberTests;\n\t\tthis.repeatCount = repeatCount;\n\t\tthis.minThinkingTime = minThinkingTime;\n\t\tthis.maxThinkingTime = maxThinkingTime;\n\t\tthis.selection = selection;\n\t\t\n\t\tthis.rnd = new Random(seed);\n\t\tthis.outstandingTestCount = numberTests;\n\t\t\n\t\tif (selection == SelectionMode.SELECTION_RANDOM) {\n\t\t\tweightedTestMap = createWeightedTestMap(inventory);\n\t\t\tnumWeightedTests = weightedTestMap.length;\n\t\t}\n\t}\n\t\n\n\tpublic int getSuiteId() {\n\t\treturn suiteId;\n\t}\n\t\n\tpublic String getInventoryFileRef() {\n\t\treturn inventory.getInventoryFileRef();\n\t}\n\n\tpublic long getNumberThreads() {\n\t\treturn numThreads;\n\t}\n\n\tpublic InventoryData getInventory() {\n\t\treturn inventory;\n\t}\n\n\t/**\n\t * @return double containing percentage completed for this suite, or '-1'\n\t * if not workload bound.\n\t */\n\tpublic synchronized double getPercentageDone() {\n\t\tif (numberTests == -1) {\n\t\t\treturn -1.0;\n\t\t}\n\t\t\n\t\tdouble numberStarted = numberTests - outstandingTestCount;\n\t\tdouble percentageDone = (numberStarted / (double) numberTests) * 100.0;\n\t\treturn percentageDone;\n\t}\n\n\tpublic synchronized long getMinThinkingTime() {\n\t\treturn minThinkingTime;\n\t}\n\n\tpublic synchronized long getMaxThinkingTime() {\n\t\treturn maxThinkingTime;\n\t}\n\n\t/**\n\t * @return The next test to run, or null if it's time to finish load testing.\n\t */\n\tsynchronized AdaptorInterface getNextTest() {\n\t\tif (outstandingTestCount == 0) {\n\t\t\treturn null;  // No more tests to run\n\t\t}\n\t\t\n\t\t// Execution only gets here if there is either 1) some time left or 2) some more tests to run\n\t\tif (outstandingRepeats == 0) {\n\t\t\t// Pick the next test\n\t\t\tif (selection == SelectionMode.SELECTION_SEQUENTIAL) {\n\t\t\t\tif (++lastUsedTest >= inventory.getNumberOfTests()) {\n\t\t\t\t\tlastUsedTest = 0;\n\t\t\t\t}\n\t\t\t\tcurrentTest = inventory.getTest(lastUsedTest);\n\t\t\t} else {\n\t\t\t\t// Random mode\n\t\t\t\tint testNum = rnd.nextInt(numWeightedTests);\n\t\t\t\tcurrentTest = this.weightedTestMap[testNum];\n\t\t\t}\n\t\t\toutstandingRepeats = repeatCount;\n\t\t}\n\n\t\tif (outstandingTestCount != -1) {\n\t\t\toutstandingTestCount--;  // Test run is limited by test count\n\t\t}\n\t\toutstandingRepeats--;\n\t\t\n\t\treturn currentTest;\n\t}"
    },
    "380": {
      "metadata": {
        "chunk_id": "42ba5074198bdfe3ce526788fa137b44bdc9395eadcfab4e82c3436e3fcee985",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/SuiteData.java",
        "content": "if (outstandingTestCount != -1) {\n\t\t\toutstandingTestCount--;  // Test run is limited by test count\n\t\t}\n\t\toutstandingRepeats--;\n\t\t\n\t\treturn currentTest;\n\t}\n\t\n\n\t// Create a weighting adjusted test lookup table.\n\t// This supports fast test selection whilst still honouring the weighting for each test.\n\t//\n\t// For example if we have the following test inventory:\n\t//    test A, weighting = 1\n\t//    test B, weighting = 0.5\n\t//    test C, weighting = 1.25\n\t// Then InventoryData holds:\n\t//    [0] test A, adjustedWeighting = 4\n\t//    [1] test B, adjustedWeighting = 2\n\t//    [2] test C, adjustedWeighting = 5\n\t// So the array used to randomly pick tests with the correct distribution is:\n\t//    00001122222\n\tprivate AdaptorInterface[] createWeightedTestMap(InventoryData inventory) {\n\t\tArrayList<AdaptorInterface> weightedMap = new ArrayList<AdaptorInterface>();\n\t\t\n\t\tBigDecimal weightingMultiplier = inventory.getWeightingMultiplier();\n\t\t\n\t\tfor (int i=0; i<inventory.getNumberOfTests(); i++) {\n\t\t\tAdaptorInterface test = inventory.getTest(i);\n\t\t\tint testWeighting = test.getRoundedAdjustedWeighting(weightingMultiplier);\n\t\t\tfor (int repeat=0; repeat<testWeighting; repeat++) {\n\t\t\t\tweightedMap.add(test);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Convert to map to an array of ints (for faster access)\n\t\tAdaptorInterface[] weightedArray = new AdaptorInterface[weightedMap.size()];\n\t    for (int i=0; i<weightedMap.size(); i++) {\n\t        weightedArray[i] = weightedMap.get(i);\n\t    }\n\t   \n    \tlogger.debug(\"Weighted array:\");\n    \tfor (int x=0; x<weightedArray.length; x++) {\n    \t\tlogger.debug(\"  [\" + x + \"] \" + weightedArray[x]);\n\t    }\n\n\t    return weightedArray;\n\t}\n}",
        "start_line": 152,
        "end_line": 200,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 444,
        "node_type": null,
        "file_sha": "fe589de49b1b7f283c96d3bb1448dab5e95328a2",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.932188"
      },
      "text": "if (outstandingTestCount != -1) {\n\t\t\toutstandingTestCount--;  // Test run is limited by test count\n\t\t}\n\t\toutstandingRepeats--;\n\t\t\n\t\treturn currentTest;\n\t}\n\t\n\n\t// Create a weighting adjusted test lookup table.\n\t// This supports fast test selection whilst still honouring the weighting for each test.\n\t//\n\t// For example if we have the following test inventory:\n\t//    test A, weighting = 1\n\t//    test B, weighting = 0.5\n\t//    test C, weighting = 1.25\n\t// Then InventoryData holds:\n\t//    [0] test A, adjustedWeighting = 4\n\t//    [1] test B, adjustedWeighting = 2\n\t//    [2] test C, adjustedWeighting = 5\n\t// So the array used to randomly pick tests with the correct distribution is:\n\t//    00001122222\n\tprivate AdaptorInterface[] createWeightedTestMap(InventoryData inventory) {\n\t\tArrayList<AdaptorInterface> weightedMap = new ArrayList<AdaptorInterface>();\n\t\t\n\t\tBigDecimal weightingMultiplier = inventory.getWeightingMultiplier();\n\t\t\n\t\tfor (int i=0; i<inventory.getNumberOfTests(); i++) {\n\t\t\tAdaptorInterface test = inventory.getTest(i);\n\t\t\tint testWeighting = test.getRoundedAdjustedWeighting(weightingMultiplier);\n\t\t\tfor (int repeat=0; repeat<testWeighting; repeat++) {\n\t\t\t\tweightedMap.add(test);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Convert to map to an array of ints (for faster access)\n\t\tAdaptorInterface[] weightedArray = new AdaptorInterface[weightedMap.size()];\n\t    for (int i=0; i<weightedMap.size(); i++) {\n\t        weightedArray[i] = weightedMap.get(i);\n\t    }\n\t   \n    \tlogger.debug(\"Weighted array:\");\n    \tfor (int x=0; x<weightedArray.length; x++) {\n    \t\tlogger.debug(\"  [\" + x + \"] \" + weightedArray[x]);\n\t    }\n\n\t    return weightedArray;\n\t}\n}"
    },
    "381": {
      "metadata": {
        "chunk_id": "e39e15d5972b27dacb47ec28df331440603d1b687d137bb91bd06ad7786501ba",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/TimeBasedLoadTest.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      https://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.StfTestArguments;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.util.TimeParser; \n\n/** \n * An abstract class to be extended and implemented by STF test plugins that needs the capability to run \n * in a time-based fashion. \n * */\npublic abstract class TimeBasedLoadTest implements StfPluginInterface {\n\t\n\tString defaultTimeout = \"1h\";\n\tprotected String timeLimit;\n\tprotected StfTestArguments testArgs;\n\tprotected boolean isTimeBasedLoadTest = true;\n\tprotected String finalTimeout = defaultTimeout; \n\n\tpublic void pluginInit(StfCoreExtension stf) throws StfException {\n\t\t\n\t\t// When used as a time based test, this STF test plugin accepts the following two parameters:\n\t\t//   (1) timeLimit : Optional Time duration value (e.g. 5s, 5m, 5h) for which the load should be run. \n\t\t//   (2) workload  : Optional workload value used in a subset of tests (e.g. DAA).\n\t\ttestArgs = stf.env().getTestProperties(\"timeLimit=[0]\",\"workload=[none]\");\n\t\ttimeLimit = testArgs.get(\"timeLimit\");\n\t\t\n\t\t// When We are running an iteration based load test, no timeLimit is specified \n\t\tif ( timeLimit.equals(\"0\")) {\n\t\t\tisTimeBasedLoadTest = false; \n\t\t}\n\n\t\tif (isTimeBasedLoadTest) { \n\t\t\tlong finalTimeoutInSeconds = TimeParser.parseTimeSpecification(defaultTimeout).getSeconds() + \n\t\t\t\tTimeParser.parseTimeSpecification(timeLimit).getSeconds();\n\t\t\tfinalTimeout = finalTimeoutInSeconds + \"s\"; \n\t\t}\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws StfException {\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws StfException {\n\t}\n}",
        "start_line": 0,
        "end_line": 59,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 564,
        "node_type": null,
        "file_sha": "059ddfb824864fa29d9e299117ef3a1c83deb837",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.955249"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      https://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.StfTestArguments;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.util.TimeParser; \n\n/** \n * An abstract class to be extended and implemented by STF test plugins that needs the capability to run \n * in a time-based fashion. \n * */\npublic abstract class TimeBasedLoadTest implements StfPluginInterface {\n\t\n\tString defaultTimeout = \"1h\";\n\tprotected String timeLimit;\n\tprotected StfTestArguments testArgs;\n\tprotected boolean isTimeBasedLoadTest = true;\n\tprotected String finalTimeout = defaultTimeout; \n\n\tpublic void pluginInit(StfCoreExtension stf) throws StfException {\n\t\t\n\t\t// When used as a time based test, this STF test plugin accepts the following two parameters:\n\t\t//   (1) timeLimit : Optional Time duration value (e.g. 5s, 5m, 5h) for which the load should be run. \n\t\t//   (2) workload  : Optional workload value used in a subset of tests (e.g. DAA).\n\t\ttestArgs = stf.env().getTestProperties(\"timeLimit=[0]\",\"workload=[none]\");\n\t\ttimeLimit = testArgs.get(\"timeLimit\");\n\t\t\n\t\t// When We are running an iteration based load test, no timeLimit is specified \n\t\tif ( timeLimit.equals(\"0\")) {\n\t\t\tisTimeBasedLoadTest = false; \n\t\t}\n\n\t\tif (isTimeBasedLoadTest) { \n\t\t\tlong finalTimeoutInSeconds = TimeParser.parseTimeSpecification(defaultTimeout).getSeconds() + \n\t\t\t\tTimeParser.parseTimeSpecification(timeLimit).getSeconds();\n\t\t\tfinalTimeout = finalTimeoutInSeconds + \"s\"; \n\t\t}\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws StfException {\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws StfException {\n\t}\n}"
    },
    "382": {
      "metadata": {
        "chunk_id": "d5ca4f9e1d394c32af887391aee6edc0f789dc1bb188ca39e21de8ba83cd72bb",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/AdaptorInterface.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.math.BigDecimal;\n\n/**\n * Key interface for allowing the load test to run any test code.\n * \n * To support a new test type:\n *   1) Add a new class which implements this interface.\n *   2) Add parsing support into InventoryData.java\n *   3) Make sure that the new subclass implements equals() and hashcode(). \n *      Test exclusion will not work correctly without these methods.\n */",
        "start_line": 0,
        "end_line": 26,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 222,
        "node_type": null,
        "file_sha": "fa4cb3180272843d660d16d999bc23f0d2b0c298",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.977995"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.math.BigDecimal;\n\n/**\n * Key interface for allowing the load test to run any test code.\n * \n * To support a new test type:\n *   1) Add a new class which implements this interface.\n *   2) Add parsing support into InventoryData.java\n *   3) Make sure that the new subclass implements equals() and hashcode(). \n *      Test exclusion will not work correctly without these methods.\n */"
    },
    "383": {
      "metadata": {
        "chunk_id": "2a0a6bd346bce349ae11e9157309cfd71593aa2073a22c95be321f50316b1c87",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/AdaptorInterface.java",
        "content": "public interface AdaptorInterface {\n\t/**\n\t * @return The name of the test case which the implementation will run.\n\t */\n\tpublic String getTestName();\n\t\n\t/**\n\t * For Arbitrary java we run a single named test method.\n\t * @return Name of test method to run.\n\t */\n\tpublic String getTestMethodName();\n\t\n\t/**\n\t * Get the number of this test. \n\t * The numbers are allocated by InventoryData.java and passed to the adaptors constructor.\n\t * @return an int with the number of the test.\n\t */\n\tpublic int getTestNum();\n\t\n\t/**\n\t * Gets the weighting value for the test. When running with random test selection \n\t * the likelihood of selecting a test can be partially controlled by adjusting its \n\t * weighting. \n\t * If not specified then each test has a default weighting of 1.\n\t * Tests with a positive whole number are more likely to be selected. So a weighting \n\t * of 3 means that the test is 3* more likely to be executed.\n\t * A fractional value makes it less likely that a test will run. A value of say 0.25\n\t * means that on average a test would run only a quarter as frequently as it would \n\t * with a weighting of 1. \n\t * Each test In order to allow balance  \n\t * @return BigDecimal with the weighting value for the test.\n\t */\n\tpublic BigDecimal getWeighting();\n\t\n\t/**\n\t * @return The result of weighting * weightingMultipier. \n\t */\n\tpublic BigDecimal getAdjustedWeighting(BigDecimal weightingMultiplier);\n\n\t/**\n\t * @return Rounded adjusted weighting. Values less than 1 are rounded up to 1.\n\t */\n\tpublic int getRoundedAdjustedWeighting(BigDecimal weightingMultiplier);\n\n\t\n\t// Results are ordered from lowest to highest importance.\n\t// A test observation of higher importance will override one of lower importance. \n\tpublic enum ResultStatus {\n\t\tUNKNOWN(true),            // No failure detected, but also no positive confirmation of passing.\n\t\tPASS(true),               // The test passed.\n\t\tBLOCKED_EXIT_PASS(true),  // Test attempted to call System.exit() with a zero exit value.\n\t\tFAIL(false),              // Test indicated a failure, or ended in exception.\n\t\tBLOCKED_EXIT_FAIL(false); // Test attempted to call System.exit() with non-zero value (indicating failure) \n\t\t\n\t\tprivate final boolean passed;\n\t\t\n\t\tprivate ResultStatus(boolean passed) {\n\t\t\tthis.passed = passed;\n\t\t}\t\t\n\t\tpublic boolean testPassed() {\n\t\t\treturn passed;\n\t\t}\n\t};\n\n\t/**\n\t * Runs the test code.\n\t * The test is marked as a failure if it throws an Exception or Throwable.\n\t * Test output can be checked with the checkTestOutput() method. \n\t * \n\t * @returns A ResultStatus value to indicate the success/failure of the test.\n\t * @throws Throwable or Exception on failure.\n\t */\n\tpublic ResultStatus executeTest() throws Throwable;\n\t\n\t/**\n\t * The load test intercepts the stdout and stderr for the test.\n\t * This method gives the adaptor the chance to examine the output and fail the test.\n\t * One call is made to this method for each piece of intercepted output.\n\t * Return results of say, 'pass, pass, fail, pass' means that the test has failed.\n\t * \n\t * @return ResultStatus value. Set to NO_MATCH if you can't tell the pass/fail\n\t * status from the output. \n\t */\n\tpublic ResultStatus checkTestOutput(byte[] output, int off, int len);\n}",
        "start_line": 27,
        "end_line": 111,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 745,
        "node_type": null,
        "file_sha": "fa4cb3180272843d660d16d999bc23f0d2b0c298",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.978005"
      },
      "text": "public interface AdaptorInterface {\n\t/**\n\t * @return The name of the test case which the implementation will run.\n\t */\n\tpublic String getTestName();\n\t\n\t/**\n\t * For Arbitrary java we run a single named test method.\n\t * @return Name of test method to run.\n\t */\n\tpublic String getTestMethodName();\n\t\n\t/**\n\t * Get the number of this test. \n\t * The numbers are allocated by InventoryData.java and passed to the adaptors constructor.\n\t * @return an int with the number of the test.\n\t */\n\tpublic int getTestNum();\n\t\n\t/**\n\t * Gets the weighting value for the test. When running with random test selection \n\t * the likelihood of selecting a test can be partially controlled by adjusting its \n\t * weighting. \n\t * If not specified then each test has a default weighting of 1.\n\t * Tests with a positive whole number are more likely to be selected. So a weighting \n\t * of 3 means that the test is 3* more likely to be executed.\n\t * A fractional value makes it less likely that a test will run. A value of say 0.25\n\t * means that on average a test would run only a quarter as frequently as it would \n\t * with a weighting of 1. \n\t * Each test In order to allow balance  \n\t * @return BigDecimal with the weighting value for the test.\n\t */\n\tpublic BigDecimal getWeighting();\n\t\n\t/**\n\t * @return The result of weighting * weightingMultipier. \n\t */\n\tpublic BigDecimal getAdjustedWeighting(BigDecimal weightingMultiplier);\n\n\t/**\n\t * @return Rounded adjusted weighting. Values less than 1 are rounded up to 1.\n\t */\n\tpublic int getRoundedAdjustedWeighting(BigDecimal weightingMultiplier);\n\n\t\n\t// Results are ordered from lowest to highest importance.\n\t// A test observation of higher importance will override one of lower importance. \n\tpublic enum ResultStatus {\n\t\tUNKNOWN(true),            // No failure detected, but also no positive confirmation of passing.\n\t\tPASS(true),               // The test passed.\n\t\tBLOCKED_EXIT_PASS(true),  // Test attempted to call System.exit() with a zero exit value.\n\t\tFAIL(false),              // Test indicated a failure, or ended in exception.\n\t\tBLOCKED_EXIT_FAIL(false); // Test attempted to call System.exit() with non-zero value (indicating failure) \n\t\t\n\t\tprivate final boolean passed;\n\t\t\n\t\tprivate ResultStatus(boolean passed) {\n\t\t\tthis.passed = passed;\n\t\t}\t\t\n\t\tpublic boolean testPassed() {\n\t\t\treturn passed;\n\t\t}\n\t};\n\n\t/**\n\t * Runs the test code.\n\t * The test is marked as a failure if it throws an Exception or Throwable.\n\t * Test output can be checked with the checkTestOutput() method. \n\t * \n\t * @returns A ResultStatus value to indicate the success/failure of the test.\n\t * @throws Throwable or Exception on failure.\n\t */\n\tpublic ResultStatus executeTest() throws Throwable;\n\t\n\t/**\n\t * The load test intercepts the stdout and stderr for the test.\n\t * This method gives the adaptor the chance to examine the output and fail the test.\n\t * One call is made to this method for each piece of intercepted output.\n\t * Return results of say, 'pass, pass, fail, pass' means that the test has failed.\n\t * \n\t * @return ResultStatus value. Set to NO_MATCH if you can't tell the pass/fail\n\t * status from the output. \n\t */\n\tpublic ResultStatus checkTestOutput(byte[] output, int off, int len);\n}"
    },
    "384": {
      "metadata": {
        "chunk_id": "9235efbb1507c9302f3b9568bce66b91c505a380e6b5f3288eba42718ed3b1dd",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/ArbitraryJavaAdaptor.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.loadTest.FirstFailureDumper;\nimport net.adoptopenjdk.stf.StfException;\n\n/**\n * This class allows load test to run any piece of Java code.\n * The 'test' is only recorded as a failure if it throws an exception.\n */",
        "start_line": 0,
        "end_line": 28,
        "chunk_index": 0,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 222,
        "node_type": null,
        "file_sha": "3f398bb95a8e5c9ffc6c29d6b866e0ab8af87c4a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.997833"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.loadTest.FirstFailureDumper;\nimport net.adoptopenjdk.stf.StfException;\n\n/**\n * This class allows load test to run any piece of Java code.\n * The 'test' is only recorded as a failure if it throws an exception.\n */"
    },
    "385": {
      "metadata": {
        "chunk_id": "b23abb7622ffda14f679dc06d234c7b6c572d346b7cf6e2d7606447bdf8dcbf7",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/ArbitraryJavaAdaptor.java",
        "content": "public class ArbitraryJavaAdaptor extends LoadTestBase {\n\tprivate String testClassName;\n\tprivate String testMethodName;\n\n\tprivate Class<?> javaClass;\n\tprivate Constructor<?> constructor;\n\tprivate Object[] constructorArgs;\n\tprivate Method javaMethod;\n\tprivate Object[] methodArgs;\n\tprivate boolean dumpRequested; \n\t\n\tpublic ArbitraryJavaAdaptor(int testNum, String testClassName, ArrayList<String> constructorArgValues, \n\t\t\t\t\tString testMethodName, ArrayList<String> methodArgValues, BigDecimal weighting, boolean countingOnly, boolean dumpRequired) \n\t\t\t\tthrows ClassNotFoundException, NoSuchMethodException, SecurityException, StfException {\n\t\tsuper(testNum, testClassName, testMethodName, weighting);",
        "start_line": 29,
        "end_line": 43,
        "chunk_index": 1,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 128,
        "node_type": null,
        "file_sha": "3f398bb95a8e5c9ffc6c29d6b866e0ab8af87c4a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.997840"
      },
      "text": "public class ArbitraryJavaAdaptor extends LoadTestBase {\n\tprivate String testClassName;\n\tprivate String testMethodName;\n\n\tprivate Class<?> javaClass;\n\tprivate Constructor<?> constructor;\n\tprivate Object[] constructorArgs;\n\tprivate Method javaMethod;\n\tprivate Object[] methodArgs;\n\tprivate boolean dumpRequested; \n\t\n\tpublic ArbitraryJavaAdaptor(int testNum, String testClassName, ArrayList<String> constructorArgValues, \n\t\t\t\t\tString testMethodName, ArrayList<String> methodArgValues, BigDecimal weighting, boolean countingOnly, boolean dumpRequired) \n\t\t\t\tthrows ClassNotFoundException, NoSuchMethodException, SecurityException, StfException {\n\t\tsuper(testNum, testClassName, testMethodName, weighting);"
    },
    "386": {
      "metadata": {
        "chunk_id": "34263be8cc2894c685e7672e475d3135f9dbc2866046257a60a9018fc1cd2a18",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/ArbitraryJavaAdaptor.java",
        "content": "if (countingOnly) {\n\t\t\t// Don't need to do anything else as we are only counting how many tests there are.\n\t\t\t// This will be test generation time, so classpath not set to load test cases.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.testClassName = testClassName;\n\t\tthis.testMethodName = testMethodName;\n\t\tthis.dumpRequested = dumpRequired; \n\t\t\n\t\tjavaClass = Class.forName(testClassName);\n\t\t\n\t\t// Find a constructor which is compatible with the supplied constructor arguments\n\t\tfor (Constructor<?> method : javaClass.getConstructors()) {\n\t\t\tClass<?>[] actualParameterTypes = method.getParameterTypes();\n\t\t\tif (constructorArgValues.size() == actualParameterTypes.length) {\n\t\t\t\tObject[] candidateConstructorArgs = convertArguments(constructorArgValues, actualParameterTypes);\n\t\t\t\tif (candidateConstructorArgs != null) {\n\t\t\t\t\tconstructorArgs = candidateConstructorArgs;\n\t\t\t\t\tconstructor = method;\n\t\t\t\t\tconstructor.setAccessible(true);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Find an instance method which is compatible with the supplied method arguments\n\t\tfor (Method method : javaClass.getMethods()) {\n\t\t\tClass<?>[] actualParameterTypes = method.getParameterTypes();\n\t\t\tif (method.getName().equals(testMethodName)  &&  methodArgValues.size() == actualParameterTypes.length) {\n\t\t\t\tObject[] candidateMethodArgs = convertArguments(methodArgValues, actualParameterTypes);\n\t\t\t\tif (candidateMethodArgs != null) {\n\t\t\t\t\tmethodArgs = candidateMethodArgs;\n\t\t\t\t\tjavaMethod = method;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Validate that suitable constructor and test methods were found\n\t\tif (constructor == null) {\n\t\t\tthrow new StfException(\"Failed to find a matching constructor for test number '\" + testNum + \"'.\"\n\t\t\t\t\t+ \" Expecting a constructor in class '\" + testClassName + \"' which is compatible with arguments '\" + constructorArgValues + \"'\");\n\t\t}\n\t\tif (javaMethod == null) {\n\t\t\tthrow new StfException(\"Failed to find a matching test method for test number '\" + testNum + \"'.\" \n\t\t\t\t\t+ \" Expecting a method in class '\" + testClassName + \"' called '\" + testMethodName + \"' which is compatible with arguments '\" + methodArgValues.toString() + \"'\");\n\t\t}\n\t}\n\t\n\t\n\t@Override\n\tpublic ResultStatus executeTest() throws Throwable {\n\t\t// Create instance of test class and run the test method\n\t\ttry {\n\t\t\tObject instance = constructor.newInstance(constructorArgs);\n\t\t\tjavaMethod.invoke(instance, methodArgs);\n\t\t} catch (InvocationTargetException e) {\n\t\t\t// Test will be marked as a failure\n\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure(this, dumpRequested);\n\t\t\tthrow e.getCause();\n\t\t} catch (Throwable t) {\n\t\t\t// Test will be marked as a failure\n\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure(this, dumpRequested);\n\t\t\tthrow t;\n\t\t}\n\t\t\n\t\treturn ResultStatus.UNKNOWN;\n\t}\n\t\n\t\n\t// Attempts to convert a bunch of String values into the types for a constructor/method.\n\t// Returns null if not compatible, otherwise returns an array with the string values \n\t// converted to the appropriate Java object.\n\tprivate Object[] convertArguments(ArrayList<String> sourceValues, Class<?>[] destinationTypes) {\n\t\tObject[] converted = new Object[sourceValues.size()];\n\t\t\n\t\tfor (int i=0; i<sourceValues.size(); i++) {\n\t\t\tString sourceValue = sourceValues.get(i);\n\t\t\tString destinationType = destinationTypes[i].getName();\n\t\t\t\n\t\t\tObject convertedValue = convertToType(sourceValue, destinationType);\n\t\t\tif (convertedValue == null) {\n\t\t\t\t// Not possible to convert the current value to the target type. Bail out.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconverted[i] = convertedValue;\n\t\t}\n\n\t\treturn converted;\n\t}",
        "start_line": 44,
        "end_line": 134,
        "chunk_index": 2,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 803,
        "node_type": null,
        "file_sha": "3f398bb95a8e5c9ffc6c29d6b866e0ab8af87c4a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.997842"
      },
      "text": "if (countingOnly) {\n\t\t\t// Don't need to do anything else as we are only counting how many tests there are.\n\t\t\t// This will be test generation time, so classpath not set to load test cases.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.testClassName = testClassName;\n\t\tthis.testMethodName = testMethodName;\n\t\tthis.dumpRequested = dumpRequired; \n\t\t\n\t\tjavaClass = Class.forName(testClassName);\n\t\t\n\t\t// Find a constructor which is compatible with the supplied constructor arguments\n\t\tfor (Constructor<?> method : javaClass.getConstructors()) {\n\t\t\tClass<?>[] actualParameterTypes = method.getParameterTypes();\n\t\t\tif (constructorArgValues.size() == actualParameterTypes.length) {\n\t\t\t\tObject[] candidateConstructorArgs = convertArguments(constructorArgValues, actualParameterTypes);\n\t\t\t\tif (candidateConstructorArgs != null) {\n\t\t\t\t\tconstructorArgs = candidateConstructorArgs;\n\t\t\t\t\tconstructor = method;\n\t\t\t\t\tconstructor.setAccessible(true);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Find an instance method which is compatible with the supplied method arguments\n\t\tfor (Method method : javaClass.getMethods()) {\n\t\t\tClass<?>[] actualParameterTypes = method.getParameterTypes();\n\t\t\tif (method.getName().equals(testMethodName)  &&  methodArgValues.size() == actualParameterTypes.length) {\n\t\t\t\tObject[] candidateMethodArgs = convertArguments(methodArgValues, actualParameterTypes);\n\t\t\t\tif (candidateMethodArgs != null) {\n\t\t\t\t\tmethodArgs = candidateMethodArgs;\n\t\t\t\t\tjavaMethod = method;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Validate that suitable constructor and test methods were found\n\t\tif (constructor == null) {\n\t\t\tthrow new StfException(\"Failed to find a matching constructor for test number '\" + testNum + \"'.\"\n\t\t\t\t\t+ \" Expecting a constructor in class '\" + testClassName + \"' which is compatible with arguments '\" + constructorArgValues + \"'\");\n\t\t}\n\t\tif (javaMethod == null) {\n\t\t\tthrow new StfException(\"Failed to find a matching test method for test number '\" + testNum + \"'.\" \n\t\t\t\t\t+ \" Expecting a method in class '\" + testClassName + \"' called '\" + testMethodName + \"' which is compatible with arguments '\" + methodArgValues.toString() + \"'\");\n\t\t}\n\t}\n\t\n\t\n\t@Override\n\tpublic ResultStatus executeTest() throws Throwable {\n\t\t// Create instance of test class and run the test method\n\t\ttry {\n\t\t\tObject instance = constructor.newInstance(constructorArgs);\n\t\t\tjavaMethod.invoke(instance, methodArgs);\n\t\t} catch (InvocationTargetException e) {\n\t\t\t// Test will be marked as a failure\n\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure(this, dumpRequested);\n\t\t\tthrow e.getCause();\n\t\t} catch (Throwable t) {\n\t\t\t// Test will be marked as a failure\n\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure(this, dumpRequested);\n\t\t\tthrow t;\n\t\t}\n\t\t\n\t\treturn ResultStatus.UNKNOWN;\n\t}\n\t\n\t\n\t// Attempts to convert a bunch of String values into the types for a constructor/method.\n\t// Returns null if not compatible, otherwise returns an array with the string values \n\t// converted to the appropriate Java object.\n\tprivate Object[] convertArguments(ArrayList<String> sourceValues, Class<?>[] destinationTypes) {\n\t\tObject[] converted = new Object[sourceValues.size()];\n\t\t\n\t\tfor (int i=0; i<sourceValues.size(); i++) {\n\t\t\tString sourceValue = sourceValues.get(i);\n\t\t\tString destinationType = destinationTypes[i].getName();\n\t\t\t\n\t\t\tObject convertedValue = convertToType(sourceValue, destinationType);\n\t\t\tif (convertedValue == null) {\n\t\t\t\t// Not possible to convert the current value to the target type. Bail out.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconverted[i] = convertedValue;\n\t\t}\n\n\t\treturn converted;\n\t}"
    },
    "387": {
      "metadata": {
        "chunk_id": "feb9253b801f2928939a70978b1a9fcc73291f9fc733654455dc12c485037737",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/ArbitraryJavaAdaptor.java",
        "content": "return converted;\n\t}\n\n\t\n\t// Converts a single value from a String to the specified type.\n\t// Returns null if the conversion from string value to required type is not possible/supported. \n\t// If a conversion from String to the destination type is supported then this method returns \n\t// a Java object which holds the source value.\n\tprivate Object convertToType(String sourceValue, String destinationType) {\n\t\ttry {\n\t\t\tif (destinationType.equals(\"java.lang.String\")) {\n\t\t\t\treturn sourceValue;\n\t\t\t} else if (destinationType.equals(\"int\")) {\n\t\t\t\treturn new Integer(sourceValue);\n\t\t\t} else if (destinationType.equals(\"long\")) {\n\t\t\t\treturn new Long(sourceValue);\n\t\t\t} else if (destinationType.equals(\"float\")) {\n\t\t\t\treturn new Float(sourceValue);\n\t\t\t} else if (destinationType.equals(\"double\")) {\n\t\t\t\treturn new Double(sourceValue);\n\t\t\t} else if (destinationType.equals(\"boolean\")) {\n\t\t\t\tif (sourceValue.equalsIgnoreCase(\"true\") || sourceValue.equalsIgnoreCase(\"false\")) { \n\t\t\t\t\treturn new Boolean(sourceValue);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\t// Conversion failed, so obviously not compatible \n\t\t\treturn null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic ResultStatus checkTestOutput(byte[] output, int off, int len) {\n\t\treturn ResultStatus.UNKNOWN;\n\t}\n\t\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof ArbitraryJavaAdaptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tArbitraryJavaAdaptor junit = (ArbitraryJavaAdaptor) o;\n\t\treturn testClassName.equals(junit.testClassName) && testMethodName.equals(junit.testMethodName);\n\t}\n\t\n\tpublic int hashCode() { \n\t\treturn testClassName.hashCode() + testMethodName.hashCode();\n\t}\n\t\n\tpublic String toString() { \n\t\treturn \"ArbitraryJava[\" + testClassName + \" \" + testMethodName + \"]\";\n\t}\n}",
        "start_line": 135,
        "end_line": 192,
        "chunk_index": 3,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 417,
        "node_type": null,
        "file_sha": "3f398bb95a8e5c9ffc6c29d6b866e0ab8af87c4a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:52.997845"
      },
      "text": "return converted;\n\t}\n\n\t\n\t// Converts a single value from a String to the specified type.\n\t// Returns null if the conversion from string value to required type is not possible/supported. \n\t// If a conversion from String to the destination type is supported then this method returns \n\t// a Java object which holds the source value.\n\tprivate Object convertToType(String sourceValue, String destinationType) {\n\t\ttry {\n\t\t\tif (destinationType.equals(\"java.lang.String\")) {\n\t\t\t\treturn sourceValue;\n\t\t\t} else if (destinationType.equals(\"int\")) {\n\t\t\t\treturn new Integer(sourceValue);\n\t\t\t} else if (destinationType.equals(\"long\")) {\n\t\t\t\treturn new Long(sourceValue);\n\t\t\t} else if (destinationType.equals(\"float\")) {\n\t\t\t\treturn new Float(sourceValue);\n\t\t\t} else if (destinationType.equals(\"double\")) {\n\t\t\t\treturn new Double(sourceValue);\n\t\t\t} else if (destinationType.equals(\"boolean\")) {\n\t\t\t\tif (sourceValue.equalsIgnoreCase(\"true\") || sourceValue.equalsIgnoreCase(\"false\")) { \n\t\t\t\t\treturn new Boolean(sourceValue);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\t// Conversion failed, so obviously not compatible \n\t\t\treturn null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic ResultStatus checkTestOutput(byte[] output, int off, int len) {\n\t\treturn ResultStatus.UNKNOWN;\n\t}\n\t\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof ArbitraryJavaAdaptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tArbitraryJavaAdaptor junit = (ArbitraryJavaAdaptor) o;\n\t\treturn testClassName.equals(junit.testClassName) && testMethodName.equals(junit.testMethodName);\n\t}\n\t\n\tpublic int hashCode() { \n\t\treturn testClassName.hashCode() + testMethodName.hashCode();\n\t}\n\t\n\tpublic String toString() { \n\t\treturn \"ArbitraryJava[\" + testClassName + \" \" + testMethodName + \"]\";\n\t}\n}"
    },
    "388": {
      "metadata": {
        "chunk_id": "fd3e0c8a95be79a06c0271ae983ad27ee26ddf43a789778e45aaf65908102cba",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/JUnitAdaptor.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\n\nimport net.adoptopenjdk.loadTest.FirstFailureDumper;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\n\n\n/**\n * This class allows the load test to run junit tests.\n */",
        "start_line": 0,
        "end_line": 32,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 223,
        "node_type": null,
        "file_sha": "936e5a8c83ffc836bcb0f385b83822e2164f7215",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.019151"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.JUnitCore;\nimport org.junit.runner.Request;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.Failure;\nimport org.junit.runner.notification.RunListener;\n\nimport net.adoptopenjdk.loadTest.FirstFailureDumper;\nimport net.adoptopenjdk.stf.environment.PlatformFinder;\n\n\n/**\n * This class allows the load test to run junit tests.\n */"
    },
    "389": {
      "metadata": {
        "chunk_id": "f1e2cad7e3ffd4d622ce8fdb5bd1b6f455c8943f773c3322ff429f618eb278a8",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/JUnitAdaptor.java",
        "content": "public class JUnitAdaptor extends LoadTestBase {\n\tprivate final String testClass;\n\tprivate boolean dumpRequested; \n\n\tpublic JUnitAdaptor(int testNum, String testClass, BigDecimal weighting, boolean dumpRequested) {\n\t\tsuper(testNum, testClass, null, weighting);\n\t\t\n\t\tthis.testClass = testClass;\n\t\tthis.dumpRequested = dumpRequested; \n\t}\n\n\n\t/**\n\t * Gets JUnit to run the tests, and examines the results from the execution.\n\t * @returns A ResultStatus object with the pass/fail result. \n\t */\n\t@Override\n\tpublic ResultStatus executeTest() throws Throwable {\n\t\tfinal LoadTestBase test = this;\n    \t// Find the test classes that need to be run\n    \tArrayList<Class<?>> testClasses = new ArrayList<Class<?>>();\n   \t\ttestClasses.add(Class.forName(testClass));\n\n    \t// The results from this run are collected into this string buffer.\n    \t// Using string buffer for thread safety, as the anonymous inner class may be \n    \t// run in a different thread.\n    \tfinal StringBuffer resultsText = new StringBuffer();\n    \tfinal ArrayList<Throwable> failures = new ArrayList<Throwable>();\n    \tfinal String platform = PlatformFinder.getPlatformAsString();\n    \t\n    \tJUnitCore jUnitCore = new JUnitCore();\n        jUnitCore.addListener(new RunListener() {\n        \tprivate boolean awaitingResult = false;\n        \t\n        \tpublic void testRunStarted(Description description) throws Exception {\n        \t}\n        \tpublic void testRunFinished(Result result) throws Exception {\n        \t}\n        \tpublic void testStarted(Description description) throws Exception {\n        \t\treportProgress(\"testStarted : \" + description);\n        \t\tawaitingResult = true;\n        \t}\n        \tpublic void testFinished(Description description) throws Exception {\n        \t\treportProgress(\"testFinished: \" + description);\n        \t\t// Only report result if test has not already failed  \n        \t\tif (awaitingResult == true) {\n        \t\t\taddResult(\"pass\", platform, description, null, null);\n        \t\t\tawaitingResult = false;\n        \t\t}\n        \t}\n        \tpublic void testFailure(Failure failure) throws Exception {\n        \t\tFirstFailureDumper.instance().createDumpIfFirstFailure(test, dumpRequested);\n        \t\treportProgress(\"testFailure: \" + failure);\n        \t\tfailures.add(failure.getException());\n        \t\tfailure.getException().printStackTrace(System.out);\n       \t\t\taddResult(\"fail\", platform, failure.getDescription(), failure.getMessage(), failure.getException());\n       \t\t\tawaitingResult = false;\n        \t}\n\t\t\tpublic void testAssumptionFailure(Failure failure) {\n        \t\tFirstFailureDumper.instance().createDumpIfFirstFailure(test, dumpRequested);\n\t\t\t\treportProgress(\"testAssumptionFailure: \" + failure);\n        \t\tfailures.add(failure.getException());\n       \t\t\taddResult(\"fail\", platform, failure.getDescription(), failure.getMessage(), failure.getException());\n       \t\t\tawaitingResult = false;\n        \t}\n        \tpublic void testIgnored(Description description) throws Exception {\n        \t\treportProgress(\"testIgnored: \" + description);\n        \t\taddResult(\"ignored\", platform, description, null, null);\n        \t}",
        "start_line": 33,
        "end_line": 101,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 629,
        "node_type": null,
        "file_sha": "936e5a8c83ffc836bcb0f385b83822e2164f7215",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.019172"
      },
      "text": "public class JUnitAdaptor extends LoadTestBase {\n\tprivate final String testClass;\n\tprivate boolean dumpRequested; \n\n\tpublic JUnitAdaptor(int testNum, String testClass, BigDecimal weighting, boolean dumpRequested) {\n\t\tsuper(testNum, testClass, null, weighting);\n\t\t\n\t\tthis.testClass = testClass;\n\t\tthis.dumpRequested = dumpRequested; \n\t}\n\n\n\t/**\n\t * Gets JUnit to run the tests, and examines the results from the execution.\n\t * @returns A ResultStatus object with the pass/fail result. \n\t */\n\t@Override\n\tpublic ResultStatus executeTest() throws Throwable {\n\t\tfinal LoadTestBase test = this;\n    \t// Find the test classes that need to be run\n    \tArrayList<Class<?>> testClasses = new ArrayList<Class<?>>();\n   \t\ttestClasses.add(Class.forName(testClass));\n\n    \t// The results from this run are collected into this string buffer.\n    \t// Using string buffer for thread safety, as the anonymous inner class may be \n    \t// run in a different thread.\n    \tfinal StringBuffer resultsText = new StringBuffer();\n    \tfinal ArrayList<Throwable> failures = new ArrayList<Throwable>();\n    \tfinal String platform = PlatformFinder.getPlatformAsString();\n    \t\n    \tJUnitCore jUnitCore = new JUnitCore();\n        jUnitCore.addListener(new RunListener() {\n        \tprivate boolean awaitingResult = false;\n        \t\n        \tpublic void testRunStarted(Description description) throws Exception {\n        \t}\n        \tpublic void testRunFinished(Result result) throws Exception {\n        \t}\n        \tpublic void testStarted(Description description) throws Exception {\n        \t\treportProgress(\"testStarted : \" + description);\n        \t\tawaitingResult = true;\n        \t}\n        \tpublic void testFinished(Description description) throws Exception {\n        \t\treportProgress(\"testFinished: \" + description);\n        \t\t// Only report result if test has not already failed  \n        \t\tif (awaitingResult == true) {\n        \t\t\taddResult(\"pass\", platform, description, null, null);\n        \t\t\tawaitingResult = false;\n        \t\t}\n        \t}\n        \tpublic void testFailure(Failure failure) throws Exception {\n        \t\tFirstFailureDumper.instance().createDumpIfFirstFailure(test, dumpRequested);\n        \t\treportProgress(\"testFailure: \" + failure);\n        \t\tfailures.add(failure.getException());\n        \t\tfailure.getException().printStackTrace(System.out);\n       \t\t\taddResult(\"fail\", platform, failure.getDescription(), failure.getMessage(), failure.getException());\n       \t\t\tawaitingResult = false;\n        \t}\n\t\t\tpublic void testAssumptionFailure(Failure failure) {\n        \t\tFirstFailureDumper.instance().createDumpIfFirstFailure(test, dumpRequested);\n\t\t\t\treportProgress(\"testAssumptionFailure: \" + failure);\n        \t\tfailures.add(failure.getException());\n       \t\t\taddResult(\"fail\", platform, failure.getDescription(), failure.getMessage(), failure.getException());\n       \t\t\tawaitingResult = false;\n        \t}\n        \tpublic void testIgnored(Description description) throws Exception {\n        \t\treportProgress(\"testIgnored: \" + description);\n        \t\taddResult(\"ignored\", platform, description, null, null);\n        \t}"
    },
    "390": {
      "metadata": {
        "chunk_id": "048ba7e6d97c5dcdc8383ee280470f3a91477b034220350e6e920037adeb68ea",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/JUnitAdaptor.java",
        "content": "private void reportProgress(String testInfo) {\n        \t\t// With extra flushing to try and keep output in approximate time order - to help with debugging\n        \t\tSystem.out.flush();\n        \t\tSystem.err.flush();\n        \t\tSystem.out.println(testInfo);\n        \t\tSystem.out.flush();\n        \t\tSystem.err.flush();\n        \t}\n        \t\n        \t// Record the progress\n        \tprivate void addResult(String status, String platform, Description description, String message, Throwable exception) {\n        \t\tString messageText   = message == null ? \"\" : \" message=\\\"\" + message + \"\\\"\";\n        \t\tString exceptionText = exception == null ? \"\" : \" exception=\" + exception.getClass().getName();\n        \t\tString resultLine = \"platform=\" + platform \n        \t\t\t\t\t+ \" result=\" + status \n        \t\t\t\t\t+ \" class=\" + description.getClassName() \n        \t\t\t\t\t+ \" test=\" + description.getMethodName() \n        \t\t\t\t\t+ messageText\n        \t\t\t\t\t+ exceptionText; \n        \t\tresultsText.append(resultLine + \"\\n\");\n        \t}\n        });\n        \n\n        // Run the tests\n        Request request = Request.classes(testClasses.toArray(new Class[testClasses.size()]));\n\t\tResult result = jUnitCore.run(request);\n\t\t\n\t\t// Report results\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"JUnit Test Results for: \" + testClass);\n        System.out.println(\"  Ran    : \" + result.getRunCount());\n        System.out.println(\"  Passed : \" + (result.getRunCount() - result.getFailureCount()));\n        System.out.println(\"  Failed : \" + result.getFailureCount());\n        System.out.println(\"  Ignored: \" + result.getIgnoreCount());\n        System.out.println(\"  Result : \" + (result.wasSuccessful() ? \"PASSED\" : \"FAILED\"));\n\n        // Only throw an exception if OOM, to allow abort of test run\n        for (Throwable e : failures) {\n        \tif (e instanceof java.lang.OutOfMemoryError) {\n        \t\tthrow e;\n        \t}\n        }\n        \n        ResultStatus overallResult;\n        if (result.wasSuccessful()) {\n        \toverallResult = ResultStatus.PASS;\n        } else {\n        \toverallResult = ResultStatus.FAIL;\n        }\n        return overallResult;\n\t}\n\n\n\tpublic ResultStatus checkTestOutput(byte[] output, int off, int len) {\n\t\treturn ResultStatus.UNKNOWN;\n\t}\n\t\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof JUnitAdaptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tJUnitAdaptor junit = (JUnitAdaptor) o;\n\t\treturn testClass.equals(junit.testClass);\n\t}\n\t\n\tpublic int hashCode() { \n\t\treturn testClass.hashCode();\n\t}\n\n\tpublic String toString() { \n\t\treturn \"JUnit[\" + testClass + \"]\";\n\t}\n}",
        "start_line": 102,
        "end_line": 178,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 577,
        "node_type": null,
        "file_sha": "936e5a8c83ffc836bcb0f385b83822e2164f7215",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.019175"
      },
      "text": "private void reportProgress(String testInfo) {\n        \t\t// With extra flushing to try and keep output in approximate time order - to help with debugging\n        \t\tSystem.out.flush();\n        \t\tSystem.err.flush();\n        \t\tSystem.out.println(testInfo);\n        \t\tSystem.out.flush();\n        \t\tSystem.err.flush();\n        \t}\n        \t\n        \t// Record the progress\n        \tprivate void addResult(String status, String platform, Description description, String message, Throwable exception) {\n        \t\tString messageText   = message == null ? \"\" : \" message=\\\"\" + message + \"\\\"\";\n        \t\tString exceptionText = exception == null ? \"\" : \" exception=\" + exception.getClass().getName();\n        \t\tString resultLine = \"platform=\" + platform \n        \t\t\t\t\t+ \" result=\" + status \n        \t\t\t\t\t+ \" class=\" + description.getClassName() \n        \t\t\t\t\t+ \" test=\" + description.getMethodName() \n        \t\t\t\t\t+ messageText\n        \t\t\t\t\t+ exceptionText; \n        \t\tresultsText.append(resultLine + \"\\n\");\n        \t}\n        });\n        \n\n        // Run the tests\n        Request request = Request.classes(testClasses.toArray(new Class[testClasses.size()]));\n\t\tResult result = jUnitCore.run(request);\n\t\t\n\t\t// Report results\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"JUnit Test Results for: \" + testClass);\n        System.out.println(\"  Ran    : \" + result.getRunCount());\n        System.out.println(\"  Passed : \" + (result.getRunCount() - result.getFailureCount()));\n        System.out.println(\"  Failed : \" + result.getFailureCount());\n        System.out.println(\"  Ignored: \" + result.getIgnoreCount());\n        System.out.println(\"  Result : \" + (result.wasSuccessful() ? \"PASSED\" : \"FAILED\"));\n\n        // Only throw an exception if OOM, to allow abort of test run\n        for (Throwable e : failures) {\n        \tif (e instanceof java.lang.OutOfMemoryError) {\n        \t\tthrow e;\n        \t}\n        }\n        \n        ResultStatus overallResult;\n        if (result.wasSuccessful()) {\n        \toverallResult = ResultStatus.PASS;\n        } else {\n        \toverallResult = ResultStatus.FAIL;\n        }\n        return overallResult;\n\t}\n\n\n\tpublic ResultStatus checkTestOutput(byte[] output, int off, int len) {\n\t\treturn ResultStatus.UNKNOWN;\n\t}\n\t\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof JUnitAdaptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tJUnitAdaptor junit = (JUnitAdaptor) o;\n\t\treturn testClass.equals(junit.testClass);\n\t}\n\t\n\tpublic int hashCode() { \n\t\treturn testClass.hashCode();\n\t}\n\n\tpublic String toString() { \n\t\treturn \"JUnit[\" + testClass + \"]\";\n\t}\n}"
    },
    "391": {
      "metadata": {
        "chunk_id": "d424333af2944077c15137cac7c6d65bed46c548a0731efebd9e96b1dee13deb",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/LoadTestBase.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\n\n/**\n * This is a base class for all types of test that are runnable by the STF Load test.\n * \n * It holds attributes which are common to all tests:\n *   - their name\n *   - the test number \n *   - the test weighting (defaults to 1)\n */\npublic abstract class LoadTestBase implements AdaptorInterface {\n\tprivate final int testNum;\n\tprivate final String testName;\n\tprivate final String testMethodName;\n\tprivate final BigDecimal weighting;\n\n\tpublic LoadTestBase(int testNum, String testName, String testMethodName, BigDecimal weighting) {\n\t\tthis.testNum = testNum;\n\t\tthis.testName = testName;\n\t\tthis.testMethodName = testMethodName;\n\t\tthis.weighting = weighting;\n\t}\n\n\t@Override\n\tpublic int getTestNum() {\n\t\treturn testNum;\n\t}\n\t\n\t@Override\n\tpublic String getTestName() {\n\t\treturn testName;\n\t}\n\t\n\t@Override\n\tpublic String getTestMethodName() {\n\t\tif (testMethodName == null) { \n\t\t\treturn \"\";\n\t\t}\n\t\treturn testMethodName;\n\t}\n\t\n\t@Override\n\tpublic BigDecimal getWeighting() {\n\t\treturn weighting;\n\t}\n\n\t/**\n\t * Return the weighting for this test once multiplied by a weighting multiplier.\n\t * @param weightingMultiplier holds the multiplier needed to balance out the weightings.\n\t * @return The result of weighting * weightingMultipier. \n\t */\n\tpublic BigDecimal getAdjustedWeighting(BigDecimal weightingMultiplier) {\n\t\treturn weighting.multiply(weightingMultiplier);\n\t}\n\n\t/**\n\t * Returns the rounded and adjusted weighting. \n\t * For example a weighting of 1.3 and a multiplier of 3 results in a value of 3.9, which is \n\t * rounded to 4.\n\t * @param weightingMultiplier holds the multiplier needed to balance out the weightings.\n\t * @return Rounded adjusted weighting. Values less than 1 are rounded up to 1.\n\t */\n\tpublic int getRoundedAdjustedWeighting(BigDecimal weightingMultiplier) {\n\t\tBigDecimal adjustedWeighting = getAdjustedWeighting(weightingMultiplier);\n\t\tBigDecimal roundedWeighting = adjustedWeighting.setScale(0, RoundingMode.HALF_UP);\n\t\troundedWeighting = roundedWeighting.max(BigDecimal.ONE);\n\t\treturn roundedWeighting.intValue();\n\t}\n\n\t/**\n\t * Subclasses must implement equals() and hashcode() so that InventoryData can\n\t * use ArrayList and Set manipulation (eg, ArrayList.removeAll) on collections of tests. \n\t */\n\tpublic abstract boolean equals(Object other);\n\tpublic abstract int hashCode();\n\t\n\t/**\n\t * Subclasses must implement toString() so that tests can be listed and described.\n\t */\n\tpublic abstract String toString();\n}",
        "start_line": 0,
        "end_line": 98,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 687,
        "node_type": null,
        "file_sha": "cd57cc5b236bce2de33f4ba1c0d9644143fb31b7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.042796"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\n\n/**\n * This is a base class for all types of test that are runnable by the STF Load test.\n * \n * It holds attributes which are common to all tests:\n *   - their name\n *   - the test number \n *   - the test weighting (defaults to 1)\n */\npublic abstract class LoadTestBase implements AdaptorInterface {\n\tprivate final int testNum;\n\tprivate final String testName;\n\tprivate final String testMethodName;\n\tprivate final BigDecimal weighting;\n\n\tpublic LoadTestBase(int testNum, String testName, String testMethodName, BigDecimal weighting) {\n\t\tthis.testNum = testNum;\n\t\tthis.testName = testName;\n\t\tthis.testMethodName = testMethodName;\n\t\tthis.weighting = weighting;\n\t}\n\n\t@Override\n\tpublic int getTestNum() {\n\t\treturn testNum;\n\t}\n\t\n\t@Override\n\tpublic String getTestName() {\n\t\treturn testName;\n\t}\n\t\n\t@Override\n\tpublic String getTestMethodName() {\n\t\tif (testMethodName == null) { \n\t\t\treturn \"\";\n\t\t}\n\t\treturn testMethodName;\n\t}\n\t\n\t@Override\n\tpublic BigDecimal getWeighting() {\n\t\treturn weighting;\n\t}\n\n\t/**\n\t * Return the weighting for this test once multiplied by a weighting multiplier.\n\t * @param weightingMultiplier holds the multiplier needed to balance out the weightings.\n\t * @return The result of weighting * weightingMultipier. \n\t */\n\tpublic BigDecimal getAdjustedWeighting(BigDecimal weightingMultiplier) {\n\t\treturn weighting.multiply(weightingMultiplier);\n\t}\n\n\t/**\n\t * Returns the rounded and adjusted weighting. \n\t * For example a weighting of 1.3 and a multiplier of 3 results in a value of 3.9, which is \n\t * rounded to 4.\n\t * @param weightingMultiplier holds the multiplier needed to balance out the weightings.\n\t * @return Rounded adjusted weighting. Values less than 1 are rounded up to 1.\n\t */\n\tpublic int getRoundedAdjustedWeighting(BigDecimal weightingMultiplier) {\n\t\tBigDecimal adjustedWeighting = getAdjustedWeighting(weightingMultiplier);\n\t\tBigDecimal roundedWeighting = adjustedWeighting.setScale(0, RoundingMode.HALF_UP);\n\t\troundedWeighting = roundedWeighting.max(BigDecimal.ONE);\n\t\treturn roundedWeighting.intValue();\n\t}\n\n\t/**\n\t * Subclasses must implement equals() and hashcode() so that InventoryData can\n\t * use ArrayList and Set manipulation (eg, ArrayList.removeAll) on collections of tests. \n\t */\n\tpublic abstract boolean equals(Object other);\n\tpublic abstract int hashCode();\n\t\n\t/**\n\t * Subclasses must implement toString() so that tests can be listed and described.\n\t */\n\tpublic abstract String toString();\n}"
    },
    "392": {
      "metadata": {
        "chunk_id": "9a4291f26d78f18c3c003e7b5d90b85c5769023e4017f85da5083a743ace629e",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/MauveAdaptor.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\n\nimport net.adoptopenjdk.loadTest.FirstFailureDumper;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionTracker;",
        "start_line": 0,
        "end_line": 22,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 184,
        "node_type": null,
        "file_sha": "828c215360e6483eff03ed5737c9fdb10df4756b",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.062434"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.adaptors;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\n\nimport net.adoptopenjdk.loadTest.FirstFailureDumper;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionTracker;"
    },
    "393": {
      "metadata": {
        "chunk_id": "19d83e1d3af92073be5fe7889e97cd8f9f05087887d4fa5b2a076c4eede496a6",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/MauveAdaptor.java",
        "content": "public class MauveAdaptor extends LoadTestBase {\n\tprivate final String fullMauveClass;  // eg, gnu.testlet.java.lang.InheritableThreadLocal.simple\n\n\t// Define the strings that we'll see in the output which tell us\n\t// if a Mauve test has passed or failed\n\tprivate static byte[] PASS_INDICATOR = \"PASS:\".getBytes();\n\tprivate static byte[] FAIL_INDICATOR = \"FAIL:\".getBytes();\n\tboolean dumpRequested; \n\n\tpublic MauveAdaptor(int testNum, String fullClassname, BigDecimal weighting, boolean dumpRequired) {\n\t\tsuper(testNum, fullClassname, null, weighting);\n\t\t\n\t\tthis.fullMauveClass = fullClassname;\n\t\tthis.dumpRequested = dumpRequired; \n\t}\n\n\n\t// The Mauve code is not directly accessible so needs to be run using reflection.\n\t// This method is basically doing the following:\n\t//    Testlet testlet = new <fullMauveClass>();\n\t//    SingleTestHarness harness = new SingleTestHarness(testlet, true);\n\t//    testlet.test(harness);\n\t@Override\n\tpublic ResultStatus executeTest() throws Throwable {\n\t\t// Create an instance of the class under test\n\t\tClass<?> testletClass1 = Class.forName(fullMauveClass);\n\t\tObject testlet = testletClass1.newInstance();\n\n\t\t// Find the SingleTestHarness constructor. ie. 'public SingleTestHarness(Testlet t, boolean verbose)'\n\t\tConstructor<?> singleConstructor = null;\n\t\tClass<?> singleTestHarnessClass = Class.forName(\"gnu.testlet.SingleTestHarness\");\n\t\tClass<?> gnuTestletClass = Class.forName(\"gnu.testlet.Testlet\");\n\t\tsingleConstructor = singleTestHarnessClass.getConstructor(gnuTestletClass, Boolean.TYPE);\n\t\t\n\t\t// Create an instance of SingleTestHarness\n\t\t// Equivalent to: 'new SingleTestHarness(testlet, true)'\n\t\tObject testHarness = null;\n\t\tObject args[] = { testlet, Boolean.TRUE };\n\t\ttestHarness = singleConstructor.newInstance(args);\n\n\t\t// Find the test method\n\t\tMethod testMethod = null;\n\t\tClass<?> testHarnessClass = Class.forName(\"gnu.testlet.TestHarness\");\n\t\ttestMethod = testletClass1.getDeclaredMethod(\"test\", testHarnessClass);\n\n\t\t// Invoke the test method - call 'public void test (TestHarness harness)'\n\t\ttry {\n\t\t\tObject[] testMethodArgs = { testHarness };\n\t\t\ttestMethod.invoke(testlet, testMethodArgs);\n\t\t} catch (InvocationTargetException e) {\n\t\t\t// Test code caused Throwable or Exception. Let the caller handle the root cause.\n\t\t\tthrow e.getCause();\n\t\t}\n\t\t\n\t\t// Result of Mauve test can only be discovered by parsing its output\n\t\treturn ExecutionTracker.instance().getFinalResult();\n\t}\n\n\t\n\t/**\n\t * Examines a line of Mauve test output to see if it starts with 'PASS:' or 'FAIL:'\n\t * \n\t * @param output is the bytes of a string being output by a Mauve test.\n\t * @param off is the offset to the start of the data.\n\t * @param len is the length of the data in the output buffer.\n\t * @returns Pass/Fail if the line contains the special Mauve output, otherwise NO_MATCH.\n\t */\n\tpublic ResultStatus checkTestOutput(byte[] output, int off, int len) {\n\t\tResultStatus resultStatus = ResultStatus.UNKNOWN;\n\t\t\n\t\tif (startsWith(output, off, len, PASS_INDICATOR)) {\n\t\t\tresultStatus = ResultStatus.PASS;\n\t\t} else if (startsWith(output, off, len, FAIL_INDICATOR)) {\n\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure(this, dumpRequested);\n\t\t\tresultStatus = ResultStatus.FAIL;\n\t\t}\n\t\t\n\t\treturn resultStatus;\n\t}\n\n\t\n\t/**\n\t * Examines the data in the output buffer and compares it for equality with the target data.\n\t * Returns true if the output starts with same data as the target, otherwise false.\n\t */\n\tprivate boolean startsWith(byte[] output, int off, int len, byte[] target) {\n\t\tif (len <= target.length) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<target.length; i++) {\n\t\t\tif (output[off+i] != target[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof MauveAdaptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tMauveAdaptor mauve = (MauveAdaptor) o;\n\t\treturn fullMauveClass.equals(mauve.fullMauveClass);\n\t}\n\t\n\tpublic int hashCode() { \n\t\treturn fullMauveClass.hashCode();\n\t}",
        "start_line": 23,
        "end_line": 135,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 1022,
        "node_type": null,
        "file_sha": "828c215360e6483eff03ed5737c9fdb10df4756b",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.062442"
      },
      "text": "public class MauveAdaptor extends LoadTestBase {\n\tprivate final String fullMauveClass;  // eg, gnu.testlet.java.lang.InheritableThreadLocal.simple\n\n\t// Define the strings that we'll see in the output which tell us\n\t// if a Mauve test has passed or failed\n\tprivate static byte[] PASS_INDICATOR = \"PASS:\".getBytes();\n\tprivate static byte[] FAIL_INDICATOR = \"FAIL:\".getBytes();\n\tboolean dumpRequested; \n\n\tpublic MauveAdaptor(int testNum, String fullClassname, BigDecimal weighting, boolean dumpRequired) {\n\t\tsuper(testNum, fullClassname, null, weighting);\n\t\t\n\t\tthis.fullMauveClass = fullClassname;\n\t\tthis.dumpRequested = dumpRequired; \n\t}\n\n\n\t// The Mauve code is not directly accessible so needs to be run using reflection.\n\t// This method is basically doing the following:\n\t//    Testlet testlet = new <fullMauveClass>();\n\t//    SingleTestHarness harness = new SingleTestHarness(testlet, true);\n\t//    testlet.test(harness);\n\t@Override\n\tpublic ResultStatus executeTest() throws Throwable {\n\t\t// Create an instance of the class under test\n\t\tClass<?> testletClass1 = Class.forName(fullMauveClass);\n\t\tObject testlet = testletClass1.newInstance();\n\n\t\t// Find the SingleTestHarness constructor. ie. 'public SingleTestHarness(Testlet t, boolean verbose)'\n\t\tConstructor<?> singleConstructor = null;\n\t\tClass<?> singleTestHarnessClass = Class.forName(\"gnu.testlet.SingleTestHarness\");\n\t\tClass<?> gnuTestletClass = Class.forName(\"gnu.testlet.Testlet\");\n\t\tsingleConstructor = singleTestHarnessClass.getConstructor(gnuTestletClass, Boolean.TYPE);\n\t\t\n\t\t// Create an instance of SingleTestHarness\n\t\t// Equivalent to: 'new SingleTestHarness(testlet, true)'\n\t\tObject testHarness = null;\n\t\tObject args[] = { testlet, Boolean.TRUE };\n\t\ttestHarness = singleConstructor.newInstance(args);\n\n\t\t// Find the test method\n\t\tMethod testMethod = null;\n\t\tClass<?> testHarnessClass = Class.forName(\"gnu.testlet.TestHarness\");\n\t\ttestMethod = testletClass1.getDeclaredMethod(\"test\", testHarnessClass);\n\n\t\t// Invoke the test method - call 'public void test (TestHarness harness)'\n\t\ttry {\n\t\t\tObject[] testMethodArgs = { testHarness };\n\t\t\ttestMethod.invoke(testlet, testMethodArgs);\n\t\t} catch (InvocationTargetException e) {\n\t\t\t// Test code caused Throwable or Exception. Let the caller handle the root cause.\n\t\t\tthrow e.getCause();\n\t\t}\n\t\t\n\t\t// Result of Mauve test can only be discovered by parsing its output\n\t\treturn ExecutionTracker.instance().getFinalResult();\n\t}\n\n\t\n\t/**\n\t * Examines a line of Mauve test output to see if it starts with 'PASS:' or 'FAIL:'\n\t * \n\t * @param output is the bytes of a string being output by a Mauve test.\n\t * @param off is the offset to the start of the data.\n\t * @param len is the length of the data in the output buffer.\n\t * @returns Pass/Fail if the line contains the special Mauve output, otherwise NO_MATCH.\n\t */\n\tpublic ResultStatus checkTestOutput(byte[] output, int off, int len) {\n\t\tResultStatus resultStatus = ResultStatus.UNKNOWN;\n\t\t\n\t\tif (startsWith(output, off, len, PASS_INDICATOR)) {\n\t\t\tresultStatus = ResultStatus.PASS;\n\t\t} else if (startsWith(output, off, len, FAIL_INDICATOR)) {\n\t\t\tFirstFailureDumper.instance().createDumpIfFirstFailure(this, dumpRequested);\n\t\t\tresultStatus = ResultStatus.FAIL;\n\t\t}\n\t\t\n\t\treturn resultStatus;\n\t}\n\n\t\n\t/**\n\t * Examines the data in the output buffer and compares it for equality with the target data.\n\t * Returns true if the output starts with same data as the target, otherwise false.\n\t */\n\tprivate boolean startsWith(byte[] output, int off, int len, byte[] target) {\n\t\tif (len <= target.length) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<target.length; i++) {\n\t\t\tif (output[off+i] != target[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof MauveAdaptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tMauveAdaptor mauve = (MauveAdaptor) o;\n\t\treturn fullMauveClass.equals(mauve.fullMauveClass);\n\t}\n\t\n\tpublic int hashCode() { \n\t\treturn fullMauveClass.hashCode();\n\t}"
    },
    "394": {
      "metadata": {
        "chunk_id": "c740f879a2a717c09367da9aeb912f0a0ee235fa192ce2a9e3fa77f405f93513",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/adaptors/MauveAdaptor.java",
        "content": "/**\n\t * Examines the data in the output buffer and compares it for equality with the target data.\n\t * Returns true if the output starts with same data as the target, otherwise false.\n\t */\n\tprivate boolean startsWith(byte[] output, int off, int len, byte[] target) {\n\t\tif (len <= target.length) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<target.length; i++) {\n\t\t\tif (output[off+i] != target[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof MauveAdaptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tMauveAdaptor mauve = (MauveAdaptor) o;\n\t\treturn fullMauveClass.equals(mauve.fullMauveClass);\n\t}\n\t\n\tpublic int hashCode() { \n\t\treturn fullMauveClass.hashCode();\n\t}\n\n\tpublic String toString() { \n\t\treturn \"Mauve[\" + fullMauveClass + \"]\";\n\t}\n}",
        "start_line": 136,
        "end_line": 172,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 243,
        "node_type": null,
        "file_sha": "828c215360e6483eff03ed5737c9fdb10df4756b",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.062445"
      },
      "text": "/**\n\t * Examines the data in the output buffer and compares it for equality with the target data.\n\t * Returns true if the output starts with same data as the target, otherwise false.\n\t */\n\tprivate boolean startsWith(byte[] output, int off, int len, byte[] target) {\n\t\tif (len <= target.length) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<target.length; i++) {\n\t\t\tif (output[off+i] != target[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof MauveAdaptor)) {\n\t\t\treturn false;\n\t\t}\n\t\tMauveAdaptor mauve = (MauveAdaptor) o;\n\t\treturn fullMauveClass.equals(mauve.fullMauveClass);\n\t}\n\t\n\tpublic int hashCode() { \n\t\treturn fullMauveClass.hashCode();\n\t}\n\n\tpublic String toString() { \n\t\treturn \"Mauve[\" + fullMauveClass + \"]\";\n\t}\n}"
    },
    "395": {
      "metadata": {
        "chunk_id": "0ef007a838dcfc53346cf3715487f5c49227f6a1d92dcfa1c37c85908e13ae0c",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionLog.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Calendar;\n\nimport net.adoptopenjdk.loadTest.InventoryData;\nimport net.adoptopenjdk.loadTest.SuiteData;\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\n\n\n/**\n * The load test records what is happening in an execution log file. \n * This class handles the creation of such a file.\n * \n * This basically adds a single entry every time the following occurs:\n *   - Thread starts a test\n *   - A test completes (passes/fails or results unknown)\n *   - An exception or Throwable is caught from a test execution.\n *   \n * The data is written in a compact binary format for later post processing.\n */",
        "start_line": 0,
        "end_line": 40,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 307,
        "node_type": null,
        "file_sha": "1d4a2d9eeba4d86b0215b33c85a01c18fb1dccab",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.081985"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Calendar;\n\nimport net.adoptopenjdk.loadTest.InventoryData;\nimport net.adoptopenjdk.loadTest.SuiteData;\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\n\n\n/**\n * The load test records what is happening in an execution log file. \n * This class handles the creation of such a file.\n * \n * This basically adds a single entry every time the following occurs:\n *   - Thread starts a test\n *   - A test completes (passes/fails or results unknown)\n *   - An exception or Throwable is caught from a test execution.\n *   \n * The data is written in a compact binary format for later post processing.\n */"
    },
    "396": {
      "metadata": {
        "chunk_id": "20b1566a4a849243a5dd4f4403c9aee9b8bb927b1807ad4f21656a7feead2464",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionLog.java",
        "content": "public class ExecutionLog {\n\t// Execution log is a singleton as all output goes to the same file\n\tprivate static ExecutionLog instance = null;\n\t\n\t// This is the time that the run started. All logged times are relative to this.\n\tprivate long baseTimestamp = System.currentTimeMillis();\n\t\n\t// Holds the binary data for a single ExcutionRecord\n\tprivate byte[] buffer = new byte[ExecutionRecord.SIZE_IN_BYTES];\n\t\n\t// Output file to record to\n\tprivate File currentOutputFile;\n\tprivate OutputStream output;\n\n\t// To support log file rotation\n\tprivate String logFileBaseName;\n\tprivate ExecutionLogManager logManager;\n\tprivate int maxLogFileSize;\n\tprivate int nextLogFileNumber = 1;\n\n\t// Data about the current log file\n\tprivate int spaceLeftInCurrentLog;\n\tprivate int numErrorsInCurrentLog;\n\t\n\t\n\t/**\n\t * Create a new log file.\n\t * Writes fixed header information to the new file.\n\t * \n\t * @param logFile Is the execution log file to write to.\n\t * @throws IOException if we fail to write to the file.\n\t */\n\tprivate ExecutionLog(File logFileBaseName, long maxTotalLogFileSpace, int maxSingleLogSize, ArrayList<SuiteData> suites) throws IOException {\n\t\tthis.logFileBaseName = logFileBaseName.getAbsolutePath();\n\n\t\tthis.maxLogFileSize = maxSingleLogSize;\n\t\tlong maxNumLogFiles = maxTotalLogFileSpace / maxSingleLogSize;\n\t\tlogManager = new ExecutionLogManager(maxNumLogFiles);\n\n\t\t// Create file with load test data applicable to all log files\n\t\tcreateLogFileMetaDataFile(suites);\n\n\t\t// Start the first log file\n\t\tcreateNewLoadTestDataFile();\n\t}\n\n\t\n\t// Create load test meta data file.\n\t// This holds the version number of the data format and the start timestamp.\n\tprivate void createLogFileMetaDataFile(ArrayList<SuiteData> suites) throws IOException {\n\t\tFile loadTestMetaDataFile = new File(logFileBaseName + \".ltm\");\n\t\t\n\t\tDataOutputStream output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(loadTestMetaDataFile)));\n\t\t\n\t\t// Write a version number as the first byte of the file\n\t\toutput.writeByte(4);\n\t\t\n\t\t// Write the base timestamp as the second value in the output file\n\t\toutput.writeLong(baseTimestamp);\n\n\t\t// Write number of bytes in timeZoneId, and then the timeZoneId string itself\n\t\tString timeZoneId = Calendar.getInstance().getTimeZone().getID();\n\t\toutput.writeUTF(timeZoneId);\n\n\t\t// Write out data about each suite\n\t\toutput.writeInt(suites.size());\n\t\tfor (SuiteData suite : suites) {\n\t\t\tInventoryData inventory = suite.getInventory();\n\t\t\toutput.writeInt((int) suite.getNumberThreads());\n\t\t\toutput.writeUTF(suite.getInventoryFileRef());\n\t\t\toutput.writeInt((int) inventory.getNumberOfTests());\n\t\t\t\n\t\t\t// Write out names of all tests\n\t\t\tfor (int t=0; t<inventory.getNumberOfTests(); t++) {\n\t\t\t\tAdaptorInterface test = inventory.getTest(t);\n\t\t\t\toutput.writeInt(test.getTestNum());\n\t\t\t\toutput.writeUTF(test.getTestName());\n\t\t\t\toutput.writeUTF(test.getTestMethodName());\n\t\t\t}\n\t\t}\n\t\t\n\t\toutput.close();\n\t}\n\n\tprivate void createNewLoadTestDataFile() throws IOException {\n\t\t// Close existing file\n\t\tif (output != null) {\n\t\t\toutput.close();\n\t\t\t\n\t\t\t// Track data about this log file. Delete old log file if needed\n\t\t\tlogManager.fileCompleted(currentOutputFile, numErrorsInCurrentLog);\n\t\t}\n\t\t\n\t\t// Start next log file\n\t\tcurrentOutputFile = new File(logFileBaseName + \".\" + nextLogFileNumber + \".ltd\");\n\t\toutput = new FileOutputStream(currentOutputFile);\n\t\tnextLogFileNumber++;\n\t\t\n\t\tspaceLeftInCurrentLog = maxLogFileSize;\n\t\tnumErrorsInCurrentLog = 0;\n\t}\n\n\n\tpublic static synchronized void createInstance(File logFileBaseName, long maxTotalLogFileSpace, int maxSingleLogSize, ArrayList<SuiteData> suites) throws IOException {\n\t\tinstance = new ExecutionLog(logFileBaseName, maxTotalLogFileSpace, maxSingleLogSize, suites);\n\t}\n\n\tpublic static synchronized ExecutionLog instance() {\n\t\treturn instance;\n\t}",
        "start_line": 41,
        "end_line": 150,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 873,
        "node_type": null,
        "file_sha": "1d4a2d9eeba4d86b0215b33c85a01c18fb1dccab",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.081993"
      },
      "text": "public class ExecutionLog {\n\t// Execution log is a singleton as all output goes to the same file\n\tprivate static ExecutionLog instance = null;\n\t\n\t// This is the time that the run started. All logged times are relative to this.\n\tprivate long baseTimestamp = System.currentTimeMillis();\n\t\n\t// Holds the binary data for a single ExcutionRecord\n\tprivate byte[] buffer = new byte[ExecutionRecord.SIZE_IN_BYTES];\n\t\n\t// Output file to record to\n\tprivate File currentOutputFile;\n\tprivate OutputStream output;\n\n\t// To support log file rotation\n\tprivate String logFileBaseName;\n\tprivate ExecutionLogManager logManager;\n\tprivate int maxLogFileSize;\n\tprivate int nextLogFileNumber = 1;\n\n\t// Data about the current log file\n\tprivate int spaceLeftInCurrentLog;\n\tprivate int numErrorsInCurrentLog;\n\t\n\t\n\t/**\n\t * Create a new log file.\n\t * Writes fixed header information to the new file.\n\t * \n\t * @param logFile Is the execution log file to write to.\n\t * @throws IOException if we fail to write to the file.\n\t */\n\tprivate ExecutionLog(File logFileBaseName, long maxTotalLogFileSpace, int maxSingleLogSize, ArrayList<SuiteData> suites) throws IOException {\n\t\tthis.logFileBaseName = logFileBaseName.getAbsolutePath();\n\n\t\tthis.maxLogFileSize = maxSingleLogSize;\n\t\tlong maxNumLogFiles = maxTotalLogFileSpace / maxSingleLogSize;\n\t\tlogManager = new ExecutionLogManager(maxNumLogFiles);\n\n\t\t// Create file with load test data applicable to all log files\n\t\tcreateLogFileMetaDataFile(suites);\n\n\t\t// Start the first log file\n\t\tcreateNewLoadTestDataFile();\n\t}\n\n\t\n\t// Create load test meta data file.\n\t// This holds the version number of the data format and the start timestamp.\n\tprivate void createLogFileMetaDataFile(ArrayList<SuiteData> suites) throws IOException {\n\t\tFile loadTestMetaDataFile = new File(logFileBaseName + \".ltm\");\n\t\t\n\t\tDataOutputStream output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(loadTestMetaDataFile)));\n\t\t\n\t\t// Write a version number as the first byte of the file\n\t\toutput.writeByte(4);\n\t\t\n\t\t// Write the base timestamp as the second value in the output file\n\t\toutput.writeLong(baseTimestamp);\n\n\t\t// Write number of bytes in timeZoneId, and then the timeZoneId string itself\n\t\tString timeZoneId = Calendar.getInstance().getTimeZone().getID();\n\t\toutput.writeUTF(timeZoneId);\n\n\t\t// Write out data about each suite\n\t\toutput.writeInt(suites.size());\n\t\tfor (SuiteData suite : suites) {\n\t\t\tInventoryData inventory = suite.getInventory();\n\t\t\toutput.writeInt((int) suite.getNumberThreads());\n\t\t\toutput.writeUTF(suite.getInventoryFileRef());\n\t\t\toutput.writeInt((int) inventory.getNumberOfTests());\n\t\t\t\n\t\t\t// Write out names of all tests\n\t\t\tfor (int t=0; t<inventory.getNumberOfTests(); t++) {\n\t\t\t\tAdaptorInterface test = inventory.getTest(t);\n\t\t\t\toutput.writeInt(test.getTestNum());\n\t\t\t\toutput.writeUTF(test.getTestName());\n\t\t\t\toutput.writeUTF(test.getTestMethodName());\n\t\t\t}\n\t\t}\n\t\t\n\t\toutput.close();\n\t}\n\n\tprivate void createNewLoadTestDataFile() throws IOException {\n\t\t// Close existing file\n\t\tif (output != null) {\n\t\t\toutput.close();\n\t\t\t\n\t\t\t// Track data about this log file. Delete old log file if needed\n\t\t\tlogManager.fileCompleted(currentOutputFile, numErrorsInCurrentLog);\n\t\t}\n\t\t\n\t\t// Start next log file\n\t\tcurrentOutputFile = new File(logFileBaseName + \".\" + nextLogFileNumber + \".ltd\");\n\t\toutput = new FileOutputStream(currentOutputFile);\n\t\tnextLogFileNumber++;\n\t\t\n\t\tspaceLeftInCurrentLog = maxLogFileSize;\n\t\tnumErrorsInCurrentLog = 0;\n\t}\n\n\n\tpublic static synchronized void createInstance(File logFileBaseName, long maxTotalLogFileSpace, int maxSingleLogSize, ArrayList<SuiteData> suites) throws IOException {\n\t\tinstance = new ExecutionLog(logFileBaseName, maxTotalLogFileSpace, maxSingleLogSize, suites);\n\t}\n\n\tpublic static synchronized ExecutionLog instance() {\n\t\treturn instance;\n\t}"
    },
    "397": {
      "metadata": {
        "chunk_id": "6f7861257d1eeeef107cb443285839c265f5331985f9c6b3a8e2c435fdf72c57",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionLog.java",
        "content": "public static synchronized void createInstance(File logFileBaseName, long maxTotalLogFileSpace, int maxSingleLogSize, ArrayList<SuiteData> suites) throws IOException {\n\t\tinstance = new ExecutionLog(logFileBaseName, maxTotalLogFileSpace, maxSingleLogSize, suites);\n\t}\n\n\tpublic static synchronized ExecutionLog instance() {\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Logs an ExecutionLog to the file.\n\t * @param record holds information about the test event to log.\n\t * @throws IOException if the write failed.\n\t */\n\tpublic synchronized void log(ExecutionRecord record) throws IOException {\n\t\tbyte[] data = record.convertToBytes(buffer, baseTimestamp);\n\t\t\n\t\t// Decide if the current log file has enough space for this record\n\t\tspaceLeftInCurrentLog -= data.length;\n\t\tif (spaceLeftInCurrentLog < 0) {\n\t\t\t// Log file is full, start another one\n\t\t\tcreateNewLoadTestDataFile();\n\t\t\tspaceLeftInCurrentLog = maxLogFileSize - data.length;\n\t\t}\n\t\t\n\t\tnumErrorsInCurrentLog += record.getAction().getErrorIndicator();\n\t\t\n\t\toutput.write(data);\n\t\toutput.flush();\n\t}\n\t\n\tpublic synchronized void close() throws IOException {\n\t\toutput.close();\n\t}\n}",
        "start_line": 151,
        "end_line": 184,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 257,
        "node_type": null,
        "file_sha": "1d4a2d9eeba4d86b0215b33c85a01c18fb1dccab",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.081995"
      },
      "text": "public static synchronized void createInstance(File logFileBaseName, long maxTotalLogFileSpace, int maxSingleLogSize, ArrayList<SuiteData> suites) throws IOException {\n\t\tinstance = new ExecutionLog(logFileBaseName, maxTotalLogFileSpace, maxSingleLogSize, suites);\n\t}\n\n\tpublic static synchronized ExecutionLog instance() {\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Logs an ExecutionLog to the file.\n\t * @param record holds information about the test event to log.\n\t * @throws IOException if the write failed.\n\t */\n\tpublic synchronized void log(ExecutionRecord record) throws IOException {\n\t\tbyte[] data = record.convertToBytes(buffer, baseTimestamp);\n\t\t\n\t\t// Decide if the current log file has enough space for this record\n\t\tspaceLeftInCurrentLog -= data.length;\n\t\tif (spaceLeftInCurrentLog < 0) {\n\t\t\t// Log file is full, start another one\n\t\t\tcreateNewLoadTestDataFile();\n\t\t\tspaceLeftInCurrentLog = maxLogFileSize - data.length;\n\t\t}\n\t\t\n\t\tnumErrorsInCurrentLog += record.getAction().getErrorIndicator();\n\t\t\n\t\toutput.write(data);\n\t\toutput.flush();\n\t}\n\t\n\tpublic synchronized void close() throws IOException {\n\t\toutput.close();\n\t}\n}"
    },
    "398": {
      "metadata": {
        "chunk_id": "7900120a45129ab022a6763709f0c4f618dfda987607055f949ba280fbbd213d",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionLogManager.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\n\n/**\n * This class tracks the creation of binary trace logs for the load test application. \n * \n * It is told how many log files can be saved and deletes excess logs as they\n * build up.\n * This code attempts to retain the most useful log files, with a special emphasis\n * on keeping data on the first failure and, if possible, the test execution \n * until that point.\n */",
        "start_line": 0,
        "end_line": 31,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 243,
        "node_type": null,
        "file_sha": "11e80058c2ccc13864b8f6e6dee815711290a0f7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.105916"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\n\n/**\n * This class tracks the creation of binary trace logs for the load test application. \n * \n * It is told how many log files can be saved and deletes excess logs as they\n * build up.\n * This code attempts to retain the most useful log files, with a special emphasis\n * on keeping data on the first failure and, if possible, the test execution \n * until that point.\n */"
    },
    "399": {
      "metadata": {
        "chunk_id": "16e208ea1bac85ffdace9288b444227d2d25e5dade4effbe33e103ad8c58ddc6",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionLogManager.java",
        "content": "// For precedence 2 & 1, find out if we have logs leading up to the first failure \n\t\tint firstFailureWithPreceeding = -1;\n\t\tfor (int i=0; i<logData.size(); i++) {\n\t\t\tLogFileData log = logData.get(i);\n\t\t\tif (log == null) {\n\t\t\t\tbreak;\n\t\t\t} else if (log.numErrors > 0) {\n\t\t\t\tfirstFailureWithPreceeding = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Precedence 2 & 1.\n\t\t// First failure and the preceding logs are the most valuable\n\t\tif (firstFailureWithPreceeding >= 0) {\n\t\t\tfor (int i=0; i<firstFailureWithPreceeding; i++) {\n\t\t\t\tweightings[i] = WEIGHTING_LOGS_BEFORE_FIRST_FAILURE;\n\t\t\t}\n\t\t\tweightings[firstFailureWithPreceeding] = WEIGHTING_FIRST_FAILURE;\n\t\t}\n\n\t\t\n\t\t// Find the log with the lowest weighting\n\t\tint lowestWeighting = Integer.MAX_VALUE;\n\t\tint lowestIndex = 0;\n\t\tfor (int i=0; i<logData.size(); i++) {\n\t\t\tLogFileData log = logData.get(i); \n\t\t\tif (log != null && weightings[i] <= lowestWeighting) {\n\t\t\t\tlowestWeighting = weightings[i];\n\t\t\t\tlowestIndex = i;\n\t\t\t}\n\t\t}\n\n\t\treturn lowestIndex;\n\t}\n\n\t\n\t/*\n\t * Delete a log file.\n\t * This method deletes the binary log file and clears out our remaining reference to it.\n\t * @param logNum is the index of the log file to delete.\n\t */\n\tprivate void doEviction(int victimIndex) {\n\t\t// Delete log file\n\t\tLogFileData victim = logData.get(victimIndex);\n\t\tlogger.debug(\"Deleting log file: \" + victim.logFile.getAbsolutePath());\n\t\tvictim.logFile.delete();\n\t\t\n\t\t// Clear tracking data, so that it is not considered next time\n\t\tlogData.set(victimIndex, null);\n\t}\n\n\t\n\t/**\n\t * @return String representing currently held data. \n\t * Uses 1 character for each log file:\n\t *   ' ' No data for log. File has been deleted.\n\t *   '-' Log file has no errors.\n\t *   '*' Log file with at least 1 test failure.\n\t */\n\tpublic String toString() {\n\t\tStringBuilder buff = new StringBuilder();\n\t\t\n\t\tbuff.append(\"[\");\n\t\tfor (LogFileData log : logData) {\n\t\t\tif (log == null) {\n\t\t\t\tbuff.append(' ');\n\t\t\t} else if (log.numErrors == 0) {\n\t\t\t\tbuff.append('-');\n\t\t\t} else if (log.numErrors > 0) {\n\t\t\t\tbuff.append('X');\n\t\t\t}\n\t\t}\n\t\tbuff.append(\"]\");\n\t\t\n\t\treturn buff.toString();\n\t}\n}",
        "start_line": 32,
        "end_line": 109,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 607,
        "node_type": null,
        "file_sha": "11e80058c2ccc13864b8f6e6dee815711290a0f7",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.105925"
      },
      "text": "// For precedence 2 & 1, find out if we have logs leading up to the first failure \n\t\tint firstFailureWithPreceeding = -1;\n\t\tfor (int i=0; i<logData.size(); i++) {\n\t\t\tLogFileData log = logData.get(i);\n\t\t\tif (log == null) {\n\t\t\t\tbreak;\n\t\t\t} else if (log.numErrors > 0) {\n\t\t\t\tfirstFailureWithPreceeding = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Precedence 2 & 1.\n\t\t// First failure and the preceding logs are the most valuable\n\t\tif (firstFailureWithPreceeding >= 0) {\n\t\t\tfor (int i=0; i<firstFailureWithPreceeding; i++) {\n\t\t\t\tweightings[i] = WEIGHTING_LOGS_BEFORE_FIRST_FAILURE;\n\t\t\t}\n\t\t\tweightings[firstFailureWithPreceeding] = WEIGHTING_FIRST_FAILURE;\n\t\t}\n\n\t\t\n\t\t// Find the log with the lowest weighting\n\t\tint lowestWeighting = Integer.MAX_VALUE;\n\t\tint lowestIndex = 0;\n\t\tfor (int i=0; i<logData.size(); i++) {\n\t\t\tLogFileData log = logData.get(i); \n\t\t\tif (log != null && weightings[i] <= lowestWeighting) {\n\t\t\t\tlowestWeighting = weightings[i];\n\t\t\t\tlowestIndex = i;\n\t\t\t}\n\t\t}\n\n\t\treturn lowestIndex;\n\t}\n\n\t\n\t/*\n\t * Delete a log file.\n\t * This method deletes the binary log file and clears out our remaining reference to it.\n\t * @param logNum is the index of the log file to delete.\n\t */\n\tprivate void doEviction(int victimIndex) {\n\t\t// Delete log file\n\t\tLogFileData victim = logData.get(victimIndex);\n\t\tlogger.debug(\"Deleting log file: \" + victim.logFile.getAbsolutePath());\n\t\tvictim.logFile.delete();\n\t\t\n\t\t// Clear tracking data, so that it is not considered next time\n\t\tlogData.set(victimIndex, null);\n\t}\n\n\t\n\t/**\n\t * @return String representing currently held data. \n\t * Uses 1 character for each log file:\n\t *   ' ' No data for log. File has been deleted.\n\t *   '-' Log file has no errors.\n\t *   '*' Log file with at least 1 test failure.\n\t */\n\tpublic String toString() {\n\t\tStringBuilder buff = new StringBuilder();\n\t\t\n\t\tbuff.append(\"[\");\n\t\tfor (LogFileData log : logData) {\n\t\t\tif (log == null) {\n\t\t\t\tbuff.append(' ');\n\t\t\t} else if (log.numErrors == 0) {\n\t\t\t\tbuff.append('-');\n\t\t\t} else if (log.numErrors > 0) {\n\t\t\t\tbuff.append('X');\n\t\t\t}\n\t\t}\n\t\tbuff.append(\"]\");\n\t\t\n\t\treturn buff.toString();\n\t}\n}"
    },
    "400": {
      "metadata": {
        "chunk_id": "8e5432167132d97df2b36262496f5df94e3cc8d3c18cec01b19cf03607199532",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionRecord.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\n/**\n * This is a simple immutable class for holding key details about the \n * starting or completion of a single test.\n * \n * It also handles the conversion to and from a binary form.\n */",
        "start_line": 0,
        "end_line": 25,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 182,
        "node_type": null,
        "file_sha": "9563c3c645f4a76af2a8f3f59d59145ff59f6386",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.126621"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\n/**\n * This is a simple immutable class for holding key details about the \n * starting or completion of a single test.\n * \n * It also handles the conversion to and from a binary form.\n */"
    },
    "401": {
      "metadata": {
        "chunk_id": "0bedeb384697dd7a926cf7e1b70c48b13207637ba14608d232752c52c3fd6e4e",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionRecord.java",
        "content": "public class ExecutionRecord {\n\tpublic enum Action {\n\t\t//                  Code   Name       Failure  Show output\n\t\tSTARTED(            'S', \"Started\",    false,   false),\n\t\tPASSED(             'P', \"Passed\",     false,   false),\n\t\tTEST_RESULT_UNKNOWN('U', \"Completed\",  false,   false),\n\t\tBLOCKED_EXIT_PASS(  'Z', \"ExitPass\",   false,   false),  // Test called System.exit with zero exit value\n\t\tBLOCKED_EXIT_FAIL(  'E', \"*ExitFail*\", true,    true),\n\t\tFAILED(             'F', \"*Failed*\",   true,    true),\n\t\tFAILED_THROWABLE(   'T', \"*Failed*\",   true,    true);\n\t\t\n\t\tprivate char code;\n\t\tprivate String codeAsString;\n\t\tprivate String name;\n\t\tprivate boolean isFailure;\n\t\tprivate int errorIndicator;\n\t\tprivate boolean hasOutput;\n\t\t\n\t\tprivate Action(char code, String name, boolean isFailure, boolean hasOutput) { \n\t\t\tthis.code = code; \n\t\t\tthis.codeAsString = \"\" + code;\n\t\t\tthis.name = name;\n\t\t\tthis.isFailure = isFailure;\n\t\t\tthis.errorIndicator = isFailure ? 1 : 0;\n\t\t\tthis.hasOutput = hasOutput;\n\t\t}\n\t\t\n\t\tpublic String getName() { return name; }\n\t\tpublic boolean isFailure() { return isFailure; }\n\t\tpublic int getErrorIndicator() { return errorIndicator; }\n\t\tpublic boolean hasOutput() { return hasOutput; }\n\t\tpublic String toString() { return codeAsString; }\n\t};\n\n\t\n\t// Binary file structure for execution log is:\n\t//   1 byte holding the version number of the format. Starting at version 1. \n\t//   8 bytes holding a long with the start time of the run (milliseconds).\n\t// Then any number of 9 byte records each consisting off:\n\t//   4 bytes holding the time in milliseconds since the start of the run. Range 0-4,294,967,296 milli (approx 49 days)\n\t//   1 byte with the Action code. Started, Passed, etc.\n\t//   2 bytes holding the test id. 0 to 65,535\n\t//   2 bytes holding:\n\t//       Uppermost 3 bits holds the suite id. 0-7\n\t//       Lowermost 13 bits holding the thread id. 0-8,191\n\t// Records with the 'hasOutput' attribute also have the following after the 9 byte record:\n\t//   4 bytes with length of subsequent output.\n\t//   The byte output captured for the failing test\n\t// Byte offsets for these fields are:\n\tpublic static int SIZE_IN_BYTES = 9;\n\tprivate static int TIMESTAMP_1  = 0;\n\tprivate static int TIMESTAMP_2  = 1;\n\tprivate static int TIMESTAMP_3  = 2;\n\tprivate static int TIMESTAMP_4  = 3;\n\tprivate static int ACTION_CODE  = 4;\n\tprivate static int TEST_ID_1    = 5;\n\tprivate static int TEST_ID_2    = 6;\n\tprivate static int THREAD_ID_1  = 7;\n\tprivate static int THREAD_ID_2  = 8;\n\tprivate static int OUTPUT_LEN_1 = 9;\n\tprivate static int OUTPUT_LEN_2 = 10;\n\tprivate static int OUTPUT_LEN_3 = 11;\n\tprivate static int OUTPUT_LEN_4 = 12;\n\tprivate static int OUTPUT       = 13;\n\n\t\n\tprivate long timestamp;\n\t\n\tprivate Action action;\n\tprivate int threadNum;\n\tprivate int suiteNum;\n\tprivate int testNum;\n\tprivate String testName;\n\tprivate String threadName;\n\tprivate byte[] output;\n\n\n\tExecutionRecord(long timestamp, Action action, int threadNum, int suiteNum, int testNum, String testName, byte[] output) {\n\t\tthis.timestamp = timestamp;\n\n\t\tthis.action = action;\n\t\tthis.threadNum = threadNum;\n\t\tthis.suiteNum = suiteNum;\n\t\tthis.testNum = testNum;\n\t\tthis.testName = testName.intern();\n\t\tthis.threadName = Thread.currentThread().getName();\n\t\tthis.output = output;\n\t}\n\n\t\n\tpublic long getTimestamp() {\n\t\treturn timestamp;\n\t}\n\n\tpublic Action getAction() {\n\t\treturn action;\n\t}\n\n\tpublic int getSuiteId() {\n\t\treturn suiteNum;\n\t}\n\n\tpublic int getTestNum() {\n\t\treturn testNum;\n\t}\n\n\tpublic String getTestName() {\n\t\treturn testName;\n\t}\n\n\tpublic int getThreadNum() {\n\t\treturn threadNum;\n\t}\n\n\tpublic String getThreadName() {\n\t\treturn threadName;\n\t}\n\n\tpublic String getOutputAsString() {\n\t\treturn new String(output);\n\t}",
        "start_line": 26,
        "end_line": 146,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 977,
        "node_type": null,
        "file_sha": "9563c3c645f4a76af2a8f3f59d59145ff59f6386",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.126628"
      },
      "text": "public class ExecutionRecord {\n\tpublic enum Action {\n\t\t//                  Code   Name       Failure  Show output\n\t\tSTARTED(            'S', \"Started\",    false,   false),\n\t\tPASSED(             'P', \"Passed\",     false,   false),\n\t\tTEST_RESULT_UNKNOWN('U', \"Completed\",  false,   false),\n\t\tBLOCKED_EXIT_PASS(  'Z', \"ExitPass\",   false,   false),  // Test called System.exit with zero exit value\n\t\tBLOCKED_EXIT_FAIL(  'E', \"*ExitFail*\", true,    true),\n\t\tFAILED(             'F', \"*Failed*\",   true,    true),\n\t\tFAILED_THROWABLE(   'T', \"*Failed*\",   true,    true);\n\t\t\n\t\tprivate char code;\n\t\tprivate String codeAsString;\n\t\tprivate String name;\n\t\tprivate boolean isFailure;\n\t\tprivate int errorIndicator;\n\t\tprivate boolean hasOutput;\n\t\t\n\t\tprivate Action(char code, String name, boolean isFailure, boolean hasOutput) { \n\t\t\tthis.code = code; \n\t\t\tthis.codeAsString = \"\" + code;\n\t\t\tthis.name = name;\n\t\t\tthis.isFailure = isFailure;\n\t\t\tthis.errorIndicator = isFailure ? 1 : 0;\n\t\t\tthis.hasOutput = hasOutput;\n\t\t}\n\t\t\n\t\tpublic String getName() { return name; }\n\t\tpublic boolean isFailure() { return isFailure; }\n\t\tpublic int getErrorIndicator() { return errorIndicator; }\n\t\tpublic boolean hasOutput() { return hasOutput; }\n\t\tpublic String toString() { return codeAsString; }\n\t};\n\n\t\n\t// Binary file structure for execution log is:\n\t//   1 byte holding the version number of the format. Starting at version 1. \n\t//   8 bytes holding a long with the start time of the run (milliseconds).\n\t// Then any number of 9 byte records each consisting off:\n\t//   4 bytes holding the time in milliseconds since the start of the run. Range 0-4,294,967,296 milli (approx 49 days)\n\t//   1 byte with the Action code. Started, Passed, etc.\n\t//   2 bytes holding the test id. 0 to 65,535\n\t//   2 bytes holding:\n\t//       Uppermost 3 bits holds the suite id. 0-7\n\t//       Lowermost 13 bits holding the thread id. 0-8,191\n\t// Records with the 'hasOutput' attribute also have the following after the 9 byte record:\n\t//   4 bytes with length of subsequent output.\n\t//   The byte output captured for the failing test\n\t// Byte offsets for these fields are:\n\tpublic static int SIZE_IN_BYTES = 9;\n\tprivate static int TIMESTAMP_1  = 0;\n\tprivate static int TIMESTAMP_2  = 1;\n\tprivate static int TIMESTAMP_3  = 2;\n\tprivate static int TIMESTAMP_4  = 3;\n\tprivate static int ACTION_CODE  = 4;\n\tprivate static int TEST_ID_1    = 5;\n\tprivate static int TEST_ID_2    = 6;\n\tprivate static int THREAD_ID_1  = 7;\n\tprivate static int THREAD_ID_2  = 8;\n\tprivate static int OUTPUT_LEN_1 = 9;\n\tprivate static int OUTPUT_LEN_2 = 10;\n\tprivate static int OUTPUT_LEN_3 = 11;\n\tprivate static int OUTPUT_LEN_4 = 12;\n\tprivate static int OUTPUT       = 13;\n\n\t\n\tprivate long timestamp;\n\t\n\tprivate Action action;\n\tprivate int threadNum;\n\tprivate int suiteNum;\n\tprivate int testNum;\n\tprivate String testName;\n\tprivate String threadName;\n\tprivate byte[] output;\n\n\n\tExecutionRecord(long timestamp, Action action, int threadNum, int suiteNum, int testNum, String testName, byte[] output) {\n\t\tthis.timestamp = timestamp;\n\n\t\tthis.action = action;\n\t\tthis.threadNum = threadNum;\n\t\tthis.suiteNum = suiteNum;\n\t\tthis.testNum = testNum;\n\t\tthis.testName = testName.intern();\n\t\tthis.threadName = Thread.currentThread().getName();\n\t\tthis.output = output;\n\t}\n\n\t\n\tpublic long getTimestamp() {\n\t\treturn timestamp;\n\t}\n\n\tpublic Action getAction() {\n\t\treturn action;\n\t}\n\n\tpublic int getSuiteId() {\n\t\treturn suiteNum;\n\t}\n\n\tpublic int getTestNum() {\n\t\treturn testNum;\n\t}\n\n\tpublic String getTestName() {\n\t\treturn testName;\n\t}\n\n\tpublic int getThreadNum() {\n\t\treturn threadNum;\n\t}\n\n\tpublic String getThreadName() {\n\t\treturn threadName;\n\t}\n\n\tpublic String getOutputAsString() {\n\t\treturn new String(output);\n\t}"
    },
    "402": {
      "metadata": {
        "chunk_id": "b6b5a9e854051bb1069f106f4abf04d4912541ffa2438cec2ef9b23a1bf46d2c",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionRecord.java",
        "content": "// Extract the suite and thread numbers which are packed into the next 2 bytes\n\t    int suiteAndThreadNums = (((int) buffer[THREAD_ID_1] & 0xFF) << 8)\n\t    \t\t\t\t\t    | ((int) buffer[THREAD_ID_2] & 0xFF);\n\t    int suiteNum = (suiteAndThreadNums >> 13) & 0xFF;\n\t    int threadNum = (suiteAndThreadNums) & 0x1FFF;\n\n\t    // If test produced output read it in \n\t    byte[] output = null;\n\t    if (action.hasOutput) {\n\t    \t// Find out how long the output is\n\t    \tbyte[] bufferLen = new byte[4];\n\t    \tinput.read(bufferLen);\n\t    \tint outputLen = (int) ((bufferLen[0] & 0xFF) \n\t\t \t\t | ((bufferLen[1] & 0xFF) << 8) \n\t\t\t\t | ((bufferLen[2] & 0xFF) << 16) \n\t\t\t\t | (((long) bufferLen[3] & 0xFF) << 24));\n\t    \t\n\t    \t// Read the actual output data\n\t    \toutput = new byte[outputLen];\n\t    \tinput.read(output);\n\t    }\n\t\t\n\t    String testName = \"\";\t\n\t\treturn new ExecutionRecord(timestamp, action, threadNum, suiteNum, testNum, testName, output);\n\t}\n}",
        "start_line": 147,
        "end_line": 172,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 289,
        "node_type": null,
        "file_sha": "9563c3c645f4a76af2a8f3f59d59145ff59f6386",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.126631"
      },
      "text": "// Extract the suite and thread numbers which are packed into the next 2 bytes\n\t    int suiteAndThreadNums = (((int) buffer[THREAD_ID_1] & 0xFF) << 8)\n\t    \t\t\t\t\t    | ((int) buffer[THREAD_ID_2] & 0xFF);\n\t    int suiteNum = (suiteAndThreadNums >> 13) & 0xFF;\n\t    int threadNum = (suiteAndThreadNums) & 0x1FFF;\n\n\t    // If test produced output read it in \n\t    byte[] output = null;\n\t    if (action.hasOutput) {\n\t    \t// Find out how long the output is\n\t    \tbyte[] bufferLen = new byte[4];\n\t    \tinput.read(bufferLen);\n\t    \tint outputLen = (int) ((bufferLen[0] & 0xFF) \n\t\t \t\t | ((bufferLen[1] & 0xFF) << 8) \n\t\t\t\t | ((bufferLen[2] & 0xFF) << 16) \n\t\t\t\t | (((long) bufferLen[3] & 0xFF) << 24));\n\t    \t\n\t    \t// Read the actual output data\n\t    \toutput = new byte[outputLen];\n\t    \tinput.read(output);\n\t    }\n\t\t\n\t    String testName = \"\";\t\n\t\treturn new ExecutionRecord(timestamp, action, threadNum, suiteNum, testNum, testName, output);\n\t}\n}"
    },
    "403": {
      "metadata": {
        "chunk_id": "5c7c7115f02d58fa6661b76df20b5910360cbdc67fcc3fff7ffa775c35ac06b3",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionTracker.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport net.adoptopenjdk.loadTest.reporting.MauveTestFailureException;\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface.ResultStatus;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord.Action;\n\n\n/**\n * Utility class which records key information about the test running on the \n * current thread.\n * \n * This is a critical class for the load test application. It uses an \n * InheritableThreadLocal so that the information about the running test is \n * visible from all points within the test execution (eg, intercepting the\n * stdout/stderr output).\n * \n * It uses InheritableThreadLocal so that the same tracking object is visible\n * to any child threads that the test creates. \n * If the child thread detects a failure it updates the same tracking\n * object, so the failure is visible to LoadTestRunner when the test completes. \n */",
        "start_line": 0,
        "end_line": 38,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 340,
        "node_type": null,
        "file_sha": "e217c63d1de37ed80939feee85348edb83554c9c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.147145"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport net.adoptopenjdk.loadTest.reporting.MauveTestFailureException;\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface;\nimport net.adoptopenjdk.loadTest.adaptors.AdaptorInterface.ResultStatus;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord.Action;\n\n\n/**\n * Utility class which records key information about the test running on the \n * current thread.\n * \n * This is a critical class for the load test application. It uses an \n * InheritableThreadLocal so that the information about the running test is \n * visible from all points within the test execution (eg, intercepting the\n * stdout/stderr output).\n * \n * It uses InheritableThreadLocal so that the same tracking object is visible\n * to any child threads that the test creates. \n * If the child thread detects a failure it updates the same tracking\n * object, so the failure is visible to LoadTestRunner when the test completes. \n */"
    },
    "404": {
      "metadata": {
        "chunk_id": "2f3c1edfdad1a836a8e89b66431495dfaa56b6e678301df6330627b1ceb83f75",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionTracker.java",
        "content": "public class ExecutionTracker {\n\t// Information about the test which the thread is running\n\tprivate int threadNum = -1;\n\tprivate int suiteNum = -1;\n    private AdaptorInterface test = null;\n    \n    // Captures stdout/stderr output from the running test. Held in a stream as\n    // it accepts bytes and most output is never needed (most tests pass)\n    private ByteArrayOutputStream outputCapture;\n    \n\tprivate ResultStatus testResult;  // passed or failed\n\n\t// Table to convert test pass/fail status to an action enum\n\tprivate static Action resultToActionMapping[] = new Action[5];\n\tstatic {\n\t\tresultToActionMapping[ResultStatus.UNKNOWN.ordinal()]           = Action.TEST_RESULT_UNKNOWN;          \n\t\tresultToActionMapping[ResultStatus.PASS.ordinal()]              = Action.PASSED;             \n\t\tresultToActionMapping[ResultStatus.BLOCKED_EXIT_PASS.ordinal()] = Action.BLOCKED_EXIT_PASS;\n\t\tresultToActionMapping[ResultStatus.FAIL.ordinal()]              = Action.FAILED;             \n\t\tresultToActionMapping[ResultStatus.BLOCKED_EXIT_FAIL.ordinal()] = Action.BLOCKED_EXIT_FAIL;  \n\t};\n\n\t\n\tprivate static final InheritableThreadLocal<ExecutionTracker> tracker = new InheritableThreadLocal<ExecutionTracker>() {\n\t\tpublic ExecutionTracker initialValue() {\n\t\t\treturn new ExecutionTracker();\n\t\t}\n\t};\t\n\n\t// Private to force access through the instance method.\n\tprivate ExecutionTracker() {\n\t\tthis.outputCapture = new ByteArrayOutputStream(100000);\n\t}\n\t\n\t\n\t/**\n\t * @return the ExecutionTracker for the current thread.\n\t */\n\tpublic static ExecutionTracker instance() {\n\t\treturn tracker.get();\n\t}\n\t\n\t/**\n\t * Forces the creation of a new tracker object.\n\t * Needed when we want a child thread to have its own object.\n\t */\n\tpublic static void createNewTracker() {\n\t\ttracker.set(new ExecutionTracker());\n\t}\n\t\n\t\n\tpublic synchronized void checkTestOutput(byte[] buff, int off, int len) throws MauveTestFailureException {\n\t\t// Store this piece of output, incase the test fails and it's needed for debugging\n\t\toutputCapture.write(buff, off, len);\n\t\t\n\t\t// Get the adaptor to decide if this output indicates a pass or a failure\n\t\tResultStatus outputScanResult = test.checkTestOutput(buff, off, len);\n\t\t\n\t\t// Update result state\n\t\ttestResult = determineNewStatus(testResult, outputScanResult);\n\t\tif (!testResult.testPassed()) {\n\t\t\tthrow new MauveTestFailureException(\"Mauve test failure detected\"); \n\t\t}\n\t}\n\n\t\n\t// Work out what the actual test result is, by comparing the existing result with \n\t// a new observation. \n\t// This logic means that if a fail value is ever seen then the test is ultimately\n\t// recorded as a failure.\n\t// For example the sequence 'Pass, Pass, Fail, Pass' would result in a final verdict of 'Fail'.\n\tprivate ResultStatus determineNewStatus(ResultStatus existingResult, ResultStatus newResult) {\n\t\tif (newResult.ordinal() > existingResult.ordinal()) {\n\t\t\t// New observation takes precedence over existing result\n\t\t\treturn newResult;\n\t\t} else {\n\t\t\treturn existingResult;\n\t\t}\n\t}\n\n\n\tpublic synchronized boolean isRunningTest() { \n\t\treturn test != null;\n\t}\n\t\n\t\n\tpublic synchronized ByteArrayOutputStream getCapturedOutput() {\n\t\treturn outputCapture;\n\t}",
        "start_line": 39,
        "end_line": 127,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 707,
        "node_type": null,
        "file_sha": "e217c63d1de37ed80939feee85348edb83554c9c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.147153"
      },
      "text": "public class ExecutionTracker {\n\t// Information about the test which the thread is running\n\tprivate int threadNum = -1;\n\tprivate int suiteNum = -1;\n    private AdaptorInterface test = null;\n    \n    // Captures stdout/stderr output from the running test. Held in a stream as\n    // it accepts bytes and most output is never needed (most tests pass)\n    private ByteArrayOutputStream outputCapture;\n    \n\tprivate ResultStatus testResult;  // passed or failed\n\n\t// Table to convert test pass/fail status to an action enum\n\tprivate static Action resultToActionMapping[] = new Action[5];\n\tstatic {\n\t\tresultToActionMapping[ResultStatus.UNKNOWN.ordinal()]           = Action.TEST_RESULT_UNKNOWN;          \n\t\tresultToActionMapping[ResultStatus.PASS.ordinal()]              = Action.PASSED;             \n\t\tresultToActionMapping[ResultStatus.BLOCKED_EXIT_PASS.ordinal()] = Action.BLOCKED_EXIT_PASS;\n\t\tresultToActionMapping[ResultStatus.FAIL.ordinal()]              = Action.FAILED;             \n\t\tresultToActionMapping[ResultStatus.BLOCKED_EXIT_FAIL.ordinal()] = Action.BLOCKED_EXIT_FAIL;  \n\t};\n\n\t\n\tprivate static final InheritableThreadLocal<ExecutionTracker> tracker = new InheritableThreadLocal<ExecutionTracker>() {\n\t\tpublic ExecutionTracker initialValue() {\n\t\t\treturn new ExecutionTracker();\n\t\t}\n\t};\t\n\n\t// Private to force access through the instance method.\n\tprivate ExecutionTracker() {\n\t\tthis.outputCapture = new ByteArrayOutputStream(100000);\n\t}\n\t\n\t\n\t/**\n\t * @return the ExecutionTracker for the current thread.\n\t */\n\tpublic static ExecutionTracker instance() {\n\t\treturn tracker.get();\n\t}\n\t\n\t/**\n\t * Forces the creation of a new tracker object.\n\t * Needed when we want a child thread to have its own object.\n\t */\n\tpublic static void createNewTracker() {\n\t\ttracker.set(new ExecutionTracker());\n\t}\n\t\n\t\n\tpublic synchronized void checkTestOutput(byte[] buff, int off, int len) throws MauveTestFailureException {\n\t\t// Store this piece of output, incase the test fails and it's needed for debugging\n\t\toutputCapture.write(buff, off, len);\n\t\t\n\t\t// Get the adaptor to decide if this output indicates a pass or a failure\n\t\tResultStatus outputScanResult = test.checkTestOutput(buff, off, len);\n\t\t\n\t\t// Update result state\n\t\ttestResult = determineNewStatus(testResult, outputScanResult);\n\t\tif (!testResult.testPassed()) {\n\t\t\tthrow new MauveTestFailureException(\"Mauve test failure detected\"); \n\t\t}\n\t}\n\n\t\n\t// Work out what the actual test result is, by comparing the existing result with \n\t// a new observation. \n\t// This logic means that if a fail value is ever seen then the test is ultimately\n\t// recorded as a failure.\n\t// For example the sequence 'Pass, Pass, Fail, Pass' would result in a final verdict of 'Fail'.\n\tprivate ResultStatus determineNewStatus(ResultStatus existingResult, ResultStatus newResult) {\n\t\tif (newResult.ordinal() > existingResult.ordinal()) {\n\t\t\t// New observation takes precedence over existing result\n\t\t\treturn newResult;\n\t\t} else {\n\t\t\treturn existingResult;\n\t\t}\n\t}\n\n\n\tpublic synchronized boolean isRunningTest() { \n\t\treturn test != null;\n\t}\n\t\n\t\n\tpublic synchronized ByteArrayOutputStream getCapturedOutput() {\n\t\treturn outputCapture;\n\t}"
    },
    "405": {
      "metadata": {
        "chunk_id": "011460bef31d81b01f25a9eecf9d048a10628e9bbd91e18bcc70143387c719a3",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/ExecutionTracker.java",
        "content": "// Work out what the actual test result is, by comparing the existing result with \n\t// a new observation. \n\t// This logic means that if a fail value is ever seen then the test is ultimately\n\t// recorded as a failure.\n\t// For example the sequence 'Pass, Pass, Fail, Pass' would result in a final verdict of 'Fail'.\n\tprivate ResultStatus determineNewStatus(ResultStatus existingResult, ResultStatus newResult) {\n\t\tif (newResult.ordinal() > existingResult.ordinal()) {\n\t\t\t// New observation takes precedence over existing result\n\t\t\treturn newResult;\n\t\t} else {\n\t\t\treturn existingResult;\n\t\t}\n\t}\n\n\n\tpublic synchronized boolean isRunningTest() { \n\t\treturn test != null;\n\t}\n\t\n\t\n\tpublic synchronized ByteArrayOutputStream getCapturedOutput() {\n\t\treturn outputCapture;\n\t}\n\n\tpublic ResultStatus getFinalResult() {\n\t\treturn testResult;\n\t}\n\t\n\tpublic synchronized void recordTestStart(AdaptorInterface test, int suiteNum, int threadNum) throws IOException {\n\t\tthis.testResult = ResultStatus.UNKNOWN;\n\t\tthis.suiteNum = suiteNum;\n\t\tthis.threadNum = threadNum;\n\t\tthis.test = test;\n\t\tthis.outputCapture.reset();\n\t\t\n\t\tstoreTestActivity(Action.STARTED);\n\t}\n\t\n\tpublic synchronized boolean recordTestCompletion(ResultStatus overallResult) throws IOException {\n\t\ttestResult = determineNewStatus(testResult, overallResult);\n\t\t\n\t\t// Do a lookup to find the Action code that should be stored for this result.\n\t\t// This code is on the critical path so lookup much preferred over if statements.\n\t\tAction completionAction = resultToActionMapping[testResult.ordinal()];\n\t\t\n\t\tstoreTestActivity(completionAction);\n\t\t\n\t\treturn testResult.testPassed();\n\t}\n\t\n\tpublic synchronized void recordTestFailure() throws IOException {\n\t\tstoreTestActivity(Action.FAILED);\n\t}\n\n\tpublic synchronized void recordTestFailure(Throwable t) throws IOException {\n\t\tSystem.err.println(\"Test failed:\");\n\t\tt.printStackTrace();\n\t\tstoreTestActivity(Action.FAILED_THROWABLE);\n\t}\n\n\n\t// Writes information about what has just happened to a binary log file.\n\tprivate void storeTestActivity(Action action) throws IOException {\n\t\tlong timestamp = System.currentTimeMillis();\n\t\tExecutionRecord startRecord = new ExecutionRecord(timestamp, action, threadNum, suiteNum, test.getTestNum(), \"\", outputCapture.toByteArray());\n\t\tExecutionLog.instance().log(startRecord);\n\t}\n}",
        "start_line": 128,
        "end_line": 195,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 490,
        "node_type": null,
        "file_sha": "e217c63d1de37ed80939feee85348edb83554c9c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.147156"
      },
      "text": "// Work out what the actual test result is, by comparing the existing result with \n\t// a new observation. \n\t// This logic means that if a fail value is ever seen then the test is ultimately\n\t// recorded as a failure.\n\t// For example the sequence 'Pass, Pass, Fail, Pass' would result in a final verdict of 'Fail'.\n\tprivate ResultStatus determineNewStatus(ResultStatus existingResult, ResultStatus newResult) {\n\t\tif (newResult.ordinal() > existingResult.ordinal()) {\n\t\t\t// New observation takes precedence over existing result\n\t\t\treturn newResult;\n\t\t} else {\n\t\t\treturn existingResult;\n\t\t}\n\t}\n\n\n\tpublic synchronized boolean isRunningTest() { \n\t\treturn test != null;\n\t}\n\t\n\t\n\tpublic synchronized ByteArrayOutputStream getCapturedOutput() {\n\t\treturn outputCapture;\n\t}\n\n\tpublic ResultStatus getFinalResult() {\n\t\treturn testResult;\n\t}\n\t\n\tpublic synchronized void recordTestStart(AdaptorInterface test, int suiteNum, int threadNum) throws IOException {\n\t\tthis.testResult = ResultStatus.UNKNOWN;\n\t\tthis.suiteNum = suiteNum;\n\t\tthis.threadNum = threadNum;\n\t\tthis.test = test;\n\t\tthis.outputCapture.reset();\n\t\t\n\t\tstoreTestActivity(Action.STARTED);\n\t}\n\t\n\tpublic synchronized boolean recordTestCompletion(ResultStatus overallResult) throws IOException {\n\t\ttestResult = determineNewStatus(testResult, overallResult);\n\t\t\n\t\t// Do a lookup to find the Action code that should be stored for this result.\n\t\t// This code is on the critical path so lookup much preferred over if statements.\n\t\tAction completionAction = resultToActionMapping[testResult.ordinal()];\n\t\t\n\t\tstoreTestActivity(completionAction);\n\t\t\n\t\treturn testResult.testPassed();\n\t}\n\t\n\tpublic synchronized void recordTestFailure() throws IOException {\n\t\tstoreTestActivity(Action.FAILED);\n\t}\n\n\tpublic synchronized void recordTestFailure(Throwable t) throws IOException {\n\t\tSystem.err.println(\"Test failed:\");\n\t\tt.printStackTrace();\n\t\tstoreTestActivity(Action.FAILED_THROWABLE);\n\t}\n\n\n\t// Writes information about what has just happened to a binary log file.\n\tprivate void storeTestActivity(Action action) throws IOException {\n\t\tlong timestamp = System.currentTimeMillis();\n\t\tExecutionRecord startRecord = new ExecutionRecord(timestamp, action, threadNum, suiteNum, test.getTestNum(), \"\", outputCapture.toByteArray());\n\t\tExecutionLog.instance().log(startRecord);\n\t}\n}"
    },
    "406": {
      "metadata": {
        "chunk_id": "a7eaa2b3bbcf2b09406a64b6dcbbd52295ae42d9d9343c91b5412ec7f671f9cf",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/MauveTestFailureException.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\npublic class MauveTestFailureException extends Exception {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tpublic MauveTestFailureException(String errMessage) {\n\t\tsuper(errMessage);\n\t}\n}",
        "start_line": 0,
        "end_line": 23,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 175,
        "node_type": null,
        "file_sha": "2b6e430e540e0a9b6ca5fe9b6edd9b640a1e787d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.167475"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\npublic class MauveTestFailureException extends Exception {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tpublic MauveTestFailureException(String errMessage) {\n\t\tsuper(errMessage);\n\t}\n}"
    },
    "407": {
      "metadata": {
        "chunk_id": "66129982b4b249cfdae523e3a1b21ba2eed85e8396b69422f0a66dddca6649d8",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTest/reporting/OutputFilter.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.PrintStream;\n\n\n/**\n * This class examines the output which would normally be written to stdout and stderr.\n * \n * The principle reasons for intercepting the output are:\n *   1) Tests such as Mauve write output with magic 'Pass:' and 'Fail:' lines. These\n *      need to be examined to tell if the test has passed or failed.\n *   2) Allows the output from a single test to be captured (rather than intermingled \n *      with the output from many other concurrent threads).\n *   3) Some tests simply produce too much output to be realistically held (eg, Mauve).\n *      Logging all output can also have a significant performance impact. \n */\npublic class OutputFilter extends PrintStream {\n\tprivate boolean echoToOriginal;\n\n\t/**\n\t * Create a new stream object to intercept output.\n\t * \n\t * @param originalStream is the stream to examine. Either stdout or stderr.\n\t * @param echoToOriginal if set to true then the output is passed to the original stream.\n\t */\n\tpublic OutputFilter(PrintStream originalStream, boolean echoToOriginal) {\n\t\tsuper(originalStream);\n\t\tthis.echoToOriginal = echoToOriginal;\n\t}\n\n\t\n\t/**\n\t * The stream has been told to write out some data.\n\t * Allow the test to examine the output. \n\t * Note: Time critical method, as caller synchronises all output.\n\t */\n\tpublic void write(byte buf[], int off, int len) {\n\t\t// Find out what the load test has told this thread to do\n\t\tExecutionTracker executionTracker = ExecutionTracker.instance();\n\n\t\tif (executionTracker.isRunningTest()) {\n\t\t\ttry {\n\t\t\t\t// Allow the test adaptor to examine the output, and decide if test is passing/failing\n\t\t\t\texecutionTracker.checkTestOutput(buf, off, len);\n\t\t\t} catch (MauveTestFailureException e) {}\n\n\t\t\tif (echoToOriginal) {\n\t\t\t\t// Write to the original stdout/stderr\n\t\t\t\tsuper.write(buf, off, len);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// Thread is not running a test. Write the output to stdout/stderr\n\t\t\tsuper.write(buf, off, len);  \n\t\t}\n\t}\n\n\t// To help debug this class, the specified string is written to the output\n\t@SuppressWarnings(\"unused\")\n\tprivate void debug(String debugStr) {\n\t\tbyte[] bytes = debugStr.getBytes();\n\t\tsuper.write(bytes, 0, bytes.length);  // write to stdout/stderr\n\t}\n\n\tpublic void flush() {\n\t\tsuper.flush();\n\t}\n}",
        "start_line": 0,
        "end_line": 81,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 669,
        "node_type": null,
        "file_sha": "ce1e741500dcc9ccf6ec640e01f426db38b3ad4a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.190964"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport java.io.PrintStream;\n\n\n/**\n * This class examines the output which would normally be written to stdout and stderr.\n * \n * The principle reasons for intercepting the output are:\n *   1) Tests such as Mauve write output with magic 'Pass:' and 'Fail:' lines. These\n *      need to be examined to tell if the test has passed or failed.\n *   2) Allows the output from a single test to be captured (rather than intermingled \n *      with the output from many other concurrent threads).\n *   3) Some tests simply produce too much output to be realistically held (eg, Mauve).\n *      Logging all output can also have a significant performance impact. \n */\npublic class OutputFilter extends PrintStream {\n\tprivate boolean echoToOriginal;\n\n\t/**\n\t * Create a new stream object to intercept output.\n\t * \n\t * @param originalStream is the stream to examine. Either stdout or stderr.\n\t * @param echoToOriginal if set to true then the output is passed to the original stream.\n\t */\n\tpublic OutputFilter(PrintStream originalStream, boolean echoToOriginal) {\n\t\tsuper(originalStream);\n\t\tthis.echoToOriginal = echoToOriginal;\n\t}\n\n\t\n\t/**\n\t * The stream has been told to write out some data.\n\t * Allow the test to examine the output. \n\t * Note: Time critical method, as caller synchronises all output.\n\t */\n\tpublic void write(byte buf[], int off, int len) {\n\t\t// Find out what the load test has told this thread to do\n\t\tExecutionTracker executionTracker = ExecutionTracker.instance();\n\n\t\tif (executionTracker.isRunningTest()) {\n\t\t\ttry {\n\t\t\t\t// Allow the test adaptor to examine the output, and decide if test is passing/failing\n\t\t\t\texecutionTracker.checkTestOutput(buf, off, len);\n\t\t\t} catch (MauveTestFailureException e) {}\n\n\t\t\tif (echoToOriginal) {\n\t\t\t\t// Write to the original stdout/stderr\n\t\t\t\tsuper.write(buf, off, len);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// Thread is not running a test. Write the output to stdout/stderr\n\t\t\tsuper.write(buf, off, len);  \n\t\t}\n\t}\n\n\t// To help debug this class, the specified string is written to the output\n\t@SuppressWarnings(\"unused\")\n\tprivate void debug(String debugStr) {\n\t\tbyte[] bytes = debugStr.getBytes();\n\t\tsuper.write(bytes, 0, bytes.length);  // write to stdout/stderr\n\t}\n\n\tpublic void flush() {\n\t\tsuper.flush();\n\t}\n}"
    },
    "408": {
      "metadata": {
        "chunk_id": "a3530474018fff647b2f47b40d7fbf2acf89b6d93ed1a636b4cbb1988390a716",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/ExecutionLogMetaData.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.io.BufferedInputStream;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.TimeZone;\n\n\n/**\n * This class reads and holds the metadata from a load test execution log.\n * It reads the .ltm file and then makes the metadata available to output formatters.\n */",
        "start_line": 0,
        "end_line": 29,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 211,
        "node_type": null,
        "file_sha": "14fae866751430cd2d26707eb2c7e2c3f16398a3",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.216817"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.io.BufferedInputStream;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.TimeZone;\n\n\n/**\n * This class reads and holds the metadata from a load test execution log.\n * It reads the .ltm file and then makes the metadata available to output formatters.\n */"
    },
    "409": {
      "metadata": {
        "chunk_id": "c17a18ad28ded3bf2a4d7a6c78af52ad052629ba2e8831114b59010bd6d41ec9",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/ExecutionLogMetaData.java",
        "content": "public class ExecutionLogMetaData {\n\tprivate int version;\n\t\n\tprivate long baseTimestamp;\n\tprivate String timeZoneId;\n\n\t// To hold data about each suite\n\tprivate class SuiteData {\n\t\tint numberThreads;\n\t\tString inventoryFileName;\n\t\tint numberTests;\n\t\tArrayList<TestData> tests;\n\t}\n\tprivate ArrayList<SuiteData> suites = new ArrayList<SuiteData>();\n\t\n\t// To hold details about tests\n\tprivate class TestData {\n\t\tint testNumber;\n\t\tString className;\n\t\tString methodName;\n\t}\n\tprivate TestData[] tests;\n\t\n\t\n\tpublic ExecutionLogMetaData(String baseNameExecutionLog) throws IOException {\n\t\tFile executionMetaDataFile = new File(baseNameExecutionLog + \".ltm\");\n\t\t\n\t\tif (!executionMetaDataFile.exists()) { \n\t\t\tthrow new IllegalStateException(\"Execution log meta data does not exist: \" + executionMetaDataFile);\n\t\t}\n\t\t\n\t\tDataInputStream metaDataInput = new DataInputStream(new BufferedInputStream(new FileInputStream(executionMetaDataFile)));\n\t\t\n\t\ttry {\n\t\t\tthis.version = metaDataInput.readByte();\n\t\t\tif (version == -1) { \n\t\t\t\tthrow new IllegalStateException(\"Execution log file is empty\");\n\t\t\t} else if (version != 4) { \n\t\t\t\tthrow new IllegalStateException(\"Unsupported metadata version number: \" + version);\n\t\t\t}\n\t\t\t\n\t\t    // Read the next 8 bytes which contain the timestamp that the load test was started.\n\t\t\tthis.baseTimestamp = metaDataInput.readLong();\n\n\t\t\t// Read string containing the time zone that the test ran in\n\t\t\tthis.timeZoneId = metaDataInput.readUTF();\n\t\t\t\n\t\t\t// Read suite data\n\t\t\tint biggestTestNumber = 0;\n\t\t\tint numSuites = metaDataInput.readInt();\n\t\t\tfor (int s=0; s<numSuites; s++) {\n\t\t\t\tSuiteData suite = new SuiteData();\n\t\t\t\tsuite.numberThreads     = metaDataInput.readInt();\n\t\t\t\tsuite.inventoryFileName = metaDataInput.readUTF();\n\t\t\t\tsuite.numberTests       = metaDataInput.readInt();\n\t\t\t\tsuites.add(suite);\n\n\t\t\t\t// Read information about all tests for current suite\n\t\t\t\tsuite.tests = new ArrayList<TestData>();\n\t\t\t\tfor (int i=0; i<suite.numberTests; i++) {\n\t\t\t\t\tTestData test = new TestData();\n\t\t\t\t\ttest.testNumber = metaDataInput.readInt();\n\t\t\t\t\ttest.className  = metaDataInput.readUTF();\n\t\t\t\t\ttest.methodName = metaDataInput.readUTF();\n\t\t\t\t\tsuite.tests.add(test);\n\t\t\t\t\tbiggestTestNumber = Math.max(biggestTestNumber, test.testNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Chuck all tests from the suites into an array\n\t\t\tthis.tests = new TestData[biggestTestNumber+1];\n\t\t\tfor (SuiteData suite : suites) {\n\t\t\t\tfor (TestData test : suite.tests) {\n\t\t\t\t\tthis.tests[test.testNumber] = test;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tmetaDataInput.close();\n\t\t}\n\t}\n\n\t/**\n\t * @return a new DateFormatter set to the timezone that was used when the test ran.\n\t */\n\tpublic SimpleDateFormat getFormatter() {\n\t\tSimpleDateFormat formatter = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n\t\tformatter.setTimeZone(TimeZone.getTimeZone(timeZoneId));\n\t\treturn formatter;\n\t}\n\n\tpublic long getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic long getBaseTimestamp() {\n\t\treturn baseTimestamp;\n\t}\n\n\tpublic String getTimeZoneId() {\n\t\treturn timeZoneId;\n\t}\n\n\tpublic int getNumberSuites() {\n\t\treturn suites.size();\n\t}\n\n\tpublic int getTotalNumberThreads() {\n\t\tint numThreads = 0;\n\t\tfor (SuiteData suite : suites) {\n\t\t\tnumThreads += suite.numberThreads;\n\t\t}\n\t\treturn numThreads;\n\t}\n\t\n\tpublic int getTotalNumberTests() {\n\t\treturn tests.length;\n\t}\n\t\n\tpublic int getSuiteNumThreads(int suiteNum) {\n\t\treturn suites.get(suiteNum).numberThreads;\n\t}\n\t\n\tpublic String getSuiteInventoryName(int suiteNum) {\n\t\treturn suites.get(suiteNum).inventoryFileName;\n\t}\n\t\n\tpublic int getSuiteNumTests(int suiteNum) {\n\t\treturn suites.get(suiteNum).numberTests;\n\t}\n\n\tpublic String getTestClassName(int testNum) {\n\t\tif (tests[testNum] == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn tests[testNum].className;\n\t}\n\n\tpublic String getTestMethodName(int testNum) {\n\t\tif (tests[testNum] == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn tests[testNum].methodName;\n\t}\n}",
        "start_line": 30,
        "end_line": 173,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 907,
        "node_type": null,
        "file_sha": "14fae866751430cd2d26707eb2c7e2c3f16398a3",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.216825"
      },
      "text": "public class ExecutionLogMetaData {\n\tprivate int version;\n\t\n\tprivate long baseTimestamp;\n\tprivate String timeZoneId;\n\n\t// To hold data about each suite\n\tprivate class SuiteData {\n\t\tint numberThreads;\n\t\tString inventoryFileName;\n\t\tint numberTests;\n\t\tArrayList<TestData> tests;\n\t}\n\tprivate ArrayList<SuiteData> suites = new ArrayList<SuiteData>();\n\t\n\t// To hold details about tests\n\tprivate class TestData {\n\t\tint testNumber;\n\t\tString className;\n\t\tString methodName;\n\t}\n\tprivate TestData[] tests;\n\t\n\t\n\tpublic ExecutionLogMetaData(String baseNameExecutionLog) throws IOException {\n\t\tFile executionMetaDataFile = new File(baseNameExecutionLog + \".ltm\");\n\t\t\n\t\tif (!executionMetaDataFile.exists()) { \n\t\t\tthrow new IllegalStateException(\"Execution log meta data does not exist: \" + executionMetaDataFile);\n\t\t}\n\t\t\n\t\tDataInputStream metaDataInput = new DataInputStream(new BufferedInputStream(new FileInputStream(executionMetaDataFile)));\n\t\t\n\t\ttry {\n\t\t\tthis.version = metaDataInput.readByte();\n\t\t\tif (version == -1) { \n\t\t\t\tthrow new IllegalStateException(\"Execution log file is empty\");\n\t\t\t} else if (version != 4) { \n\t\t\t\tthrow new IllegalStateException(\"Unsupported metadata version number: \" + version);\n\t\t\t}\n\t\t\t\n\t\t    // Read the next 8 bytes which contain the timestamp that the load test was started.\n\t\t\tthis.baseTimestamp = metaDataInput.readLong();\n\n\t\t\t// Read string containing the time zone that the test ran in\n\t\t\tthis.timeZoneId = metaDataInput.readUTF();\n\t\t\t\n\t\t\t// Read suite data\n\t\t\tint biggestTestNumber = 0;\n\t\t\tint numSuites = metaDataInput.readInt();\n\t\t\tfor (int s=0; s<numSuites; s++) {\n\t\t\t\tSuiteData suite = new SuiteData();\n\t\t\t\tsuite.numberThreads     = metaDataInput.readInt();\n\t\t\t\tsuite.inventoryFileName = metaDataInput.readUTF();\n\t\t\t\tsuite.numberTests       = metaDataInput.readInt();\n\t\t\t\tsuites.add(suite);\n\n\t\t\t\t// Read information about all tests for current suite\n\t\t\t\tsuite.tests = new ArrayList<TestData>();\n\t\t\t\tfor (int i=0; i<suite.numberTests; i++) {\n\t\t\t\t\tTestData test = new TestData();\n\t\t\t\t\ttest.testNumber = metaDataInput.readInt();\n\t\t\t\t\ttest.className  = metaDataInput.readUTF();\n\t\t\t\t\ttest.methodName = metaDataInput.readUTF();\n\t\t\t\t\tsuite.tests.add(test);\n\t\t\t\t\tbiggestTestNumber = Math.max(biggestTestNumber, test.testNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Chuck all tests from the suites into an array\n\t\t\tthis.tests = new TestData[biggestTestNumber+1];\n\t\t\tfor (SuiteData suite : suites) {\n\t\t\t\tfor (TestData test : suite.tests) {\n\t\t\t\t\tthis.tests[test.testNumber] = test;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tmetaDataInput.close();\n\t\t}\n\t}\n\n\t/**\n\t * @return a new DateFormatter set to the timezone that was used when the test ran.\n\t */\n\tpublic SimpleDateFormat getFormatter() {\n\t\tSimpleDateFormat formatter = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n\t\tformatter.setTimeZone(TimeZone.getTimeZone(timeZoneId));\n\t\treturn formatter;\n\t}\n\n\tpublic long getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic long getBaseTimestamp() {\n\t\treturn baseTimestamp;\n\t}\n\n\tpublic String getTimeZoneId() {\n\t\treturn timeZoneId;\n\t}\n\n\tpublic int getNumberSuites() {\n\t\treturn suites.size();\n\t}\n\n\tpublic int getTotalNumberThreads() {\n\t\tint numThreads = 0;\n\t\tfor (SuiteData suite : suites) {\n\t\t\tnumThreads += suite.numberThreads;\n\t\t}\n\t\treturn numThreads;\n\t}\n\t\n\tpublic int getTotalNumberTests() {\n\t\treturn tests.length;\n\t}\n\t\n\tpublic int getSuiteNumThreads(int suiteNum) {\n\t\treturn suites.get(suiteNum).numberThreads;\n\t}\n\t\n\tpublic String getSuiteInventoryName(int suiteNum) {\n\t\treturn suites.get(suiteNum).inventoryFileName;\n\t}\n\t\n\tpublic int getSuiteNumTests(int suiteNum) {\n\t\treturn suites.get(suiteNum).numberTests;\n\t}\n\n\tpublic String getTestClassName(int testNum) {\n\t\tif (tests[testNum] == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn tests[testNum].className;\n\t}\n\n\tpublic String getTestMethodName(int testNum) {\n\t\tif (tests[testNum] == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn tests[testNum].methodName;\n\t}\n}"
    },
    "410": {
      "metadata": {
        "chunk_id": "5e696ce2a591e04b650ea140671f492eef4f14b9f32ad129a9224282beab521b",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/FormatExecutionLog.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.DetailFormatter;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.FailureFormatter;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.FormatterInterface;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.MetaDataFormatter;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.SummaryFormatter;\n\n\n/**\n * This class provides a human readable dump of the load test execution logs.\n * \n * It reads the test start time from the .ltm (load test metadata) file.\n * Depending on the command line arguments it produces different type of dump/analysis of the data. \n */",
        "start_line": 0,
        "end_line": 37,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 309,
        "node_type": null,
        "file_sha": "141559557ba401198a2cb33b22233d27cc49e7cb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.239388"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.DetailFormatter;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.FailureFormatter;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.FormatterInterface;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.MetaDataFormatter;\nimport net.adoptopenjdk.loadTestAnalysis.formatter.SummaryFormatter;\n\n\n/**\n * This class provides a human readable dump of the load test execution logs.\n * \n * It reads the test start time from the .ltm (load test metadata) file.\n * Depending on the command line arguments it produces different type of dump/analysis of the data. \n */"
    },
    "411": {
      "metadata": {
        "chunk_id": "d15a52f9814f6becc67d8a1ccc9ba041c4bd5008d761fcca4d03c87382db6022",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/FormatExecutionLog.java",
        "content": "public class FormatExecutionLog {\n    // Command line arguments control the output mode to use\n\tprivate enum OutputMode {\n\t\tMODE_DETAIL,\t// Dumps every start + stop log file entry\n\t\tMODE_FAILURES,  // Lists test failures\n\t\tMODE_SUMMARY,   // Produces stats on number of tests ran, passed, etc.\n\t\tMODE_METADATA,  // Dump metadata from .ltm file\n\t};\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tArrayList<OutputMode> specifiedModes = new ArrayList<OutputMode>();\n\t\tboolean verbose = false;\n\t\tString executionLog = null;\n\t\t\n\t\tint i = 0;\n\t\twhile (i < args.length) {\n\t\t\tString argName = args[i++];\n\t\t\t\n\t\t\tif (argName.equals(\"--detail\") || argName.equals(\"-d\")) {\n\t\t\t\tspecifiedModes.add(OutputMode.MODE_DETAIL);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"--summary\") || argName.equals(\"-s\")) {\n\t\t\t\tspecifiedModes.add(OutputMode.MODE_SUMMARY);\n\t\t\t\t\t\n\t\t\t} else if (argName.equals(\"--failures\") || argName.equals(\"-f\")) {\n\t\t\t\tspecifiedModes.add(OutputMode.MODE_FAILURES);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"--metadata\") || argName.equals(\"-m\")) {\n\t\t\t\tspecifiedModes.add(OutputMode.MODE_METADATA);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"--verbose\") || argName.equals(\"-v\")) {\n\t\t\t\tverbose = true;\n\n\t\t\t} else if (i == args.length) {\n\t\t\t\texecutionLog = argName;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tusage(\"Unknown argument '\" + argName + \"' \" + i + \" \" + args.length);\n\t\t\t\tSystem.exit(2);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t// Validate the mode\n\t\tif (specifiedModes.isEmpty()) {\n\t\t\tusage(\"No mode argument supplied.\");\n\t\t\tSystem.exit(2);\n\t\t} else if (specifiedModes.size() > 1) {\n\t\t\tusage(\"Only 1 mode argument can be supplied.\");\n\t\t\tSystem.exit(2);\n\t\t}\n\t\tOutputMode mode = specifiedModes.get(0);\n\t\t\n\t\t// Validate execution log name\n\t\tif (executionLog == null) {\n\t\t\tusage(\"Load test execution log file must be specified.\");\n\t\t\tSystem.exit(2);\n\t\t}\n\t\tif (executionLog.endsWith(\".ltm\") || executionLog.endsWith(\".ltd\")) {\n\t\t\t// Remove the extension, so that we can keep running\n\t\t\texecutionLog = executionLog.substring(0, executionLog.length()-4);\n\t\t\tSystem.out.println(\"Truncating log name to: \" + executionLog);\n\t\t}\n\n\t\t// Finally output some of the ltm/ltd file content\n\t\tFormatterInterface formatter = createFormatter(mode);\n\t\tnew FormatExecutionLog().dump(formatter, verbose, executionLog);\n\t}\n\n\n\tprivate static FormatterInterface createFormatter(OutputMode mode) {\n\t\tif (mode == OutputMode.MODE_DETAIL) {\n\t\t\treturn new DetailFormatter();\n\t\t} else if (mode == OutputMode.MODE_FAILURES) {\n\t\t\treturn new FailureFormatter();\n\t\t} else if (mode == OutputMode.MODE_SUMMARY) {\n\t\t\treturn new SummaryFormatter();\n\t\t} else if (mode == OutputMode.MODE_METADATA) {\n\t\t\treturn new MetaDataFormatter();\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Failed to create formatter for mode: \" + mode);\n\t\t}\t\t\n\t}\n\n\n\tprivate static void usage(String errorMessage) {\n\t\tSystem.out.println(\"FormatExecutionLog failed to parse arguments.\");\n\t\tSystem.out.println(\"Error: \" + errorMessage);\n\t\tSystem.out.println(\"Usage: FormatExecutionLog --summary -s --chart -c <execution-log>\");\n\t\tSystem.out.println(\"Where:\");\n\t\tSystem.out.println(\"  --detail, -d   Lists detailed test stop/start data.\");\n\t\tSystem.out.println(\"  --summary, -s  Produce summary information about the log file.\");\n\t\tSystem.out.println(\"  --failures, -f List test failures.\");\n\t\tSystem.out.println(\"  --metadata, -m Dumps metadata from the .ltm file.\");\n\t\tSystem.out.println(\"  --verbose, -v  Lists extra details when available.\");\n\t\tSystem.out.println(\"  <execution-log>  Points to a load test execution log.\");\n\t\tSystem.out.println(\"                   For example, '/stf/SampleLoadTest/results/1.LT.executionlog'\");\n\t}",
        "start_line": 38,
        "end_line": 136,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 910,
        "node_type": null,
        "file_sha": "141559557ba401198a2cb33b22233d27cc49e7cb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.239397"
      },
      "text": "public class FormatExecutionLog {\n    // Command line arguments control the output mode to use\n\tprivate enum OutputMode {\n\t\tMODE_DETAIL,\t// Dumps every start + stop log file entry\n\t\tMODE_FAILURES,  // Lists test failures\n\t\tMODE_SUMMARY,   // Produces stats on number of tests ran, passed, etc.\n\t\tMODE_METADATA,  // Dump metadata from .ltm file\n\t};\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tArrayList<OutputMode> specifiedModes = new ArrayList<OutputMode>();\n\t\tboolean verbose = false;\n\t\tString executionLog = null;\n\t\t\n\t\tint i = 0;\n\t\twhile (i < args.length) {\n\t\t\tString argName = args[i++];\n\t\t\t\n\t\t\tif (argName.equals(\"--detail\") || argName.equals(\"-d\")) {\n\t\t\t\tspecifiedModes.add(OutputMode.MODE_DETAIL);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"--summary\") || argName.equals(\"-s\")) {\n\t\t\t\tspecifiedModes.add(OutputMode.MODE_SUMMARY);\n\t\t\t\t\t\n\t\t\t} else if (argName.equals(\"--failures\") || argName.equals(\"-f\")) {\n\t\t\t\tspecifiedModes.add(OutputMode.MODE_FAILURES);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"--metadata\") || argName.equals(\"-m\")) {\n\t\t\t\tspecifiedModes.add(OutputMode.MODE_METADATA);\n\t\t\t\t\n\t\t\t} else if (argName.equals(\"--verbose\") || argName.equals(\"-v\")) {\n\t\t\t\tverbose = true;\n\n\t\t\t} else if (i == args.length) {\n\t\t\t\texecutionLog = argName;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tusage(\"Unknown argument '\" + argName + \"' \" + i + \" \" + args.length);\n\t\t\t\tSystem.exit(2);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t// Validate the mode\n\t\tif (specifiedModes.isEmpty()) {\n\t\t\tusage(\"No mode argument supplied.\");\n\t\t\tSystem.exit(2);\n\t\t} else if (specifiedModes.size() > 1) {\n\t\t\tusage(\"Only 1 mode argument can be supplied.\");\n\t\t\tSystem.exit(2);\n\t\t}\n\t\tOutputMode mode = specifiedModes.get(0);\n\t\t\n\t\t// Validate execution log name\n\t\tif (executionLog == null) {\n\t\t\tusage(\"Load test execution log file must be specified.\");\n\t\t\tSystem.exit(2);\n\t\t}\n\t\tif (executionLog.endsWith(\".ltm\") || executionLog.endsWith(\".ltd\")) {\n\t\t\t// Remove the extension, so that we can keep running\n\t\t\texecutionLog = executionLog.substring(0, executionLog.length()-4);\n\t\t\tSystem.out.println(\"Truncating log name to: \" + executionLog);\n\t\t}\n\n\t\t// Finally output some of the ltm/ltd file content\n\t\tFormatterInterface formatter = createFormatter(mode);\n\t\tnew FormatExecutionLog().dump(formatter, verbose, executionLog);\n\t}\n\n\n\tprivate static FormatterInterface createFormatter(OutputMode mode) {\n\t\tif (mode == OutputMode.MODE_DETAIL) {\n\t\t\treturn new DetailFormatter();\n\t\t} else if (mode == OutputMode.MODE_FAILURES) {\n\t\t\treturn new FailureFormatter();\n\t\t} else if (mode == OutputMode.MODE_SUMMARY) {\n\t\t\treturn new SummaryFormatter();\n\t\t} else if (mode == OutputMode.MODE_METADATA) {\n\t\t\treturn new MetaDataFormatter();\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Failed to create formatter for mode: \" + mode);\n\t\t}\t\t\n\t}\n\n\n\tprivate static void usage(String errorMessage) {\n\t\tSystem.out.println(\"FormatExecutionLog failed to parse arguments.\");\n\t\tSystem.out.println(\"Error: \" + errorMessage);\n\t\tSystem.out.println(\"Usage: FormatExecutionLog --summary -s --chart -c <execution-log>\");\n\t\tSystem.out.println(\"Where:\");\n\t\tSystem.out.println(\"  --detail, -d   Lists detailed test stop/start data.\");\n\t\tSystem.out.println(\"  --summary, -s  Produce summary information about the log file.\");\n\t\tSystem.out.println(\"  --failures, -f List test failures.\");\n\t\tSystem.out.println(\"  --metadata, -m Dumps metadata from the .ltm file.\");\n\t\tSystem.out.println(\"  --verbose, -v  Lists extra details when available.\");\n\t\tSystem.out.println(\"  <execution-log>  Points to a load test execution log.\");\n\t\tSystem.out.println(\"                   For example, '/stf/SampleLoadTest/results/1.LT.executionlog'\");\n\t}"
    },
    "412": {
      "metadata": {
        "chunk_id": "8d396fbadf7760e2e5ab086e6f28bf4437bea426d50db2176e5bafef6e7f338d",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/FormatExecutionLog.java",
        "content": "// Returns an array with the numbers of load test data files.\n\t// Data is returned in oldest to newest order.\n\t// There may be holes in the sequence following log deletion to keep\n\t// log files within disk space limits.\n\t// eg, could return: 1, 2, 3, 8, 10, 11\n\tprivate ArrayList<Integer> findDataFiles(String baseNameExecutionLog) {\n\t\tArrayList<Integer> dataFileNumbers = new ArrayList<Integer>();\n\t\t\n\t\t// Build ArrayList of the numbers of all .ltd files\n\t\tFile baseNameExecutionLogFile = new File(baseNameExecutionLog).getAbsoluteFile();\n\t\tFile containingDir = baseNameExecutionLogFile.getParentFile();\n\t\tfor (String fileName : containingDir.list()) {\n\t\t\tif (fileName.endsWith(\".ltd\")  &&  fileName.startsWith(baseNameExecutionLogFile.getName())) {\n\t\t\t\tString nameWithExtension = fileName.substring(0, fileName.length()-\".ltd\".length());\n\t\t\t\tString partNumString = nameWithExtension.substring(nameWithExtension.lastIndexOf('.')+1);\n\t\t\t\tint partNum = Integer.parseInt(partNumString);\n\t\t\t\tdataFileNumbers.add(partNum);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Sort .ltd file numbers from oldest to newest\n\t\tCollections.sort(dataFileNumbers);\n\t\t\n\t\treturn dataFileNumbers;\n\t}\n\t\n\n\t// Reads contents of all execution log files and gives the contents to the formatter.\n\t// Note that there may be hundreds of megabytes of log file data, but this record-by-record\n\t// processing keeps the memory footprint very low.\n\tprivate void dump(FormatterInterface formatterClass, boolean verbose, String baseNameExecutionLog) throws IOException {\n\t\tSystem.out.println(\"Formatting execution log for: \" + baseNameExecutionLog);\n\t\tSystem.out.println();\n\t\t\n\t\t// Find out when the test started\n\t\t// Note that the timestamp formatter is set to the time zone that the test executed in \n\t\tExecutionLogMetaData metaData = new ExecutionLogMetaData(baseNameExecutionLog);\n\n\t\tlong baseTimestamp = metaData.getBaseTimestamp();\n\t\tformatterClass.start(metaData, verbose);\n\t\t\n\t\t// Find out which log file numbers still exist\n\t\tArrayList<Integer> dataFiles = findDataFiles(baseNameExecutionLog);\n\t\t\n\t\t// Dump content of all remaining log files\n\t\tint lastFileNum = 0;\n\t\tfor (int fileNum : dataFiles) {\n\t\t\t// Report any log file gaps\n\t\t\tfor (int i=lastFileNum+1; i<fileNum; i++) {\n\t\t\t\tformatterClass.missingLogFile(i);\n\t\t\t}\n\t\t\tlastFileNum = fileNum;\n\t\t\t\n\t\t\t// Process all records in current log file\n\t\t\tFile dataFile = new File(baseNameExecutionLog + \".\" + fileNum + \".ltd\");\n\t\t\tInputStream dataFileInput = new BufferedInputStream(new FileInputStream(dataFile), 64*1024);\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\t// Read the next record\n\t\t\t\t\tExecutionRecord record = ExecutionRecord.createFromBytes(dataFileInput, baseTimestamp);\n\t\t\t\t\tif (record == null) {\n\t\t\t\t\t\tbreak; // EOF\n\t\t\t\t\t}\n\n\t\t\t\t\t// Allow the formatter to process the current record\n\t\t\t\t\tlong offset = record.getTimestamp() - baseTimestamp;\n\t\t\t\t\tformatterClass.processRecord(fileNum, record, offset);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tdataFileInput.close();\n\t\t\t}\n\t\t}\n\t\t\n\t\tformatterClass.end();\n\t}\n}",
        "start_line": 137,
        "end_line": 212,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 713,
        "node_type": null,
        "file_sha": "141559557ba401198a2cb33b22233d27cc49e7cb",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.239400"
      },
      "text": "// Returns an array with the numbers of load test data files.\n\t// Data is returned in oldest to newest order.\n\t// There may be holes in the sequence following log deletion to keep\n\t// log files within disk space limits.\n\t// eg, could return: 1, 2, 3, 8, 10, 11\n\tprivate ArrayList<Integer> findDataFiles(String baseNameExecutionLog) {\n\t\tArrayList<Integer> dataFileNumbers = new ArrayList<Integer>();\n\t\t\n\t\t// Build ArrayList of the numbers of all .ltd files\n\t\tFile baseNameExecutionLogFile = new File(baseNameExecutionLog).getAbsoluteFile();\n\t\tFile containingDir = baseNameExecutionLogFile.getParentFile();\n\t\tfor (String fileName : containingDir.list()) {\n\t\t\tif (fileName.endsWith(\".ltd\")  &&  fileName.startsWith(baseNameExecutionLogFile.getName())) {\n\t\t\t\tString nameWithExtension = fileName.substring(0, fileName.length()-\".ltd\".length());\n\t\t\t\tString partNumString = nameWithExtension.substring(nameWithExtension.lastIndexOf('.')+1);\n\t\t\t\tint partNum = Integer.parseInt(partNumString);\n\t\t\t\tdataFileNumbers.add(partNum);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Sort .ltd file numbers from oldest to newest\n\t\tCollections.sort(dataFileNumbers);\n\t\t\n\t\treturn dataFileNumbers;\n\t}\n\t\n\n\t// Reads contents of all execution log files and gives the contents to the formatter.\n\t// Note that there may be hundreds of megabytes of log file data, but this record-by-record\n\t// processing keeps the memory footprint very low.\n\tprivate void dump(FormatterInterface formatterClass, boolean verbose, String baseNameExecutionLog) throws IOException {\n\t\tSystem.out.println(\"Formatting execution log for: \" + baseNameExecutionLog);\n\t\tSystem.out.println();\n\t\t\n\t\t// Find out when the test started\n\t\t// Note that the timestamp formatter is set to the time zone that the test executed in \n\t\tExecutionLogMetaData metaData = new ExecutionLogMetaData(baseNameExecutionLog);\n\n\t\tlong baseTimestamp = metaData.getBaseTimestamp();\n\t\tformatterClass.start(metaData, verbose);\n\t\t\n\t\t// Find out which log file numbers still exist\n\t\tArrayList<Integer> dataFiles = findDataFiles(baseNameExecutionLog);\n\t\t\n\t\t// Dump content of all remaining log files\n\t\tint lastFileNum = 0;\n\t\tfor (int fileNum : dataFiles) {\n\t\t\t// Report any log file gaps\n\t\t\tfor (int i=lastFileNum+1; i<fileNum; i++) {\n\t\t\t\tformatterClass.missingLogFile(i);\n\t\t\t}\n\t\t\tlastFileNum = fileNum;\n\t\t\t\n\t\t\t// Process all records in current log file\n\t\t\tFile dataFile = new File(baseNameExecutionLog + \".\" + fileNum + \".ltd\");\n\t\t\tInputStream dataFileInput = new BufferedInputStream(new FileInputStream(dataFile), 64*1024);\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\t// Read the next record\n\t\t\t\t\tExecutionRecord record = ExecutionRecord.createFromBytes(dataFileInput, baseTimestamp);\n\t\t\t\t\tif (record == null) {\n\t\t\t\t\t\tbreak; // EOF\n\t\t\t\t\t}\n\n\t\t\t\t\t// Allow the formatter to process the current record\n\t\t\t\t\tlong offset = record.getTimestamp() - baseTimestamp;\n\t\t\t\t\tformatterClass.processRecord(fileNum, record, offset);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tdataFileInput.close();\n\t\t\t}\n\t\t}\n\t\t\n\t\tformatterClass.end();\n\t}\n}"
    },
    "413": {
      "metadata": {
        "chunk_id": "489d06ab491acd5cd31f30f71f5282f298253d503dacbd80fcc16ab422ff295c",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/RunActivitySummaryReport.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map.Entry;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord.Action;\n\n\n/** \n * This class produces ascii charts showing thread activity during a test run.\n * \n * Here is the activity of a trivial test run, showing the columns used for run with \n * 2 suites which each have 2 threads: \n *    Timestamp      Delta  Event       Test                                  0   1   0   1\n *   10:16:32.820     +12ms Start   1 MarkReset                           -  1MR            \n *   10:16:32.822     +14ms Start   1 ProtectedVars                       -   |  1PV        \n *   10:16:32.823     +15ms Start   2 MarkReset                           -   |   |  2MR    \n *   10:16:32.824     +16ms Start   2 ProtectedVars                       -   |   |   |  2PV\n *   10:16:32.827     +19ms Passed  1 ProtectedVars                       -   |   V   |   | \n *   10:16:32.827     +19ms Passed  2 ProtectedVars                       -   |       |   V \n *   10:16:32.828     +20ms Start   1 ProtectedVars                       -   |  1PV  |     \n *   10:16:32.828     +20ms Start   2 ProtectedVars                       -   |   |   |  2PV\n *   10:16:32.829     +21ms Passed  2 ProtectedVars                       -   |   |   |   V \n *   10:16:32.830     +22ms Passed  1 ProtectedVars                       -   |   V   |     \n *   10:16:32.830     +22ms Start   2 LineNumberReader                    -   |       |  2LN\n *   10:16:32.831     +23ms Start   1 LineNumberReader                    -   |  1LN  |   | \n *   10:16:32.832     +24ms Passed  2 MarkReset                           -   |   |   V   | \n *   10:16:32.832     +24ms Passed  1 MarkReset                           -   V   |       | \n *   10:16:32.833     +25ms Passed  1 LineNumberReader                    -       V       | \n *   10:16:32.833     +25ms Passed  2 LineNumberReader                    -               V \n */",
        "start_line": 0,
        "end_line": 51,
        "chunk_index": 0,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 758,
        "node_type": null,
        "file_sha": "e1ffbffc6afb9d13127c91f340747af71ece1d76",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.262562"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map.Entry;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord.Action;\n\n\n/** \n * This class produces ascii charts showing thread activity during a test run.\n * \n * Here is the activity of a trivial test run, showing the columns used for run with \n * 2 suites which each have 2 threads: \n *    Timestamp      Delta  Event       Test                                  0   1   0   1\n *   10:16:32.820     +12ms Start   1 MarkReset                           -  1MR            \n *   10:16:32.822     +14ms Start   1 ProtectedVars                       -   |  1PV        \n *   10:16:32.823     +15ms Start   2 MarkReset                           -   |   |  2MR    \n *   10:16:32.824     +16ms Start   2 ProtectedVars                       -   |   |   |  2PV\n *   10:16:32.827     +19ms Passed  1 ProtectedVars                       -   |   V   |   | \n *   10:16:32.827     +19ms Passed  2 ProtectedVars                       -   |       |   V \n *   10:16:32.828     +20ms Start   1 ProtectedVars                       -   |  1PV  |     \n *   10:16:32.828     +20ms Start   2 ProtectedVars                       -   |   |   |  2PV\n *   10:16:32.829     +21ms Passed  2 ProtectedVars                       -   |   |   |   V \n *   10:16:32.830     +22ms Passed  1 ProtectedVars                       -   |   V   |     \n *   10:16:32.830     +22ms Start   2 LineNumberReader                    -   |       |  2LN\n *   10:16:32.831     +23ms Start   1 LineNumberReader                    -   |  1LN  |   | \n *   10:16:32.832     +24ms Passed  2 MarkReset                           -   |   |   V   | \n *   10:16:32.832     +24ms Passed  1 MarkReset                           -   V   |       | \n *   10:16:32.833     +25ms Passed  1 LineNumberReader                    -       V       | \n *   10:16:32.833     +25ms Passed  2 LineNumberReader                    -               V \n */"
    },
    "414": {
      "metadata": {
        "chunk_id": "dbafce09f97747aaa15069dc11d7dbe5292b9a926a6aa8096fc19a5c34c5c3a4",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/RunActivitySummaryReport.java",
        "content": "class RunActivitySummaryReport {\n\tprivate ArrayList<ExecutionRecord> testActivity;\n\tprivate long startTime;\n\t\n\tprivate LinkedHashMap<String, String> longToShortTestNames = new LinkedHashMap<String, String>();\n\t\n\t\n\tRunActivitySummaryReport(ArrayList<ExecutionRecord> testActivity, long startTime) {\n\t\tthis.testActivity = testActivity;\n\t\tthis.startTime = startTime;\n\t}\n\t\n\t\n\tString produceReport() {\n\t\tSystem.out.println(\"Producting activity report for \" + this.testActivity.size() + \" observations\");\n\t\tcreateLongToShortTestNameMapping();\n\t\t\n\t\tThreadMapper threadMapper = new ThreadMapper(testActivity);\n\t\tString activityChart = createActivityChart(threadMapper, startTime);\n\t\tString legend = createReportLegend(threadMapper);\n\t\t\n\t\treturn activityChart + legend;\n\t}\n\n\n\t// This method abbreviates full test names, creating short test names that will \n\t// fit into the limited space of the runtime activity chart.\n\t// eg, abbreviates testLongMultiply for suite 2 to '2LM' \n\tprivate void createLongToShortTestNameMapping() {\n\t\t// Work out how many suites there are\n\t\tint numSuites = 0;\n\t\tfor (ExecutionRecord activity : testActivity) {\n\t\t\tnumSuites = Math.max(numSuites, activity.getSuiteId());\n\t\t}\n\n\t\t// For each suite, abbreviate test names.\n\t\tfor (int suiteId=1; suiteId<=numSuites; suiteId++) {\n\t\t\t// First build a set with the unique test names for the current suite\n\t\t\tLinkedHashSet<String> testNames = new LinkedHashSet<String>();\n\t\t\tfor (ExecutionRecord activity : testActivity) {\n\t\t\t\tif (activity.getSuiteId() == suiteId) {\n\t\t\t\t\ttestNames.add(activity.getTestName());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Process each test long name to create an abbreviation. eg, testStringConcatFunction -> SC\n\t        for (String longTestName : testNames) {\n\t        \t// Remove the 'test' word from the testcase name\n\t        \tString cleanedTestName = longTestName.replace(\"test\", \"\");\n\t        \tcleanedTestName = cleanedTestName.replace(\"Test\", \"\");",
        "start_line": 52,
        "end_line": 101,
        "chunk_index": 1,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 443,
        "node_type": null,
        "file_sha": "e1ffbffc6afb9d13127c91f340747af71ece1d76",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.262570"
      },
      "text": "class RunActivitySummaryReport {\n\tprivate ArrayList<ExecutionRecord> testActivity;\n\tprivate long startTime;\n\t\n\tprivate LinkedHashMap<String, String> longToShortTestNames = new LinkedHashMap<String, String>();\n\t\n\t\n\tRunActivitySummaryReport(ArrayList<ExecutionRecord> testActivity, long startTime) {\n\t\tthis.testActivity = testActivity;\n\t\tthis.startTime = startTime;\n\t}\n\t\n\t\n\tString produceReport() {\n\t\tSystem.out.println(\"Producting activity report for \" + this.testActivity.size() + \" observations\");\n\t\tcreateLongToShortTestNameMapping();\n\t\t\n\t\tThreadMapper threadMapper = new ThreadMapper(testActivity);\n\t\tString activityChart = createActivityChart(threadMapper, startTime);\n\t\tString legend = createReportLegend(threadMapper);\n\t\t\n\t\treturn activityChart + legend;\n\t}\n\n\n\t// This method abbreviates full test names, creating short test names that will \n\t// fit into the limited space of the runtime activity chart.\n\t// eg, abbreviates testLongMultiply for suite 2 to '2LM' \n\tprivate void createLongToShortTestNameMapping() {\n\t\t// Work out how many suites there are\n\t\tint numSuites = 0;\n\t\tfor (ExecutionRecord activity : testActivity) {\n\t\t\tnumSuites = Math.max(numSuites, activity.getSuiteId());\n\t\t}\n\n\t\t// For each suite, abbreviate test names.\n\t\tfor (int suiteId=1; suiteId<=numSuites; suiteId++) {\n\t\t\t// First build a set with the unique test names for the current suite\n\t\t\tLinkedHashSet<String> testNames = new LinkedHashSet<String>();\n\t\t\tfor (ExecutionRecord activity : testActivity) {\n\t\t\t\tif (activity.getSuiteId() == suiteId) {\n\t\t\t\t\ttestNames.add(activity.getTestName());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Process each test long name to create an abbreviation. eg, testStringConcatFunction -> SC\n\t        for (String longTestName : testNames) {\n\t        \t// Remove the 'test' word from the testcase name\n\t        \tString cleanedTestName = longTestName.replace(\"test\", \"\");\n\t        \tcleanedTestName = cleanedTestName.replace(\"Test\", \"\");"
    },
    "415": {
      "metadata": {
        "chunk_id": "be1407ebd60a9d15a7388ff69404adb620048078af09e4820cd64bd3b576db40",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/RunActivitySummaryReport.java",
        "content": "// For each suite, abbreviate test names.\n\t\tfor (int suiteId=1; suiteId<=numSuites; suiteId++) {\n\t\t\t// First build a set with the unique test names for the current suite\n\t\t\tLinkedHashSet<String> testNames = new LinkedHashSet<String>();\n\t\t\tfor (ExecutionRecord activity : testActivity) {\n\t\t\t\tif (activity.getSuiteId() == suiteId) {\n\t\t\t\t\ttestNames.add(activity.getTestName());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Process each test long name to create an abbreviation. eg, testStringConcatFunction -> SC\n\t        for (String longTestName : testNames) {\n\t        \t// Remove the 'test' word from the testcase name\n\t        \tString cleanedTestName = longTestName.replace(\"test\", \"\");\n\t        \tcleanedTestName = cleanedTestName.replace(\"Test\", \"\");\n\n\t        \t// Make sure the first character is upper case. \n\t        \t// So that names such as 'hashcode_Boolean' can still create a sensible abbreviation\n\t        \tif (Character.isLowerCase(cleanedTestName.charAt(0))) {\n\t        \t\tcleanedTestName = cleanedTestName.substring(0,1).toUpperCase() + cleanedTestName.substring(1); \n\t        \t}\n\t        \t\t\t\n\t        \t// Build up the possible short names, from high to low preference.\n\t        \t// We prefer to build a 2 char short name, but there are not that many \n\t        \t// combinations available so also build 3 character short names.\n\t        \tArrayList<String> abbreviations = new ArrayList<String>();\n\t        \tabbreviateTestName(cleanedTestName, abbreviations);\n\t        \t\n\t\t\t\t// Remove all the vowels, and run through abbreviation again\n\t        \tcleanedTestName = cleanedTestName.replaceAll(\"[aeiou]\\\\B\", \"\");\n\t        \tabbreviateTestName(cleanedTestName, abbreviations);\n\t\t\t\t\n\t        \t// Get rid of unsuitable abbreviations (empty or too long)\n\t        \tabbreviations = cleanAbbreviations(abbreviations);\n\t        \t\n\t        \t// Pick the first abbreviation that has not already been used\n\t        \tString shortTestName = null;\n\t        \tfor (String abbr : abbreviations) { \n\t        \t\tif (!longToShortTestNames.values().contains(\"\" + suiteId + abbr)) {\n\t        \t\t\tshortTestName = abbr;\n\t        \t\t\tbreak;\n\t        \t\t}\n\t        \t}\n\t        \t\n\t        \t// If none of the abbreviations were picked then generate a name.\n\t        \tif (shortTestName == null) {\n\t        \t\tfor (int i=0; i<cleanedTestName.length() && shortTestName == null; i++) {\n\t        \t\t\tchar c = cleanedTestName.charAt(i);\n\t        \t\t\tfor (int j=0; j<99; j++) {\n\t        \t\t\t\tString candidate = \"\" + suiteId + c + j;\n\t                \t\tif (!longToShortTestNames.values().contains(candidate)) {\n\t                \t\t\tshortTestName = candidate;\n\t                \t\t\tbreak;\n\t                \t\t}\n\t        \t\t\t}\n\t        \t\t}\n\t        \t}\n\t\n\t        \t// Add chosen abbreviation to long to short map\n\t           \tString key   = suiteId + \".\" + longTestName;\n\t\t\t\tString value = suiteId + shortTestName;\n\t\t\t\tlongToShortTestNames.put(key, value);\n\t        }\n\t\t}\n\t}\n\n\n\tprivate void abbreviateTestName(String cleanedTestName, ArrayList<String> abbreviations) {\n    \t// Extract significant camel-case letters. eg, LongTimerRun extracts 'Lo' 'Ti' and 'Ru'\n    \tString pairs[] = { \"  \", \"  \", \"  \" };\n        Pattern pattern = Pattern.compile(\".*?([A-Z][A-Za-z]).*?([A-Z][A-Za-z])?.*?([A-Z][A-Za-z])?.*?\");\n    \tMatcher matcher = pattern.matcher(cleanedTestName);\n    \tint i=0;\n\n    \twhile (matcher.find()) {\n    \t\tpairs[i++] = matcher.group(1);\n    \t\tif (i >= pairs.length) break;\n    \t}\n\n\t\tchar c0 = pairs[0].charAt(0);\n\t\tchar c1 = pairs[1].charAt(0);\n\t\tchar c2 = pairs[2].charAt(0);\n     \t\n\t\t// Combinations of the first letter of each camel case pair\n\t\tabbreviations.add(\"\" + c0 + c1);\n\t\tabbreviations.add(\"\" + c1 + c2);\n\t\tabbreviations.add(\"\" + c0 + c2);\n\t\t\n\t\t// Use camel case pairs as-is\n\t\tabbreviations.add(pairs[0]);\n\t\tabbreviations.add(pairs[1]);\n\t\tabbreviations.add(pairs[2]);",
        "start_line": 102,
        "end_line": 193,
        "chunk_index": 2,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 965,
        "node_type": null,
        "file_sha": "e1ffbffc6afb9d13127c91f340747af71ece1d76",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.262572"
      },
      "text": "// For each suite, abbreviate test names.\n\t\tfor (int suiteId=1; suiteId<=numSuites; suiteId++) {\n\t\t\t// First build a set with the unique test names for the current suite\n\t\t\tLinkedHashSet<String> testNames = new LinkedHashSet<String>();\n\t\t\tfor (ExecutionRecord activity : testActivity) {\n\t\t\t\tif (activity.getSuiteId() == suiteId) {\n\t\t\t\t\ttestNames.add(activity.getTestName());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Process each test long name to create an abbreviation. eg, testStringConcatFunction -> SC\n\t        for (String longTestName : testNames) {\n\t        \t// Remove the 'test' word from the testcase name\n\t        \tString cleanedTestName = longTestName.replace(\"test\", \"\");\n\t        \tcleanedTestName = cleanedTestName.replace(\"Test\", \"\");\n\n\t        \t// Make sure the first character is upper case. \n\t        \t// So that names such as 'hashcode_Boolean' can still create a sensible abbreviation\n\t        \tif (Character.isLowerCase(cleanedTestName.charAt(0))) {\n\t        \t\tcleanedTestName = cleanedTestName.substring(0,1).toUpperCase() + cleanedTestName.substring(1); \n\t        \t}\n\t        \t\t\t\n\t        \t// Build up the possible short names, from high to low preference.\n\t        \t// We prefer to build a 2 char short name, but there are not that many \n\t        \t// combinations available so also build 3 character short names.\n\t        \tArrayList<String> abbreviations = new ArrayList<String>();\n\t        \tabbreviateTestName(cleanedTestName, abbreviations);\n\t        \t\n\t\t\t\t// Remove all the vowels, and run through abbreviation again\n\t        \tcleanedTestName = cleanedTestName.replaceAll(\"[aeiou]\\\\B\", \"\");\n\t        \tabbreviateTestName(cleanedTestName, abbreviations);\n\t\t\t\t\n\t        \t// Get rid of unsuitable abbreviations (empty or too long)\n\t        \tabbreviations = cleanAbbreviations(abbreviations);\n\t        \t\n\t        \t// Pick the first abbreviation that has not already been used\n\t        \tString shortTestName = null;\n\t        \tfor (String abbr : abbreviations) { \n\t        \t\tif (!longToShortTestNames.values().contains(\"\" + suiteId + abbr)) {\n\t        \t\t\tshortTestName = abbr;\n\t        \t\t\tbreak;\n\t        \t\t}\n\t        \t}\n\t        \t\n\t        \t// If none of the abbreviations were picked then generate a name.\n\t        \tif (shortTestName == null) {\n\t        \t\tfor (int i=0; i<cleanedTestName.length() && shortTestName == null; i++) {\n\t        \t\t\tchar c = cleanedTestName.charAt(i);\n\t        \t\t\tfor (int j=0; j<99; j++) {\n\t        \t\t\t\tString candidate = \"\" + suiteId + c + j;\n\t                \t\tif (!longToShortTestNames.values().contains(candidate)) {\n\t                \t\t\tshortTestName = candidate;\n\t                \t\t\tbreak;\n\t                \t\t}\n\t        \t\t\t}\n\t        \t\t}\n\t        \t}\n\t\n\t        \t// Add chosen abbreviation to long to short map\n\t           \tString key   = suiteId + \".\" + longTestName;\n\t\t\t\tString value = suiteId + shortTestName;\n\t\t\t\tlongToShortTestNames.put(key, value);\n\t        }\n\t\t}\n\t}\n\n\n\tprivate void abbreviateTestName(String cleanedTestName, ArrayList<String> abbreviations) {\n    \t// Extract significant camel-case letters. eg, LongTimerRun extracts 'Lo' 'Ti' and 'Ru'\n    \tString pairs[] = { \"  \", \"  \", \"  \" };\n        Pattern pattern = Pattern.compile(\".*?([A-Z][A-Za-z]).*?([A-Z][A-Za-z])?.*?([A-Z][A-Za-z])?.*?\");\n    \tMatcher matcher = pattern.matcher(cleanedTestName);\n    \tint i=0;\n\n    \twhile (matcher.find()) {\n    \t\tpairs[i++] = matcher.group(1);\n    \t\tif (i >= pairs.length) break;\n    \t}\n\n\t\tchar c0 = pairs[0].charAt(0);\n\t\tchar c1 = pairs[1].charAt(0);\n\t\tchar c2 = pairs[2].charAt(0);\n     \t\n\t\t// Combinations of the first letter of each camel case pair\n\t\tabbreviations.add(\"\" + c0 + c1);\n\t\tabbreviations.add(\"\" + c1 + c2);\n\t\tabbreviations.add(\"\" + c0 + c2);\n\t\t\n\t\t// Use camel case pairs as-is\n\t\tabbreviations.add(pairs[0]);\n\t\tabbreviations.add(pairs[1]);\n\t\tabbreviations.add(pairs[2]);"
    },
    "416": {
      "metadata": {
        "chunk_id": "d17fb170695f7eacebff6257f400936d71554be70e8f75dde6a3782e45942310",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/RunActivitySummaryReport.java",
        "content": "while (matcher.find()) {\n    \t\tpairs[i++] = matcher.group(1);\n    \t\tif (i >= pairs.length) break;\n    \t}\n\n\t\tchar c0 = pairs[0].charAt(0);\n\t\tchar c1 = pairs[1].charAt(0);\n\t\tchar c2 = pairs[2].charAt(0);\n     \t\n\t\t// Combinations of the first letter of each camel case pair\n\t\tabbreviations.add(\"\" + c0 + c1);\n\t\tabbreviations.add(\"\" + c1 + c2);\n\t\tabbreviations.add(\"\" + c0 + c2);\n\t\t\n\t\t// Use camel case pairs as-is\n\t\tabbreviations.add(pairs[0]);\n\t\tabbreviations.add(pairs[1]);\n\t\tabbreviations.add(pairs[2]);\n\n\t\t// Long name, from all 3 pairs, or parts off\n\t\tabbreviations.add(pairs[0] + pairs[1]);\n\t\tabbreviations.add(pairs[0] + pairs[2]);\n\t\tabbreviations.add(pairs[1] + pairs[2]);\n\t\t\n\t\t// Short names, from first letter of camel case\n\t\tabbreviations.add(\"\" + c0);\n\t\tabbreviations.add(\"\" + c1);\n\t\tabbreviations.add(\"\" + c2);\n\t\t\n\t\t// First and last letter of cleaned test name\n\t\tchar firstChar = cleanedTestName.charAt(0);\n\t\tchar lastChar  = cleanedTestName.charAt(cleanedTestName.length()-1);\n\t\tabbreviations.add(\"\" + firstChar + lastChar);\n\t}\n\n\n\t// Takes a list of possible abbreviations and returns a cleaned up list\n\tprivate ArrayList<String> cleanAbbreviations(ArrayList<String> abbreviations) {\n\t\tArrayList<String> cleaned = new ArrayList<String>();\n\t\t\n\t\tfor (String s : abbreviations) {\n\t\t\ts = s.trim();\n\t\t\tif (s.length() > 3) {\n\t\t\t\tcleaned.add(s.substring(0,3));  // It's a long name. Only use first 3 characters\n\t\t\t} else if (s.length() >= 1) {\n\t\t\t\tcleaned.add(s); // Usable, as between 1 and 3 chars long\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn cleaned;\n\t}\n\n\n\tprivate String createActivityChart(ThreadMapper threadMapper, long startTime) {\n\t\tStringBuilder chart = new StringBuilder();\n\t\tSimpleDateFormat dateFormatter = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n\n\t\t// Find the length of the longest test name - so help with table formatting\n\t\tint longestTestNameLength = -1;\n\t\tfor (ExecutionRecord activity : this.testActivity) { \n\t\t\tlongestTestNameLength = Math.max(longestTestNameLength, activity.getTestName().length());\n\t\t}\n\t\t\n\t    // Build banner text to describe column contents\n\t    StringBuilder banner = new StringBuilder();\n\t    String bannerFormat = \" Timestamp      Delta  Event       Test %\" + (longestTestNameLength-5) + \"s\";\n\t    banner.append(String.format(bannerFormat, \" \"));\n\t    for (int i=0; i<threadMapper.getNumThreads(); i++) { \n\t    \tString threadId = String.format(\"%4d\", threadMapper.getThreadDetailsForColumn(i).getThreadId());\n\t    \tbanner.append(threadId);\n\t    }\n\t    \n\t    chart.append(banner + \"\\n\");\n\t    \n\t    // Create an array to keep track of whether or not each thread is working. Index by column number\n\t    boolean[] threadBusy = new boolean[threadMapper.getNumThreads()]; \n\t    \n\t    // Produce a 1 line summary of what's going on when each start/stop event was logged\n\t    for (ExecutionRecord activity : this.testActivity) { \n\t    \tint threadIndex = threadMapper.getColumnIndex(new ThreadDetails(activity.getSuiteId(), activity.getThreadName()));\n\t    \tString testShortName = longToShortTestNames.get(activity.getTestReference());\n\n\t    \t// Prepare data for start of trace line. Summarises the reason for the current line.\n\t    \tString formattedTime = dateFormatter.format(new Date(activity.getTimestamp()));\n\t\t\tlong elapsedTime = activity.getTimestamp() - startTime;\n\t\t\tString action = \"Start\";\n\t\t\tif (activity.getAction() == Action.PASSED) {\n\t\t\t\taction = \"Passed\";\n\t\t\t} else if (activity.getAction() == Action.FAILED) {\n\t\t\t\taction = \"Failed\";\n\t\t\t}",
        "start_line": 194,
        "end_line": 284,
        "chunk_index": 3,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 900,
        "node_type": null,
        "file_sha": "e1ffbffc6afb9d13127c91f340747af71ece1d76",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.262575"
      },
      "text": "while (matcher.find()) {\n    \t\tpairs[i++] = matcher.group(1);\n    \t\tif (i >= pairs.length) break;\n    \t}\n\n\t\tchar c0 = pairs[0].charAt(0);\n\t\tchar c1 = pairs[1].charAt(0);\n\t\tchar c2 = pairs[2].charAt(0);\n     \t\n\t\t// Combinations of the first letter of each camel case pair\n\t\tabbreviations.add(\"\" + c0 + c1);\n\t\tabbreviations.add(\"\" + c1 + c2);\n\t\tabbreviations.add(\"\" + c0 + c2);\n\t\t\n\t\t// Use camel case pairs as-is\n\t\tabbreviations.add(pairs[0]);\n\t\tabbreviations.add(pairs[1]);\n\t\tabbreviations.add(pairs[2]);\n\n\t\t// Long name, from all 3 pairs, or parts off\n\t\tabbreviations.add(pairs[0] + pairs[1]);\n\t\tabbreviations.add(pairs[0] + pairs[2]);\n\t\tabbreviations.add(pairs[1] + pairs[2]);\n\t\t\n\t\t// Short names, from first letter of camel case\n\t\tabbreviations.add(\"\" + c0);\n\t\tabbreviations.add(\"\" + c1);\n\t\tabbreviations.add(\"\" + c2);\n\t\t\n\t\t// First and last letter of cleaned test name\n\t\tchar firstChar = cleanedTestName.charAt(0);\n\t\tchar lastChar  = cleanedTestName.charAt(cleanedTestName.length()-1);\n\t\tabbreviations.add(\"\" + firstChar + lastChar);\n\t}\n\n\n\t// Takes a list of possible abbreviations and returns a cleaned up list\n\tprivate ArrayList<String> cleanAbbreviations(ArrayList<String> abbreviations) {\n\t\tArrayList<String> cleaned = new ArrayList<String>();\n\t\t\n\t\tfor (String s : abbreviations) {\n\t\t\ts = s.trim();\n\t\t\tif (s.length() > 3) {\n\t\t\t\tcleaned.add(s.substring(0,3));  // It's a long name. Only use first 3 characters\n\t\t\t} else if (s.length() >= 1) {\n\t\t\t\tcleaned.add(s); // Usable, as between 1 and 3 chars long\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn cleaned;\n\t}\n\n\n\tprivate String createActivityChart(ThreadMapper threadMapper, long startTime) {\n\t\tStringBuilder chart = new StringBuilder();\n\t\tSimpleDateFormat dateFormatter = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n\n\t\t// Find the length of the longest test name - so help with table formatting\n\t\tint longestTestNameLength = -1;\n\t\tfor (ExecutionRecord activity : this.testActivity) { \n\t\t\tlongestTestNameLength = Math.max(longestTestNameLength, activity.getTestName().length());\n\t\t}\n\t\t\n\t    // Build banner text to describe column contents\n\t    StringBuilder banner = new StringBuilder();\n\t    String bannerFormat = \" Timestamp      Delta  Event       Test %\" + (longestTestNameLength-5) + \"s\";\n\t    banner.append(String.format(bannerFormat, \" \"));\n\t    for (int i=0; i<threadMapper.getNumThreads(); i++) { \n\t    \tString threadId = String.format(\"%4d\", threadMapper.getThreadDetailsForColumn(i).getThreadId());\n\t    \tbanner.append(threadId);\n\t    }\n\t    \n\t    chart.append(banner + \"\\n\");\n\t    \n\t    // Create an array to keep track of whether or not each thread is working. Index by column number\n\t    boolean[] threadBusy = new boolean[threadMapper.getNumThreads()]; \n\t    \n\t    // Produce a 1 line summary of what's going on when each start/stop event was logged\n\t    for (ExecutionRecord activity : this.testActivity) { \n\t    \tint threadIndex = threadMapper.getColumnIndex(new ThreadDetails(activity.getSuiteId(), activity.getThreadName()));\n\t    \tString testShortName = longToShortTestNames.get(activity.getTestReference());\n\n\t    \t// Prepare data for start of trace line. Summarises the reason for the current line.\n\t    \tString formattedTime = dateFormatter.format(new Date(activity.getTimestamp()));\n\t\t\tlong elapsedTime = activity.getTimestamp() - startTime;\n\t\t\tString action = \"Start\";\n\t\t\tif (activity.getAction() == Action.PASSED) {\n\t\t\t\taction = \"Passed\";\n\t\t\t} else if (activity.getAction() == Action.FAILED) {\n\t\t\t\taction = \"Failed\";\n\t\t\t}"
    },
    "417": {
      "metadata": {
        "chunk_id": "87bbe98fc19aed2140d56a962a8a1649ddd699be3c1beabe4775b2218f1ff77c",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/RunActivitySummaryReport.java",
        "content": "// Prepare data for start of trace line. Summarises the reason for the current line.\n\t    \tString formattedTime = dateFormatter.format(new Date(activity.getTimestamp()));\n\t\t\tlong elapsedTime = activity.getTimestamp() - startTime;\n\t\t\tString action = \"Start\";\n\t\t\tif (activity.getAction() == Action.PASSED) {\n\t\t\t\taction = \"Passed\";\n\t\t\t} else if (activity.getAction() == Action.FAILED) {\n\t\t\t\taction = \"Failed\";\n\t\t\t}\n\n\t\t\tString tracePrefix = String.format(\"%s %+7dms %-6s %2d %-\" + longestTestNameLength + \"s - \", \n\t\t\t\t\tformattedTime, elapsedTime, action, activity.getSuiteId(), activity.getTestName());\n\t\t\tchart.append(tracePrefix);\n\t\t\t\n\t\t\t// Output activity summary for each thread. 4 characters per thread.\n\t\t\tfor (int i=0; i<threadBusy.length; i++) {\n\t\t\t\tif (i == threadIndex && activity.getAction() == Action.STARTED) {\n\t\t\t\t\tthreadBusy[i] = true;\n\t\t\t\t\tchart.append(String.format(\"%4s\", testShortName));\n\t\t\t\t} else if (i == threadIndex && activity.getAction() == Action.PASSED) {\n\t\t\t\t\tthreadBusy[i] = false;\n\t\t\t\t\tchart.append(\"  V \");\n\t\t\t\t} else if (i == threadIndex && activity.getAction() == Action.FAILED) {\n\t\t\t\t\tthreadBusy[i] = false;\n\t\t\t\t\tchart.append(\"  # \");\n\t\t\t\t} else if (threadBusy[i]) {\n\t\t\t\t\tchart.append(\"  | \");\n\t\t\t\t} else {\n\t\t\t\t\tchart.append(\"    \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tchart.append(\"\\n\");\n\t    }\n\t    \n\t    chart.append(banner + \"\\n\");\n\t    \n\t    return chart.toString();\n\t}\n\t\n\t\n\tprivate String createReportLegend(ThreadMapper threadMapper) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\t\n\t\tbuilder.append(\"\\nThreadnames to short name mappings:\\n\");\n\t\tfor (int i=0; i<threadMapper.getNumThreads(); i++) {\n\t\t\tThreadDetails t = threadMapper.getThreadDetailsForColumn(i);\n\t\t\tString threadInfo = String.format(\"  %s %s -> %s\\n\", t.getSuiteId(), t.getThreadName(), t.getShortThreadName());\n\t\t\tbuilder.append(threadInfo);\n\t\t}\n\n\t\t// Produce listing showing test name abbreviations\n\t\tbuilder.append(\"TestNames:\\n\");\n\t\tfor (Entry<String, String> machineEntry : longToShortTestNames.entrySet()) {\n\t\t\tString longTestName  = machineEntry.getKey();\n\t\t\tString shortTestName = machineEntry.getValue();\n\t\t\tbuilder.append(\"  \" + longTestName + \" -> \" + shortTestName + \"\\n\");\n\t\t}\n\t\t\n\t\treturn builder.toString();\n\t}\n}",
        "start_line": 285,
        "end_line": 345,
        "chunk_index": 4,
        "total_chunks": 5,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 566,
        "node_type": null,
        "file_sha": "e1ffbffc6afb9d13127c91f340747af71ece1d76",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.262577"
      },
      "text": "// Prepare data for start of trace line. Summarises the reason for the current line.\n\t    \tString formattedTime = dateFormatter.format(new Date(activity.getTimestamp()));\n\t\t\tlong elapsedTime = activity.getTimestamp() - startTime;\n\t\t\tString action = \"Start\";\n\t\t\tif (activity.getAction() == Action.PASSED) {\n\t\t\t\taction = \"Passed\";\n\t\t\t} else if (activity.getAction() == Action.FAILED) {\n\t\t\t\taction = \"Failed\";\n\t\t\t}\n\n\t\t\tString tracePrefix = String.format(\"%s %+7dms %-6s %2d %-\" + longestTestNameLength + \"s - \", \n\t\t\t\t\tformattedTime, elapsedTime, action, activity.getSuiteId(), activity.getTestName());\n\t\t\tchart.append(tracePrefix);\n\t\t\t\n\t\t\t// Output activity summary for each thread. 4 characters per thread.\n\t\t\tfor (int i=0; i<threadBusy.length; i++) {\n\t\t\t\tif (i == threadIndex && activity.getAction() == Action.STARTED) {\n\t\t\t\t\tthreadBusy[i] = true;\n\t\t\t\t\tchart.append(String.format(\"%4s\", testShortName));\n\t\t\t\t} else if (i == threadIndex && activity.getAction() == Action.PASSED) {\n\t\t\t\t\tthreadBusy[i] = false;\n\t\t\t\t\tchart.append(\"  V \");\n\t\t\t\t} else if (i == threadIndex && activity.getAction() == Action.FAILED) {\n\t\t\t\t\tthreadBusy[i] = false;\n\t\t\t\t\tchart.append(\"  # \");\n\t\t\t\t} else if (threadBusy[i]) {\n\t\t\t\t\tchart.append(\"  | \");\n\t\t\t\t} else {\n\t\t\t\t\tchart.append(\"    \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tchart.append(\"\\n\");\n\t    }\n\t    \n\t    chart.append(banner + \"\\n\");\n\t    \n\t    return chart.toString();\n\t}\n\t\n\t\n\tprivate String createReportLegend(ThreadMapper threadMapper) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\t\n\t\tbuilder.append(\"\\nThreadnames to short name mappings:\\n\");\n\t\tfor (int i=0; i<threadMapper.getNumThreads(); i++) {\n\t\t\tThreadDetails t = threadMapper.getThreadDetailsForColumn(i);\n\t\t\tString threadInfo = String.format(\"  %s %s -> %s\\n\", t.getSuiteId(), t.getThreadName(), t.getShortThreadName());\n\t\t\tbuilder.append(threadInfo);\n\t\t}\n\n\t\t// Produce listing showing test name abbreviations\n\t\tbuilder.append(\"TestNames:\\n\");\n\t\tfor (Entry<String, String> machineEntry : longToShortTestNames.entrySet()) {\n\t\t\tString longTestName  = machineEntry.getKey();\n\t\t\tString shortTestName = machineEntry.getValue();\n\t\t\tbuilder.append(\"  \" + longTestName + \" -> \" + shortTestName + \"\\n\");\n\t\t}\n\t\t\n\t\treturn builder.toString();\n\t}\n}"
    },
    "418": {
      "metadata": {
        "chunk_id": "e2d6352f09996afefc005fc2184d374f382ad18988a5fe2c5bf74f58cd3eb3c0",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/ThreadDetails.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * Holds details about a single thread.\n * \n * This is mostly needed because in TestNG different suites reuse the same thread names!\n * So this class is needed so that we can tell the difference between a thread running \n * tests for suite 1 called say 'PoolService-2' and a thread with the same name\n * running tests for suite 2. \n */\nclass ThreadDetails implements Comparable<ThreadDetails> {\n\tint suiteId;\n\tString threadName;\n\tint threadId;  \n\n\tThreadDetails(int suiteId, String threadName) {\n\t\tthis.suiteId = suiteId;\n\t\tthis.threadName = threadName;\n\n\t\t// Extract the thread number from the thread name. eg PoolService-2 has an id of 2\n        Pattern pattern = Pattern.compile(\".*?([0-9]*)$\");\n        Matcher matcher = pattern.matcher(threadName);\n       \tif (!matcher.find()) { \n       \t\tthrow new IllegalStateException(\"Failed to extract thread number from thread name: \" + threadName);\n       \t}\n       \tthreadId = Integer.parseInt(matcher.group(1));\n\t}\n\t\n\tObject getSuiteId() {\n\t\treturn suiteId;\n\t}\n\n\tObject getThreadName() {\n\t\treturn threadName;\n\t}\n\n\tObject getThreadId() {\n\t\treturn threadId;\n\t}\n\n\tObject getShortThreadName() {\n\t\treturn suiteId + \".\" + threadId;\n\t}\n\n\t\n\tpublic boolean equals(Object o) {\n\t\tif (o == this) return true;\n\t\tif (!(o instanceof ThreadDetails)) return false;\n\t\tThreadDetails other = (ThreadDetails) o;\n\t\t\n\t\treturn this.suiteId == other.suiteId \n\t\t\t\t&& this.threadName.equals(other.threadName)\n\t\t\t\t&& this.threadId == other.threadId;\n\t}\n\t\n\tpublic int hashCode() { \n\t\tint result = 17;\n\t\tresult = 31 * result * suiteId;\n\t\tresult = 31 * result * threadName.hashCode();\n\t\tresult = 31 * result * threadId;\n\t\treturn result;\n\t}\n\t\n    public String toString() {\n\t\treturn suiteId + \" \" + threadName + \" \" + threadId;\n\t}\n\n\tpublic int compareTo(ThreadDetails other) {\n    \tif (suiteId == other.suiteId) { \n    \t\treturn threadId - other.threadId;\n    \t}\n    \treturn suiteId - other.suiteId;\n\t}\n}",
        "start_line": 0,
        "end_line": 91,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 627,
        "node_type": null,
        "file_sha": "c9cbee0b1724ae12128649479ca1b0c88c7642f8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.284995"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * Holds details about a single thread.\n * \n * This is mostly needed because in TestNG different suites reuse the same thread names!\n * So this class is needed so that we can tell the difference between a thread running \n * tests for suite 1 called say 'PoolService-2' and a thread with the same name\n * running tests for suite 2. \n */\nclass ThreadDetails implements Comparable<ThreadDetails> {\n\tint suiteId;\n\tString threadName;\n\tint threadId;  \n\n\tThreadDetails(int suiteId, String threadName) {\n\t\tthis.suiteId = suiteId;\n\t\tthis.threadName = threadName;\n\n\t\t// Extract the thread number from the thread name. eg PoolService-2 has an id of 2\n        Pattern pattern = Pattern.compile(\".*?([0-9]*)$\");\n        Matcher matcher = pattern.matcher(threadName);\n       \tif (!matcher.find()) { \n       \t\tthrow new IllegalStateException(\"Failed to extract thread number from thread name: \" + threadName);\n       \t}\n       \tthreadId = Integer.parseInt(matcher.group(1));\n\t}\n\t\n\tObject getSuiteId() {\n\t\treturn suiteId;\n\t}\n\n\tObject getThreadName() {\n\t\treturn threadName;\n\t}\n\n\tObject getThreadId() {\n\t\treturn threadId;\n\t}\n\n\tObject getShortThreadName() {\n\t\treturn suiteId + \".\" + threadId;\n\t}\n\n\t\n\tpublic boolean equals(Object o) {\n\t\tif (o == this) return true;\n\t\tif (!(o instanceof ThreadDetails)) return false;\n\t\tThreadDetails other = (ThreadDetails) o;\n\t\t\n\t\treturn this.suiteId == other.suiteId \n\t\t\t\t&& this.threadName.equals(other.threadName)\n\t\t\t\t&& this.threadId == other.threadId;\n\t}\n\t\n\tpublic int hashCode() { \n\t\tint result = 17;\n\t\tresult = 31 * result * suiteId;\n\t\tresult = 31 * result * threadName.hashCode();\n\t\tresult = 31 * result * threadId;\n\t\treturn result;\n\t}\n\t\n    public String toString() {\n\t\treturn suiteId + \" \" + threadName + \" \" + threadId;\n\t}\n\n\tpublic int compareTo(ThreadDetails other) {\n    \tif (suiteId == other.suiteId) { \n    \t\treturn threadId - other.threadId;\n    \t}\n    \treturn suiteId - other.suiteId;\n\t}\n}"
    },
    "419": {
      "metadata": {
        "chunk_id": "8962db2a923182fc12cfa860e7aa780b0c3d45f63e171edb6b607d60ac1f5e76",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/ThreadMapper.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.TreeSet;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\n\n\n/**\n * This class plays a key role in producing a chart which shows thread activity. \n * It allocates columns in the chart to individual threads, and allows the caller \n * to map between thread information and column numbers.\n * \n * Here is the activity of a trivial test run, showing the columns used for run with \n * 2 suites which each have 2 threads: \n *    Timestamp      Delta  Event       Test                                  0   1   0   1\n *   10:16:32.820     +12ms Start   1 MarkReset                           -  1MR            \n *   10:16:32.822     +14ms Start   1 ProtectedVars                       -   |  1PV        \n *   10:16:32.823     +15ms Start   2 MarkReset                           -   |   |  2MR    \n *   10:16:32.824     +16ms Start   2 ProtectedVars                       -   |   |   |  2PV\n *   10:16:32.827     +19ms Passed  1 ProtectedVars                       -   |   V   |   | \n *   10:16:32.827     +19ms Passed  2 ProtectedVars                       -   |       |   V \n *   10:16:32.828     +20ms Start   1 ProtectedVars                       -   |  1PV  |     \n *   10:16:32.828     +20ms Start   2 ProtectedVars                       -   |   |   |  2PV\n *   10:16:32.829     +21ms Passed  2 ProtectedVars                       -   |   |   |   V \n *   10:16:32.830     +22ms Passed  1 ProtectedVars                       -   |   V   |     \n *   10:16:32.830     +22ms Start   2 LineNumberReader                    -   |       |  2LN\n *   10:16:32.831     +23ms Start   1 LineNumberReader                    -   |  1LN  |   | \n *   10:16:32.832     +24ms Passed  2 MarkReset                           -   |   |   V   | \n *   10:16:32.832     +24ms Passed  1 MarkReset                           -   V   |       | \n *   10:16:32.833     +25ms Passed  1 LineNumberReader                    -       V       | \n *   10:16:32.833     +25ms Passed  2 LineNumberReader                    -               V \n */",
        "start_line": 0,
        "end_line": 47,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 745,
        "node_type": null,
        "file_sha": "28f497f2550a9528eb53daa173f42efb90246862",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.307565"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.TreeSet;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\n\n\n/**\n * This class plays a key role in producing a chart which shows thread activity. \n * It allocates columns in the chart to individual threads, and allows the caller \n * to map between thread information and column numbers.\n * \n * Here is the activity of a trivial test run, showing the columns used for run with \n * 2 suites which each have 2 threads: \n *    Timestamp      Delta  Event       Test                                  0   1   0   1\n *   10:16:32.820     +12ms Start   1 MarkReset                           -  1MR            \n *   10:16:32.822     +14ms Start   1 ProtectedVars                       -   |  1PV        \n *   10:16:32.823     +15ms Start   2 MarkReset                           -   |   |  2MR    \n *   10:16:32.824     +16ms Start   2 ProtectedVars                       -   |   |   |  2PV\n *   10:16:32.827     +19ms Passed  1 ProtectedVars                       -   |   V   |   | \n *   10:16:32.827     +19ms Passed  2 ProtectedVars                       -   |       |   V \n *   10:16:32.828     +20ms Start   1 ProtectedVars                       -   |  1PV  |     \n *   10:16:32.828     +20ms Start   2 ProtectedVars                       -   |   |   |  2PV\n *   10:16:32.829     +21ms Passed  2 ProtectedVars                       -   |   |   |   V \n *   10:16:32.830     +22ms Passed  1 ProtectedVars                       -   |   V   |     \n *   10:16:32.830     +22ms Start   2 LineNumberReader                    -   |       |  2LN\n *   10:16:32.831     +23ms Start   1 LineNumberReader                    -   |  1LN  |   | \n *   10:16:32.832     +24ms Passed  2 MarkReset                           -   |   |   V   | \n *   10:16:32.832     +24ms Passed  1 MarkReset                           -   V   |       | \n *   10:16:32.833     +25ms Passed  1 LineNumberReader                    -       V       | \n *   10:16:32.833     +25ms Passed  2 LineNumberReader                    -               V \n */"
    },
    "420": {
      "metadata": {
        "chunk_id": "28675b31bec4246db0bed0c9c0a02fc69d2bb84a25107895ee21ac3fbac3e645",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/ThreadMapper.java",
        "content": "class ThreadMapper {\n\tprivate TreeSet<ThreadDetails> knownThreads = new TreeSet<ThreadDetails>();\n\n\t// Maps between thread details and a column index\n\t// eg, if we have some information about thread 3 for suite 1, we can use this map to find \n\t// out that this goes into the 3rd column.\n\tprivate HashMap<ThreadDetails, Integer> threadToColumn = new HashMap<ThreadDetails, Integer>();\n\t\n\t// This map is the reverse of the previous map.\n\t// It goes from a column number back to thread information.\n\tprivate HashMap<Integer, ThreadDetails> columnToThread = new HashMap<Integer, ThreadDetails>();\n\n\t\n\tThreadMapper(ArrayList<ExecutionRecord> testActivity) {\n\t\t// Build a sorted of all unique threads\n\t\tfor (ExecutionRecord activity : testActivity) { \n\t       \t// Add to set of known threads\n\t       \tThreadDetails threadDetails = new ThreadDetails(activity.getSuiteId(), activity.getThreadName()); \n\t        knownThreads.add(threadDetails);\n\t\t}\n\t\t\n\t\t// Thread details are now in a consistent order. Sorted by 1) suite id, from lowest to highest\n\t\t// and 2) with each suite sorted by thread number, again lowest to highest.\n\t\t// Build a map to allow a lookup of thread reference to column index, and vice versa. \n\t\t//  \n\t\tint i=0;\n\t    for (ThreadDetails t : knownThreads) {\n\t    \tthreadToColumn.put(t, i);\n\t    \tcolumnToThread.put(i, t);\n\t    \ti++;\n\t    }\n\t}\n\n\n\tint getNumThreads() {\n\t\treturn knownThreads.size();\n\t}\n\n\t\n\t/**\n\t * @return the column number allocated to the supplied thread.\n\t */\n\tint getColumnIndex(ThreadDetails threadDetails) {\n\t\treturn threadToColumn.get(threadDetails);\n\t}\n\t\n\t\n\t/**\n\t * @return information about the thread allocated to the referenced column number. \n\t */\n\tThreadDetails getThreadDetailsForColumn(int columnIndex) {\n\t\treturn columnToThread.get(columnIndex);\n\t}\n}",
        "start_line": 48,
        "end_line": 101,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 418,
        "node_type": null,
        "file_sha": "28f497f2550a9528eb53daa173f42efb90246862",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.307572"
      },
      "text": "class ThreadMapper {\n\tprivate TreeSet<ThreadDetails> knownThreads = new TreeSet<ThreadDetails>();\n\n\t// Maps between thread details and a column index\n\t// eg, if we have some information about thread 3 for suite 1, we can use this map to find \n\t// out that this goes into the 3rd column.\n\tprivate HashMap<ThreadDetails, Integer> threadToColumn = new HashMap<ThreadDetails, Integer>();\n\t\n\t// This map is the reverse of the previous map.\n\t// It goes from a column number back to thread information.\n\tprivate HashMap<Integer, ThreadDetails> columnToThread = new HashMap<Integer, ThreadDetails>();\n\n\t\n\tThreadMapper(ArrayList<ExecutionRecord> testActivity) {\n\t\t// Build a sorted of all unique threads\n\t\tfor (ExecutionRecord activity : testActivity) { \n\t       \t// Add to set of known threads\n\t       \tThreadDetails threadDetails = new ThreadDetails(activity.getSuiteId(), activity.getThreadName()); \n\t        knownThreads.add(threadDetails);\n\t\t}\n\t\t\n\t\t// Thread details are now in a consistent order. Sorted by 1) suite id, from lowest to highest\n\t\t// and 2) with each suite sorted by thread number, again lowest to highest.\n\t\t// Build a map to allow a lookup of thread reference to column index, and vice versa. \n\t\t//  \n\t\tint i=0;\n\t    for (ThreadDetails t : knownThreads) {\n\t    \tthreadToColumn.put(t, i);\n\t    \tcolumnToThread.put(i, t);\n\t    \ti++;\n\t    }\n\t}\n\n\n\tint getNumThreads() {\n\t\treturn knownThreads.size();\n\t}\n\n\t\n\t/**\n\t * @return the column number allocated to the supplied thread.\n\t */\n\tint getColumnIndex(ThreadDetails threadDetails) {\n\t\treturn threadToColumn.get(threadDetails);\n\t}\n\t\n\t\n\t/**\n\t * @return information about the thread allocated to the referenced column number. \n\t */\n\tThreadDetails getThreadDetailsForColumn(int columnIndex) {\n\t\treturn columnToThread.get(columnIndex);\n\t}\n}"
    },
    "421": {
      "metadata": {
        "chunk_id": "10d5116356778a1b8ed10394156765699391a58b4cfc2fa42ab186346b627c1a",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/DetailFormatter.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord.Action;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This formatter produces detailed information about every record in the remaining execution logs.\n * \n * Example output:\n *    Timestamp       Delta Thr Event      Test   Test name                                                         0  1  2  3  4  5  6\n *   11:48:37.371    +111ms  0 Started    1147 ..testlet.java.lang.ExceptionInInitializerError.classInfo.isArray -  o                   \n *   11:48:37.371    +111ms  4 Started     942 gnu.testlet.java.lang.Double.classInfo.getDeclaredAnnotations     -  |           o       \n *   11:48:37.371    +111ms  2 Started    2528 gnu.testlet.java.lang.Short.classInfo.isAssignableFrom            -  |     o     |       \n *   11:48:37.372    +112ms  5 Started     874 ..let.java.lang.ClassNotFoundException.classInfo.isAnonymousClass -  |     |     |  o    \n *   11:48:37.372    +112ms  3 Started    1557 ..let.java.lang.InheritableThreadLocal.classInfo.getCanonicalName -  |     |  o  |  |    \n *   11:48:37.375    +115ms  1 Started    1513 ..et.java.lang.IndexOutOfBoundsException.classInfo.getAnnotations -  |  o  |  |  |  |    \n *   11:48:37.375    +115ms  6 Started    3133 gnu.testlet.java.text.AttributedString.getIterator                -  |  |  |  |  |  |  o \n *   11:48:37.383    +123ms  4 Completed   942 gnu.testlet.java.lang.Double.classInfo.getDeclaredAnnotations     -  |  |  |  |  V  |  | \n *   11:48:37.383    +123ms  3 Passed     1557 ..let.java.lang.InheritableThreadLocal.classInfo.getCanonicalName -  |  |  |  V     |  | \n *   11:48:37.383    +123ms  4 Started    1932 ..ang.NegativeArraySizeException.classInfo.getDeclaredConstructor -  |  |  |     o  |  | \n */",
        "start_line": 0,
        "end_line": 39,
        "chunk_index": 0,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 690,
        "node_type": null,
        "file_sha": "7d02f37aa81c790b5cec21bd1c3a21716e7488f9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.329210"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord.Action;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This formatter produces detailed information about every record in the remaining execution logs.\n * \n * Example output:\n *    Timestamp       Delta Thr Event      Test   Test name                                                         0  1  2  3  4  5  6\n *   11:48:37.371    +111ms  0 Started    1147 ..testlet.java.lang.ExceptionInInitializerError.classInfo.isArray -  o                   \n *   11:48:37.371    +111ms  4 Started     942 gnu.testlet.java.lang.Double.classInfo.getDeclaredAnnotations     -  |           o       \n *   11:48:37.371    +111ms  2 Started    2528 gnu.testlet.java.lang.Short.classInfo.isAssignableFrom            -  |     o     |       \n *   11:48:37.372    +112ms  5 Started     874 ..let.java.lang.ClassNotFoundException.classInfo.isAnonymousClass -  |     |     |  o    \n *   11:48:37.372    +112ms  3 Started    1557 ..let.java.lang.InheritableThreadLocal.classInfo.getCanonicalName -  |     |  o  |  |    \n *   11:48:37.375    +115ms  1 Started    1513 ..et.java.lang.IndexOutOfBoundsException.classInfo.getAnnotations -  |  o  |  |  |  |    \n *   11:48:37.375    +115ms  6 Started    3133 gnu.testlet.java.text.AttributedString.getIterator                -  |  |  |  |  |  |  o \n *   11:48:37.383    +123ms  4 Completed   942 gnu.testlet.java.lang.Double.classInfo.getDeclaredAnnotations     -  |  |  |  |  V  |  | \n *   11:48:37.383    +123ms  3 Passed     1557 ..let.java.lang.InheritableThreadLocal.classInfo.getCanonicalName -  |  |  |  V     |  | \n *   11:48:37.383    +123ms  4 Started    1932 ..ang.NegativeArraySizeException.classInfo.getDeclaredConstructor -  |  |  |     o  |  | \n */"
    },
    "422": {
      "metadata": {
        "chunk_id": "e50070bdc583881e8d3ce9a97e7c094b2a5963bafa66c625ca6d276cab100788",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/DetailFormatter.java",
        "content": "public class DetailFormatter implements FormatterInterface {\n\tprivate SimpleDateFormat formatter;\n\tprivate boolean verbose;\n\t\n\t// Buffer the output to improve performance. This buffer almost halves execution time.\n\tprivate StringBuilder outputBuffer = new StringBuilder();\n\n\t// Create an array to keep track of whether or not each thread is working. Index by column number\n    boolean[] threadRunningTest = null; \n    \n    // Store name for each test. Possibly truncated due to lack of space\n    private int MAX_TEST_NAME = 65;\n    private String testNames[];\n    \n\t\n\tpublic void start(ExecutionLogMetaData metaData, boolean verbose) {\n\t\tthis.verbose = verbose;\n\t\tthis.formatter = metaData.getFormatter();\n\t\tthis.threadRunningTest = new boolean[metaData.getTotalNumberThreads()];\n\n\t\t// Build array containing names for all tests\n\t\ttestNames = new String[metaData.getTotalNumberTests()];\n\t\tfor (int testNum=0; testNum<metaData.getTotalNumberTests(); testNum++) {\n\t\t\tString className = metaData.getTestClassName(testNum);\n\t\t\tString methodName = metaData.getTestMethodName(testNum);\n\t\t\tif (className == null) {\n\t\t\t\ttestNames[testNum] = \"\";\n\t\t\t} else {\n\t\t\t\tString testName = className;\n\t\t\t\tif (!methodName.isEmpty()) {\n\t\t\t\t\t// Must be an arbitrary java test. Add the method name onto the test name\n\t\t\t\t\ttestName = testName + \":\" + methodName + \"()\";\n\t\t\t\t}\n\t\t\t\ttestNames[testNum] = testName;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Examine all test names and truncate those that are too long.\n\t\tboolean truncationDone = false;\n\t\tfor (int i=0; i<testNames.length; i++) {\n\t\t\tString testName = testNames[i];\n\t\t\tif (testName.length() > MAX_TEST_NAME) {\n\t\t\t\tint trailingPartStart = Math.max(0, testName.length()-MAX_TEST_NAME+2);\n\t\t\t\tString truncatedTestName = \"..\" + testName.substring(trailingPartStart);\n\t\t\t\ttestNames[i] = truncatedTestName;\n\t\t\t\t\n\t\t\t\tif (!truncationDone) {\n\t\t\t\t\tSystem.out.println(\"Truncated test names:\");\n\t\t\t\t\ttruncationDone = true;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"  Test \" + i + \": \" + testName + \" -> \" + truncatedTestName);\n\t\t\t}\n\t\t}\n\t\tif (truncationDone) { \n\t\t\tSystem.out.println();\n\t\t}",
        "start_line": 40,
        "end_line": 95,
        "chunk_index": 1,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 489,
        "node_type": null,
        "file_sha": "7d02f37aa81c790b5cec21bd1c3a21716e7488f9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.329224"
      },
      "text": "public class DetailFormatter implements FormatterInterface {\n\tprivate SimpleDateFormat formatter;\n\tprivate boolean verbose;\n\t\n\t// Buffer the output to improve performance. This buffer almost halves execution time.\n\tprivate StringBuilder outputBuffer = new StringBuilder();\n\n\t// Create an array to keep track of whether or not each thread is working. Index by column number\n    boolean[] threadRunningTest = null; \n    \n    // Store name for each test. Possibly truncated due to lack of space\n    private int MAX_TEST_NAME = 65;\n    private String testNames[];\n    \n\t\n\tpublic void start(ExecutionLogMetaData metaData, boolean verbose) {\n\t\tthis.verbose = verbose;\n\t\tthis.formatter = metaData.getFormatter();\n\t\tthis.threadRunningTest = new boolean[metaData.getTotalNumberThreads()];\n\n\t\t// Build array containing names for all tests\n\t\ttestNames = new String[metaData.getTotalNumberTests()];\n\t\tfor (int testNum=0; testNum<metaData.getTotalNumberTests(); testNum++) {\n\t\t\tString className = metaData.getTestClassName(testNum);\n\t\t\tString methodName = metaData.getTestMethodName(testNum);\n\t\t\tif (className == null) {\n\t\t\t\ttestNames[testNum] = \"\";\n\t\t\t} else {\n\t\t\t\tString testName = className;\n\t\t\t\tif (!methodName.isEmpty()) {\n\t\t\t\t\t// Must be an arbitrary java test. Add the method name onto the test name\n\t\t\t\t\ttestName = testName + \":\" + methodName + \"()\";\n\t\t\t\t}\n\t\t\t\ttestNames[testNum] = testName;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Examine all test names and truncate those that are too long.\n\t\tboolean truncationDone = false;\n\t\tfor (int i=0; i<testNames.length; i++) {\n\t\t\tString testName = testNames[i];\n\t\t\tif (testName.length() > MAX_TEST_NAME) {\n\t\t\t\tint trailingPartStart = Math.max(0, testName.length()-MAX_TEST_NAME+2);\n\t\t\t\tString truncatedTestName = \"..\" + testName.substring(trailingPartStart);\n\t\t\t\ttestNames[i] = truncatedTestName;\n\t\t\t\t\n\t\t\t\tif (!truncationDone) {\n\t\t\t\t\tSystem.out.println(\"Truncated test names:\");\n\t\t\t\t\ttruncationDone = true;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"  Test \" + i + \": \" + testName + \" -> \" + truncatedTestName);\n\t\t\t}\n\t\t}\n\t\tif (truncationDone) { \n\t\t\tSystem.out.println();\n\t\t}"
    },
    "423": {
      "metadata": {
        "chunk_id": "e3d1ff90df5ced8ece8d9c52779d7ca3a3506c865e4aa261314258b3d49f0456",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/DetailFormatter.java",
        "content": "// Explain which suite owns which threads\n\t\tSystem.out.println(\"Ownership of \" + metaData.getTotalNumberThreads() + \" worker threads:\");\n\t    int firstThreadNum = 0;\n\t    int lastThreadNum = 0;\n\t    for (int s=0; s<metaData.getNumberSuites(); s++) {\n\t    \tlastThreadNum = firstThreadNum + metaData.getSuiteNumThreads(s) - 1;\n\t    \tif (firstThreadNum == lastThreadNum) {\n\t    \t\tSystem.out.println(\"  Suite \" + s + \" owns thread: \" + firstThreadNum);\n\t    \t} else {\n\t    \t\tSystem.out.println(\"  Suite \" + s + \" owns threads: \" + firstThreadNum + \" to \" + lastThreadNum);\n\t    \t}\n\t    \tfirstThreadNum = lastThreadNum + 1;\n\t    }\n\t    System.out.println();\n\t    \n    \t// Output header lines to show which suites owns which threads. eg,\n    \t//   <--- suite 0 ----><-- suite 1 -->< suite 2 -><---3---><--4-><5>\n    \t//    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\t    if (metaData.getNumberSuites() > 1) {\n\t    \tint leadingSpaces = 42 + MAX_TEST_NAME + 3;\n\t    \tSystem.out.print(String.format(\"%\" + leadingSpaces + \"s\", \"\"));\n\t\t    for (int s=0; s<metaData.getNumberSuites(); s++) {\n\t\t    \t// Build a char array such as '<----------->'\n\t\t    \tchar[] header = new char[metaData.getSuiteNumThreads(s)*3];\n\t\t    \theader[0] = '<';\n\t\t    \tfor (int i=1; i<header.length-1; i++) {\n\t\t    \t\theader[i] = '-';\n\t\t    \t}\n\t\t    \theader[header.length-1] = '>';\n\t\t    \t\n\t\t    \t// Add the suite number to the header string\n\t\t    \tif (metaData.getSuiteNumThreads(s) < 4) {\n\t\t    \t\t// Output the suite number in the middle of the '<---->' string, eg, '<--3->'\n\t\t    \t\theader[header.length/2] = (char)(s + '0');\n\t\t    \t} else {\n\t\t    \t\t// Add longer descriptive text and suite number, to create string such as '<-- suite 1 -->'\n\t\t    \t\tchar[] suiteLabel = (\" suite \" + s + \" \").toCharArray();\n\t\t    \t\tint insertPos = (header.length - suiteLabel.length) /2;\n\t\t    \t\tSystem.arraycopy(suiteLabel, 0, header, insertPos, suiteLabel.length);\n\t\t    \t}\n\t\t    \tSystem.out.print(header);\n\t\t    }\n\t\t    System.out.println();\n\t    }\n\t    \n\t    \n\t    // Output banner line to describe column contents\n\t    System.out.print(String.format(\" Timestamp       Delta Thr Event      Test   Test name %\" + (MAX_TEST_NAME-11) + \"s\", \" \"));\n\t    for (int i=0; i<metaData.getTotalNumberThreads(); i++) {\n\t    \t// Output thread number\n\t    \tSystem.out.print(String.format(\"%3d\", i));\n\t    }\n\t    System.out.println();\n\t}\n\n\n\t\n\tpublic void processRecord(int logFile, ExecutionRecord record, long offset) {\n\t\t// Prepare data for start of trace line\n    \tString formattedTime = formatter.format(new Date(record.getTimestamp()));\n\t\tAction action = record.getAction();\n\t\tint threadNumber = record.getThreadNum();\n\t\tint testNumber = record.getTestNum();\n\n\t\t// Output first part of event line: timestamp, testname, etc. \n\t\tString tracePrefix = String.format(\"%s %+7dms %2d %-10s %4d %-\" + MAX_TEST_NAME + \"s - \", \n\t\t\t\tformattedTime, offset, threadNumber, action.getName(), testNumber, testNames[testNumber]);\n\t\toutputBuffer.append(tracePrefix);\n\t\t\n\t\t// Output activity summary for each thread. 3 characters per thread.\n\t\tfor (int i=0; i<threadRunningTest.length; i++) {\n\t\t\tif (i == threadNumber && action == Action.STARTED) {\n\t\t\t\tthreadRunningTest[i] = true;\n\t\t\t\toutputBuffer.append(\" o \");\n\t\t\t} else if (i == threadNumber && action.isFailure()) {\n\t\t\t\tthreadRunningTest[i] = false;\n\t\t\t\toutputBuffer.append(\" # \");\n\t\t\t} else if (i == threadNumber) {\n\t\t\t\tthreadRunningTest[i] = false;\n\t\t\t\toutputBuffer.append(\" V \");\n\t\t\t} else if (threadRunningTest[i]) {\n\t\t\t\toutputBuffer.append(\" | \");\n\t\t\t} else {\n\t\t\t\toutputBuffer.append(\"   \");\n\t\t\t}\n\t\t}\n\t\toutputBuffer.append(\"\\n\");\n\n\t\t// Show output from failed tests when in verbose mode\n\t\tif (verbose && action.hasOutput()) {\n\t\t\toutputBuffer.append(record.getOutputAsString() + \"/n\");\n\t\t}",
        "start_line": 96,
        "end_line": 187,
        "chunk_index": 2,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 1032,
        "node_type": null,
        "file_sha": "7d02f37aa81c790b5cec21bd1c3a21716e7488f9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.329227"
      },
      "text": "// Explain which suite owns which threads\n\t\tSystem.out.println(\"Ownership of \" + metaData.getTotalNumberThreads() + \" worker threads:\");\n\t    int firstThreadNum = 0;\n\t    int lastThreadNum = 0;\n\t    for (int s=0; s<metaData.getNumberSuites(); s++) {\n\t    \tlastThreadNum = firstThreadNum + metaData.getSuiteNumThreads(s) - 1;\n\t    \tif (firstThreadNum == lastThreadNum) {\n\t    \t\tSystem.out.println(\"  Suite \" + s + \" owns thread: \" + firstThreadNum);\n\t    \t} else {\n\t    \t\tSystem.out.println(\"  Suite \" + s + \" owns threads: \" + firstThreadNum + \" to \" + lastThreadNum);\n\t    \t}\n\t    \tfirstThreadNum = lastThreadNum + 1;\n\t    }\n\t    System.out.println();\n\t    \n    \t// Output header lines to show which suites owns which threads. eg,\n    \t//   <--- suite 0 ----><-- suite 1 -->< suite 2 -><---3---><--4-><5>\n    \t//    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\t    if (metaData.getNumberSuites() > 1) {\n\t    \tint leadingSpaces = 42 + MAX_TEST_NAME + 3;\n\t    \tSystem.out.print(String.format(\"%\" + leadingSpaces + \"s\", \"\"));\n\t\t    for (int s=0; s<metaData.getNumberSuites(); s++) {\n\t\t    \t// Build a char array such as '<----------->'\n\t\t    \tchar[] header = new char[metaData.getSuiteNumThreads(s)*3];\n\t\t    \theader[0] = '<';\n\t\t    \tfor (int i=1; i<header.length-1; i++) {\n\t\t    \t\theader[i] = '-';\n\t\t    \t}\n\t\t    \theader[header.length-1] = '>';\n\t\t    \t\n\t\t    \t// Add the suite number to the header string\n\t\t    \tif (metaData.getSuiteNumThreads(s) < 4) {\n\t\t    \t\t// Output the suite number in the middle of the '<---->' string, eg, '<--3->'\n\t\t    \t\theader[header.length/2] = (char)(s + '0');\n\t\t    \t} else {\n\t\t    \t\t// Add longer descriptive text and suite number, to create string such as '<-- suite 1 -->'\n\t\t    \t\tchar[] suiteLabel = (\" suite \" + s + \" \").toCharArray();\n\t\t    \t\tint insertPos = (header.length - suiteLabel.length) /2;\n\t\t    \t\tSystem.arraycopy(suiteLabel, 0, header, insertPos, suiteLabel.length);\n\t\t    \t}\n\t\t    \tSystem.out.print(header);\n\t\t    }\n\t\t    System.out.println();\n\t    }\n\t    \n\t    \n\t    // Output banner line to describe column contents\n\t    System.out.print(String.format(\" Timestamp       Delta Thr Event      Test   Test name %\" + (MAX_TEST_NAME-11) + \"s\", \" \"));\n\t    for (int i=0; i<metaData.getTotalNumberThreads(); i++) {\n\t    \t// Output thread number\n\t    \tSystem.out.print(String.format(\"%3d\", i));\n\t    }\n\t    System.out.println();\n\t}\n\n\n\t\n\tpublic void processRecord(int logFile, ExecutionRecord record, long offset) {\n\t\t// Prepare data for start of trace line\n    \tString formattedTime = formatter.format(new Date(record.getTimestamp()));\n\t\tAction action = record.getAction();\n\t\tint threadNumber = record.getThreadNum();\n\t\tint testNumber = record.getTestNum();\n\n\t\t// Output first part of event line: timestamp, testname, etc. \n\t\tString tracePrefix = String.format(\"%s %+7dms %2d %-10s %4d %-\" + MAX_TEST_NAME + \"s - \", \n\t\t\t\tformattedTime, offset, threadNumber, action.getName(), testNumber, testNames[testNumber]);\n\t\toutputBuffer.append(tracePrefix);\n\t\t\n\t\t// Output activity summary for each thread. 3 characters per thread.\n\t\tfor (int i=0; i<threadRunningTest.length; i++) {\n\t\t\tif (i == threadNumber && action == Action.STARTED) {\n\t\t\t\tthreadRunningTest[i] = true;\n\t\t\t\toutputBuffer.append(\" o \");\n\t\t\t} else if (i == threadNumber && action.isFailure()) {\n\t\t\t\tthreadRunningTest[i] = false;\n\t\t\t\toutputBuffer.append(\" # \");\n\t\t\t} else if (i == threadNumber) {\n\t\t\t\tthreadRunningTest[i] = false;\n\t\t\t\toutputBuffer.append(\" V \");\n\t\t\t} else if (threadRunningTest[i]) {\n\t\t\t\toutputBuffer.append(\" | \");\n\t\t\t} else {\n\t\t\t\toutputBuffer.append(\"   \");\n\t\t\t}\n\t\t}\n\t\toutputBuffer.append(\"\\n\");\n\n\t\t// Show output from failed tests when in verbose mode\n\t\tif (verbose && action.hasOutput()) {\n\t\t\toutputBuffer.append(record.getOutputAsString() + \"/n\");\n\t\t}"
    },
    "424": {
      "metadata": {
        "chunk_id": "0005d90b5a1c777920c1ac0e969bc393b84006b65a28307a81c2321fcf40b507",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/DetailFormatter.java",
        "content": "// Show output from failed tests when in verbose mode\n\t\tif (verbose && action.hasOutput()) {\n\t\t\toutputBuffer.append(record.getOutputAsString() + \"/n\");\n\t\t}\n\n\t\t// Flush output if enough has built up\n\t\tif (outputBuffer.length() > 4000) {\n\t\t\tSystem.out.print(outputBuffer);\n\t\t\toutputBuffer.setLength(0);\n\t\t}\n\t}\n\t\n\t\n\tpublic void missingLogFile(int missingLogNumber) {\n\t\t// Output text to show that there is a gap in the log files\n\t\toutputBuffer.append(String.format(\"%-\" + (44 + MAX_TEST_NAME) + \"s\", \"  Hole detected in log files. Missing log file number=\" + missingLogNumber));\n\t\tStringBuilder perforations = new StringBuilder();\n\t\twhile (perforations.length() < threadRunningTest.length*3) {\n\t\t\tperforations.append(\"^v\");\n\t\t}\n\t\toutputBuffer.append(perforations + \"/n\");\n\t\t\n\t\t// Reset thread state, as we have no idea if they are busy or not.\n\t\tfor (int i=0; i<threadRunningTest.length; i++) {\n\t\t\tthreadRunningTest[i] = false;\n\t\t}\n\t}\n\n\t\n\tpublic void end() {\n\t\t// Flush any remaining output\n\t\tif (outputBuffer.length() > 0) {\n\t\t\tSystem.out.print(outputBuffer);\n\t\t}\n\t}\n}",
        "start_line": 188,
        "end_line": 223,
        "chunk_index": 3,
        "total_chunks": 4,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 286,
        "node_type": null,
        "file_sha": "7d02f37aa81c790b5cec21bd1c3a21716e7488f9",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.329229"
      },
      "text": "// Show output from failed tests when in verbose mode\n\t\tif (verbose && action.hasOutput()) {\n\t\t\toutputBuffer.append(record.getOutputAsString() + \"/n\");\n\t\t}\n\n\t\t// Flush output if enough has built up\n\t\tif (outputBuffer.length() > 4000) {\n\t\t\tSystem.out.print(outputBuffer);\n\t\t\toutputBuffer.setLength(0);\n\t\t}\n\t}\n\t\n\t\n\tpublic void missingLogFile(int missingLogNumber) {\n\t\t// Output text to show that there is a gap in the log files\n\t\toutputBuffer.append(String.format(\"%-\" + (44 + MAX_TEST_NAME) + \"s\", \"  Hole detected in log files. Missing log file number=\" + missingLogNumber));\n\t\tStringBuilder perforations = new StringBuilder();\n\t\twhile (perforations.length() < threadRunningTest.length*3) {\n\t\t\tperforations.append(\"^v\");\n\t\t}\n\t\toutputBuffer.append(perforations + \"/n\");\n\t\t\n\t\t// Reset thread state, as we have no idea if they are busy or not.\n\t\tfor (int i=0; i<threadRunningTest.length; i++) {\n\t\t\tthreadRunningTest[i] = false;\n\t\t}\n\t}\n\n\t\n\tpublic void end() {\n\t\t// Flush any remaining output\n\t\tif (outputBuffer.length() > 0) {\n\t\t\tSystem.out.print(outputBuffer);\n\t\t}\n\t}\n}"
    },
    "425": {
      "metadata": {
        "chunk_id": "80e106846334982d9816fc459dac004e44bc69c0d2b5110661c9732b69852e4f",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/FailureFormatter.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This formatter summaries the results from a run.\n *  \n * It lists the key data about each individual execution log and displays overall \n * pass/fail counts.\n * \n * Example output:\n * Test failures:\n *   Failure 1) Test number=3 Test=net.adoptopenjdk.stf.sample.ArbitraryJavaTest:runTest()\n *   Failure 2) Test number=25 Test=net.adoptopenjdk.stf.sample.ArbitraryJavaTest:runTest()\n *   Failure 3) Test number=46 Test=net.adoptopenjdk.stf.sample.ArbitraryJavaTest:runTest()\n * or with '--verbose':\n *   Test failures:\n *     Failure 1) Test number=3 Test=net.adoptopenjdk.stf.sample.ArbitraryJavaTest:runTest()\n *   Test failed:\n *   java.lang.IllegalStateException: forced failure\n *   \tat net.adoptopenjdk.stf.sample.ArbitraryJavaTest.runTest(ArbitraryJavaTest.java:55)\n *   \tat sun.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)\n *   \tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)\n *   ...\n */\npublic class FailureFormatter implements FormatterInterface {\n\tprivate ExecutionLogMetaData metaData;\n\tprivate boolean verbose;\n\t\n\tprivate int numFailuresFound = 0;\n\tprivate int numMissingLogs = 0;\n\n\tpublic void start(ExecutionLogMetaData metaData, boolean verbose) {\n\t\tthis.metaData = metaData;\n\t\tthis.verbose = verbose;\n\t}\n\n\t\n\tpublic void processRecord(int logFile, ExecutionRecord record, long offset) {\n\t\tif (record.getAction().isFailure()) {\n\t\t\t// Print heading\n\t\t\tif (numFailuresFound == 0) {\n\t\t\t\tSystem.out.println(\"Test failures:\");\n\t\t\t}\n\t\t\tnumFailuresFound++;\n\t\t\t\n\t\t\t// Output details about the failure\n\t\t\tint testNum = record.getTestNum();\n\t\t\tSystem.out.print(\"  Failure \" + numFailuresFound + \") Test number=\" + testNum + \" Test=\" + metaData.getTestClassName(testNum));\n\t\t\tif (metaData.getTestMethodName(testNum).length() > 0) {\n\t\t\t\tSystem.out.print(\":\" + metaData.getTestMethodName(testNum) + \"()\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\tif (verbose && record.getAction().hasOutput()) {\n\t\t\t\tSystem.out.println(record.getOutputAsString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic void missingLogFile(int missingLogNumber) {\n\t\tnumMissingLogs++;\n\t}\n\n\n\tpublic void end() {\n\t\tif (numFailuresFound == 0) {\n\t\t\tSystem.out.println(\"No failures found.\");\n\t\t}\n\t\tif (numMissingLogs > 0) {\n\t\t\tSystem.out.println(\"Note: \" + numMissingLogs + \" log files are missing.\");\n\t\t}\n\t}\n}",
        "start_line": 0,
        "end_line": 90,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 745,
        "node_type": null,
        "file_sha": "e43cf75e2d90f1bc67b1c2c440070f19ff082373",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.359837"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This formatter summaries the results from a run.\n *  \n * It lists the key data about each individual execution log and displays overall \n * pass/fail counts.\n * \n * Example output:\n * Test failures:\n *   Failure 1) Test number=3 Test=net.adoptopenjdk.stf.sample.ArbitraryJavaTest:runTest()\n *   Failure 2) Test number=25 Test=net.adoptopenjdk.stf.sample.ArbitraryJavaTest:runTest()\n *   Failure 3) Test number=46 Test=net.adoptopenjdk.stf.sample.ArbitraryJavaTest:runTest()\n * or with '--verbose':\n *   Test failures:\n *     Failure 1) Test number=3 Test=net.adoptopenjdk.stf.sample.ArbitraryJavaTest:runTest()\n *   Test failed:\n *   java.lang.IllegalStateException: forced failure\n *   \tat net.adoptopenjdk.stf.sample.ArbitraryJavaTest.runTest(ArbitraryJavaTest.java:55)\n *   \tat sun.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)\n *   \tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)\n *   ...\n */\npublic class FailureFormatter implements FormatterInterface {\n\tprivate ExecutionLogMetaData metaData;\n\tprivate boolean verbose;\n\t\n\tprivate int numFailuresFound = 0;\n\tprivate int numMissingLogs = 0;\n\n\tpublic void start(ExecutionLogMetaData metaData, boolean verbose) {\n\t\tthis.metaData = metaData;\n\t\tthis.verbose = verbose;\n\t}\n\n\t\n\tpublic void processRecord(int logFile, ExecutionRecord record, long offset) {\n\t\tif (record.getAction().isFailure()) {\n\t\t\t// Print heading\n\t\t\tif (numFailuresFound == 0) {\n\t\t\t\tSystem.out.println(\"Test failures:\");\n\t\t\t}\n\t\t\tnumFailuresFound++;\n\t\t\t\n\t\t\t// Output details about the failure\n\t\t\tint testNum = record.getTestNum();\n\t\t\tSystem.out.print(\"  Failure \" + numFailuresFound + \") Test number=\" + testNum + \" Test=\" + metaData.getTestClassName(testNum));\n\t\t\tif (metaData.getTestMethodName(testNum).length() > 0) {\n\t\t\t\tSystem.out.print(\":\" + metaData.getTestMethodName(testNum) + \"()\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\tif (verbose && record.getAction().hasOutput()) {\n\t\t\t\tSystem.out.println(record.getOutputAsString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic void missingLogFile(int missingLogNumber) {\n\t\tnumMissingLogs++;\n\t}\n\n\n\tpublic void end() {\n\t\tif (numFailuresFound == 0) {\n\t\t\tSystem.out.println(\"No failures found.\");\n\t\t}\n\t\tif (numMissingLogs > 0) {\n\t\t\tSystem.out.println(\"Note: \" + numMissingLogs + \" log files are missing.\");\n\t\t}\n\t}\n}"
    },
    "426": {
      "metadata": {
        "chunk_id": "c3b821a2f958941212a6e6e528df1b4e4b88ce871d09198bafc37dc368960416",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/FormatterInterface.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This interface allows different data formatters to be used by the FormatExecutionLog program. \n */\npublic interface FormatterInterface {\n\t/**\n\t * Called before opening any load test execution log files, to allow the\n\t * formatter to initialise itself. \n\t * @param metaData basically holds the contents of the .ltm metadata file.\n\t * @param verbose If set to true then the formatter should provide appropriate extra information.\n\t */\n\tvoid start(ExecutionLogMetaData metaData, boolean verbose);\n\n\t/**\n\t * Called when a gap in execution log files is detected. It is called for each missing log file.\n\t * This method is called when the gap is detected. eg, if log file 4 is \n\t * missing then the callback sequence would be 1) processRecord(last-from-log-3), 2) missingLogFile(4)\n\t * and then 3) processRecord(first-from-log5).\n\t * @param missingLogNumber is the number of the missing log file.\n\t */\n\tvoid missingLogFile(int missingLogNumber);\n\n\t/**\n\t * Allows the formatter to examine a single execution log file.\n\t * @param logFile is the number of the log file containing this record.\n\t * @param record contains information about a test start/end from the .ltd file.\n\t * @param offset is the number of milliseconds between the start of the run and\n\t * the original creation of this record. \n\t */\n\tvoid processRecord(int logFile, ExecutionRecord record, long offset);\n\n\t/**\n\t * Called at the end of execution log file processing, for those formatters that \n\t * need to produce their output at the end.\n\t */\n\tvoid end();\n}",
        "start_line": 0,
        "end_line": 55,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 504,
        "node_type": null,
        "file_sha": "47128cc11aff25e519064d9dc7d61824af347a43",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.380917"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This interface allows different data formatters to be used by the FormatExecutionLog program. \n */\npublic interface FormatterInterface {\n\t/**\n\t * Called before opening any load test execution log files, to allow the\n\t * formatter to initialise itself. \n\t * @param metaData basically holds the contents of the .ltm metadata file.\n\t * @param verbose If set to true then the formatter should provide appropriate extra information.\n\t */\n\tvoid start(ExecutionLogMetaData metaData, boolean verbose);\n\n\t/**\n\t * Called when a gap in execution log files is detected. It is called for each missing log file.\n\t * This method is called when the gap is detected. eg, if log file 4 is \n\t * missing then the callback sequence would be 1) processRecord(last-from-log-3), 2) missingLogFile(4)\n\t * and then 3) processRecord(first-from-log5).\n\t * @param missingLogNumber is the number of the missing log file.\n\t */\n\tvoid missingLogFile(int missingLogNumber);\n\n\t/**\n\t * Allows the formatter to examine a single execution log file.\n\t * @param logFile is the number of the log file containing this record.\n\t * @param record contains information about a test start/end from the .ltd file.\n\t * @param offset is the number of milliseconds between the start of the run and\n\t * the original creation of this record. \n\t */\n\tvoid processRecord(int logFile, ExecutionRecord record, long offset);\n\n\t/**\n\t * Called at the end of execution log file processing, for those formatters that \n\t * need to produce their output at the end.\n\t */\n\tvoid end();\n}"
    },
    "427": {
      "metadata": {
        "chunk_id": "1b287cae686396cd5dea0d5ee0f97162402f57b32555813f67022f6f1a653ca5",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/MetaDataFormatter.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This formatter dumps the data which has been read from the metadata file.\n */\npublic class MetaDataFormatter implements FormatterInterface {\n\tpublic void start(ExecutionLogMetaData metaData, boolean verbose) {\n\t\tSimpleDateFormat formatter = metaData.getFormatter();\n\n\t\tSystem.out.println(\"File version: \" + metaData.getVersion());\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Start time:   \" + formatter.format(new Date(metaData.getBaseTimestamp())));\n\t\tSystem.out.println(\"Time zone:    \" + metaData.getTimeZoneId());\n\t\tSystem.out.println();\n\t\t\n\t\t// Output suite information\n\t\tSystem.out.println(\"Number suites: \"  + metaData.getNumberSuites());\n\t\tfor (int suiteNum=0; suiteNum<metaData.getNumberSuites(); suiteNum++) {\n\t\t\tSystem.out.println(\"Suite \" + suiteNum);\n\t\t\tSystem.out.println(\"  Number threads: \" + metaData.getSuiteNumThreads(suiteNum));\n\t\t\tSystem.out.println(\"  Inventory     : \" + metaData.getSuiteInventoryName(suiteNum));\n\t\t\tSystem.out.println(\"  Number tests  : \" + metaData.getSuiteNumTests(suiteNum));\n\t\t}\n\t\t\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Total thread count: \" + metaData.getTotalNumberThreads());\n\n\t\t// Output information about each test\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Tests\");\n\t\tfor (int testNum=0; testNum<metaData.getTotalNumberTests(); testNum++) {\n\t\t\tString className = metaData.getTestClassName(testNum);\n\t\t\tString methodName = metaData.getTestMethodName(testNum);\n\t\t\tif (className == null) {\n\t\t\t\tSystem.out.println(\"  #\" + testNum + \" <ignored>\");\n\t\t\t} else {\n\t\t\t\tString methodDescription = methodName.isEmpty() ? \"\" : \" method:\"+methodName;\n\t\t\t\tSystem.out.println(\"  #\" + testNum + \" \" + className + methodDescription);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic void processRecord(int logFile, ExecutionRecord record, long offset) {\n\t}\n\n\tpublic void missingLogFile(int missingLogNumber) {\n\t}\n\t\n\tpublic void end() {\n\t}\n}",
        "start_line": 0,
        "end_line": 72,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 591,
        "node_type": null,
        "file_sha": "e53feaf1fe470137308e7970a4dbf00e7cca4151",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.406365"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This formatter dumps the data which has been read from the metadata file.\n */\npublic class MetaDataFormatter implements FormatterInterface {\n\tpublic void start(ExecutionLogMetaData metaData, boolean verbose) {\n\t\tSimpleDateFormat formatter = metaData.getFormatter();\n\n\t\tSystem.out.println(\"File version: \" + metaData.getVersion());\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Start time:   \" + formatter.format(new Date(metaData.getBaseTimestamp())));\n\t\tSystem.out.println(\"Time zone:    \" + metaData.getTimeZoneId());\n\t\tSystem.out.println();\n\t\t\n\t\t// Output suite information\n\t\tSystem.out.println(\"Number suites: \"  + metaData.getNumberSuites());\n\t\tfor (int suiteNum=0; suiteNum<metaData.getNumberSuites(); suiteNum++) {\n\t\t\tSystem.out.println(\"Suite \" + suiteNum);\n\t\t\tSystem.out.println(\"  Number threads: \" + metaData.getSuiteNumThreads(suiteNum));\n\t\t\tSystem.out.println(\"  Inventory     : \" + metaData.getSuiteInventoryName(suiteNum));\n\t\t\tSystem.out.println(\"  Number tests  : \" + metaData.getSuiteNumTests(suiteNum));\n\t\t}\n\t\t\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Total thread count: \" + metaData.getTotalNumberThreads());\n\n\t\t// Output information about each test\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Tests\");\n\t\tfor (int testNum=0; testNum<metaData.getTotalNumberTests(); testNum++) {\n\t\t\tString className = metaData.getTestClassName(testNum);\n\t\t\tString methodName = metaData.getTestMethodName(testNum);\n\t\t\tif (className == null) {\n\t\t\t\tSystem.out.println(\"  #\" + testNum + \" <ignored>\");\n\t\t\t} else {\n\t\t\t\tString methodDescription = methodName.isEmpty() ? \"\" : \" method:\"+methodName;\n\t\t\t\tSystem.out.println(\"  #\" + testNum + \" \" + className + methodDescription);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic void processRecord(int logFile, ExecutionRecord record, long offset) {\n\t}\n\n\tpublic void missingLogFile(int missingLogNumber) {\n\t}\n\t\n\tpublic void end() {\n\t}\n}"
    },
    "428": {
      "metadata": {
        "chunk_id": "aaf381c3f0d6bcca767d4b51cff6397490a4a659d9670864bf414b5a5b36d6aa",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/SummaryFormatter.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord.Action;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This formatter summaries the results from a run.\n *  \n * It lists the key data about each individual execution log and displays overall \n * pass/fail counts.\n * \n * Example output::\n *   Log file summaries\n *     Part 1  Covers 10:00:41.934 to 10:00:41.956  Started:57 Passed:56 Failed:0\n *     Part 2  Covers 10:00:41.956 to 10:00:41.990  Started:57 Passed:56 Failed:0\n *     Part 3  Covers 10:00:41.991 to 10:00:42.011  Started:58 Passed:55 Failed:0\n *     Part 4  Missing\n *     Part 5  Missing\n *     Part 6  Covers 10:00:42.049 to 10:00:42.059  Started:36 Passed:37 Failed:0\n *   \n *   Log file counts\n *     Number log files found  : 4\n *     Number log files missing: 2\n *   \n *   Overall test result counts. Note: Partial results due to missing log file(s)\n *     Started: 208\n *     Passed : 204\n *     Failed : 0\n */",
        "start_line": 0,
        "end_line": 47,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 455,
        "node_type": null,
        "file_sha": "ab0d7ca80e7addbd58a8bc0d56866ce79fa0edea",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.428505"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTestAnalysis.formatter;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord;\nimport net.adoptopenjdk.loadTest.reporting.ExecutionRecord.Action;\nimport net.adoptopenjdk.loadTestAnalysis.ExecutionLogMetaData;\n\n\n/**\n * This formatter summaries the results from a run.\n *  \n * It lists the key data about each individual execution log and displays overall \n * pass/fail counts.\n * \n * Example output::\n *   Log file summaries\n *     Part 1  Covers 10:00:41.934 to 10:00:41.956  Started:57 Passed:56 Failed:0\n *     Part 2  Covers 10:00:41.956 to 10:00:41.990  Started:57 Passed:56 Failed:0\n *     Part 3  Covers 10:00:41.991 to 10:00:42.011  Started:58 Passed:55 Failed:0\n *     Part 4  Missing\n *     Part 5  Missing\n *     Part 6  Covers 10:00:42.049 to 10:00:42.059  Started:36 Passed:37 Failed:0\n *   \n *   Log file counts\n *     Number log files found  : 4\n *     Number log files missing: 2\n *   \n *   Overall test result counts. Note: Partial results due to missing log file(s)\n *     Started: 208\n *     Passed : 204\n *     Failed : 0\n */"
    },
    "429": {
      "metadata": {
        "chunk_id": "fce0cafaf5584f985528e9722a71fa3a68304987a0ee30f00c37f7365b341d47",
        "file_path": "stf.load/src/stf.load/net/adoptopenjdk/loadTestAnalysis/formatter/SummaryFormatter.java",
        "content": "public class SummaryFormatter implements FormatterInterface {\n\tSimpleDateFormat formatter;\n\t\n\t// Data on the current log file\n\tprivate int currLogFile = 0;\n\tprivate boolean haveLogData = false;\n\tprivate long logStartTime;\n\tprivate long logEndTime;\n\tprivate long numTestsStarted;\n\tprivate long numTestsFailed;\n\tprivate long numTestsPassed;\n\t\n\t// Overall test statistics\n\tprivate int numMissingLogFiles = 0;\n\tprivate long totalTestsStarted;\n\tprivate long totalTestsFailed;\n\tprivate long totalTestsPassed;\n\t\n\n\tpublic void start(ExecutionLogMetaData metaData, boolean verbose) {\n\t\tthis.formatter = metaData.getFormatter();\n\t\tSystem.out.println();\n\t}\n\n\t\n\tpublic void processRecord(int logFile, ExecutionRecord record, long offset) {\n\t\tif (currLogFile != logFile) {\n\t\t\tsummariseLogFile();\n\t\t\t\n\t\t\ttotalTestsStarted += numTestsStarted;\n\t\t\ttotalTestsFailed  += numTestsFailed;\n\t\t\ttotalTestsPassed  += numTestsPassed;\n\n\t\t\tcurrLogFile = logFile;\n\t\t\thaveLogData = true;\n\t\t\tlogStartTime = record.getTimestamp();\n\t\t\tnumTestsStarted = 0;\n\t\t\tnumTestsFailed  = 0;\n\t\t\tnumTestsPassed  = 0;\n\t\t}\n\t\t\n\t\tif (record.getAction() == Action.STARTED) {\n\t\t\tnumTestsStarted++;\n\t\t} else if (record.getAction().isFailure()) {\n\t\t\tnumTestsFailed++;\n\t\t} else {\n\t\t\tnumTestsPassed++;\n\t\t}\n\t\t\n\t\tlogEndTime = record.getTimestamp();\n\t}\n\t\n\t\n\tpublic void missingLogFile(int missingLogNumber) {\n\t\tsummariseLogFile();\n\t\tcurrLogFile = missingLogNumber;\n\t\thaveLogData = false;\n\n\t\tSystem.out.printf(\"  Part %2d  Missing\\n\", missingLogNumber);\n\t\tnumMissingLogFiles++;\n\t}\n\n\t\n\tprivate void summariseLogFile() {\n\t\tif (haveLogData) {\n\t\t\tif (currLogFile == 1) {\n\t\t\t\tSystem.out.println(\"Log file summaries\");\n\t\t\t}\n\t\t\t\n\t\t\tString failureIndicator = numTestsFailed > 0 ? \"* \" : \"  \";\n\t\t\tString startTimestamp = formatter.format(new Date(logStartTime));\n\t\t\tString endTimestamp   = formatter.format(new Date(logEndTime));\n\t\t\tSystem.out.printf(\"%sPart %2d  Covers %s to %s  Started:%d Passed:%d Failed:%d\\n\", failureIndicator, currLogFile, startTimestamp, endTimestamp, numTestsStarted, numTestsPassed, numTestsFailed);\n\t\t}\n\t}\n\t\n\t\n\tpublic void end() {\n\t\t// Report on the final log file\n\t\tsummariseLogFile();\n\t\t\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Log file counts\");\n\t\tSystem.out.println(\"  Number log files found  : \" + (currLogFile - numMissingLogFiles));\n\t\tSystem.out.println(\"  Number log files missing: \" + numMissingLogFiles);\n\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Overall test result counts\" + (numMissingLogFiles > 0 ? \". Note: Partial results due to missing log file(s)\" : \"\"));\n\t\tSystem.out.println(\"  Started: \" + (totalTestsStarted + numTestsStarted));\n\t\tSystem.out.println(\"  Passed : \" + (totalTestsPassed + numTestsPassed));\n\t\tSystem.out.println(\"  Failed : \" + (totalTestsFailed + numTestsFailed));\n\t}\n}",
        "start_line": 48,
        "end_line": 140,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 682,
        "node_type": null,
        "file_sha": "ab0d7ca80e7addbd58a8bc0d56866ce79fa0edea",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.428517"
      },
      "text": "public class SummaryFormatter implements FormatterInterface {\n\tSimpleDateFormat formatter;\n\t\n\t// Data on the current log file\n\tprivate int currLogFile = 0;\n\tprivate boolean haveLogData = false;\n\tprivate long logStartTime;\n\tprivate long logEndTime;\n\tprivate long numTestsStarted;\n\tprivate long numTestsFailed;\n\tprivate long numTestsPassed;\n\t\n\t// Overall test statistics\n\tprivate int numMissingLogFiles = 0;\n\tprivate long totalTestsStarted;\n\tprivate long totalTestsFailed;\n\tprivate long totalTestsPassed;\n\t\n\n\tpublic void start(ExecutionLogMetaData metaData, boolean verbose) {\n\t\tthis.formatter = metaData.getFormatter();\n\t\tSystem.out.println();\n\t}\n\n\t\n\tpublic void processRecord(int logFile, ExecutionRecord record, long offset) {\n\t\tif (currLogFile != logFile) {\n\t\t\tsummariseLogFile();\n\t\t\t\n\t\t\ttotalTestsStarted += numTestsStarted;\n\t\t\ttotalTestsFailed  += numTestsFailed;\n\t\t\ttotalTestsPassed  += numTestsPassed;\n\n\t\t\tcurrLogFile = logFile;\n\t\t\thaveLogData = true;\n\t\t\tlogStartTime = record.getTimestamp();\n\t\t\tnumTestsStarted = 0;\n\t\t\tnumTestsFailed  = 0;\n\t\t\tnumTestsPassed  = 0;\n\t\t}\n\t\t\n\t\tif (record.getAction() == Action.STARTED) {\n\t\t\tnumTestsStarted++;\n\t\t} else if (record.getAction().isFailure()) {\n\t\t\tnumTestsFailed++;\n\t\t} else {\n\t\t\tnumTestsPassed++;\n\t\t}\n\t\t\n\t\tlogEndTime = record.getTimestamp();\n\t}\n\t\n\t\n\tpublic void missingLogFile(int missingLogNumber) {\n\t\tsummariseLogFile();\n\t\tcurrLogFile = missingLogNumber;\n\t\thaveLogData = false;\n\n\t\tSystem.out.printf(\"  Part %2d  Missing\\n\", missingLogNumber);\n\t\tnumMissingLogFiles++;\n\t}\n\n\t\n\tprivate void summariseLogFile() {\n\t\tif (haveLogData) {\n\t\t\tif (currLogFile == 1) {\n\t\t\t\tSystem.out.println(\"Log file summaries\");\n\t\t\t}\n\t\t\t\n\t\t\tString failureIndicator = numTestsFailed > 0 ? \"* \" : \"  \";\n\t\t\tString startTimestamp = formatter.format(new Date(logStartTime));\n\t\t\tString endTimestamp   = formatter.format(new Date(logEndTime));\n\t\t\tSystem.out.printf(\"%sPart %2d  Covers %s to %s  Started:%d Passed:%d Failed:%d\\n\", failureIndicator, currLogFile, startTimestamp, endTimestamp, numTestsStarted, numTestsPassed, numTestsFailed);\n\t\t}\n\t}\n\t\n\t\n\tpublic void end() {\n\t\t// Report on the final log file\n\t\tsummariseLogFile();\n\t\t\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Log file counts\");\n\t\tSystem.out.println(\"  Number log files found  : \" + (currLogFile - numMissingLogFiles));\n\t\tSystem.out.println(\"  Number log files missing: \" + numMissingLogFiles);\n\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"Overall test result counts\" + (numMissingLogFiles > 0 ? \". Note: Partial results due to missing log file(s)\" : \"\"));\n\t\tSystem.out.println(\"  Started: \" + (totalTestsStarted + numTestsStarted));\n\t\tSystem.out.println(\"  Passed : \" + (totalTestsPassed + numTestsPassed));\n\t\tSystem.out.println(\"  Failed : \" + (totalTestsFailed + numTestsFailed));\n\t}\n}"
    },
    "430": {
      "metadata": {
        "chunk_id": "9ca73372169373d81bd35e116bdfd6e5706a6193a42ba608d6b992bf688ed9cb",
        "file_path": "stf.load/test/stf.load/com/ibm/runtimes/loadTest/reporting/TestExecutionLogManager.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\n\nimport org.junit.Test;\n\n\n/**\n * Test case to verify logic for load test log rotation is deleting the correct files.\n * \n * This is in a test case as it's pretty tricky to verify that the load test run \n * is leaving behind the most significant log files.\n * \n * Notation to represent each log file is:\n *   '-' is a retained log file\n *   ' ' is a deleted log file\n *   'X' is a retained log file which contains a failing test\n */",
        "start_line": 0,
        "end_line": 33,
        "chunk_index": 0,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 247,
        "node_type": null,
        "file_sha": "1dba549a69373953bb7741d04f2786a93d3698a5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.456123"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.loadTest.reporting;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\n\nimport org.junit.Test;\n\n\n/**\n * Test case to verify logic for load test log rotation is deleting the correct files.\n * \n * This is in a test case as it's pretty tricky to verify that the load test run \n * is leaving behind the most significant log files.\n * \n * Notation to represent each log file is:\n *   '-' is a retained log file\n *   ' ' is a deleted log file\n *   'X' is a retained log file which contains a failing test\n */"
    },
    "431": {
      "metadata": {
        "chunk_id": "520e2e5ac9eb818118d5b9ccb0080e4e78458a7ccb4709862961f0974392f73f",
        "file_path": "stf.load/test/stf.load/com/ibm/runtimes/loadTest/reporting/TestExecutionLogManager.java",
        "content": "public class TestExecutionLogManager {\n\tprivate int nextLogFileNumber = 0; \n\tprivate ExecutionLogManager logManager = new ExecutionLogManager(25);\n\t\n\t\n\t@Test\n\tpublic void testAllClean() {\n\t\tSystem.out.println(\"  All clean\");\n\t\taddPassingLog(\"[-]\");\n\t\taddPassingLog(\"[--]\");\n\t\taddPassingLog(\"[---]\");\n\t\taddPassingLog(\"[----]\");\n\t\taddPassingLog(\"[-----]\");\n\t\taddPassingLog(\"[------]\");\n\t\taddPassingLog(\"[-------]\");\n\t\taddPassingLog(\"[--------]\");\n\t\taddPassingLog(\"[---------]\");\n\t\taddPassingLog(\"[----------]\");\n\t\taddPassingLog(\"[-----------]\");\n\t\taddPassingLog(\"[------------]\");\n\t\taddPassingLog(\"[-------------]\");\n\t\taddPassingLog(\"[--------------]\");\n\t\taddPassingLog(\"[---------------]\");\n\t\taddPassingLog(\"[----------------]\");\n\t\taddPassingLog(\"[-----------------]\");\n\t\taddPassingLog(\"[------------------]\");\n\t\taddPassingLog(\"[-------------------]\");\n\t\taddPassingLog(\"[--------------------]\");\n\t\taddPassingLog(\"[---------------------]\");\n\t\taddPassingLog(\"[----------------------]\");\n\t\taddPassingLog(\"[-----------------------]\");\n\t\taddPassingLog(\"[------------------------]\");\n\t\taddPassingLog(\"[-------------------------]\");\n\t\taddPassingLog(\"[------------------------ -]\");\n\t\taddPassingLog(\"[------------------------  -]\");\n\t\taddPassingLog(\"[------------------------   -]\");\n\t\taddPassingLog(\"[------------------------    -]\");\n\t\taddPassingLog(\"[------------------------     -]\");\n\t\taddPassingLog(\"[------------------------      -]\");\n\t\taddPassingLog(\"[------------------------       -]\");\n\t\taddPassingLog(\"[------------------------        -]\");\n\t\taddPassingLog(\"[------------------------         -]\");\n\t\taddPassingLog(\"[------------------------          -]\");\n\t\taddPassingLog(\"[------------------------           -]\");\n\t\taddPassingLog(\"[------------------------            -]\");\n\t\taddPassingLog(\"[------------------------             -]\");\n\t\taddPassingLog(\"[------------------------              -]\");\n\t\taddPassingLog(\"[------------------------               -]\");\n\t\taddPassingLog(\"[------------------------                -]\");\n\t\taddPassingLog(\"[------------------------                 -]\");\n\t\taddPassingLog(\"[------------------------                  -]\");\n\t\taddPassingLog(\"[------------------------                   -]\");\n\t\taddPassingLog(\"[------------------------                    -]\");\n\t\taddPassingLog(\"[------------------------                     -]\");\n\t\taddPassingLog(\"[------------------------                      -]\");\n\t\taddPassingLog(\"[------------------------                       -]\");\n\t\taddPassingLog(\"[------------------------                        -]\");\n\t\taddPassingLog(\"[------------------------                         -]\");\n\t\taddPassingLog(\"[------------------------                          -]\");\n\t}",
        "start_line": 34,
        "end_line": 93,
        "chunk_index": 1,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 546,
        "node_type": null,
        "file_sha": "1dba549a69373953bb7741d04f2786a93d3698a5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.456134"
      },
      "text": "public class TestExecutionLogManager {\n\tprivate int nextLogFileNumber = 0; \n\tprivate ExecutionLogManager logManager = new ExecutionLogManager(25);\n\t\n\t\n\t@Test\n\tpublic void testAllClean() {\n\t\tSystem.out.println(\"  All clean\");\n\t\taddPassingLog(\"[-]\");\n\t\taddPassingLog(\"[--]\");\n\t\taddPassingLog(\"[---]\");\n\t\taddPassingLog(\"[----]\");\n\t\taddPassingLog(\"[-----]\");\n\t\taddPassingLog(\"[------]\");\n\t\taddPassingLog(\"[-------]\");\n\t\taddPassingLog(\"[--------]\");\n\t\taddPassingLog(\"[---------]\");\n\t\taddPassingLog(\"[----------]\");\n\t\taddPassingLog(\"[-----------]\");\n\t\taddPassingLog(\"[------------]\");\n\t\taddPassingLog(\"[-------------]\");\n\t\taddPassingLog(\"[--------------]\");\n\t\taddPassingLog(\"[---------------]\");\n\t\taddPassingLog(\"[----------------]\");\n\t\taddPassingLog(\"[-----------------]\");\n\t\taddPassingLog(\"[------------------]\");\n\t\taddPassingLog(\"[-------------------]\");\n\t\taddPassingLog(\"[--------------------]\");\n\t\taddPassingLog(\"[---------------------]\");\n\t\taddPassingLog(\"[----------------------]\");\n\t\taddPassingLog(\"[-----------------------]\");\n\t\taddPassingLog(\"[------------------------]\");\n\t\taddPassingLog(\"[-------------------------]\");\n\t\taddPassingLog(\"[------------------------ -]\");\n\t\taddPassingLog(\"[------------------------  -]\");\n\t\taddPassingLog(\"[------------------------   -]\");\n\t\taddPassingLog(\"[------------------------    -]\");\n\t\taddPassingLog(\"[------------------------     -]\");\n\t\taddPassingLog(\"[------------------------      -]\");\n\t\taddPassingLog(\"[------------------------       -]\");\n\t\taddPassingLog(\"[------------------------        -]\");\n\t\taddPassingLog(\"[------------------------         -]\");\n\t\taddPassingLog(\"[------------------------          -]\");\n\t\taddPassingLog(\"[------------------------           -]\");\n\t\taddPassingLog(\"[------------------------            -]\");\n\t\taddPassingLog(\"[------------------------             -]\");\n\t\taddPassingLog(\"[------------------------              -]\");\n\t\taddPassingLog(\"[------------------------               -]\");\n\t\taddPassingLog(\"[------------------------                -]\");\n\t\taddPassingLog(\"[------------------------                 -]\");\n\t\taddPassingLog(\"[------------------------                  -]\");\n\t\taddPassingLog(\"[------------------------                   -]\");\n\t\taddPassingLog(\"[------------------------                    -]\");\n\t\taddPassingLog(\"[------------------------                     -]\");\n\t\taddPassingLog(\"[------------------------                      -]\");\n\t\taddPassingLog(\"[------------------------                       -]\");\n\t\taddPassingLog(\"[------------------------                        -]\");\n\t\taddPassingLog(\"[------------------------                         -]\");\n\t\taddPassingLog(\"[------------------------                          -]\");\n\t}"
    },
    "432": {
      "metadata": {
        "chunk_id": "037314b280d0cf310c47a690484b426bbdb1f95902ce19b4cd38eb1b83235975",
        "file_path": "stf.load/test/stf.load/com/ibm/runtimes/loadTest/reporting/TestExecutionLogManager.java",
        "content": "@Test\n\tpublic void testHaveLogsBeforeFirstFailure() {\n\t\taddPassingLog(\"[-]\");\n\t\taddPassingLog(\"[--]\");\n\t\taddPassingLog(\"[---]\");\n\t\taddPassingLog(\"[----]\");\n\t\taddPassingLog(\"[-----]\");\n\t\taddFailingLog(\"[-----X]\");\n\t\taddPassingLog(\"[-----X-]\");\n\t\taddPassingLog(\"[-----X--]\");\n\t\taddFailingLog(\"[-----X--X]\");\n\t\taddPassingLog(\"[-----X--X-]\");\n\t\taddPassingLog(\"[-----X--X--]\");\n\t\taddPassingLog(\"[-----X--X---]\");\n\t\taddPassingLog(\"[-----X--X----]\");\n\t\taddPassingLog(\"[-----X--X-----]\");\n\t\taddPassingLog(\"[-----X--X------]\");\n\t\taddPassingLog(\"[-----X--X-------]\");\n\t\taddPassingLog(\"[-----X--X--------]\");\n\t\taddPassingLog(\"[-----X--X---------]\");\n\t\taddPassingLog(\"[-----X--X----------]\");\n\t\taddPassingLog(\"[-----X--X-----------]\");\n\t\taddPassingLog(\"[-----X--X------------]\");\n\t\taddPassingLog(\"[-----X--X-------------]\");\n\t\taddPassingLog(\"[-----X--X--------------]\");\n\t\taddPassingLog(\"[-----X--X---------------]\");\n\t\taddPassingLog(\"[-----X--X----------------]\");\n\t\taddPassingLog(\"[-----X--X--------------- -]\");\n\t\taddPassingLog(\"[-----X--X---------------  -]\");\n\t\taddPassingLog(\"[-----X--X---------------   -]\");\n\t\taddPassingLog(\"[-----X--X---------------    -]\");\n\t\taddPassingLog(\"[-----X--X---------------     -]\");\n\t\taddFailingLog(\"[-----X--X--------------      -X]\");\n\t\taddPassingLog(\"[-----X--X-------------       -X-]\");\n\t\taddPassingLog(\"[-----X--X-------------       -X -]\");\n\t\taddFailingLog(\"[-----X--X------------        -X -X]\");\n\t\taddFailingLog(\"[-----X--X-----------         -X -XX]\");\n\t\taddPassingLog(\"[-----X--X----------          -X -XX-]\");\n\t\taddPassingLog(\"[-----X--X----------          -X -XX -]\");\n\t\taddFailingLog(\"[-----X--X---------           -X -XX -X]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X-]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X  -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X   -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X    -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X     -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X      -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X       -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X        -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X         -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X          -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X           -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X            -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X             -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X              -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X               -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                 -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                  -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                   -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                    -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                     -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                      -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                       -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                        -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                         -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                          -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                           -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                            -]\");\n\t}",
        "start_line": 94,
        "end_line": 163,
        "chunk_index": 2,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 1098,
        "node_type": null,
        "file_sha": "1dba549a69373953bb7741d04f2786a93d3698a5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.456137"
      },
      "text": "@Test\n\tpublic void testHaveLogsBeforeFirstFailure() {\n\t\taddPassingLog(\"[-]\");\n\t\taddPassingLog(\"[--]\");\n\t\taddPassingLog(\"[---]\");\n\t\taddPassingLog(\"[----]\");\n\t\taddPassingLog(\"[-----]\");\n\t\taddFailingLog(\"[-----X]\");\n\t\taddPassingLog(\"[-----X-]\");\n\t\taddPassingLog(\"[-----X--]\");\n\t\taddFailingLog(\"[-----X--X]\");\n\t\taddPassingLog(\"[-----X--X-]\");\n\t\taddPassingLog(\"[-----X--X--]\");\n\t\taddPassingLog(\"[-----X--X---]\");\n\t\taddPassingLog(\"[-----X--X----]\");\n\t\taddPassingLog(\"[-----X--X-----]\");\n\t\taddPassingLog(\"[-----X--X------]\");\n\t\taddPassingLog(\"[-----X--X-------]\");\n\t\taddPassingLog(\"[-----X--X--------]\");\n\t\taddPassingLog(\"[-----X--X---------]\");\n\t\taddPassingLog(\"[-----X--X----------]\");\n\t\taddPassingLog(\"[-----X--X-----------]\");\n\t\taddPassingLog(\"[-----X--X------------]\");\n\t\taddPassingLog(\"[-----X--X-------------]\");\n\t\taddPassingLog(\"[-----X--X--------------]\");\n\t\taddPassingLog(\"[-----X--X---------------]\");\n\t\taddPassingLog(\"[-----X--X----------------]\");\n\t\taddPassingLog(\"[-----X--X--------------- -]\");\n\t\taddPassingLog(\"[-----X--X---------------  -]\");\n\t\taddPassingLog(\"[-----X--X---------------   -]\");\n\t\taddPassingLog(\"[-----X--X---------------    -]\");\n\t\taddPassingLog(\"[-----X--X---------------     -]\");\n\t\taddFailingLog(\"[-----X--X--------------      -X]\");\n\t\taddPassingLog(\"[-----X--X-------------       -X-]\");\n\t\taddPassingLog(\"[-----X--X-------------       -X -]\");\n\t\taddFailingLog(\"[-----X--X------------        -X -X]\");\n\t\taddFailingLog(\"[-----X--X-----------         -X -XX]\");\n\t\taddPassingLog(\"[-----X--X----------          -X -XX-]\");\n\t\taddPassingLog(\"[-----X--X----------          -X -XX -]\");\n\t\taddFailingLog(\"[-----X--X---------           -X -XX -X]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X-]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X  -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X   -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X    -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X     -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X      -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X       -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X        -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X         -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X          -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X           -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X            -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X             -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X              -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X               -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                 -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                  -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                   -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                    -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                     -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                      -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                       -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                        -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                         -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                          -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                           -]\");\n\t\taddPassingLog(\"[-----X--X--------            -X -XX -X                            -]\");\n\t}"
    },
    "433": {
      "metadata": {
        "chunk_id": "b35521628cea60129a756ed454bd531f273a2de3dd9dcfada940515b3b5952e1",
        "file_path": "stf.load/test/stf.load/com/ibm/runtimes/loadTest/reporting/TestExecutionLogManager.java",
        "content": "@Test\n\tpublic void testNoLogsBeforeFirstFailure() {\n\t\taddPassingLog(\"[-]\");\n\t\taddPassingLog(\"[--]\");\n\t\taddPassingLog(\"[---]\");\n\t\taddPassingLog(\"[----]\");\n\t\taddPassingLog(\"[-----]\");\n\t\taddPassingLog(\"[------]\");\n\t\taddPassingLog(\"[-------]\");\n\t\taddPassingLog(\"[--------]\");\n\t\taddPassingLog(\"[---------]\");\n\t\taddPassingLog(\"[----------]\");\n\t\taddPassingLog(\"[-----------]\");\n\t\taddPassingLog(\"[------------]\");\n\t\taddPassingLog(\"[-------------]\");\n\t\taddPassingLog(\"[--------------]\");\n\t\taddPassingLog(\"[---------------]\");\n\t\taddPassingLog(\"[----------------]\");\n\t\taddPassingLog(\"[-----------------]\");\n\t\taddPassingLog(\"[------------------]\");\n\t\taddPassingLog(\"[-------------------]\");\n\t\taddPassingLog(\"[--------------------]\");\n\t\taddPassingLog(\"[---------------------]\");\n\t\taddPassingLog(\"[----------------------]\");\n\t\taddPassingLog(\"[-----------------------]\");\n\t\taddPassingLog(\"[------------------------]\");\n\t\taddPassingLog(\"[-------------------------]\");\n\t\taddPassingLog(\"[------------------------ -]\");\n\t\taddPassingLog(\"[------------------------  -]\");\n\t\taddPassingLog(\"[------------------------   -]\");\n\t\taddPassingLog(\"[------------------------    -]\");\n\t\taddPassingLog(\"[------------------------     -]\");\n\t\taddFailingLog(\"[-----------------------      -X]\");\n\t\taddPassingLog(\"[----------------------       -X-]\");\n\t\taddPassingLog(\"[----------------------       -X -]\");\n\t\taddFailingLog(\"[---------------------        -X -X]\");\n\t\taddPassingLog(\"[--------------------         -X -X-]\");\n\t\taddPassingLog(\"[--------------------         -X -X -]\");\n\t\taddPassingLog(\"[--------------------         -X -X  -]\");\n\t\taddPassingLog(\"[--------------------         -X -X   -]\");\n\t\taddFailingLog(\"[-------------------          -X -X   -X]\");\n\t\taddPassingLog(\"[------------------           -X -X   -X-]\");\n\t\taddPassingLog(\"[------------------           -X -X   -X -]\");\n\t\taddPassingLog(\"[------------------           -X -X   -X  -]\");\n\t\taddFailingLog(\"[-----------------            -X -X   -X  -X]\");\n\t\taddPassingLog(\"[----------------             -X -X   -X  -X-]\");\n\t\taddFailingLog(\"[---------------              -X -X   -X  -X-X]\");\n\t\taddFailingLog(\"[--------------               -X -X   -X  -X-XX]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX-]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX  -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX   -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX    -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX     -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX      -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX       -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX        -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX         -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX          -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX           -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX            -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX             -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX              -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX               -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                 -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                  -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                   -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                    -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                     -]\");",
        "start_line": 164,
        "end_line": 233,
        "chunk_index": 3,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 1042,
        "node_type": null,
        "file_sha": "1dba549a69373953bb7741d04f2786a93d3698a5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.456140"
      },
      "text": "@Test\n\tpublic void testNoLogsBeforeFirstFailure() {\n\t\taddPassingLog(\"[-]\");\n\t\taddPassingLog(\"[--]\");\n\t\taddPassingLog(\"[---]\");\n\t\taddPassingLog(\"[----]\");\n\t\taddPassingLog(\"[-----]\");\n\t\taddPassingLog(\"[------]\");\n\t\taddPassingLog(\"[-------]\");\n\t\taddPassingLog(\"[--------]\");\n\t\taddPassingLog(\"[---------]\");\n\t\taddPassingLog(\"[----------]\");\n\t\taddPassingLog(\"[-----------]\");\n\t\taddPassingLog(\"[------------]\");\n\t\taddPassingLog(\"[-------------]\");\n\t\taddPassingLog(\"[--------------]\");\n\t\taddPassingLog(\"[---------------]\");\n\t\taddPassingLog(\"[----------------]\");\n\t\taddPassingLog(\"[-----------------]\");\n\t\taddPassingLog(\"[------------------]\");\n\t\taddPassingLog(\"[-------------------]\");\n\t\taddPassingLog(\"[--------------------]\");\n\t\taddPassingLog(\"[---------------------]\");\n\t\taddPassingLog(\"[----------------------]\");\n\t\taddPassingLog(\"[-----------------------]\");\n\t\taddPassingLog(\"[------------------------]\");\n\t\taddPassingLog(\"[-------------------------]\");\n\t\taddPassingLog(\"[------------------------ -]\");\n\t\taddPassingLog(\"[------------------------  -]\");\n\t\taddPassingLog(\"[------------------------   -]\");\n\t\taddPassingLog(\"[------------------------    -]\");\n\t\taddPassingLog(\"[------------------------     -]\");\n\t\taddFailingLog(\"[-----------------------      -X]\");\n\t\taddPassingLog(\"[----------------------       -X-]\");\n\t\taddPassingLog(\"[----------------------       -X -]\");\n\t\taddFailingLog(\"[---------------------        -X -X]\");\n\t\taddPassingLog(\"[--------------------         -X -X-]\");\n\t\taddPassingLog(\"[--------------------         -X -X -]\");\n\t\taddPassingLog(\"[--------------------         -X -X  -]\");\n\t\taddPassingLog(\"[--------------------         -X -X   -]\");\n\t\taddFailingLog(\"[-------------------          -X -X   -X]\");\n\t\taddPassingLog(\"[------------------           -X -X   -X-]\");\n\t\taddPassingLog(\"[------------------           -X -X   -X -]\");\n\t\taddPassingLog(\"[------------------           -X -X   -X  -]\");\n\t\taddFailingLog(\"[-----------------            -X -X   -X  -X]\");\n\t\taddPassingLog(\"[----------------             -X -X   -X  -X-]\");\n\t\taddFailingLog(\"[---------------              -X -X   -X  -X-X]\");\n\t\taddFailingLog(\"[--------------               -X -X   -X  -X-XX]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX-]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX  -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX   -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX    -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX     -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX      -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX       -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX        -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX         -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX          -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX           -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX            -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX             -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX              -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX               -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                 -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                  -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                   -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                    -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                     -]\");"
    },
    "434": {
      "metadata": {
        "chunk_id": "38c72219160ac6d32d67e7c9c8f55515e8c951bdea163dc195c78ba55c5efd39",
        "file_path": "stf.load/test/stf.load/com/ibm/runtimes/loadTest/reporting/TestExecutionLogManager.java",
        "content": "addPassingLog(\"[-------------                -X -X   -X  -X-XX             -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX              -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX               -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                 -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                  -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                   -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                    -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                     -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                      -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                       -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                        -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                         -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                          -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                           -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                            -]\");\t\n\t}",
        "start_line": 234,
        "end_line": 250,
        "chunk_index": 4,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 371,
        "node_type": null,
        "file_sha": "1dba549a69373953bb7741d04f2786a93d3698a5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.456143"
      },
      "text": "addPassingLog(\"[-------------                -X -X   -X  -X-XX             -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX              -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX               -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                 -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                  -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                   -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                    -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                     -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                      -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                       -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                        -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                         -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                          -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                           -]\");\n\t\taddPassingLog(\"[-------------                -X -X   -X  -X-XX                            -]\");\t\n\t}"
    },
    "435": {
      "metadata": {
        "chunk_id": "cd5cc85959c89692144bc1df3a058ac8cf852d80e5a5c7f80500687c9c868b40",
        "file_path": "stf.load/test/stf.load/com/ibm/runtimes/loadTest/reporting/TestExecutionLogManager.java",
        "content": "private void addPassingLog(String expectedStatus) {\n\t\taddLog(0, expectedStatus);\n\t}\n\n\tprivate void addFailingLog(String expectedStatus) {\n\t\taddLog(1, expectedStatus);\n\t}\n\n\tprivate void addLog(int numErrors, String expectedStatus) {\n\t\tFile logFile = new File(\"/tmp/logEvictionTest.\" + nextLogFileNumber + \".ltd\");\n\t\tnextLogFileNumber++;\n\t\t\n\t\tlogManager.fileCompleted(logFile, numErrors);\n\t\t\n\t\tSystem.out.println(logManager.toString());\n\t\tassertEquals(expectedStatus, logManager.toString());\n\t}\n}",
        "start_line": 251,
        "end_line": 268,
        "chunk_index": 5,
        "total_chunks": 6,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 118,
        "node_type": null,
        "file_sha": "1dba549a69373953bb7741d04f2786a93d3698a5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.456146"
      },
      "text": "private void addPassingLog(String expectedStatus) {\n\t\taddLog(0, expectedStatus);\n\t}\n\n\tprivate void addFailingLog(String expectedStatus) {\n\t\taddLog(1, expectedStatus);\n\t}\n\n\tprivate void addLog(int numErrors, String expectedStatus) {\n\t\tFile logFile = new File(\"/tmp/logEvictionTest.\" + nextLogFileNumber + \".ltd\");\n\t\tnextLogFileNumber++;\n\t\t\n\t\tlogManager.fileCompleted(logFile, numErrors);\n\t\t\n\t\tSystem.out.println(logManager.toString());\n\t\tassertEquals(expectedStatus, logManager.toString());\n\t}\n}"
    },
    "436": {
      "metadata": {
        "chunk_id": "2a2db39d878ccea0d0959d8d3e24f060993b2c7aaa0dd6a71068010a2fb1b7ec",
        "file_path": "stf.samples/.classpath",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<classpath>\n\t<classpathentry kind=\"src\" path=\"src/stf.samples\"/>\n\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"/>\n\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"/stf.core\"/>\n\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"/stf.load\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/junit/junit.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-api.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-core.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/asm/asm.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/asm/asm-commons.jar\"/>\n\t<classpathentry kind=\"output\" path=\"bin\"/>\n</classpath>\n\n\n",
        "start_line": 0,
        "end_line": 15,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 220,
        "node_type": null,
        "file_sha": "1abcedb4ea7f610fc832f9263faabaa97cc04136",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.513639"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<classpath>\n\t<classpathentry kind=\"src\" path=\"src/stf.samples\"/>\n\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"/>\n\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"/stf.core\"/>\n\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"/stf.load\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/junit/junit.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-api.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/log4j/log4j-core.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/asm/asm.jar\"/>\n\t<classpathentry kind=\"lib\" path=\"/systemtest_prereqs/asm/asm-commons.jar\"/>\n\t<classpathentry kind=\"output\" path=\"bin\"/>\n</classpath>\n\n\n"
    },
    "437": {
      "metadata": {
        "chunk_id": "acb58a01800c7f70a669c9a1575d07fcf8646ecd48fa663ce73b846898ed7fcc",
        "file_path": "stf.samples/.project",
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>stf.samples</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.jdt.core.javabuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.jdt.core.javanature</nature>\n\t</natures>\n</projectDescription>\n\n\n",
        "start_line": 0,
        "end_line": 19,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 119,
        "node_type": null,
        "file_sha": "45aa77fdc3e5d3ae15b17b10068f09b99c10e6b4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.544022"
      },
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>stf.samples</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.jdt.core.javabuilder</name>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.jdt.core.javanature</nature>\n\t</natures>\n</projectDescription>\n\n\n"
    },
    "438": {
      "metadata": {
        "chunk_id": "3c634524b7e69b21657c8ec8af922784a9c206e124888150ad8a759762e4a940",
        "file_path": "stf.samples/.settings/org.eclipse.jdt.core.prefs",
        "content": "eclipse.preferences.version=1\norg.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled\norg.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8\norg.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve\norg.eclipse.jdt.core.compiler.compliance=1.8\norg.eclipse.jdt.core.compiler.debug.lineNumber=generate\norg.eclipse.jdt.core.compiler.debug.localVariable=generate\norg.eclipse.jdt.core.compiler.debug.sourceFile=generate\norg.eclipse.jdt.core.compiler.problem.assertIdentifier=error\norg.eclipse.jdt.core.compiler.problem.enumIdentifier=error\norg.eclipse.jdt.core.compiler.source=1.8\n\n\n",
        "start_line": 0,
        "end_line": 13,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 137,
        "node_type": null,
        "file_sha": "3a21537071bf4118b9e1ee864cb4bc258aa48211",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.564791"
      },
      "text": "eclipse.preferences.version=1\norg.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled\norg.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8\norg.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve\norg.eclipse.jdt.core.compiler.compliance=1.8\norg.eclipse.jdt.core.compiler.debug.lineNumber=generate\norg.eclipse.jdt.core.compiler.debug.localVariable=generate\norg.eclipse.jdt.core.compiler.debug.sourceFile=generate\norg.eclipse.jdt.core.compiler.problem.assertIdentifier=error\norg.eclipse.jdt.core.compiler.problem.enumIdentifier=error\norg.eclipse.jdt.core.compiler.source=1.8\n\n\n"
    },
    "439": {
      "metadata": {
        "chunk_id": "32f6b7705d609720de815eb6ce6b3973c12a609a550b45591c6b8facb0f2a760",
        "file_path": "stf.samples/build.xml",
        "content": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n     http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<project name=\"stf.samples\" default=\"build\">\n\n\t<echo message=\"Executing stf.samples/build.xml\"/>\n\n\t<!-- Set default for source_root.  -->\n\t<property name=\"source_root\" location=\"../\"/>\n\n\t<property name=\"stf_root\" location=\"${source_root}/../stf\"/>\n\n\t<!-- Import settings used by multiple projects.  -->\n\t<import file=\"${stf_root}/stf.build/include/top.xml\"/>\n\n\t<!-- We need stf.core and junit to compile this project. -->\n\t<path id=\"project.class.path\">\n\t\t<path refid=\"junit.class.path\" />\n\t\t<path refid=\"log4j.class.path\" />\n\t\t<pathelement location=\"${stf_root}/stf.core/bin/stf.core.jar\"/>\n\t\t<pathelement location=\"${stf_root}/stf.load/bin/stf.load.jar\"/>\n\t</path>\n\n\t<!-- For modularity you need a directory above the package structure to hold the module.java file -->\n\t<property name=\"stf_samples_module\" value=\"stf.samples\" />\n\t<property name=\"stf_samples_src_dir\" value=\"src/${stf_samples_module}\" />\n\t<property name=\"stf_samples_bin_dir\" value=\"bin\" />\n\n\t<property name=\"stf_samples_jar_file\" value=\"${stf_samples_bin_dir}/${stf_samples_module}.jar\" />\n\n\t<!-- Projects which need to be built before this one. -->\n\t<!-- dir must be set on the ant task otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-dependencies\">\n\t\t<ant antfile=\"${stf_root}/stf.core/build.xml\" dir=\"${stf_root}/stf.core\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.load/build.xml\" dir=\"${stf_root}/stf.load\" inheritAll=\"true\"/>\n\t</target>\n\n\t<target name=\"build\" depends=\"build-no-natives, build-natives\">\n\t</target>\n\n\t<target name=\"build-no-natives\" depends=\"check-prereqs, build-dependencies, build-archives\">\n\t</target>\n\n\t<target name=\"build-natives\" depends=\"check-prereqs\">\n\t</target>\n\n\t<target name=\"build-archives\" depends=\"build-jar\">\n\t</target>\n\n\t<target name=\"build-jar\" depends=\"build-java, create-bin-dir\">\n\t\t<jar destfile=\"${stf_samples_jar_file}\">\n\t\t\t<fileset dir=\"${stf_samples_bin_dir}\" includes=\"**/*.class\" />\n\t\t</jar>\n\t</target>\n\n\t<target name=\"build-java\" depends=\"check-prereqs, create-bin-dir\">\n\t\t <!--\n\t\t \tThe Ant javac task only checks time dependencies between .java files and their .class files,\n\t\t\tso fails to recompile in situations such as the signatures of a dependent method changing.\n\t\t\tThe depend target checks the dependencies and deletes any .class files older than the files\n\t\t\twhich depend on them, thereby ensuring recompilation.\n\t\t-->\n\t\t<!--\n\t\tCommented out because depend appears to be evaluating class files as always out of date with jdk11 (at 28/03/2019)\n\t\t<depend srcdir=\"${stf_samples_src_dir}\" destdir=\"${stf_samples_bin_dir}\" classpathref=\"project.class.path\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</depend>\n\t\t-->\n\t    <!-- Classes can be built using Java 7 or later.  -->\n\t\t<javac srcdir=\"${stf_samples_src_dir}\"\n\t\t\t   destdir=\"${stf_samples_bin_dir}\"\n\t\t\t   debug=\"true\"\n\t\t\t   fork=\"true\"\n\t\t\t   executable=\"${java_compiler}\"\n\t\t\t   classpathref=\"project.class.path\"\n\t\t\t   encoding=\"${src-encoding}\"\n\t\t\t   includeantruntime=\"false\"\n\t\t\t   failonerror=\"true\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</javac>\n\t</target>\n\n\t<target name=\"create-bin-dir\">\n\t\t<mkdir dir=\"${stf_samples_bin_dir}\"/>\n\t</target>\n\n\t<target name=\"clean\">\n\t\t<delete dir=\"${stf_samples_bin_dir}\"/>\n\t</target>\n\n</project>",
        "start_line": 0,
        "end_line": 101,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 1014,
        "node_type": null,
        "file_sha": "5062d9530cd8436d4cc09e6b6a50cf734c68de20",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.596667"
      },
      "text": "<?xml version=\"1.0\"?>\n\n<!--\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n     http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<project name=\"stf.samples\" default=\"build\">\n\n\t<echo message=\"Executing stf.samples/build.xml\"/>\n\n\t<!-- Set default for source_root.  -->\n\t<property name=\"source_root\" location=\"../\"/>\n\n\t<property name=\"stf_root\" location=\"${source_root}/../stf\"/>\n\n\t<!-- Import settings used by multiple projects.  -->\n\t<import file=\"${stf_root}/stf.build/include/top.xml\"/>\n\n\t<!-- We need stf.core and junit to compile this project. -->\n\t<path id=\"project.class.path\">\n\t\t<path refid=\"junit.class.path\" />\n\t\t<path refid=\"log4j.class.path\" />\n\t\t<pathelement location=\"${stf_root}/stf.core/bin/stf.core.jar\"/>\n\t\t<pathelement location=\"${stf_root}/stf.load/bin/stf.load.jar\"/>\n\t</path>\n\n\t<!-- For modularity you need a directory above the package structure to hold the module.java file -->\n\t<property name=\"stf_samples_module\" value=\"stf.samples\" />\n\t<property name=\"stf_samples_src_dir\" value=\"src/${stf_samples_module}\" />\n\t<property name=\"stf_samples_bin_dir\" value=\"bin\" />\n\n\t<property name=\"stf_samples_jar_file\" value=\"${stf_samples_bin_dir}/${stf_samples_module}.jar\" />\n\n\t<!-- Projects which need to be built before this one. -->\n\t<!-- dir must be set on the ant task otherwise the basedir property is not set to a new value in the subant task. -->\n\t<target name=\"build-dependencies\">\n\t\t<ant antfile=\"${stf_root}/stf.core/build.xml\" dir=\"${stf_root}/stf.core\" inheritAll=\"true\"/>\n\t\t<ant antfile=\"${stf_root}/stf.load/build.xml\" dir=\"${stf_root}/stf.load\" inheritAll=\"true\"/>\n\t</target>\n\n\t<target name=\"build\" depends=\"build-no-natives, build-natives\">\n\t</target>\n\n\t<target name=\"build-no-natives\" depends=\"check-prereqs, build-dependencies, build-archives\">\n\t</target>\n\n\t<target name=\"build-natives\" depends=\"check-prereqs\">\n\t</target>\n\n\t<target name=\"build-archives\" depends=\"build-jar\">\n\t</target>\n\n\t<target name=\"build-jar\" depends=\"build-java, create-bin-dir\">\n\t\t<jar destfile=\"${stf_samples_jar_file}\">\n\t\t\t<fileset dir=\"${stf_samples_bin_dir}\" includes=\"**/*.class\" />\n\t\t</jar>\n\t</target>\n\n\t<target name=\"build-java\" depends=\"check-prereqs, create-bin-dir\">\n\t\t <!--\n\t\t \tThe Ant javac task only checks time dependencies between .java files and their .class files,\n\t\t\tso fails to recompile in situations such as the signatures of a dependent method changing.\n\t\t\tThe depend target checks the dependencies and deletes any .class files older than the files\n\t\t\twhich depend on them, thereby ensuring recompilation.\n\t\t-->\n\t\t<!--\n\t\tCommented out because depend appears to be evaluating class files as always out of date with jdk11 (at 28/03/2019)\n\t\t<depend srcdir=\"${stf_samples_src_dir}\" destdir=\"${stf_samples_bin_dir}\" classpathref=\"project.class.path\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</depend>\n\t\t-->\n\t    <!-- Classes can be built using Java 7 or later.  -->\n\t\t<javac srcdir=\"${stf_samples_src_dir}\"\n\t\t\t   destdir=\"${stf_samples_bin_dir}\"\n\t\t\t   debug=\"true\"\n\t\t\t   fork=\"true\"\n\t\t\t   executable=\"${java_compiler}\"\n\t\t\t   classpathref=\"project.class.path\"\n\t\t\t   encoding=\"${src-encoding}\"\n\t\t\t   includeantruntime=\"false\"\n\t\t\t   failonerror=\"true\">\n\t\t\t<include name=\"**/*.java\"/>\n\t\t</javac>\n\t</target>\n\n\t<target name=\"create-bin-dir\">\n\t\t<mkdir dir=\"${stf_samples_bin_dir}\"/>\n\t</target>\n\n\t<target name=\"clean\">\n\t\t<delete dir=\"${stf_samples_bin_dir}\"/>\n\t</target>\n\n</project>"
    },
    "440": {
      "metadata": {
        "chunk_id": "d6480f8e86ae088971741d121207f27b9ecc7a4d0b8f396574bca162d947bb65",
        "file_path": "stf.samples/config/example.properties",
        "content": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# This file contains default property values for the ExampleExtension\n#\n\n# If set to true then dump the contents of test data files to stdout\nshow-files=false",
        "start_line": 0,
        "end_line": 17,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "properties",
        "chunk_type": "recursive",
        "token_count": 152,
        "node_type": null,
        "file_sha": "722a1dd652805ff9e802d09ad52109256e0fb32d",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.617683"
      },
      "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# This file contains default property values for the ExampleExtension\n#\n\n# If set to true then dump the contents of test data files to stdout\nshow-files=false"
    },
    "441": {
      "metadata": {
        "chunk_id": "ef0df6ee1ad4605cbef3462745165d2815fb6ba82d3faf101223d36ef09b28d9",
        "file_path": "stf.samples/config/inventories/sampleLoadTest/sampleFailingInventory.xml",
        "content": "<inventory> \n\t<!-- Inventory for running a test which is going to fail -->\n\t<junit class=\"net.adoptopenjdk.stf.FailingJUnitTest\" />\n</inventory>",
        "start_line": 0,
        "end_line": 3,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 38,
        "node_type": null,
        "file_sha": "5e4fed4a6f6b41bcceca35b043ee4f32dad0ef9a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.641885"
      },
      "text": "<inventory> \n\t<!-- Inventory for running a test which is going to fail -->\n\t<junit class=\"net.adoptopenjdk.stf.FailingJUnitTest\" />\n</inventory>"
    },
    "442": {
      "metadata": {
        "chunk_id": "3e29bd9a9c6d76d2caadecd8ee2aded10ef83c4b59ee66b80542a081da593bf0",
        "file_path": "stf.samples/config/inventories/sampleLoadTest/sampleInventory.xml",
        "content": "<inventory> \n\t<include inventory=\"/stf.samples/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml\"/>\n\t<include inventory=\"/stf.samples/config/inventories/sampleLoadTest/subtests/junitInventory.xml\"/>\n</inventory>",
        "start_line": 0,
        "end_line": 3,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 52,
        "node_type": null,
        "file_sha": "3aa28030d4dd0147d6e93ae04b83a24b617d557e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.664652"
      },
      "text": "<inventory> \n\t<include inventory=\"/stf.samples/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml\"/>\n\t<include inventory=\"/stf.samples/config/inventories/sampleLoadTest/subtests/junitInventory.xml\"/>\n</inventory>"
    },
    "443": {
      "metadata": {
        "chunk_id": "57cfb8c10efd2c050ada9e4f029524eb2b2d53c1809de93f23b60d57e10f536b",
        "file_path": "stf.samples/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml",
        "content": "<inventory>\n    <!-- Run some java code -->\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" method=\"runSimpleTest\" />\n\t\n    <!-- Run some tests which use constructor and method arguments -->\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" constructorArguments=\"ADD\" method=\"runTest\" methodArguments=\"5, 2,3\" />\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" constructorArguments=\"SUBTRACT\" method=\"runTest\" methodArguments=\"21, 28,7\" />\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" constructorArguments=\"MULTIPLY\" method=\"runTest\" methodArguments=\"90, 10,9\" />\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" constructorArguments=\"DIVIDE\" method=\"runTest\" methodArguments=\"5, 55,11\" />\n</inventory>",
        "start_line": 0,
        "end_line": 9,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 216,
        "node_type": null,
        "file_sha": "3a349b3a39f90bb48c8cab20414552cac86a614c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.687288"
      },
      "text": "<inventory>\n    <!-- Run some java code -->\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" method=\"runSimpleTest\" />\n\t\n    <!-- Run some tests which use constructor and method arguments -->\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" constructorArguments=\"ADD\" method=\"runTest\" methodArguments=\"5, 2,3\" />\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" constructorArguments=\"SUBTRACT\" method=\"runTest\" methodArguments=\"21, 28,7\" />\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" constructorArguments=\"MULTIPLY\" method=\"runTest\" methodArguments=\"90, 10,9\" />\n\t<arbitraryJava class=\"net.adoptopenjdk.stf.ArbitraryJavaTest\" constructorArguments=\"DIVIDE\" method=\"runTest\" methodArguments=\"5, 55,11\" />\n</inventory>"
    },
    "444": {
      "metadata": {
        "chunk_id": "f91c31b14941c3fd54d7afd28af9a0e55f65ae535f822a01ce1e6f5b62bf81e2",
        "file_path": "stf.samples/config/inventories/sampleLoadTest/subtests/junitInventory.xml",
        "content": "<inventory> \n\t<junit class=\"net.adoptopenjdk.stf.MiniJUnitTest\" />\n</inventory>",
        "start_line": 0,
        "end_line": 2,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "xml",
        "chunk_type": "recursive",
        "token_count": 25,
        "node_type": null,
        "file_sha": "5519b9935c2f922e5950e8afeed51e02e2b205f4",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.709583"
      },
      "text": "<inventory> \n\t<junit class=\"net.adoptopenjdk.stf.MiniJUnitTest\" />\n</inventory>"
    },
    "445": {
      "metadata": {
        "chunk_id": "06bc19531686b769c0b5f83d3c2e2b6fc739ad36cbfdb995b97022d7f9c3b5c8",
        "file_path": "stf.samples/docs/readme.md",
        "content": "# STF Samples\nThis project contains samples which demonstrate how to use or extend the capabilities provided by STF.\n\nThe samples are built as part of the stf repository build.\n\nThe samples can be executed via\ncd stf.samples\nmake test -- runs all the samples\nmake test.xxx -- test.xxxx\n\n\n\n",
        "start_line": 0,
        "end_line": 12,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "markdown",
        "chunk_type": "simple",
        "token_count": 63,
        "node_type": null,
        "file_sha": "ba591537543a6a6e1e3517f695b8ad4514d7e8ce",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.742308"
      },
      "text": "# STF Samples\nThis project contains samples which demonstrate how to use or extend the capabilities provided by STF.\n\nThe samples are built as part of the stf repository build.\n\nThe samples can be executed via\ncd stf.samples\nmake test -- runs all the samples\nmake test.xxx -- test.xxxx\n\n\n\n"
    },
    "446": {
      "metadata": {
        "chunk_id": "6e4cb2c621d95a7ff6da0886101b00de3683bd071631eb304f1d259cb4091905",
        "file_path": "stf.samples/scripts/ExampleModule.pm",
        "content": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# This file holds test subroutines for SampleCustomExtensionTest.java\n#\n\npackage ExampleModule;\n\nour $TRUE = 1;\nour $FALSE = 0;\n\nsub checkGCData\n{\n   my ($module, $logFile) = @_;\n\n   my $total_fails = 0;\n   my $errors = [];\n\n   print \"GC data verfication starting...\\n\";\n\n   my $log = storeFile($logFile);\n   my $start = $FALSE;\n   my $end = $FALSE;\n\n   my $cnt = 0;\n   foreach my $line (@{$log})\n   {   \t\n   \t  $cnt++;\n   \t  my $match = $FALSE;\n   \t  if ($line =~ /GC agent started at /)\n   \t  {\n   \t  \t $start = $TRUE;\n   \t  \t $match = $TRUE;\n   \t  }\n\n   \t  if ($line =~ /^$/)\n   \t  { \n   \t  \t $match = $TRUE;\n   \t  }\n\n   \t  if (($line =~ /GC Finish:/) && ($start == $TRUE))\n   \t  {\n   \t  \t $match = $TRUE;\n   \t  }\t \n\n   \t  if (($line =~ /GC Start:/) && ($start == $TRUE))\n   \t  {\n   \t  \t $match = $TRUE;\n   \t  }\t \n\n   \t  if ($line =~ /GC count at program end:/)\n   \t  {\n   \t  \t $end = $TRUE;\n   \t  \t last;\n   \t  }\n\n   \t  if ($line =~ /\\*\\*JVMTI ERROR\\*\\*/)\n   \t  {\n\t      $total_fails++;\n\t      chomp($line);\n\t\t  push(@{$errors}, $line.\" found in the $logFile at line $cnt\");\t\t       \t  \t  \n   \t  }\n\n   \t  if ($start == $TRUE && $match == $FALSE)\n   \t  {\n   \t  \t $total_fails++;\n\t     push(@{$errors}, \"Unexpected output found in the $logFile at line $cnt\");\t\t    \n\n   \t  }\t\t  \t \n   }\n\n   if ($end == $FALSE)\n   {\n      $total_fails++;\n\t  push(@{$errors}, \"Expected Agent ended message missing from $logFile\");\t\t    \n\n   }\t\t  \t \n\n   logMsg(\"GC data verfication complete\");\n   return ($errors, $total_fails);   \n}       \n\nsub checkHeapData\n{\n   my ($module, $logFile) = @_;\n\n   my $total_fails = 0;\n   my $errors = [];\n\n   logMsg(\"Heap data verfication starting...\");\n\n   my $log = storeFile($logFile);\n   my $start = $FALSE;\n   my $match = $FALSE;\n   my $cnt = 0;\n   foreach my $line (@{$log})\n   {   \t\n   \t  $cnt++;\n   \t  $match = $FALSE;\n   \t  if ($line =~ /Heap agent started at /)\n   \t  {\n   \t  \t $start = $TRUE;\n   \t  \t $match = $TRUE;\n   \t  \t last;\n   \t  }\n\n   \t  if (($line =~ /HeapReference info: class_tag \\d, referrer_class_tag \\d, size \\d, length \\d/) && ($start == $TRUE))\n   \t  {\n   \t  \t $match = $TRUE;\n   \t  }\n\n   \t  if ($line =~ /\\*\\*JVMTI ERROR\\*\\*/)\n   \t  {\n\t      $total_fails++;\n\t      chomp($line);\n\t\t  push(@{$errors}, $line.\" found in the $logFile at line $cnt\");\t\t       \t  \t  \n   \t  }\n\n   \t  if ($start == $TRUE && $match == $FALSE)\n   \t  {\n   \t  \t $total_fails++;\n\t     push(@{$errors}, \"HEAP: Unexpected output found in the $logFile at line $cnt\");\t\t    \n   \t  }\t\t  \t \n   }\n\n   if ($match == $FALSE)\n   {\n      $total_fails++;\n\t  push(@{$errors}, \"HEAP: Unexpected output found in the $logFile\");\t\t    \n   }\t\t  \t \n\n   logMsg(\"Heap data verfication complete\");\n   return ($errors, $total_fails);   \n}                \n\nsub logMsg \n{\n   my ($errorMessage) = @_;\n   print \"$errorMessage\\n\";\n}\n\n",
        "start_line": 0,
        "end_line": 153,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 989,
        "node_type": null,
        "file_sha": "80fb71f3f78d9ca318e848d7d714af79ce1d870c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.765883"
      },
      "text": "#!/usr/bin/perl\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# This file holds test subroutines for SampleCustomExtensionTest.java\n#\n\npackage ExampleModule;\n\nour $TRUE = 1;\nour $FALSE = 0;\n\nsub checkGCData\n{\n   my ($module, $logFile) = @_;\n\n   my $total_fails = 0;\n   my $errors = [];\n\n   print \"GC data verfication starting...\\n\";\n\n   my $log = storeFile($logFile);\n   my $start = $FALSE;\n   my $end = $FALSE;\n\n   my $cnt = 0;\n   foreach my $line (@{$log})\n   {   \t\n   \t  $cnt++;\n   \t  my $match = $FALSE;\n   \t  if ($line =~ /GC agent started at /)\n   \t  {\n   \t  \t $start = $TRUE;\n   \t  \t $match = $TRUE;\n   \t  }\n\n   \t  if ($line =~ /^$/)\n   \t  { \n   \t  \t $match = $TRUE;\n   \t  }\n\n   \t  if (($line =~ /GC Finish:/) && ($start == $TRUE))\n   \t  {\n   \t  \t $match = $TRUE;\n   \t  }\t \n\n   \t  if (($line =~ /GC Start:/) && ($start == $TRUE))\n   \t  {\n   \t  \t $match = $TRUE;\n   \t  }\t \n\n   \t  if ($line =~ /GC count at program end:/)\n   \t  {\n   \t  \t $end = $TRUE;\n   \t  \t last;\n   \t  }\n\n   \t  if ($line =~ /\\*\\*JVMTI ERROR\\*\\*/)\n   \t  {\n\t      $total_fails++;\n\t      chomp($line);\n\t\t  push(@{$errors}, $line.\" found in the $logFile at line $cnt\");\t\t       \t  \t  \n   \t  }\n\n   \t  if ($start == $TRUE && $match == $FALSE)\n   \t  {\n   \t  \t $total_fails++;\n\t     push(@{$errors}, \"Unexpected output found in the $logFile at line $cnt\");\t\t    \n\n   \t  }\t\t  \t \n   }\n\n   if ($end == $FALSE)\n   {\n      $total_fails++;\n\t  push(@{$errors}, \"Expected Agent ended message missing from $logFile\");\t\t    \n\n   }\t\t  \t \n\n   logMsg(\"GC data verfication complete\");\n   return ($errors, $total_fails);   \n}       \n\nsub checkHeapData\n{\n   my ($module, $logFile) = @_;\n\n   my $total_fails = 0;\n   my $errors = [];\n\n   logMsg(\"Heap data verfication starting...\");\n\n   my $log = storeFile($logFile);\n   my $start = $FALSE;\n   my $match = $FALSE;\n   my $cnt = 0;\n   foreach my $line (@{$log})\n   {   \t\n   \t  $cnt++;\n   \t  $match = $FALSE;\n   \t  if ($line =~ /Heap agent started at /)\n   \t  {\n   \t  \t $start = $TRUE;\n   \t  \t $match = $TRUE;\n   \t  \t last;\n   \t  }\n\n   \t  if (($line =~ /HeapReference info: class_tag \\d, referrer_class_tag \\d, size \\d, length \\d/) && ($start == $TRUE))\n   \t  {\n   \t  \t $match = $TRUE;\n   \t  }\n\n   \t  if ($line =~ /\\*\\*JVMTI ERROR\\*\\*/)\n   \t  {\n\t      $total_fails++;\n\t      chomp($line);\n\t\t  push(@{$errors}, $line.\" found in the $logFile at line $cnt\");\t\t       \t  \t  \n   \t  }\n\n   \t  if ($start == $TRUE && $match == $FALSE)\n   \t  {\n   \t  \t $total_fails++;\n\t     push(@{$errors}, \"HEAP: Unexpected output found in the $logFile at line $cnt\");\t\t    \n   \t  }\t\t  \t \n   }\n\n   if ($match == $FALSE)\n   {\n      $total_fails++;\n\t  push(@{$errors}, \"HEAP: Unexpected output found in the $logFile\");\t\t    \n   }\t\t  \t \n\n   logMsg(\"Heap data verfication complete\");\n   return ($errors, $total_fails);   \n}                \n\nsub logMsg \n{\n   my ($errorMessage) = @_;\n   print \"$errorMessage\\n\";\n}\n\n"
    },
    "447": {
      "metadata": {
        "chunk_id": "88cc7b4b7a235eaea43b6cc63d668e0b8c9ca2f51ffbee6949be0383add3c490",
        "file_path": "stf.samples/scripts/ExampleModule.pm",
        "content": "sub storeFile\n{\n   # get filename and search argument\n   my ($filename) = @_;\n   my @lines = ();\n\n   # strip out any quotes...\n   ($filename) =~ s/\\\"//g;\n\n   # check the file exists\n   if (!(-e $filename))\n   {\n      print \"SYSTEM ERROR: The system cannot find the file $filename.\\n\";\n      return [];\n   }\n\n   if (!(-r $filename))\n   {\n      print \"SYSTEM ERROR: The system does not have read access to the file $filename.\\n\";\n      return [];\n   }\n\n   # open file\n   open (FILE, \"<$filename\");\n\n   # search array\n   @lines = <FILE>;\n\n   close FILE;\n   return \\@lines;\n}\n\n1;\n\n\n",
        "start_line": 154,
        "end_line": 189,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "text",
        "chunk_type": "simple",
        "token_count": 157,
        "node_type": null,
        "file_sha": "80fb71f3f78d9ca318e848d7d714af79ce1d870c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.765890"
      },
      "text": "sub storeFile\n{\n   # get filename and search argument\n   my ($filename) = @_;\n   my @lines = ();\n\n   # strip out any quotes...\n   ($filename) =~ s/\\\"//g;\n\n   # check the file exists\n   if (!(-e $filename))\n   {\n      print \"SYSTEM ERROR: The system cannot find the file $filename.\\n\";\n      return [];\n   }\n\n   if (!(-r $filename))\n   {\n      print \"SYSTEM ERROR: The system does not have read access to the file $filename.\\n\";\n      return [];\n   }\n\n   # open file\n   open (FILE, \"<$filename\");\n\n   # search array\n   @lines = <FILE>;\n\n   close FILE;\n   return \\@lines;\n}\n\n1;\n\n\n"
    },
    "448": {
      "metadata": {
        "chunk_id": "81fe1d66a918439928243021a6f503220774e2927e1d20a271dac79d90f3eba9",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/ArbitraryJavaTest.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\npackage net.adoptopenjdk.stf;\n\npublic class ArbitraryJavaTest {\n\tprivate enum OperationType { ADD, SUBTRACT, MULTIPLY, DIVIDE };\n\tprivate OperationType operation;\n\t\n\tpublic ArbitraryJavaTest() {\n\t}\n\t\n\tpublic ArbitraryJavaTest(String operator) {\n\t\toperation = OperationType.valueOf(operator);\n\t}\n\t\n\tpublic void runSimpleTest() {\n\t\t// Run a test that should never fail\n\t\tif (System.currentTimeMillis() < 666) { \n\t\t\tthrow new IllegalStateException(\"System clock wrong\");\n\t\t}\n\t}\n\t\n\tpublic void runTest(int expectedResult, int v1, int v2) {\n\t\tint actualResult = 0;\n\t\t\n\t\tswitch (operation) {\n\t\tcase ADD:\n\t\t\tactualResult = v1 + v2;\n\t\t\tbreak;\n\t\tcase SUBTRACT:\n\t\t\tactualResult = v1 - v2;\n\t\t\tbreak;\n\t\tcase MULTIPLY:\n\t\t\tactualResult = v1 * v2;\n\t\t\tbreak;\n\t\tcase DIVIDE:\n\t\t\tactualResult = v1 / v2;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (expectedResult != actualResult) {\n\t\t\tthrow new IllegalStateException(\"Math operation failed. Expected=\" + expectedResult + \" but actual=\" + actualResult\n\t\t\t\t\t+ \" for \" + v1 + \" \" + operation.name() + \" \" + v2);\n\t\t}\n\t}\t\n}",
        "start_line": 0,
        "end_line": 56,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 400,
        "node_type": null,
        "file_sha": "9fb959a7222d34a4d3c2035d136bd299109d4f60",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.791576"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\npackage net.adoptopenjdk.stf;\n\npublic class ArbitraryJavaTest {\n\tprivate enum OperationType { ADD, SUBTRACT, MULTIPLY, DIVIDE };\n\tprivate OperationType operation;\n\t\n\tpublic ArbitraryJavaTest() {\n\t}\n\t\n\tpublic ArbitraryJavaTest(String operator) {\n\t\toperation = OperationType.valueOf(operator);\n\t}\n\t\n\tpublic void runSimpleTest() {\n\t\t// Run a test that should never fail\n\t\tif (System.currentTimeMillis() < 666) { \n\t\t\tthrow new IllegalStateException(\"System clock wrong\");\n\t\t}\n\t}\n\t\n\tpublic void runTest(int expectedResult, int v1, int v2) {\n\t\tint actualResult = 0;\n\t\t\n\t\tswitch (operation) {\n\t\tcase ADD:\n\t\t\tactualResult = v1 + v2;\n\t\t\tbreak;\n\t\tcase SUBTRACT:\n\t\t\tactualResult = v1 - v2;\n\t\t\tbreak;\n\t\tcase MULTIPLY:\n\t\t\tactualResult = v1 * v2;\n\t\t\tbreak;\n\t\tcase DIVIDE:\n\t\t\tactualResult = v1 / v2;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (expectedResult != actualResult) {\n\t\t\tthrow new IllegalStateException(\"Math operation failed. Expected=\" + expectedResult + \" but actual=\" + actualResult\n\t\t\t\t\t+ \" for \" + v1 + \" \" + operation.name() + \" \" + v2);\n\t\t}\n\t}\t\n}"
    },
    "449": {
      "metadata": {
        "chunk_id": "f0e1964447945db3986f42f2453fc216a0b46c9d8859f7208f91fe342eeacbac",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/FailingJUnitTest.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport junit.framework.TestCase;\n\n\n/** \n * This simple junit test will deliberately fail on the 3rd to 10th invocation.\n * Expected behaviour:\n *   1st invocation - all pass.\n *   2nd invocation - all pass.\n *   3rd invocation - testPi fails.\n *   4th invocation - all pass.\n *   5th to 9th invocation - testAdding fails.\n *   10th and subsequent - all pass.\n */\npublic class FailingJUnitTest extends TestCase {\n\tprivate static int testPiCount = 0;\n\tprivate static int testAddingCount = 0;\n\t\n\tpublic void testPi() {\n\t\ttestPiCount++;\n\t\tif (testPiCount == 3) {\n\t\t\tassertEquals(\"Wrong value of pi\", 3.0d, Math.PI);\n\t\t}\n\t}\n\t\n\tpublic void testAdding() {\n\t\ttestAddingCount++;\n\t\tif (testAddingCount >= 5 && testAddingCount <=9) {\n\t\t\tassertEquals(\"Addition failed\", 5, 2+2);\n\t\t}\n\t}\n}",
        "start_line": 0,
        "end_line": 46,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 353,
        "node_type": null,
        "file_sha": "017800d4d269eb700e28a6976f3e936159e20bbc",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.813477"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport junit.framework.TestCase;\n\n\n/** \n * This simple junit test will deliberately fail on the 3rd to 10th invocation.\n * Expected behaviour:\n *   1st invocation - all pass.\n *   2nd invocation - all pass.\n *   3rd invocation - testPi fails.\n *   4th invocation - all pass.\n *   5th to 9th invocation - testAdding fails.\n *   10th and subsequent - all pass.\n */\npublic class FailingJUnitTest extends TestCase {\n\tprivate static int testPiCount = 0;\n\tprivate static int testAddingCount = 0;\n\t\n\tpublic void testPi() {\n\t\ttestPiCount++;\n\t\tif (testPiCount == 3) {\n\t\t\tassertEquals(\"Wrong value of pi\", 3.0d, Math.PI);\n\t\t}\n\t}\n\t\n\tpublic void testAdding() {\n\t\ttestAddingCount++;\n\t\tif (testAddingCount >= 5 && testAddingCount <=9) {\n\t\t\tassertEquals(\"Addition failed\", 5, 2+2);\n\t\t}\n\t}\n}"
    },
    "450": {
      "metadata": {
        "chunk_id": "9a3f0ea808ea013d5baaaa3d58af2186afe278da62dd2c5e2aa28b30ed4b382c",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/MiniJUnitTest.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport junit.framework.TestCase;\n\n\n/** \n * Bare bones JUnit test for SampleLoadTest.\n */\npublic class MiniJUnitTest extends TestCase {\n\tpublic void testMaths() {\n\t\tassertEquals(\"Maths max test\", 818.222d, Math.max(3.14d, 818.222d));\n\t}\n}",
        "start_line": 0,
        "end_line": 26,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 196,
        "node_type": null,
        "file_sha": "1263d03e2a9e1386d1f14fcaabd717c9f7217841",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.836663"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport junit.framework.TestCase;\n\n\n/** \n * Bare bones JUnit test for SampleLoadTest.\n */\npublic class MiniJUnitTest extends TestCase {\n\tpublic void testMaths() {\n\t\tassertEquals(\"Maths max test\", 818.222d, Math.max(3.14d, 818.222d));\n\t}\n}"
    },
    "451": {
      "metadata": {
        "chunk_id": "baccadafbf9f220806cf1c8385856107e33095c57f08b53d5622568c7bed408b",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/SampleEchoFile.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.SpeedyApplication;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test demonstrates how tests can echo the contents of a file.\n */\npublic class SampleEchoFile implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"SampleEchoFile\");\n\t\thelp.outputText(\"This test demonstrates how to echo a file.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws StfException {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws StfException {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws StfException {\n\t\t// Run a short lived java process\n\t\tJavaProcessDefinition speedyAppDefinition = test.createJavaProcessDefinition()\n\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t.runClass(SpeedyApplication.class);\n\t\tStfProcess speedyAppProcess = test.doRunForegroundProcess(\"Run speedy app\", \"SA\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"20s\"), speedyAppDefinition);\n\t\t\n\t\t// Show output from SpeedyApplication on the STF standard output\n\t\tFileRef targetFile = speedyAppProcess.getStdoutFileRef();\n\t\ttest.doEchoFile(\"Echo speedy app output\", targetFile);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws StfException {\n\t}\n}",
        "start_line": 0,
        "end_line": 57,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 540,
        "node_type": null,
        "file_sha": "8b0cf1272b8c605ebab158e5426d4fc11e4ef500",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.859963"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.SpeedyApplication;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test demonstrates how tests can echo the contents of a file.\n */\npublic class SampleEchoFile implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"SampleEchoFile\");\n\t\thelp.outputText(\"This test demonstrates how to echo a file.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws StfException {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws StfException {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws StfException {\n\t\t// Run a short lived java process\n\t\tJavaProcessDefinition speedyAppDefinition = test.createJavaProcessDefinition()\n\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t.runClass(SpeedyApplication.class);\n\t\tStfProcess speedyAppProcess = test.doRunForegroundProcess(\"Run speedy app\", \"SA\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"20s\"), speedyAppDefinition);\n\t\t\n\t\t// Show output from SpeedyApplication on the STF standard output\n\t\tFileRef targetFile = speedyAppProcess.getStdoutFileRef();\n\t\ttest.doEchoFile(\"Echo speedy app output\", targetFile);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws StfException {\n\t}\n}"
    },
    "452": {
      "metadata": {
        "chunk_id": "dc6fe0fea236bfbc55504d9213408b2da196f00992a2a457dab09c927b5253c5",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/SampleFailingLoadTest.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.LoadTestProcessDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This is a sample test which demonstrates a failing load test.\n * It also shows the usage of the load test arguments to control error reporting \n * and aborting when there are too many failures:\n *    LoadTestProcessDefinition.setReportFailureLimit(int)\n *    LoadTestProcessDefinition.setAbortAtFailureLimit(int)\n * \n * It can be used as a STF regression test to verify:\n *   - STF reporting of first failure.\n *   - 2nd and subsequent failures not reported in detail.\n *   - Load test exit when failure limit reached.\n *   - Load test requests javacore on first failure.\n *   - Process management passing a test which fails (ie, as expected).\n *\n */",
        "start_line": 0,
        "end_line": 42,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 416,
        "node_type": null,
        "file_sha": "218e687e386433da130c090dad709652c01f92b8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.884983"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.LoadTestProcessDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This is a sample test which demonstrates a failing load test.\n * It also shows the usage of the load test arguments to control error reporting \n * and aborting when there are too many failures:\n *    LoadTestProcessDefinition.setReportFailureLimit(int)\n *    LoadTestProcessDefinition.setAbortAtFailureLimit(int)\n * \n * It can be used as a STF regression test to verify:\n *   - STF reporting of first failure.\n *   - 2nd and subsequent failures not reported in detail.\n *   - Load test exit when failure limit reached.\n *   - Load test requests javacore on first failure.\n *   - Process management passing a test which fails (ie, as expected).\n *\n */"
    },
    "453": {
      "metadata": {
        "chunk_id": "a41eca3b3cd5a4cde094919c34f626999b254f115a4e09aca0f5d2f766ed68f4",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/SampleFailingLoadTest.java",
        "content": "public class SampleFailingLoadTest implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"Runs a failing load test.\");\n\t}\n\t\n\tpublic void pluginInit(StfCoreExtension stfCore) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension stfCore) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension stfCore) throws Exception {\n\t\tString inventoryFile = \"/stf.samples/config/inventories/sampleLoadTest/sampleFailingInventory.xml\";\n\t\t\n\t\tLoadTestProcessDefinition loadTestSpecification = stfCore.createLoadTestSpecification()\n\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.JUNIT)\n\t\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.HAMCREST)\n\t\t\t\t.setReportFailureLimit(1) \t\t\t// Only report the first failure in detail\n\t\t\t\t.setAbortAtFailureLimit(4)\t\t\t// Abandon the run after 4 failures \n\t\t\t\t.addSuite(\"suite\")\n\t\t\t\t.setSuiteInventory(inventoryFile)\t// Point to inventory file which has failing test\n \t\t\t\t.setSuiteThreadCount(1)\t\t\t\t// Run with only 1 worker thread\n \t\t\t\t.setSuiteNumTests(25)\t\t\t\t// Plan to run 25 tests\n \t\t\t\t.setSuiteSequentialSelection();\t    // Sequential run test. Only 1 test so a bit academic\n\t\t\n\t\t// Run load test and wait for it to finish\n\t\tstfCore.doRunForegroundProcess(\"Run load test for project\", \"LT\", ECHO_ON, ExpectedOutcome.exitValue(1).within(\"1m\"), \n\t\t\t\tloadTestSpecification);\n\t\t\n\t\t// Verify expected tests failed \n\t\tFileRef loadTestStdout = stfCore.env().getResultsDir().childFile(\"1.LT.stdout\");\n\t\tstfCore.doCountFileMatches(\"Verify first failure reported\", loadTestStdout, 1, \"junit.framework.AssertionFailedError: Wrong value of pi\");\n\t\tstfCore.doCountFileMatches(\"Verify subsequent failure not reported\", loadTestStdout, 0, \"junit.framework.AssertionFailedError: Addition failed\");\n\t\tstfCore.doCountFileMatches(\"Verify 3 failures detected but not reported\", loadTestStdout, 3, \"Test failed. Details recorded in execution log\");\n\t\tstfCore.doCountFileMatches(\"Verify overall failure count\", loadTestStdout, 1, \"Failed  : 4$\");\n\t\t\n\t\t// Verify javacore requested\n\t\tFileRef loadTestStderr = stfCore.env().getResultsDir().childFile(\"1.LT.stderr\");\n\t\tif (stfCore.env().primaryJvm().isIBMJvm()) {\n\t\t\tstfCore.doCountFileMatches(\"Verify javacore requested\", loadTestStderr, 1, \"User requested Java dump\");\n\t\t} else {\n\t\t\tstfCore.doCountFileMatches(\"Verify javacore requested\", loadTestStdout, 1, \"Not creating dumps as not running on an IBM JVM\");\n\t\t}\n\t}\n\n\tpublic void tearDown(StfCoreExtension stfCore) throws Exception {\n\t}\n}",
        "start_line": 43,
        "end_line": 91,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 683,
        "node_type": null,
        "file_sha": "218e687e386433da130c090dad709652c01f92b8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.885001"
      },
      "text": "public class SampleFailingLoadTest implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"Runs a failing load test.\");\n\t}\n\t\n\tpublic void pluginInit(StfCoreExtension stfCore) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension stfCore) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension stfCore) throws Exception {\n\t\tString inventoryFile = \"/stf.samples/config/inventories/sampleLoadTest/sampleFailingInventory.xml\";\n\t\t\n\t\tLoadTestProcessDefinition loadTestSpecification = stfCore.createLoadTestSpecification()\n\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.JUNIT)\n\t\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.HAMCREST)\n\t\t\t\t.setReportFailureLimit(1) \t\t\t// Only report the first failure in detail\n\t\t\t\t.setAbortAtFailureLimit(4)\t\t\t// Abandon the run after 4 failures \n\t\t\t\t.addSuite(\"suite\")\n\t\t\t\t.setSuiteInventory(inventoryFile)\t// Point to inventory file which has failing test\n \t\t\t\t.setSuiteThreadCount(1)\t\t\t\t// Run with only 1 worker thread\n \t\t\t\t.setSuiteNumTests(25)\t\t\t\t// Plan to run 25 tests\n \t\t\t\t.setSuiteSequentialSelection();\t    // Sequential run test. Only 1 test so a bit academic\n\t\t\n\t\t// Run load test and wait for it to finish\n\t\tstfCore.doRunForegroundProcess(\"Run load test for project\", \"LT\", ECHO_ON, ExpectedOutcome.exitValue(1).within(\"1m\"), \n\t\t\t\tloadTestSpecification);\n\t\t\n\t\t// Verify expected tests failed \n\t\tFileRef loadTestStdout = stfCore.env().getResultsDir().childFile(\"1.LT.stdout\");\n\t\tstfCore.doCountFileMatches(\"Verify first failure reported\", loadTestStdout, 1, \"junit.framework.AssertionFailedError: Wrong value of pi\");\n\t\tstfCore.doCountFileMatches(\"Verify subsequent failure not reported\", loadTestStdout, 0, \"junit.framework.AssertionFailedError: Addition failed\");\n\t\tstfCore.doCountFileMatches(\"Verify 3 failures detected but not reported\", loadTestStdout, 3, \"Test failed. Details recorded in execution log\");\n\t\tstfCore.doCountFileMatches(\"Verify overall failure count\", loadTestStdout, 1, \"Failed  : 4$\");\n\t\t\n\t\t// Verify javacore requested\n\t\tFileRef loadTestStderr = stfCore.env().getResultsDir().childFile(\"1.LT.stderr\");\n\t\tif (stfCore.env().primaryJvm().isIBMJvm()) {\n\t\t\tstfCore.doCountFileMatches(\"Verify javacore requested\", loadTestStderr, 1, \"User requested Java dump\");\n\t\t} else {\n\t\t\tstfCore.doCountFileMatches(\"Verify javacore requested\", loadTestStdout, 1, \"Not creating dumps as not running on an IBM JVM\");\n\t\t}\n\t}\n\n\tpublic void tearDown(StfCoreExtension stfCore) throws Exception {\n\t}\n}"
    },
    "454": {
      "metadata": {
        "chunk_id": "f338bb79a9f94894a9aa05512b0373a69cc55f4efc8a8e6e639a1f6043a1bf87",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/SampleLoadTest.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.LoadTestProcessDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\nimport net.adoptopenjdk.loadTest.InventoryData;\n\n/** \n * This sample test demonstrates the STF interface to the load test program.\n * It's a reasonably complex test as it runs 2 suites in multiple threads, and \n * shows the usage of some of the less rarely used arguments.\n * \n * For a much simpler example see SampleMauveLoadTest.java\n */",
        "start_line": 0,
        "end_line": 33,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 334,
        "node_type": null,
        "file_sha": "4a89672567f4f46e1068e20e074892a81a74f346",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.908819"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.processes.definitions.LoadTestProcessDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\nimport net.adoptopenjdk.loadTest.InventoryData;\n\n/** \n * This sample test demonstrates the STF interface to the load test program.\n * It's a reasonably complex test as it runs 2 suites in multiple threads, and \n * shows the usage of some of the less rarely used arguments.\n * \n * For a much simpler example see SampleMauveLoadTest.java\n */"
    },
    "455": {
      "metadata": {
        "chunk_id": "49505cc0d1b0608ebb9fd533ccb49633aadd90fab62cd5a085c68efa702d5d19",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/SampleLoadTest.java",
        "content": "public class SampleLoadTest implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"Runs a load test.\");\n\t}\n\t\n\tpublic void pluginInit(StfCoreExtension stfCore) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension stfCore) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension stfCore) throws Exception {\n\t\tString inventoryFile1 = \"/stf.samples/config/inventories/sampleLoadTest/sampleInventory.xml\";\n\t\tString inventoryFile2 = \"/stf.samples/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml\";\n\t\tint numTests = InventoryData.getNumberOfTests(stfCore, inventoryFile1);\n\t\t\t\t\n\t\tLoadTestProcessDefinition loadTestSpecification = stfCore.createLoadTestSpecification()\n\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.JUNIT)\n\t\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.HAMCREST)\n\t\t\t\t.setTimeLimit(\"12s\")\t\t\t\t// Don't start any tests after 12 seconds\n\t\t\t    .setMaxTotalLogFileSpace(\"500M\")    // Optional. Prevent logging from exceeding 500M of log files\n\t\t\t    .setMaxSingleLogSize(\"1/50\")        // Optional. Run with limit of 50 logs, each up to 10M. \n\t\t\t\t.addSuite(\"suite1\")\t\t\t\t\t// Arguments for the first suite follow\n \t\t\t\t.setSuiteThreadCount(Runtime.getRuntime().availableProcessors()-3, 2,16)  // Leave 1 cpu for the JIT, 1 for GC, 1 for the other suite. But always run at least two threads and never more than 16\n \t\t\t\t.setSuiteInventory(inventoryFile1)\t//   Point at the file which lists the tests. There are no exclusion files.\n \t\t\t\t.setSuiteNumTests(numTests * 10)    //   Number of tests to run varies with size of inventory file\n \t\t\t\t.setSuiteTestRepeatCount(3)\t\t    //   Run each test 3 times \n \t\t\t\t.setSuiteThinkingTime(\"5ms\", \"75ms\")//   Waiting time between tests is randomly selected between 5ms and 75ms. Can also use 's' for seconds.\n \t\t\t\t.setSuiteSequentialSelection()\t    //   Not random selection. Sequential from start. eg, 0,1,2,3,4,5,0,1,...\n\t\t\t\t.addSuite(\"suite2\")\t\t\t\t\t// Add 2nd (optional) suite\n\t\t\t\t.setSuiteThreadCount(1)\t\t\t    //   Run in a single thread\n\t\t\t\t.setSuiteInventory(inventoryFile2)\t//   Use the sample inventory file, which has 2 exclusion files.\n\t\t\t\t.setSuiteNumTests(1000)\t\t\t    //   Run 1000 tests in total\n\t\t\t\t.setSuiteTestRepeatCount(25)\t    //   Run which ever test is picked 25 times before picking next test \n\t\t\t\t.setSuiteRandomSelection();\t\t    //   Randomly choose test to run. Note this suite doesn't have a 'thinking' time.\n\t\t\n\t\t// Run load test and wait for it to finish\n\t\tstfCore.doRunForegroundProcess(\"Run load test for project\", \"LT\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"5m\"), \n\t\t\t\tloadTestSpecification);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stfCore) throws Exception {\n\t}\n}",
        "start_line": 34,
        "end_line": 78,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 742,
        "node_type": null,
        "file_sha": "4a89672567f4f46e1068e20e074892a81a74f346",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.908826"
      },
      "text": "public class SampleLoadTest implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"Runs a load test.\");\n\t}\n\t\n\tpublic void pluginInit(StfCoreExtension stfCore) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension stfCore) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension stfCore) throws Exception {\n\t\tString inventoryFile1 = \"/stf.samples/config/inventories/sampleLoadTest/sampleInventory.xml\";\n\t\tString inventoryFile2 = \"/stf.samples/config/inventories/sampleLoadTest/subtests/arbitraryJavaInventory.xml\";\n\t\tint numTests = InventoryData.getNumberOfTests(stfCore, inventoryFile1);\n\t\t\t\t\n\t\tLoadTestProcessDefinition loadTestSpecification = stfCore.createLoadTestSpecification()\n\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.JUNIT)\n\t\t\t\t.addPrereqJarToClasspath(JavaProcessDefinition.JarId.HAMCREST)\n\t\t\t\t.setTimeLimit(\"12s\")\t\t\t\t// Don't start any tests after 12 seconds\n\t\t\t    .setMaxTotalLogFileSpace(\"500M\")    // Optional. Prevent logging from exceeding 500M of log files\n\t\t\t    .setMaxSingleLogSize(\"1/50\")        // Optional. Run with limit of 50 logs, each up to 10M. \n\t\t\t\t.addSuite(\"suite1\")\t\t\t\t\t// Arguments for the first suite follow\n \t\t\t\t.setSuiteThreadCount(Runtime.getRuntime().availableProcessors()-3, 2,16)  // Leave 1 cpu for the JIT, 1 for GC, 1 for the other suite. But always run at least two threads and never more than 16\n \t\t\t\t.setSuiteInventory(inventoryFile1)\t//   Point at the file which lists the tests. There are no exclusion files.\n \t\t\t\t.setSuiteNumTests(numTests * 10)    //   Number of tests to run varies with size of inventory file\n \t\t\t\t.setSuiteTestRepeatCount(3)\t\t    //   Run each test 3 times \n \t\t\t\t.setSuiteThinkingTime(\"5ms\", \"75ms\")//   Waiting time between tests is randomly selected between 5ms and 75ms. Can also use 's' for seconds.\n \t\t\t\t.setSuiteSequentialSelection()\t    //   Not random selection. Sequential from start. eg, 0,1,2,3,4,5,0,1,...\n\t\t\t\t.addSuite(\"suite2\")\t\t\t\t\t// Add 2nd (optional) suite\n\t\t\t\t.setSuiteThreadCount(1)\t\t\t    //   Run in a single thread\n\t\t\t\t.setSuiteInventory(inventoryFile2)\t//   Use the sample inventory file, which has 2 exclusion files.\n\t\t\t\t.setSuiteNumTests(1000)\t\t\t    //   Run 1000 tests in total\n\t\t\t\t.setSuiteTestRepeatCount(25)\t    //   Run which ever test is picked 25 times before picking next test \n\t\t\t\t.setSuiteRandomSelection();\t\t    //   Randomly choose test to run. Note this suite doesn't have a 'thinking' time.\n\t\t\n\t\t// Run load test and wait for it to finish\n\t\tstfCore.doRunForegroundProcess(\"Run load test for project\", \"LT\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"5m\"), \n\t\t\t\tloadTestSpecification);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stfCore) throws Exception {\n\t}\n}"
    },
    "456": {
      "metadata": {
        "chunk_id": "77aea3eaaeb0477e7a6d0d3a7c25bd9b8e47bd7532c8942d555a447a4612e275",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/SampleSecondaryJvm.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniServer;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\n/**\n * This sample test shows how a test can run with a primary and secondary JVM.\n * It's a variant of SampleClientServer:\n *   - server process. Runs on IBM JVM.\n *   - client processes. Run on Oracle JVM.\n *\n * This test will fail unless told about the secondary JVM by either:\n *   1) Setting the JAVA_HOME_SECONDARY environment variable, or\n *   2) The VM is explicitly supplied as test arguments.\n */\npublic class SampleSecondaryJvm implements StfPluginInterface {\n\n    private static final Logger logger = LogManager.getLogger(JavaVersion.class.getName());\n\n    public void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleSecondaryJvm\");\n\t\thelp.outputText(\"This test demonstrates running different processes with different JVM's\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\tJavaVersion primaryJvm   = test.env().primaryJvm();\n\t\tJavaVersion secondaryJvm = test.env().secondaryJvm();\n\t\t\n\t\t// Sample code to validate that the expected Java implementation is being used for the test.\n\t\t//primaryJvm.verifyUsingIBMJava();\n\t\t//secondaryJvm.verifyUsingOracleJava();\n\n\t\t// List the java version output for the two JDKs.\n\t\tlogger.info(\"java -version output for primary JVM:\\n\" + primaryJvm.getRawOutput());\n\t\tlogger.info(\"java -version output for secondary JVM:\\n\" + secondaryJvm.getRawOutput());\n\t\t\n\t\t// Start a server process using IBM Java on the primary JVM\n\t\tStfProcess server = test.doRunBackgroundProcess(\"Run server\", \"SRV\", ECHO_ON, ExpectedOutcome.neverCompletes(), \n\t\t\t\ttest.createJavaProcessDefinition(primaryJvm)\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniServer.class));\n\t\t\n\t\t// Run several client processes using the secondary JVM. \n\t\tStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition(secondaryJvm)\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Wait for clients to complete, and then kill the server\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", server, clients);\n\t\ttest.doKillProcesses(\"Stop server process\", server);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 0,
        "end_line": 87,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 859,
        "node_type": null,
        "file_sha": "4601ffef2c7dad59940e5662b0b456e724dad348",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.933260"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.environment.JavaVersion;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniServer;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\n/**\n * This sample test shows how a test can run with a primary and secondary JVM.\n * It's a variant of SampleClientServer:\n *   - server process. Runs on IBM JVM.\n *   - client processes. Run on Oracle JVM.\n *\n * This test will fail unless told about the secondary JVM by either:\n *   1) Setting the JAVA_HOME_SECONDARY environment variable, or\n *   2) The VM is explicitly supplied as test arguments.\n */\npublic class SampleSecondaryJvm implements StfPluginInterface {\n\n    private static final Logger logger = LogManager.getLogger(JavaVersion.class.getName());\n\n    public void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleSecondaryJvm\");\n\t\thelp.outputText(\"This test demonstrates running different processes with different JVM's\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\tJavaVersion primaryJvm   = test.env().primaryJvm();\n\t\tJavaVersion secondaryJvm = test.env().secondaryJvm();\n\t\t\n\t\t// Sample code to validate that the expected Java implementation is being used for the test.\n\t\t//primaryJvm.verifyUsingIBMJava();\n\t\t//secondaryJvm.verifyUsingOracleJava();\n\n\t\t// List the java version output for the two JDKs.\n\t\tlogger.info(\"java -version output for primary JVM:\\n\" + primaryJvm.getRawOutput());\n\t\tlogger.info(\"java -version output for secondary JVM:\\n\" + secondaryJvm.getRawOutput());\n\t\t\n\t\t// Start a server process using IBM Java on the primary JVM\n\t\tStfProcess server = test.doRunBackgroundProcess(\"Run server\", \"SRV\", ECHO_ON, ExpectedOutcome.neverCompletes(), \n\t\t\t\ttest.createJavaProcessDefinition(primaryJvm)\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniServer.class));\n\t\t\n\t\t// Run several client processes using the secondary JVM. \n\t\tStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition(secondaryJvm)\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Wait for clients to complete, and then kill the server\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", server, clients);\n\t\ttest.doKillProcesses(\"Stop server process\", server);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "457": {
      "metadata": {
        "chunk_id": "73d73968fb267acae3fd350d4022885aea3c42d62582c892c3deccd9504699e0",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/SampleValidateFileAbsence.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test demonstrates how tests can validate absence of a file.\n */\npublic class SampleValidateFileAbsence implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"SampleValidateFileAbsence\");\n\t\thelp.outputText(\"This test demonstrates how to validate absence of a file.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws StfException {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws StfException {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws StfException {\n\t\t// For demonstration purposes, create reference to a fake file\n\t\tFileRef fileToBeAbsent = test.env().getJavaHome().childFile(\"aFakeFile.txt\");\n\t\t\n\t\t// Pass reference to a fake file to doValidateFileAbsent(). \n\t\t// Since this test passes only if the given file is not present,Our test should pass\n\t\ttest.doValidateFileAbsent(\"Validate file is absent\", fileToBeAbsent);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws StfException {\n\t}\n}",
        "start_line": 0,
        "end_line": 48,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 424,
        "node_type": null,
        "file_sha": "d040b27d3512474c6591f3751d5ce453970b1bfd",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.960038"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test demonstrates how tests can validate absence of a file.\n */\npublic class SampleValidateFileAbsence implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"SampleValidateFileAbsence\");\n\t\thelp.outputText(\"This test demonstrates how to validate absence of a file.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws StfException {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws StfException {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws StfException {\n\t\t// For demonstration purposes, create reference to a fake file\n\t\tFileRef fileToBeAbsent = test.env().getJavaHome().childFile(\"aFakeFile.txt\");\n\t\t\n\t\t// Pass reference to a fake file to doValidateFileAbsent(). \n\t\t// Since this test passes only if the given file is not present,Our test should pass\n\t\ttest.doValidateFileAbsent(\"Validate file is absent\", fileToBeAbsent);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws StfException {\n\t}\n}"
    },
    "458": {
      "metadata": {
        "chunk_id": "b32ad1c24f9ed162ac0b440bb65f80321062ca22a91f9673e429ca002241e235",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/SampleWriteFile.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test makes use of the api to write a file.\n */\npublic class SampleWriteFile implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"SampleWriteFile\");\n\t\thelp.outputText(\"This test demonstrates file writing.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws StfException {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws StfException {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws StfException {\n\t\t// Create some sort of content which needs to be written to an output file.\n\t\tString fileContent = \n\t\t\t\t  \"userName=bob\\n\"\n\t\t\t\t+ \"password=secret\\n\"\n\t\t\t\t+ \"outputPort = 233\\n\"\n\t\t\t\t+ \"PATH=C:\\\\path\\\\\\\\temp\\\\\\\\\\\\\\\\rest\\n\";  // 1, 2 & 4 backslash characters\n\t\t\n\t\t// Write the dummy configuration to a new file\n\t\tFileRef outputFile = test.env().getTmpDir().childFile(\"SampleConfig.properties\");\n\t\ttest.doWriteFile(\"Sample file write\", outputFile, fileContent);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws StfException {\n\t}\n}",
        "start_line": 0,
        "end_line": 52,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 449,
        "node_type": null,
        "file_sha": "73ad1d39352a69becd33ebe89cb9d6864f11190a",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:53.992612"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf;\n\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test makes use of the api to write a file.\n */\npublic class SampleWriteFile implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws StfException {\n\t\thelp.outputSection(\"SampleWriteFile\");\n\t\thelp.outputText(\"This test demonstrates file writing.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws StfException {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws StfException {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws StfException {\n\t\t// Create some sort of content which needs to be written to an output file.\n\t\tString fileContent = \n\t\t\t\t  \"userName=bob\\n\"\n\t\t\t\t+ \"password=secret\\n\"\n\t\t\t\t+ \"outputPort = 233\\n\"\n\t\t\t\t+ \"PATH=C:\\\\path\\\\\\\\temp\\\\\\\\\\\\\\\\rest\\n\";  // 1, 2 & 4 backslash characters\n\t\t\n\t\t// Write the dummy configuration to a new file\n\t\tFileRef outputFile = test.env().getTmpDir().childFile(\"SampleConfig.properties\");\n\t\ttest.doWriteFile(\"Sample file write\", outputFile, fileContent);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws StfException {\n\t}\n}"
    },
    "459": {
      "metadata": {
        "chunk_id": "38e505eaa01e11c64e36d5b93f3c5caa7cea87a87bc39c39955a54b82c5e6072",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/extension/ExampleExtension.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extension;\n\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.Argument.Required;\nimport net.adoptopenjdk.stf.extensions.StfExtensionBase;\nimport net.adoptopenjdk.stf.extensions.interfaces.StfExtension;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This simple extension demonstrates how to add a custom extension.\n * See SampleCustomExtensionTest.java for more details.\n */",
        "start_line": 0,
        "end_line": 33,
        "chunk_index": 0,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 295,
        "node_type": null,
        "file_sha": "9f12247d9a4dce599efd40e673f68ed6e35a6b53",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.016025"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extension;\n\nimport java.util.ArrayList;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.codeGeneration.PerlCodeGenerator;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.StfEnvironmentCore;\nimport net.adoptopenjdk.stf.environment.properties.Argument;\nimport net.adoptopenjdk.stf.environment.properties.Argument.Required;\nimport net.adoptopenjdk.stf.extensions.StfExtensionBase;\nimport net.adoptopenjdk.stf.extensions.interfaces.StfExtension;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This simple extension demonstrates how to add a custom extension.\n * See SampleCustomExtensionTest.java for more details.\n */"
    },
    "460": {
      "metadata": {
        "chunk_id": "664b67bf3f97ff800c8717ab359d9e1cd0b7d08507bc3c7593812542d967db25",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/extension/ExampleExtension.java",
        "content": "public class ExampleExtension implements StfExtension {\n    private StfEnvironmentCore environmentCore;\n    private StfExtensionBase extensionBase;\n    private PerlCodeGenerator generator;\n    \n    private static boolean haveDeclaredVariables = false;\n    \n    \n    // Arguments for this extension.\n    // Default value set in config file, which can be overridden on the command line.\n\t//                        Java name                     extension Argument   name           Boolean            Type\n\tpublic static Argument ARG_SHOW_FILES    = new Argument(\"exampleExtension\", \"show-files\",    true,   Required.OPTIONAL); \n    \n\t@Override\n\tpublic Argument[] getSupportedArguments() {\n\t\treturn new Argument[] { \n\t\t\tARG_SHOW_FILES\n\t\t};\n\t}\n\t\n\t\n\t@Override\n\tpublic void help(HelpTextGenerator help) {\n\t\thelp.outputSection(\"Example extension options\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_SHOW_FILES.getName());\n\t\thelp.outputArgDesc(\"If set then test data files are written to stdout.\");\n\t}\n\n\t\n\t@Override\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.extensionBase = extensionBase;\n\t\tthis.generator = generator;\t\n\t}\n\t\n\t\n\t/**\n\t * This action uses perl code to validate the contents of a GC log file. \n\t */\n\tpublic void doVerifyGcLog(String comment, FileRef gcResultsFile) throws StfException {\n\t\tinvokeParsingSubroutine(comment, \"GC\", \"checkGCData\", gcResultsFile);\n\t}\n\n\n\t/**\n\t * This action uses perl code to validate the contents of a GC log file.\n\t */\n\tpublic void doVerifyHeapLog(String comment, FileRef heapResultsFile) throws StfException {\n\t\tinvokeParsingSubroutine(comment, \"Heap\", \"checkHeapData\", heapResultsFile);\n\t}",
        "start_line": 34,
        "end_line": 85,
        "chunk_index": 1,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 385,
        "node_type": null,
        "file_sha": "9f12247d9a4dce599efd40e673f68ed6e35a6b53",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.016038"
      },
      "text": "public class ExampleExtension implements StfExtension {\n    private StfEnvironmentCore environmentCore;\n    private StfExtensionBase extensionBase;\n    private PerlCodeGenerator generator;\n    \n    private static boolean haveDeclaredVariables = false;\n    \n    \n    // Arguments for this extension.\n    // Default value set in config file, which can be overridden on the command line.\n\t//                        Java name                     extension Argument   name           Boolean            Type\n\tpublic static Argument ARG_SHOW_FILES    = new Argument(\"exampleExtension\", \"show-files\",    true,   Required.OPTIONAL); \n    \n\t@Override\n\tpublic Argument[] getSupportedArguments() {\n\t\treturn new Argument[] { \n\t\t\tARG_SHOW_FILES\n\t\t};\n\t}\n\t\n\t\n\t@Override\n\tpublic void help(HelpTextGenerator help) {\n\t\thelp.outputSection(\"Example extension options\");\n\t\t\n\t\thelp.outputArgName(\"-\" + ARG_SHOW_FILES.getName());\n\t\thelp.outputArgDesc(\"If set then test data files are written to stdout.\");\n\t}\n\n\t\n\t@Override\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.extensionBase = extensionBase;\n\t\tthis.generator = generator;\t\n\t}\n\t\n\t\n\t/**\n\t * This action uses perl code to validate the contents of a GC log file. \n\t */\n\tpublic void doVerifyGcLog(String comment, FileRef gcResultsFile) throws StfException {\n\t\tinvokeParsingSubroutine(comment, \"GC\", \"checkGCData\", gcResultsFile);\n\t}\n\n\n\t/**\n\t * This action uses perl code to validate the contents of a GC log file.\n\t */\n\tpublic void doVerifyHeapLog(String comment, FileRef heapResultsFile) throws StfException {\n\t\tinvokeParsingSubroutine(comment, \"Heap\", \"checkHeapData\", heapResultsFile);\n\t}"
    },
    "461": {
      "metadata": {
        "chunk_id": "fa75a43d33260ca07a373cc05ecda55ec0896b236fe6dff7e15a7191ecbf1f9e",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/extension/ExampleExtension.java",
        "content": "@Override\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.extensionBase = extensionBase;\n\t\tthis.generator = generator;\t\n\t}\n\t\n\t\n\t/**\n\t * This action uses perl code to validate the contents of a GC log file. \n\t */\n\tpublic void doVerifyGcLog(String comment, FileRef gcResultsFile) throws StfException {\n\t\tinvokeParsingSubroutine(comment, \"GC\", \"checkGCData\", gcResultsFile);\n\t}\n\n\n\t/**\n\t * This action uses perl code to validate the contents of a GC log file.\n\t */\n\tpublic void doVerifyHeapLog(String comment, FileRef heapResultsFile) throws StfException {\n\t\tinvokeParsingSubroutine(comment, \"Heap\", \"checkHeapData\", heapResultsFile);\n\t}\n\n\n\t/**\n\t * The parsing methods have basically the same logic, so this method generates perl \n\t * to invoke the named method.\n\t * @param comment describes why the test is calling the action.\n\t * @param dataType short name describing the data type whose file is being parsed.\n\t * @param subroutineName is the method in ExampleModule.pm to run.\n\t * @param dataFile is the file to be parsed.\n\t * @throws StfException if code generation fails.\n\t */\n\tprivate void invokeParsingSubroutine(String comment, String dataType, String subroutineName, FileRef dataFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"perl\", \"Run perl method to validate \" + dataType + \" log\",\n\t\t\t\tdataType + \"File:\", dataFile.getSpec());\n\t\t\n\t\tboolean showFiles = environmentCore.getBooleanProperty(ARG_SHOW_FILES);\n\t\tif (showFiles) {\n\t\t\t// Output some perl to dump the contents of the test file\n\t\t\tgenerator.outputCreateVariable(\"$outFile\");\n\t\t\tgenerator.outputCreateVariable(\"$line\");\n\t\t\tgenerator.outputLine(\"print \\\"Contents of file \" + dataFile.getSpec() + \":\\\\n\\\";\");\n\t\t\tgenerator.outputLine(\"print \\\">>>\\\\n\\\";\");\n\t\t\tgenerator.outputLine(\"open $outFile, '<', \\\"\" + dataFile.getSpec() + \"\\\" or die \\\"Unable to open file for reading : $!\\\";\");\n\t\t\tgenerator.outputLine(\"while ( $line = <$outFile> ) {\");\n\t\t\tgenerator.outputLine(\"    print \\\"$line\\\";\");\n\t\t\tgenerator.outputLine(\"}\");\n\t\t\tgenerator.outputLine(\"close $outFile;\");\n\t\t\tgenerator.outputLine(\"print \\\"<<<\\\\n\\\";\");\n\t\t\tgenerator.outputLine(\"\");\n\t\t}    \n\t\n\t\tDirectoryRef scriptDir = environmentCore.findTestDirectory(\"stf.samples/scripts\");\n\t\t\n\t\t// Generate code to call the subroutine in the perl module\n\t\tString variablePrefix = haveDeclaredVariables ? \"\" : \"my \";  // Only create return variables on the first call\n\t\thaveDeclaredVariables = true;\n\t\tgenerator.outputLine(\"use lib \\\"\" + scriptDir.getSpec() + \"\\\";\");\n\t\tgenerator.outputLine(\"use ExampleModule;\");\n\t\tgenerator.outputLine(variablePrefix  + \"($errors, $errorCount) = ExampleModule->\" + subroutineName + \"(\\\"\" + dataFile + \"\\\");\");\n\t\t\n\t\t// Build some perl code to be used in the event of a failure.\n\t\t// It lists all of the errors returned by the parsing subroutine.\n\t\tArrayList<String> onErrorPerl = new ArrayList<String>();\n\t\tonErrorPerl.add(\"# List parsing errors and end test\");\n\t\tonErrorPerl.add(\"print \\\"$errorCount error(s) found when parsing file:\\\\n\\\";\");\n\t\tonErrorPerl.add(\"for my $i (0 .. $errorCount-1) {\");\n\t\tonErrorPerl.add(\"    print \\\"  \\\" . ($i+1) . \\\") @$errors[$i]\\\\n\\\";\");\n\t\tonErrorPerl.add(\"}\");\n\n\t\t// Output an if statement that fails the test if the number of parsing errors doesn't meet expectations.\n\t\textensionBase.outputFailIfTrue(\"perl\", comment, \"$errorCount\", \"!=\", \"0\", onErrorPerl);\n\t}\n}",
        "start_line": 86,
        "end_line": 160,
        "chunk_index": 2,
        "total_chunks": 3,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 860,
        "node_type": null,
        "file_sha": "9f12247d9a4dce599efd40e673f68ed6e35a6b53",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.016070"
      },
      "text": "@Override\n\tpublic void initialise(StfEnvironmentCore environmentCore, StfExtensionBase extensionBase, PerlCodeGenerator generator) throws StfException {\n\t\tthis.environmentCore = environmentCore;\n\t\tthis.extensionBase = extensionBase;\n\t\tthis.generator = generator;\t\n\t}\n\t\n\t\n\t/**\n\t * This action uses perl code to validate the contents of a GC log file. \n\t */\n\tpublic void doVerifyGcLog(String comment, FileRef gcResultsFile) throws StfException {\n\t\tinvokeParsingSubroutine(comment, \"GC\", \"checkGCData\", gcResultsFile);\n\t}\n\n\n\t/**\n\t * This action uses perl code to validate the contents of a GC log file.\n\t */\n\tpublic void doVerifyHeapLog(String comment, FileRef heapResultsFile) throws StfException {\n\t\tinvokeParsingSubroutine(comment, \"Heap\", \"checkHeapData\", heapResultsFile);\n\t}\n\n\n\t/**\n\t * The parsing methods have basically the same logic, so this method generates perl \n\t * to invoke the named method.\n\t * @param comment describes why the test is calling the action.\n\t * @param dataType short name describing the data type whose file is being parsed.\n\t * @param subroutineName is the method in ExampleModule.pm to run.\n\t * @param dataFile is the file to be parsed.\n\t * @throws StfException if code generation fails.\n\t */\n\tprivate void invokeParsingSubroutine(String comment, String dataType, String subroutineName, FileRef dataFile) throws StfException {\n\t\tgenerator.startNewCommand(comment, \"perl\", \"Run perl method to validate \" + dataType + \" log\",\n\t\t\t\tdataType + \"File:\", dataFile.getSpec());\n\t\t\n\t\tboolean showFiles = environmentCore.getBooleanProperty(ARG_SHOW_FILES);\n\t\tif (showFiles) {\n\t\t\t// Output some perl to dump the contents of the test file\n\t\t\tgenerator.outputCreateVariable(\"$outFile\");\n\t\t\tgenerator.outputCreateVariable(\"$line\");\n\t\t\tgenerator.outputLine(\"print \\\"Contents of file \" + dataFile.getSpec() + \":\\\\n\\\";\");\n\t\t\tgenerator.outputLine(\"print \\\">>>\\\\n\\\";\");\n\t\t\tgenerator.outputLine(\"open $outFile, '<', \\\"\" + dataFile.getSpec() + \"\\\" or die \\\"Unable to open file for reading : $!\\\";\");\n\t\t\tgenerator.outputLine(\"while ( $line = <$outFile> ) {\");\n\t\t\tgenerator.outputLine(\"    print \\\"$line\\\";\");\n\t\t\tgenerator.outputLine(\"}\");\n\t\t\tgenerator.outputLine(\"close $outFile;\");\n\t\t\tgenerator.outputLine(\"print \\\"<<<\\\\n\\\";\");\n\t\t\tgenerator.outputLine(\"\");\n\t\t}    \n\t\n\t\tDirectoryRef scriptDir = environmentCore.findTestDirectory(\"stf.samples/scripts\");\n\t\t\n\t\t// Generate code to call the subroutine in the perl module\n\t\tString variablePrefix = haveDeclaredVariables ? \"\" : \"my \";  // Only create return variables on the first call\n\t\thaveDeclaredVariables = true;\n\t\tgenerator.outputLine(\"use lib \\\"\" + scriptDir.getSpec() + \"\\\";\");\n\t\tgenerator.outputLine(\"use ExampleModule;\");\n\t\tgenerator.outputLine(variablePrefix  + \"($errors, $errorCount) = ExampleModule->\" + subroutineName + \"(\\\"\" + dataFile + \"\\\");\");\n\t\t\n\t\t// Build some perl code to be used in the event of a failure.\n\t\t// It lists all of the errors returned by the parsing subroutine.\n\t\tArrayList<String> onErrorPerl = new ArrayList<String>();\n\t\tonErrorPerl.add(\"# List parsing errors and end test\");\n\t\tonErrorPerl.add(\"print \\\"$errorCount error(s) found when parsing file:\\\\n\\\";\");\n\t\tonErrorPerl.add(\"for my $i (0 .. $errorCount-1) {\");\n\t\tonErrorPerl.add(\"    print \\\"  \\\" . ($i+1) . \\\") @$errors[$i]\\\\n\\\";\");\n\t\tonErrorPerl.add(\"}\");\n\n\t\t// Output an if statement that fails the test if the number of parsing errors doesn't meet expectations.\n\t\textensionBase.outputFailIfTrue(\"perl\", comment, \"$errorCount\", \"!=\", \"0\", onErrorPerl);\n\t}\n}"
    },
    "462": {
      "metadata": {
        "chunk_id": "3c2a857e64b422e6719e3894571aab73ca8ef25ae8a9f54201da9021d89e2ee9",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/extension/ExamplePluginInterface.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extension;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginRootInterface;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This interface defines an interface for test plugins to use the ExampleExtension.\n * \n * Note that the arguments must be the same for the init, setup and teardown methods.\n */\npublic interface ExamplePluginInterface extends StfPluginRootInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception;\n\n\tpublic void pluginInit(StfCoreExtension test, ExampleExtension customExtension) throws Exception;\n\n\tpublic void setUp(StfCoreExtension test, ExampleExtension customExtension) throws Exception;\n\t\n\tpublic void tearDown(StfCoreExtension test, ExampleExtension customExtension) throws Exception;\n}",
        "start_line": 0,
        "end_line": 34,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 296,
        "node_type": null,
        "file_sha": "5b7cfc50acfa694a3167f1779e3cd39e5ee458f8",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.043368"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extension;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginRootInterface;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This interface defines an interface for test plugins to use the ExampleExtension.\n * \n * Note that the arguments must be the same for the init, setup and teardown methods.\n */\npublic interface ExamplePluginInterface extends StfPluginRootInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception;\n\n\tpublic void pluginInit(StfCoreExtension test, ExampleExtension customExtension) throws Exception;\n\n\tpublic void setUp(StfCoreExtension test, ExampleExtension customExtension) throws Exception;\n\t\n\tpublic void tearDown(StfCoreExtension test, ExampleExtension customExtension) throws Exception;\n}"
    },
    "463": {
      "metadata": {
        "chunk_id": "11dc87c71bd4c65be328f06f111f2ff221d104fabd1eb1ecdb58d0eb76e61815",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/extension/SampleCustomExtensionTest.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extension;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.StfTestArguments;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This test demonstrates the use of a test extension.\n * \n * The extension would usually provide a range of actions that can be used by a \n * suite of tests.\n * This is a demo test so the actions that the extension provides are only used\n * by this test.\n * \n * The new custom extension has the same level of power and privilege\n * as the ever present StfCoreExtension. Authors of extension code should\n * take care to provide actions that support the aims of allowing clean and \n * simple test cases. \n * \n * The following files are needed to implement this scenario:\n *   - ExamplePluginInterface.java\n *        Defines setup/execute/teardown methods. These all include \n *        ExampleExtension in their definition.\n *   - ExampleExtension.java\n *        Provides methods to generate code which run perl subroutines.\n *   - SampleCustomExtensionTest.java\n *        This file. Makes use of the new actions in ExampleExtension.\n *   - stf.samples/config/example.properties\n *        Default values for the arguments that belong to ExampleExtension.\n *   - stf.samples/scripts/ExampleModule.pm\n *        Some perl code which the extension runs.\n * \n * The extension has a '-show-files' argument. This is a first class STF \n * argument. It's values can be provided in property files or on the command \n * line. eg, \n *   stf -test=SampleCustomExtensionTest -show-files\n * The extension argument is added by:\n *   1) Defining an Argument object in the extension to describe the new argument.\n *   2) The extension returns the argument as a supported one in getSupportedArguments()\n *   3) The extension provides help text about the argument in its help() method.\n *   4) Default values are provided in a <project>/config/<extension-name>.properties file.\n *   \n * This test also has a test specific argument called 'forceFailure'. It defaults \n * to 'false' but the failure path can be triggered by running with:\n *   stf -test=SampleCustomExtensionTest -test-args=force-failure=true\n *\n * Both the extension and test arguments appear in the help for this test.\n * Run with the following command to see the help text:\n *   stf -test=SampleCustomExtensionTest -help\n */",
        "start_line": 0,
        "end_line": 67,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 702,
        "node_type": null,
        "file_sha": "137a9897abcb669a3246ba13cf01304743156647",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.077112"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.extension;\n\nimport net.adoptopenjdk.stf.StfException;\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.environment.StfTestArguments;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This test demonstrates the use of a test extension.\n * \n * The extension would usually provide a range of actions that can be used by a \n * suite of tests.\n * This is a demo test so the actions that the extension provides are only used\n * by this test.\n * \n * The new custom extension has the same level of power and privilege\n * as the ever present StfCoreExtension. Authors of extension code should\n * take care to provide actions that support the aims of allowing clean and \n * simple test cases. \n * \n * The following files are needed to implement this scenario:\n *   - ExamplePluginInterface.java\n *        Defines setup/execute/teardown methods. These all include \n *        ExampleExtension in their definition.\n *   - ExampleExtension.java\n *        Provides methods to generate code which run perl subroutines.\n *   - SampleCustomExtensionTest.java\n *        This file. Makes use of the new actions in ExampleExtension.\n *   - stf.samples/config/example.properties\n *        Default values for the arguments that belong to ExampleExtension.\n *   - stf.samples/scripts/ExampleModule.pm\n *        Some perl code which the extension runs.\n * \n * The extension has a '-show-files' argument. This is a first class STF \n * argument. It's values can be provided in property files or on the command \n * line. eg, \n *   stf -test=SampleCustomExtensionTest -show-files\n * The extension argument is added by:\n *   1) Defining an Argument object in the extension to describe the new argument.\n *   2) The extension returns the argument as a supported one in getSupportedArguments()\n *   3) The extension provides help text about the argument in its help() method.\n *   4) Default values are provided in a <project>/config/<extension-name>.properties file.\n *   \n * This test also has a test specific argument called 'forceFailure'. It defaults \n * to 'false' but the failure path can be triggered by running with:\n *   stf -test=SampleCustomExtensionTest -test-args=force-failure=true\n *\n * Both the extension and test arguments appear in the help for this test.\n * Run with the following command to see the help text:\n *   stf -test=SampleCustomExtensionTest -help\n */"
    },
    "464": {
      "metadata": {
        "chunk_id": "eb6dcad08929c4a8c163b35c7329560269f6a77287784f0429827bef65194a20",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/extension/SampleCustomExtensionTest.java",
        "content": "public class SampleCustomExtensionTest implements ExamplePluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleCustomExtension\");\n\t\thelp.outputText(\"This test demonstrates how tests can run with a custom extension.\");\n\n\t\thelp.outputSection(\"SampleCustomExtension options\");\n\t\thelp.outputArgName(\"force-failure\", \"true|[false]\");\n\t\thelp.outputArgDesc(\"Force the test to run the failure path code.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension test, ExampleExtension customExtension) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test, ExampleExtension customExtension) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test, ExampleExtension customExtension) throws Exception {\n\t\t// Pull in a test specific property that can be used to force the code into the failure path\n\t\tStfTestArguments testArgs = test.env().getTestProperties(\"force-failure=[false]\");\n\t\tboolean forceFailure = Boolean.parseBoolean(testArgs.get(\"force-failure\"));\n\n\t\tDirectoryRef resultsRoot = test.env().getResultsDir();\n\t\t\n\t\t// Create a text file holding heap data from a simulated run \n\t\tFileRef heapLog = resultsRoot.childFile(\"example-heap.log\");\n\t\tString heapLogData = createHeapLogData();\n\t\ttest.doWriteFile(\"Create example heap log file\", heapLog, heapLogData);\t\n\t\t\n\t\t// Create a text file holding GC data from a simulated run \n\t\tFileRef gcLog = resultsRoot.childFile(\"example-gc.log\");\n\t\tString gcLogData = createGcData();\n\t\ttest.doWriteFile(\"Create example gc log file\", gcLog, gcLogData);\n\t\t\n\t\t// Verify that we call perl code to check the contents of the heap log\n\t\tcustomExtension.doVerifyHeapLog(\"Check heap log file\", heapLog);\n\n\t\t// Verify that we call perl code to check the contents of the GC log\n\t\tcustomExtension.doVerifyGcLog(\"Check GC log file\", gcLog);\n\n\t\t// If run with the '-test-args=force-failure=true' argument then deliberately cause the test to fail\n\t\tif (forceFailure) {\n\t\t\t// Feed a heap log file into the GC verification perl.\n\t\t\t// Will fail with a parsing error. \n\t\t\tcustomExtension.doVerifyGcLog(\"Check GC log file\", heapLog);\n\t\t}\n\t}\n\n\t\n\tprivate String createGcData() throws StfException {\n\t\treturn \"GC agent started at \\n\"\n\t\t\t + \"GC Start:\\n\"\n\t\t\t + \"GC Finish:\\n\"\n\t\t\t + \"GC Start:\\n\"\n\t\t\t + \"GC Finish:\\n\"\n\t\t\t + \"GC count at program end: 2\\n\";\n\t}\n\n\t\n\tprivate String createHeapLogData() throws StfException {\n\t\treturn \"HeapReference info: class_tag 123, referrer_class_tag 456, size 789, length 1112\\n\"\n\t\t\t + \"Heap agent started at \\n\";\n\t}\n\n\t\n\tpublic void tearDown(StfCoreExtension test, ExampleExtension customExtension) throws Exception {\n\t}\n}",
        "start_line": 68,
        "end_line": 134,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 648,
        "node_type": null,
        "file_sha": "137a9897abcb669a3246ba13cf01304743156647",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.077121"
      },
      "text": "public class SampleCustomExtensionTest implements ExamplePluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleCustomExtension\");\n\t\thelp.outputText(\"This test demonstrates how tests can run with a custom extension.\");\n\n\t\thelp.outputSection(\"SampleCustomExtension options\");\n\t\thelp.outputArgName(\"force-failure\", \"true|[false]\");\n\t\thelp.outputArgDesc(\"Force the test to run the failure path code.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension test, ExampleExtension customExtension) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test, ExampleExtension customExtension) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test, ExampleExtension customExtension) throws Exception {\n\t\t// Pull in a test specific property that can be used to force the code into the failure path\n\t\tStfTestArguments testArgs = test.env().getTestProperties(\"force-failure=[false]\");\n\t\tboolean forceFailure = Boolean.parseBoolean(testArgs.get(\"force-failure\"));\n\n\t\tDirectoryRef resultsRoot = test.env().getResultsDir();\n\t\t\n\t\t// Create a text file holding heap data from a simulated run \n\t\tFileRef heapLog = resultsRoot.childFile(\"example-heap.log\");\n\t\tString heapLogData = createHeapLogData();\n\t\ttest.doWriteFile(\"Create example heap log file\", heapLog, heapLogData);\t\n\t\t\n\t\t// Create a text file holding GC data from a simulated run \n\t\tFileRef gcLog = resultsRoot.childFile(\"example-gc.log\");\n\t\tString gcLogData = createGcData();\n\t\ttest.doWriteFile(\"Create example gc log file\", gcLog, gcLogData);\n\t\t\n\t\t// Verify that we call perl code to check the contents of the heap log\n\t\tcustomExtension.doVerifyHeapLog(\"Check heap log file\", heapLog);\n\n\t\t// Verify that we call perl code to check the contents of the GC log\n\t\tcustomExtension.doVerifyGcLog(\"Check GC log file\", gcLog);\n\n\t\t// If run with the '-test-args=force-failure=true' argument then deliberately cause the test to fail\n\t\tif (forceFailure) {\n\t\t\t// Feed a heap log file into the GC verification perl.\n\t\t\t// Will fail with a parsing error. \n\t\t\tcustomExtension.doVerifyGcLog(\"Check GC log file\", heapLog);\n\t\t}\n\t}\n\n\t\n\tprivate String createGcData() throws StfException {\n\t\treturn \"GC agent started at \\n\"\n\t\t\t + \"GC Start:\\n\"\n\t\t\t + \"GC Finish:\\n\"\n\t\t\t + \"GC Start:\\n\"\n\t\t\t + \"GC Finish:\\n\"\n\t\t\t + \"GC count at program end: 2\\n\";\n\t}\n\n\t\n\tprivate String createHeapLogData() throws StfException {\n\t\treturn \"HeapReference info: class_tag 123, referrer_class_tag 456, size 789, length 1112\\n\"\n\t\t\t + \"Heap agent started at \\n\";\n\t}\n\n\t\n\tpublic void tearDown(StfCoreExtension test, ExampleExtension customExtension) throws Exception {\n\t}\n}"
    },
    "465": {
      "metadata": {
        "chunk_id": "53879872f05094a12d53971b8964c59a71fd2b6b2ccb19fff199f31fc2108d36",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleClientServer.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniServer;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows how to control several concurrent processes.\n * It represents the fairly common client/server style test. This typically has 2 \n * main parts: \n *   - server process which never completes\n *   - client processes. These use the server and exit on completion.\n * \n * It is important that there are no processes still running at the end of the test, so \n * note that the test kills the server process before completion.\n * \n * STF takes cares of many details when running concurrent processes:\n *   - prevents orphan processes by aborting a run in which a process is left running.\n *   - tries to help ensure clean logical code by only allowing monitoring of running processes.\n *   - kills all running processes if a test run aborts due to an error.\n *   - monitors running process and captures core files.\n *   - fails a test run if a running process exceeds its allowed run time.\n */",
        "start_line": 0,
        "end_line": 44,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 470,
        "node_type": null,
        "file_sha": "31fee6c06aacd125e3462a9dc4dcc9008f4ba1b0",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.110462"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniServer;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows how to control several concurrent processes.\n * It represents the fairly common client/server style test. This typically has 2 \n * main parts: \n *   - server process which never completes\n *   - client processes. These use the server and exit on completion.\n * \n * It is important that there are no processes still running at the end of the test, so \n * note that the test kills the server process before completion.\n * \n * STF takes cares of many details when running concurrent processes:\n *   - prevents orphan processes by aborting a run in which a process is left running.\n *   - tries to help ensure clean logical code by only allowing monitoring of running processes.\n *   - kills all running processes if a test run aborts due to an error.\n *   - monitors running process and captures core files.\n *   - fails a test run if a running process exceeds its allowed run time.\n */"
    },
    "466": {
      "metadata": {
        "chunk_id": "eab00ba97e116fde7600c284617b42ee1a6633ff18a4a8ac1e1501937ce1f6d0",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleClientServer.java",
        "content": "public class SampleClientServer implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleClientServer\");\n\t\thelp.outputText(\"This test demonstrates running several processes concurrently\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Start a sever process. This will run indefinitely and needs to be killed at the end of the test\n\t\tStfProcess server = test.doRunBackgroundProcess(\"Run server\", \"SRV\", ECHO_ON, ExpectedOutcome.neverCompletes(), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t    .addJvmOption(\"-Xmx100M\")\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniServer.class)\n\t\t\t\t\t.addArg(\"99\"));\t// Argument is not used. Only added to show usage\t\n\t\t\n\t\t// Run several client processes. \n\t\t// These processes will exit with a '0' value when they complete.\n\t\t// Each client needs to decide if the test has worked and only exit with 0 when it has.\n\t\tStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Wait for clients to complete.\n\t\t// This also monitors the server and client processes for core and java dumps.\n\t\t// Also fails the test if the clients don't complete within the expected run time.\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", server, clients);\n\t\t\n\t\t// kill the server process\n\t\ttest.doKillProcesses(\"Stop server process\", server);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 45,
        "end_line": 85,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 424,
        "node_type": null,
        "file_sha": "31fee6c06aacd125e3462a9dc4dcc9008f4ba1b0",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.110470"
      },
      "text": "public class SampleClientServer implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleClientServer\");\n\t\thelp.outputText(\"This test demonstrates running several processes concurrently\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Start a sever process. This will run indefinitely and needs to be killed at the end of the test\n\t\tStfProcess server = test.doRunBackgroundProcess(\"Run server\", \"SRV\", ECHO_ON, ExpectedOutcome.neverCompletes(), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t    .addJvmOption(\"-Xmx100M\")\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniServer.class)\n\t\t\t\t\t.addArg(\"99\"));\t// Argument is not used. Only added to show usage\t\n\t\t\n\t\t// Run several client processes. \n\t\t// These processes will exit with a '0' value when they complete.\n\t\t// Each client needs to decide if the test has worked and only exit with 0 when it has.\n\t\tStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Wait for clients to complete.\n\t\t// This also monitors the server and client processes for core and java dumps.\n\t\t// Also fails the test if the clients don't complete within the expected run time.\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", server, clients);\n\t\t\n\t\t// kill the server process\n\t\ttest.doKillProcesses(\"Stop server process\", server);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "467": {
      "metadata": {
        "chunk_id": "2115e824cdc15bf7525d2e0d65701cd89f69c6448ff72059c0c02a99cea3c878",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleClientServer2.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniServer;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample is a variant of the SampleClientServer test.\n * Please see that test for the background on running multiple processes.\n * \n * This test runs the following processes:\n *   - server process which never completes\n *   - client processes. exits with value 0.\n *   - a failing client process. exits with value of 5.\n */\npublic class SampleClientServer2 implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleClientServer2\");\n\t\thelp.outputText(\"This test demonstrates running several processes concurrently, including \"\n\t\t\t\t+ \"a client process which is expected to complete with an error\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Start a sever process. This will run indefinitely and needs to be killed at the end of the test\n\t\tStfProcess server = test.doRunBackgroundProcess(\"Run server\", \"SRV\", ECHO_ON, ExpectedOutcome.neverCompletes(),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniServer.class));\n\t\t\n\t\t// Run several client processes. \n\t\t// These processes will exit with a '0' value when they complete.\n\t\t// Each client needs to decide if the test has worked and only exit with 0 when it has.\n\t\tStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Start a failing client\n\t\t// We expect this process to fail and finish with an exit value of 5. \n\t\t// Any other outcome is a test failure.\n\t\tStfProcess failingClient = test.doRunBackgroundProcess(\"Run failing client\", \"CLx\", ECHO_ON, ExpectedOutcome.exitValue(5).within(\"5s\"),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t    .addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class)\n\t\t\t\t\t.addArg(\"5\"));\n\n\t\t// Wait for clients to complete.\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", server, clients, failingClient);\n\t\t\n\t\t// kill the server process\n\t\ttest.doKillProcesses(\"Stop server process\", server);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 0,
        "end_line": 83,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 844,
        "node_type": null,
        "file_sha": "963d0aecfb80b19eef4a1d3f90a869930088a70f",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.137850"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniServer;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample is a variant of the SampleClientServer test.\n * Please see that test for the background on running multiple processes.\n * \n * This test runs the following processes:\n *   - server process which never completes\n *   - client processes. exits with value 0.\n *   - a failing client process. exits with value of 5.\n */\npublic class SampleClientServer2 implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleClientServer2\");\n\t\thelp.outputText(\"This test demonstrates running several processes concurrently, including \"\n\t\t\t\t+ \"a client process which is expected to complete with an error\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Start a sever process. This will run indefinitely and needs to be killed at the end of the test\n\t\tStfProcess server = test.doRunBackgroundProcess(\"Run server\", \"SRV\", ECHO_ON, ExpectedOutcome.neverCompletes(),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniServer.class));\n\t\t\n\t\t// Run several client processes. \n\t\t// These processes will exit with a '0' value when they complete.\n\t\t// Each client needs to decide if the test has worked and only exit with 0 when it has.\n\t\tStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Start a failing client\n\t\t// We expect this process to fail and finish with an exit value of 5. \n\t\t// Any other outcome is a test failure.\n\t\tStfProcess failingClient = test.doRunBackgroundProcess(\"Run failing client\", \"CLx\", ECHO_ON, ExpectedOutcome.exitValue(5).within(\"5s\"),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t    .addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class)\n\t\t\t\t\t.addArg(\"5\"));\n\n\t\t// Wait for clients to complete.\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", server, clients, failingClient);\n\t\t\n\t\t// kill the server process\n\t\ttest.doKillProcesses(\"Stop server process\", server);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "468": {
      "metadata": {
        "chunk_id": "e7c28fe65032bf87b0be24b687bd335c1524968968171525dd600e0012850a38",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleConcurrentProcesses.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processManagement.apps.SpeedyApplication;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the concurrent execution of several Java processes.\n * It represents the case in which a test starts 2 or more programs and then \n * waits for their completion. \n * \n * All processes are expected to complete with an exit code of 0, so unlike \n * the SampleClientServer this sample does not need to kill any processes.\n */",
        "start_line": 0,
        "end_line": 35,
        "chunk_index": 0,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 353,
        "node_type": null,
        "file_sha": "7871255a767eb43eb3fba0a9da191f5cd1521319",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.162691"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processManagement.apps.SpeedyApplication;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the concurrent execution of several Java processes.\n * It represents the case in which a test starts 2 or more programs and then \n * waits for their completion. \n * \n * All processes are expected to complete with an exit code of 0, so unlike \n * the SampleClientServer this sample does not need to kill any processes.\n */"
    },
    "469": {
      "metadata": {
        "chunk_id": "1c78afc5fed9fd7f89fe6b2ee1eb511fa6001d046090e80a296d6ce415467e1c",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleConcurrentProcesses.java",
        "content": "public class SampleConcurrentProcesses implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleConcurrentProcesses\");\n\t\thelp.outputText(\"This test demonstrates running several processes concurrently\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Start a relatively long lived java process.\n\t\tStfProcess processA = test.doRunBackgroundProcess(\"Run process A\", \"A\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t    .addJvmOption(\"-Xmx100M\")\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Now start a short lived java process.\n\t\tStfProcess processB = test.doRunBackgroundProcess(\"Run process B\", \"B\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"20s\"),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(SpeedyApplication.class));\n\t\t\n\t\t// Now start a several short lived java process, all using same classpath and options.\n\t\tStfProcess[] processesC = test.doRunBackgroundProcesses(\"Run processes C\", \"C\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"20s\"),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(SpeedyApplication.class));\n\t\t\n\t\t// Wait for processes A, B and C to complete (ie. all 6 child processes).\n\t\t// This also monitors the referenced processes for core and java dumps.\n\t\t// doMonitor fails the test if any clients don't complete within the expected\n\t\t// run time.\n\t\t// If this line is removed then STF aborts the run because it determines that\n\t\t// running the test would leave an orphan process behind.\n\t\t// The test will only pass if all monitored processes complete within the\n\t\t// expected time limits and with an exit code of 0.\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", processA, processB, processesC);\n\t\t\n\t\t// Attempt to kill the child processes.\n\t\t// Except that you can't!! When the monitor command completes then all processes \n\t\t// must have finished, due to one of:\n\t\t//   1) all processes complete as expected (exit code 0 in this case)\n\t\t//   2) a process crashed or completed with unexpected exit code.\n\t\t//      This will kill the remaining processes, and abort the test run.\n\t\t// So STF won't allow you to kill any of the processes as it determines that \n\t\t// they have all finished by this point.\n\t\t// The following doKill lines are listed below to show the interaction of \n\t\t// the doStart, doMonitor and doKill methods. Uncomment one and rerun to see\n\t    // the error message. \n\t\t//test.doKillProcesses(\"Stop process A\", processA);\n\t\t//test.doKillProcesses(\"Stop process B\", processB);\n\t\t//test.doKillProcesses(\"Stop process C\", processesC);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 36,
        "end_line": 96,
        "chunk_index": 1,
        "total_chunks": 2,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 729,
        "node_type": null,
        "file_sha": "7871255a767eb43eb3fba0a9da191f5cd1521319",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.162701"
      },
      "text": "public class SampleConcurrentProcesses implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleConcurrentProcesses\");\n\t\thelp.outputText(\"This test demonstrates running several processes concurrently\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Start a relatively long lived java process.\n\t\tStfProcess processA = test.doRunBackgroundProcess(\"Run process A\", \"A\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"1m\"),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t    .addJvmOption(\"-Xmx100M\")\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Now start a short lived java process.\n\t\tStfProcess processB = test.doRunBackgroundProcess(\"Run process B\", \"B\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"20s\"),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(SpeedyApplication.class));\n\t\t\n\t\t// Now start a several short lived java process, all using same classpath and options.\n\t\tStfProcess[] processesC = test.doRunBackgroundProcesses(\"Run processes C\", \"C\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"20s\"),\n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(SpeedyApplication.class));\n\t\t\n\t\t// Wait for processes A, B and C to complete (ie. all 6 child processes).\n\t\t// This also monitors the referenced processes for core and java dumps.\n\t\t// doMonitor fails the test if any clients don't complete within the expected\n\t\t// run time.\n\t\t// If this line is removed then STF aborts the run because it determines that\n\t\t// running the test would leave an orphan process behind.\n\t\t// The test will only pass if all monitored processes complete within the\n\t\t// expected time limits and with an exit code of 0.\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", processA, processB, processesC);\n\t\t\n\t\t// Attempt to kill the child processes.\n\t\t// Except that you can't!! When the monitor command completes then all processes \n\t\t// must have finished, due to one of:\n\t\t//   1) all processes complete as expected (exit code 0 in this case)\n\t\t//   2) a process crashed or completed with unexpected exit code.\n\t\t//      This will kill the remaining processes, and abort the test run.\n\t\t// So STF won't allow you to kill any of the processes as it determines that \n\t\t// they have all finished by this point.\n\t\t// The following doKill lines are listed below to show the interaction of \n\t\t// the doStart, doMonitor and doKill methods. Uncomment one and rerun to see\n\t    // the error message. \n\t\t//test.doKillProcesses(\"Stop process A\", processA);\n\t\t//test.doKillProcesses(\"Stop process B\", processB);\n\t\t//test.doKillProcesses(\"Stop process C\", processesC);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "470": {
      "metadata": {
        "chunk_id": "56091401be9d24f7c180a1547088610287390f591cf3aed999fe991e4ef9d7ce",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleJUnitTestRun.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.TestArgumentProcessing;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.results.TestResultsProcessor;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the execution of some JUnit tests.\n * The tests it runs are the internal STF unit tests.\n */\npublic class SampleJUnitTestRun implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunJUnit\");\n\t\thelp.outputText(\"This test demonstrates a JUnit test run.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// List the JUnit tests to run\n\t\tClass<?>[] junitTests = {\n\t\t\tTestArgumentProcessing.class,\n\t\t\tTestResultsProcessor.class\n\t\t};\n\t\t\n\t\t// Build a description of how to run JUnit for these tests\n\t\tJavaProcessDefinition junitProcessDefinition = test.createJUnitProcessDefinition(\"stf.samples\", null, junitTests);\n\t\t\n\t\t// Synchronously run the JUnit tests\n\t\ttest.doRunForegroundProcess(\"Run JUnit tests\", \"J\", ECHO_ON, \n\t\t\t\t\t\tExpectedOutcome.cleanRun().within(\"1m\"), \n\t\t\t\t\t\tjunitProcessDefinition);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 0,
        "end_line": 61,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 521,
        "node_type": null,
        "file_sha": "8d4a902a874f661c618bc4185eed6276f83d7225",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.185830"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.TestArgumentProcessing;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.results.TestResultsProcessor;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the execution of some JUnit tests.\n * The tests it runs are the internal STF unit tests.\n */\npublic class SampleJUnitTestRun implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunJUnit\");\n\t\thelp.outputText(\"This test demonstrates a JUnit test run.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// List the JUnit tests to run\n\t\tClass<?>[] junitTests = {\n\t\t\tTestArgumentProcessing.class,\n\t\t\tTestResultsProcessor.class\n\t\t};\n\t\t\n\t\t// Build a description of how to run JUnit for these tests\n\t\tJavaProcessDefinition junitProcessDefinition = test.createJUnitProcessDefinition(\"stf.samples\", null, junitTests);\n\t\t\n\t\t// Synchronously run the JUnit tests\n\t\ttest.doRunForegroundProcess(\"Run JUnit tests\", \"J\", ECHO_ON, \n\t\t\t\t\t\tExpectedOutcome.cleanRun().within(\"1m\"), \n\t\t\t\t\t\tjunitProcessDefinition);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "471": {
      "metadata": {
        "chunk_id": "e8cef15bb9aa0331c0abf9e0d384b4a0af1063060adcc6f17ff7ee3e71d8891b",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleOverrunProcess.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the synchronous running of a Java process.\n * When executed STF will:\n *   - start the processes \n *   - monitor the process for core and java dumps.\n *   - fail the test if the process runs for longer than the expected run time.\n *   - kill the process if a test failure is detected.\n * \n * This is the most basic scenario covered by the STF process control methods.\n */\npublic class SampleOverrunProcess implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunProcess\");\n\t\thelp.outputText(\"This test demonstrates the synchronous running of processes.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Runs a java process with two arguments.\n\t\t// The first argument tells MiniClient to exit with a zero exit code.\n\t\t// The second argument tells MiniClient to sleep for 3 minutes.\n\t\t// doRunForegroundProcess is set to expect the process to finish within 10 seconds, which it will not\n\t\t// because it is sleeping for 3 minutes.\n\t\t// STF will then take core dumps of the running process three times at thirty second intervals before killing it.\n\t\t// This sample can therefore be used to test the hang detection and core dumping capability of STF.\n\t\t// Run via 'make test.sampleOverrunProcess'. \n\t\ttest.doRunForegroundProcess(\"Run client\", \"CL\", ECHO_ON, ExpectedOutcome.exitValue(0).within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class)\n\t\t\t\t\t.addArg(\"0\")\n\t\t\t\t\t.addArg(\"180000\"));  // 180 secs in milliseconds\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 0,
        "end_line": 66,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 653,
        "node_type": null,
        "file_sha": "093f34ae5542076023cfaeb1e2e325149532c699",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.209434"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the synchronous running of a Java process.\n * When executed STF will:\n *   - start the processes \n *   - monitor the process for core and java dumps.\n *   - fail the test if the process runs for longer than the expected run time.\n *   - kill the process if a test failure is detected.\n * \n * This is the most basic scenario covered by the STF process control methods.\n */\npublic class SampleOverrunProcess implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunProcess\");\n\t\thelp.outputText(\"This test demonstrates the synchronous running of processes.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Runs a java process with two arguments.\n\t\t// The first argument tells MiniClient to exit with a zero exit code.\n\t\t// The second argument tells MiniClient to sleep for 3 minutes.\n\t\t// doRunForegroundProcess is set to expect the process to finish within 10 seconds, which it will not\n\t\t// because it is sleeping for 3 minutes.\n\t\t// STF will then take core dumps of the running process three times at thirty second intervals before killing it.\n\t\t// This sample can therefore be used to test the hang detection and core dumping capability of STF.\n\t\t// Run via 'make test.sampleOverrunProcess'. \n\t\ttest.doRunForegroundProcess(\"Run client\", \"CL\", ECHO_ON, ExpectedOutcome.exitValue(0).within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class)\n\t\t\t\t\t.addArg(\"0\")\n\t\t\t\t\t.addArg(\"180000\"));  // 180 secs in milliseconds\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "472": {
      "metadata": {
        "chunk_id": "333e23c6fbdc033f14fa177bac244788dc34b0f04cdb7c8aa888e5c64c243795",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleRunJDKTool.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This simple example runs one of the JDK tools, which ships with the JVM.\n * It also runs several java processes in the background.\n * \n * If you need to start a JDK tool/utility which will run in the background \n * until the end of the test then you'll probably need to kill it at the end \n * of the test. See SampleClientServer.java for an example of running with a \n * process which will never complete, and therefore needs killing at the end \n * of the run.  \n */\npublic class SampleRunJDKTool implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunJDKTool\");\n\t\thelp.outputText(\"This test runs the keytool application.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Create a keystore using a background process. \n\t\tFileRef keystoreFile = test.env().getTmpDir().childFile(\"mykeystore\");\n\t\tStfProcess keytool = test.doRunBackgroundProcess(\"Run keytool\", \"KEY\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"10s\"),\n\t\t\t    test.createJDKToolProcessDefinition()\n\t\t\t\t        .setJDKToolOrUtility(\"keytool\")\n\t\t\t\t        .addArg(\"-genkeypair\")\n\t\t\t\t        .addArg(\"-dname\", \"\\\"cn=John Example, ou=Java, o=IBM, c=UK\\\"\")\n\t\t\t\t        .addArg(\"-alias\", \"ks1\")\n\t\t\t\t        .addArg(\"-keypass\", \"private-key-password\")\n\t\t\t\t        .addArg(\"-keystore\", keystoreFile.getSpec())\n\t\t\t\t        .addArg(\"-storepass\", \"keystore-password\")\n\t\t\t\t        .addArg(\"-validity\", \"365\"));\n\t\t\n\t\t// Start 4 java processes in the background. \n\t\t// These processes will exit with a '0' value when they complete.\n\t\t// Each client needs to decide if the test has worked and only exit with 0 when it has.\n\t\tStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Wait for keytool and all of the java processes to complete.\n\t\t// This also monitors the keytool and java processes for core and java dumps.\n\t\t// Also fails the test if the clients don't complete within the expected run time.\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", keytool, clients);\n\t\t\n\t\t// Verify that the keystore file now exists\n\t\ttest.doValidateFileExists(\"Check keystore created\", keystoreFile);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 0,
        "end_line": 83,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 905,
        "node_type": null,
        "file_sha": "64acb139f33e6aeacfa15d2345b086114df345e1",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.239063"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.environment.FileRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.StfProcess;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This simple example runs one of the JDK tools, which ships with the JVM.\n * It also runs several java processes in the background.\n * \n * If you need to start a JDK tool/utility which will run in the background \n * until the end of the test then you'll probably need to kill it at the end \n * of the test. See SampleClientServer.java for an example of running with a \n * process which will never complete, and therefore needs killing at the end \n * of the run.  \n */\npublic class SampleRunJDKTool implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunJDKTool\");\n\t\thelp.outputText(\"This test runs the keytool application.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Create a keystore using a background process. \n\t\tFileRef keystoreFile = test.env().getTmpDir().childFile(\"mykeystore\");\n\t\tStfProcess keytool = test.doRunBackgroundProcess(\"Run keytool\", \"KEY\", ECHO_ON, ExpectedOutcome.cleanRun().within(\"10s\"),\n\t\t\t    test.createJDKToolProcessDefinition()\n\t\t\t\t        .setJDKToolOrUtility(\"keytool\")\n\t\t\t\t        .addArg(\"-genkeypair\")\n\t\t\t\t        .addArg(\"-dname\", \"\\\"cn=John Example, ou=Java, o=IBM, c=UK\\\"\")\n\t\t\t\t        .addArg(\"-alias\", \"ks1\")\n\t\t\t\t        .addArg(\"-keypass\", \"private-key-password\")\n\t\t\t\t        .addArg(\"-keystore\", keystoreFile.getSpec())\n\t\t\t\t        .addArg(\"-storepass\", \"keystore-password\")\n\t\t\t\t        .addArg(\"-validity\", \"365\"));\n\t\t\n\t\t// Start 4 java processes in the background. \n\t\t// These processes will exit with a '0' value when they complete.\n\t\t// Each client needs to decide if the test has worked and only exit with 0 when it has.\n\t\tStfProcess[] clients = test.doRunBackgroundProcesses(\"Run client\", \"CL\", 4, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class));\n\t\t\n\t\t// Wait for keytool and all of the java processes to complete.\n\t\t// This also monitors the keytool and java processes for core and java dumps.\n\t\t// Also fails the test if the clients don't complete within the expected run time.\n\t\ttest.doMonitorProcesses(\"Wait for clients to complete\", keytool, clients);\n\t\t\n\t\t// Verify that the keystore file now exists\n\t\ttest.doValidateFileExists(\"Check keystore created\", keystoreFile);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "473": {
      "metadata": {
        "chunk_id": "cfb92c3a25ed5e3f40e3b0ddd15d590788f0e545af1af6a5b15d86f06efa9269",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleRunJmod.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processes.definitions.JmodDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the execution of the Java 9 jmod utility.\n */\npublic class SampleRunJmod implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunJmod\");\n\t\thelp.outputText(\"This test demonstrates the running of a jmod process.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\tDirectoryRef dir1 = test.env().findTestDirectory(\"pmb.module/mods/com.greetings\");\n\t\tDirectoryRef dir2 = test.env().findTestDirectory(\"pmb.module/mods/org.astro\");\n\t\t\n\t\t// Run jmod with the minimal possible arguments.\n\t\tModuleRef jmodRef1 = test.doCreateJmod(\"Create minimalist jmod\",\n\t\t\tnew JmodDefinition()\n\t\t\t\t.doJmodCreate(\"com.greetings.jmod\")\n\t\t\t\t.addDirectoryToClassPath(dir1));\n\t\t\n\t\t// Verify that a jmod file was created\n\t\t// NB: Test code does not need to do this. The test will fail if the jmod file was not created.\n\t\ttest.doValidateFileExists(\"Check miniMod created\", jmodRef1.getJarFileRef());\n\n\t\t// Delete the first jmod, so that another with the same name can be created\n\t\ttest.doRm(\"Delete first module\", jmodRef1.getJarFileRef());\n\t\t\n\t\t\n\t\t// Now run the jmod command with virtually all possible options.\n\t\t// Note: This sample aims to demonstrate the different methods available. \n\t\t// It does aim to represent a realistic jmod command!\n\t\tModuleRef jmodRef = test.doCreateJmod(\"Run jmod with lots of arguments\",\n\t\t\tnew JmodDefinition()\n\t\t\t\t.doJmodCreate(\"com.greetings.jmod\")\n\t\t\t\t.addDirectoryToClassPath(dir1)\n\t\t\t\t.addDirectoryToClassPath(dir2)\n\t\t\t\t.addDirectoryToCmdsPath(dir1)\n\t\t\t\t.addDirectoryToCmdsPath(dir2)\n\t\t\t\t.addDirectoryToConfigPath(dir1)\n\t\t\t\t.addDirectoryToConfigPath(dir2)\n\t\t\t\t.setExcludePattern(\"excludePattern\")\n\t\t\t\t.setHashModulesPattern(\"HDP\")\n\t\t\t\t.addDirectoryToLibsPath(dir1)\n\t\t\t\t.addDirectoryToLibsPath(dir2)\n\t\t\t\t.setMainClass(StfCoreExtension.class)\n\t\t\t\t.setModuleVersion(\"1.2\")\n\t\t\t\t.addDirectoryToModulepath(dir1)\n\t\t\t\t.addDirectoryToModulepath(dir2)\n\t\t\t\t.setOsArchToCurrentPlatform()\n\t\t\t\t.setOsNameToCurrentPlatform()\n\t\t\t\t.setOsVersionToCurrentPlatform());\n\t\t\n\t\t// Verify that a jmod file was created\n\t\ttest.doValidateFileExists(\"Check jmod created\", jmodRef.getJarFileRef());\n\t\t\n\t\t// Run 'jmod list' against the new 'com.greetings.jmod'\n\t\ttest.doCreateJmod(\"Run jmod list\", new JmodDefinition().doJmodList(jmodRef));\n\t\t\n\t\t// Run 'jmod describe' against the new 'com.greetings.jmod'\n\t\ttest.doCreateJmod(\"Run jmod describe\", new JmodDefinition().doJmodDescribe(jmodRef));\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 0,
        "end_line": 93,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 942,
        "node_type": null,
        "file_sha": "f4137d98e75bfe187bdbcf63ad86d083c3b34a7e",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.261593"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport net.adoptopenjdk.stf.environment.DirectoryRef;\nimport net.adoptopenjdk.stf.environment.ModuleRef;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processes.definitions.JmodDefinition;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the execution of the Java 9 jmod utility.\n */\npublic class SampleRunJmod implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunJmod\");\n\t\thelp.outputText(\"This test demonstrates the running of a jmod process.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\tDirectoryRef dir1 = test.env().findTestDirectory(\"pmb.module/mods/com.greetings\");\n\t\tDirectoryRef dir2 = test.env().findTestDirectory(\"pmb.module/mods/org.astro\");\n\t\t\n\t\t// Run jmod with the minimal possible arguments.\n\t\tModuleRef jmodRef1 = test.doCreateJmod(\"Create minimalist jmod\",\n\t\t\tnew JmodDefinition()\n\t\t\t\t.doJmodCreate(\"com.greetings.jmod\")\n\t\t\t\t.addDirectoryToClassPath(dir1));\n\t\t\n\t\t// Verify that a jmod file was created\n\t\t// NB: Test code does not need to do this. The test will fail if the jmod file was not created.\n\t\ttest.doValidateFileExists(\"Check miniMod created\", jmodRef1.getJarFileRef());\n\n\t\t// Delete the first jmod, so that another with the same name can be created\n\t\ttest.doRm(\"Delete first module\", jmodRef1.getJarFileRef());\n\t\t\n\t\t\n\t\t// Now run the jmod command with virtually all possible options.\n\t\t// Note: This sample aims to demonstrate the different methods available. \n\t\t// It does aim to represent a realistic jmod command!\n\t\tModuleRef jmodRef = test.doCreateJmod(\"Run jmod with lots of arguments\",\n\t\t\tnew JmodDefinition()\n\t\t\t\t.doJmodCreate(\"com.greetings.jmod\")\n\t\t\t\t.addDirectoryToClassPath(dir1)\n\t\t\t\t.addDirectoryToClassPath(dir2)\n\t\t\t\t.addDirectoryToCmdsPath(dir1)\n\t\t\t\t.addDirectoryToCmdsPath(dir2)\n\t\t\t\t.addDirectoryToConfigPath(dir1)\n\t\t\t\t.addDirectoryToConfigPath(dir2)\n\t\t\t\t.setExcludePattern(\"excludePattern\")\n\t\t\t\t.setHashModulesPattern(\"HDP\")\n\t\t\t\t.addDirectoryToLibsPath(dir1)\n\t\t\t\t.addDirectoryToLibsPath(dir2)\n\t\t\t\t.setMainClass(StfCoreExtension.class)\n\t\t\t\t.setModuleVersion(\"1.2\")\n\t\t\t\t.addDirectoryToModulepath(dir1)\n\t\t\t\t.addDirectoryToModulepath(dir2)\n\t\t\t\t.setOsArchToCurrentPlatform()\n\t\t\t\t.setOsNameToCurrentPlatform()\n\t\t\t\t.setOsVersionToCurrentPlatform());\n\t\t\n\t\t// Verify that a jmod file was created\n\t\ttest.doValidateFileExists(\"Check jmod created\", jmodRef.getJarFileRef());\n\t\t\n\t\t// Run 'jmod list' against the new 'com.greetings.jmod'\n\t\ttest.doCreateJmod(\"Run jmod list\", new JmodDefinition().doJmodList(jmodRef));\n\t\t\n\t\t// Run 'jmod describe' against the new 'com.greetings.jmod'\n\t\ttest.doCreateJmod(\"Run jmod describe\", new JmodDefinition().doJmodDescribe(jmodRef));\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "474": {
      "metadata": {
        "chunk_id": "c37d178b4261131ae49c1e20d1bd900352ab3e897c1477fc148491b6db8d450b",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleRunProcess.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the synchronous running of a Java process.\n * When executed STF will:\n *   - start the processes \n *   - monitor the process for core and java dumps.\n *   - fail the test if the process runs for longer than the expected run time.\n *   - kill the process if a test failure is detected.\n * \n * This is the most basic scenario covered by the STF process control methods.\n */\npublic class SampleRunProcess implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunProcess\");\n\t\thelp.outputText(\"This test demonstrates the synchronous running of processes.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Synchronously run a single java process.\n\t\t// This call with start the java process and await its completion.\n\t\t// STF will monitor the process for core and java dumps. \n\t\ttest.doRunForegroundProcess(\"Run client\", \"CL\", ECHO_ON, ExpectedOutcome.exitValue(3).within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class)\n\t\t\t\t\t.addArg(\"3\"));\n\t\t\n\t\t// Synchronously run 4 instances of a java process.\n\t\t// STF will wait for all 4 processes to complete with an exit value of 3.\n\t\ttest.doRunForegroundProcesses(\"Run client\", \"CL\", 4, ECHO_ON, ExpectedOutcome.exitValue(3).within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class)\n\t\t\t\t\t.addArg(\"3\"));\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 0,
        "end_line": 68,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 642,
        "node_type": null,
        "file_sha": "ea74ba58665d50343679314abc1102d1e8fe9a0c",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.288586"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the synchronous running of a Java process.\n * When executed STF will:\n *   - start the processes \n *   - monitor the process for core and java dumps.\n *   - fail the test if the process runs for longer than the expected run time.\n *   - kill the process if a test failure is detected.\n * \n * This is the most basic scenario covered by the STF process control methods.\n */\npublic class SampleRunProcess implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunProcess\");\n\t\thelp.outputText(\"This test demonstrates the synchronous running of processes.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void execute(StfCoreExtension test) throws Exception {\n\t\t// Synchronously run a single java process.\n\t\t// This call with start the java process and await its completion.\n\t\t// STF will monitor the process for core and java dumps. \n\t\ttest.doRunForegroundProcess(\"Run client\", \"CL\", ECHO_ON, ExpectedOutcome.exitValue(3).within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class)\n\t\t\t\t\t.addArg(\"3\"));\n\t\t\n\t\t// Synchronously run 4 instances of a java process.\n\t\t// STF will wait for all 4 processes to complete with an exit value of 3.\n\t\ttest.doRunForegroundProcesses(\"Run client\", \"CL\", 4, ECHO_ON, ExpectedOutcome.exitValue(3).within(\"10s\"), \n\t\t\t\ttest.createJavaProcessDefinition()\n\t\t\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t\t\t.runClass(MiniClient.class)\n\t\t\t\t\t.addArg(\"3\"));\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "475": {
      "metadata": {
        "chunk_id": "d400a47b256396954974971d5e96ad5fe87b058d50cead1a6fc7a2a15c9608cc",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/SampleSubTests.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.TestArgumentProcessing;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.results.TestResultsProcessor;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the execution of a test containing 3 subtests:\n *   o executeRunJava\n *   o executeWriteFile\n *   o executeJunit\n * \n * The execution order is \n *   setUp -> executeRunJava -> executeWriteFile -> executeJunit -> tearDown\n *   \n * Providing that setUp completes without error then all of the execute methods are run.\n * The success or failure of each execute method is reported at the end of the test.\n * \n * The test itself is only regarded as passing if all setUp, execute and \n * tearDown methods complete successfully.\n */\npublic class SampleSubTests implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunJUnit\");\n\t\thelp.outputText(\"This test demonstrates a JUnit test run.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void executeRunJava(StfCoreExtension test) throws Exception {\n\t\t// Describe how to run a java process\n\t\tJavaProcessDefinition processDef = test.createJavaProcessDefinition()\n\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t.runClass(MiniClient.class);\n\t\t\n\t\t// Run a java process and wait for completion\n\t\ttest.doRunForegroundProcess(\"Run MiniClient\", \"CL\", ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\tprocessDef);\n\n\t\t// Run multiple instances and wait for completion\n\t\ttest.doRunForegroundProcesses(\"Run multiple processes\", \"CL\", 3, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\tprocessDef);\n\t}\n\n\tpublic void executeWriteFile(StfCoreExtension test) throws Exception {\n\t\ttest.doWriteFile(\"Create example file\", test.env().getTmpDir().childFile(\"miniFile.txt\"), \"abc\");\n\t}\n\n\tpublic void executeJunit(StfCoreExtension test) throws Exception {\n\t\t// List the JUnit tests to run\n\t\tClass<?>[] junitTests = {\n\t\t\tTestArgumentProcessing.class,\n\t\t\tTestResultsProcessor.class\n\t\t};\n\t\t\n\t\t// Build a description of how to run JUnit for these tests\n\t\tJavaProcessDefinition junitProcessDefinition = test.createJUnitProcessDefinition(\"stf.samples\", null, junitTests);\n\t\t\n\t\t// Synchronously run the JUnit tests\n\t\ttest.doRunForegroundProcess(\"Run JUnit tests\", \"J\", ECHO_ON, \n\t\t\t\t\t\tExpectedOutcome.neverCompletes().within(\"24h\"), \n\t\t\t\t\t\tjunitProcessDefinition);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}",
        "start_line": 0,
        "end_line": 93,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 857,
        "node_type": null,
        "file_sha": "92f11061f2f101f302d57cac1aa303644f654978",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.311114"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement;\n\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_OFF;\nimport static net.adoptopenjdk.stf.extensions.core.StfCoreExtension.Echo.ECHO_ON;\n\nimport net.adoptopenjdk.stf.TestArgumentProcessing;\nimport net.adoptopenjdk.stf.extensions.core.StfCoreExtension;\nimport net.adoptopenjdk.stf.plugin.interfaces.StfPluginInterface;\nimport net.adoptopenjdk.stf.processManagement.apps.MiniClient;\nimport net.adoptopenjdk.stf.processes.ExpectedOutcome;\nimport net.adoptopenjdk.stf.processes.definitions.JavaProcessDefinition;\nimport net.adoptopenjdk.stf.results.TestResultsProcessor;\nimport net.adoptopenjdk.stf.runner.modes.HelpTextGenerator;\n\n\n/**\n * This sample test shows the execution of a test containing 3 subtests:\n *   o executeRunJava\n *   o executeWriteFile\n *   o executeJunit\n * \n * The execution order is \n *   setUp -> executeRunJava -> executeWriteFile -> executeJunit -> tearDown\n *   \n * Providing that setUp completes without error then all of the execute methods are run.\n * The success or failure of each execute method is reported at the end of the test.\n * \n * The test itself is only regarded as passing if all setUp, execute and \n * tearDown methods complete successfully.\n */\npublic class SampleSubTests implements StfPluginInterface {\n\tpublic void help(HelpTextGenerator help) throws Exception {\n\t\thelp.outputSection(\"SampleRunJUnit\");\n\t\thelp.outputText(\"This test demonstrates a JUnit test run.\");\n\t}\n\n\tpublic void pluginInit(StfCoreExtension stf) throws Exception {\n\t}\n\n\tpublic void setUp(StfCoreExtension test) throws Exception {\n\t}\n\n\tpublic void executeRunJava(StfCoreExtension test) throws Exception {\n\t\t// Describe how to run a java process\n\t\tJavaProcessDefinition processDef = test.createJavaProcessDefinition()\n\t\t\t.addProjectToClasspath(\"stf.samples\")\n\t\t\t.runClass(MiniClient.class);\n\t\t\n\t\t// Run a java process and wait for completion\n\t\ttest.doRunForegroundProcess(\"Run MiniClient\", \"CL\", ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\tprocessDef);\n\n\t\t// Run multiple instances and wait for completion\n\t\ttest.doRunForegroundProcesses(\"Run multiple processes\", \"CL\", 3, ECHO_OFF, ExpectedOutcome.cleanRun().within(\"10s\"), \n\t\t\t\tprocessDef);\n\t}\n\n\tpublic void executeWriteFile(StfCoreExtension test) throws Exception {\n\t\ttest.doWriteFile(\"Create example file\", test.env().getTmpDir().childFile(\"miniFile.txt\"), \"abc\");\n\t}\n\n\tpublic void executeJunit(StfCoreExtension test) throws Exception {\n\t\t// List the JUnit tests to run\n\t\tClass<?>[] junitTests = {\n\t\t\tTestArgumentProcessing.class,\n\t\t\tTestResultsProcessor.class\n\t\t};\n\t\t\n\t\t// Build a description of how to run JUnit for these tests\n\t\tJavaProcessDefinition junitProcessDefinition = test.createJUnitProcessDefinition(\"stf.samples\", null, junitTests);\n\t\t\n\t\t// Synchronously run the JUnit tests\n\t\ttest.doRunForegroundProcess(\"Run JUnit tests\", \"J\", ECHO_ON, \n\t\t\t\t\t\tExpectedOutcome.neverCompletes().within(\"24h\"), \n\t\t\t\t\t\tjunitProcessDefinition);\n\t}\n\n\tpublic void tearDown(StfCoreExtension stf) throws Exception {\n\t}\n}"
    },
    "476": {
      "metadata": {
        "chunk_id": "8e519e2b5aac37f7e806b1f11e61cae6914772db09450352e5051b105b667808",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/apps/MiniClient.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement.apps;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * This mini program is used by the STF samples. \n * This program simulates a client application.\n */\npublic class MiniClient {\n\tprivate static SimpleDateFormat dateFormatter = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n\t\n\tpublic static void main(String[] args) {\n\t\tlog(\"Client started\");\n\t\tlong sleepTime = 2500L;\n\t\tif (args.length > 1) {\n\t\t\t// Sleep for the supplied value\n\t\t\tsleepTime = Long.parseLong(args[1]);\n\t\t\tlog(\"Client sleeping for \" + sleepTime + \" milliseconds\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(sleepTime);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlog(\"Client interrupted\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tif (args.length > 0) {\n\t\t\t// Exit the client using the supplied exit value\n\t\t\tint exitValue = Integer.parseInt(args[0]);\n\t\t\tlog(\"Client exiting with value of \" + exitValue);\n\t\t\tSystem.exit(exitValue);\n\t\t}\n\t\t\n\t\t// If no arguments were supplied just exit after a short interval.\n\t\tif (args.length == 0) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(sleepTime);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlog(\"Client interrupted\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tlog(\"Client completed normally\");\n\t}\n\n\tprivate static void log(String message) {\n\t\tSystem.out.println(dateFormatter.format(new Date()) + \" \" + message);\n\t}\n}",
        "start_line": 0,
        "end_line": 63,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 443,
        "node_type": null,
        "file_sha": "40e5880523bb7c42c8523d3a11b424c186191154",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.336404"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement.apps;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * This mini program is used by the STF samples. \n * This program simulates a client application.\n */\npublic class MiniClient {\n\tprivate static SimpleDateFormat dateFormatter = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n\t\n\tpublic static void main(String[] args) {\n\t\tlog(\"Client started\");\n\t\tlong sleepTime = 2500L;\n\t\tif (args.length > 1) {\n\t\t\t// Sleep for the supplied value\n\t\t\tsleepTime = Long.parseLong(args[1]);\n\t\t\tlog(\"Client sleeping for \" + sleepTime + \" milliseconds\");\n\t\t\ttry {\n\t\t\t\tThread.sleep(sleepTime);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlog(\"Client interrupted\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tif (args.length > 0) {\n\t\t\t// Exit the client using the supplied exit value\n\t\t\tint exitValue = Integer.parseInt(args[0]);\n\t\t\tlog(\"Client exiting with value of \" + exitValue);\n\t\t\tSystem.exit(exitValue);\n\t\t}\n\t\t\n\t\t// If no arguments were supplied just exit after a short interval.\n\t\tif (args.length == 0) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(sleepTime);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlog(\"Client interrupted\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tlog(\"Client completed normally\");\n\t}\n\n\tprivate static void log(String message) {\n\t\tSystem.out.println(dateFormatter.format(new Date()) + \" \" + message);\n\t}\n}"
    },
    "477": {
      "metadata": {
        "chunk_id": "c6e2c64fe0e77da8bb551cde828ec727b1fca90e1a262f0118105ae924974af0",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/apps/MiniServer.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement.apps;\n\n/**\n * This mini program is used by the STF samples. \n * This program simulates a client application.\n */\npublic class MiniServer {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Server running\");\n\t\twhile (true) { \n\t\t\ttry {\n\t\t\t\tSystem.out.println(\"Server is going to sleep\");\n\t\t\t\tSystem.out.flush();\n\t\t\t\tThread.sleep(500);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}",
        "start_line": 0,
        "end_line": 33,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 234,
        "node_type": null,
        "file_sha": "836dfdb20484bcea9ee6efb757c8c686edaaccc5",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.361625"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement.apps;\n\n/**\n * This mini program is used by the STF samples. \n * This program simulates a client application.\n */\npublic class MiniServer {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Server running\");\n\t\twhile (true) { \n\t\t\ttry {\n\t\t\t\tSystem.out.println(\"Server is going to sleep\");\n\t\t\t\tSystem.out.flush();\n\t\t\t\tThread.sleep(500);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "478": {
      "metadata": {
        "chunk_id": "85560a7532680ca95aff5b868b68f0e3186bfabdbc8e8ea5d7d8a682090ed5a4",
        "file_path": "stf.samples/src/stf.samples/net/adoptopenjdk/stf/processManagement/apps/SpeedyApplication.java",
        "content": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement.apps;\n\nimport java.util.Random;\n\n/**\n * This is a short running 'application', which is used by\n * the Sample programs to demonstrate multi-process control.\n */\npublic class SpeedyApplication {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"SpeedyApplication started\");\n\t\t\n\t\ttry {\n\t\t\tint sleepTime = new Random().nextInt(100);\n\t\t\tSystem.out.println(\"SpeedyApplication sleeping for \" + sleepTime + \"ms\");\n\t\t\tThread.sleep(sleepTime);\n\t\t} catch (InterruptedException e) {\n\t\t\tSystem.out.println(\"SpeedyApplication interrupted\");\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tSystem.out.println(\"SpeedyApplication completed normally\");\n\t}\n}",
        "start_line": 0,
        "end_line": 37,
        "chunk_index": 0,
        "total_chunks": 1,
        "language": "java",
        "chunk_type": "recursive",
        "token_count": 271,
        "node_type": null,
        "file_sha": "f60d501ea79803c36721c6eaa586ed54a7100707",
        "repo_name": "adoptium/STF",
        "deleted": false,
        "created_at": "2025-10-31T13:16:54.386328"
      },
      "text": "/*******************************************************************************\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\npackage net.adoptopenjdk.stf.processManagement.apps;\n\nimport java.util.Random;\n\n/**\n * This is a short running 'application', which is used by\n * the Sample programs to demonstrate multi-process control.\n */\npublic class SpeedyApplication {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"SpeedyApplication started\");\n\t\t\n\t\ttry {\n\t\t\tint sleepTime = new Random().nextInt(100);\n\t\t\tSystem.out.println(\"SpeedyApplication sleeping for \" + sleepTime + \"ms\");\n\t\t\tThread.sleep(sleepTime);\n\t\t} catch (InterruptedException e) {\n\t\t\tSystem.out.println(\"SpeedyApplication interrupted\");\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tSystem.out.println(\"SpeedyApplication completed normally\");\n\t}\n}"
    }
  },
  "next_id": 479
}